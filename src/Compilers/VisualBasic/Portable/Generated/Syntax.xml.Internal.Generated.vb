' Definition of syntax model.
' DO NOT HAND EDIT

Imports System.Collections.Generic
Imports System.Collections.Immutable
Imports System.Runtime.CompilerServices
Imports Microsoft.CodeAnalysis.Syntax.InternalSyntax
Imports Microsoft.CodeAnalysis.VisualBasic.Syntax
Imports Roslyn.Utilities

Namespace Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax

    ''' <summary>
    ''' The base class for all nodes in the VB syntax tree.
    ''' </summary>
    Partial Friend MustInherit Class VisualBasicSyntaxNode


        Public Overridable Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitVisualBasicSyntaxNode(Me)
        End Function


    End Class

    ''' <summary>
    ''' The base class for all nodes that represent statements. This includes both
    ''' declaration statements, such as class declarations as well as executable
    ''' statements.
    ''' </summary>
    Friend MustInherit Class StatementSyntax
        Inherits VisualBasicSyntaxNode


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

    End Class

    ''' <summary>
    ''' The base class for all nodes that represent executable statements.
    ''' </summary>
    Friend MustInherit Class ExecutableStatementSyntax
        Inherits StatementSyntax


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

    End Class

    ''' <summary>
    ''' The base class for all nodes that represent statements that declare options,
    ''' imports, members, etc.
    ''' </summary>
    Friend MustInherit Class DeclarationStatementSyntax
        Inherits StatementSyntax


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

    End Class

    ''' <summary>
    ''' A class to represent an empty statement. This can occur when a colon is on a
    ''' line without anything else.
    ''' </summary>
    Friend NotInheritable Class EmptyStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _empty as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, empty As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(empty)
            Me._empty = empty

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, empty As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(empty)
            Me._empty = empty

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), empty As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(empty)
            Me._empty = empty

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EmptyStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' An empty token because all non terminals must have a token.
        ''' </summary>
        Friend ReadOnly Property Empty As InternalSyntax.PunctuationSyntax
            Get
                Return Me._empty
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._empty
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new EmptyStatementSyntax(Me.Kind, newErrors, GetAnnotations, _empty)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new EmptyStatementSyntax(Me.Kind, GetDiagnostics, annotations, _empty)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitEmptyStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an "End XXX" statement, where XXX is a single keyword.
    ''' </summary>
    Friend NotInheritable Class EndBlockStatementSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _endKeyword as KeywordSyntax
        Friend ReadOnly _blockKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, endKeyword As InternalSyntax.KeywordSyntax, blockKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(endKeyword)
            Me._endKeyword = endKeyword
            AdjustFlagsAndWidth(blockKeyword)
            Me._blockKeyword = blockKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, endKeyword As InternalSyntax.KeywordSyntax, blockKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(endKeyword)
            Me._endKeyword = endKeyword
            AdjustFlagsAndWidth(blockKeyword)
            Me._blockKeyword = blockKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), endKeyword As InternalSyntax.KeywordSyntax, blockKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(endKeyword)
            Me._endKeyword = endKeyword
            AdjustFlagsAndWidth(blockKeyword)
            Me._blockKeyword = blockKeyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "End" keyword
        ''' </summary>
        Friend ReadOnly Property EndKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._endKeyword
            End Get
        End Property

        ''' <summary>
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </summary>
        Friend ReadOnly Property BlockKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._blockKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._endKeyword
                Case 1
                    Return Me._blockKeyword
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new EndBlockStatementSyntax(Me.Kind, newErrors, GetAnnotations, _endKeyword, _blockKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new EndBlockStatementSyntax(Me.Kind, GetDiagnostics, annotations, _endKeyword, _blockKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitEndBlockStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an entire source file of VB code.
    ''' </summary>
    Partial Friend NotInheritable Class CompilationUnitSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _options as GreenNode
        Friend ReadOnly _imports as GreenNode
        Friend ReadOnly _attributes as GreenNode
        Friend ReadOnly _members as GreenNode
        Friend ReadOnly _endOfFileToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, options As GreenNode, [imports] As GreenNode, attributes As GreenNode, members As GreenNode, endOfFileToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 5

            If options IsNot Nothing Then
                AdjustFlagsAndWidth(options)
                Me._options = options
            End If
            If [imports] IsNot Nothing Then
                AdjustFlagsAndWidth([imports])
                Me._imports = [imports]
            End If
            If attributes IsNot Nothing Then
                AdjustFlagsAndWidth(attributes)
                Me._attributes = attributes
            End If
            If members IsNot Nothing Then
                AdjustFlagsAndWidth(members)
                Me._members = members
            End If
            AdjustFlagsAndWidth(endOfFileToken)
            Me._endOfFileToken = endOfFileToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, options As GreenNode, [imports] As GreenNode, attributes As GreenNode, members As GreenNode, endOfFileToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            If options IsNot Nothing Then
                AdjustFlagsAndWidth(options)
                Me._options = options
            End If
            If [imports] IsNot Nothing Then
                AdjustFlagsAndWidth([imports])
                Me._imports = [imports]
            End If
            If attributes IsNot Nothing Then
                AdjustFlagsAndWidth(attributes)
                Me._attributes = attributes
            End If
            If members IsNot Nothing Then
                AdjustFlagsAndWidth(members)
                Me._members = members
            End If
            AdjustFlagsAndWidth(endOfFileToken)
            Me._endOfFileToken = endOfFileToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), options As GreenNode, [imports] As GreenNode, attributes As GreenNode, members As GreenNode, endOfFileToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 5

            If options IsNot Nothing Then
                AdjustFlagsAndWidth(options)
                Me._options = options
            End If
            If [imports] IsNot Nothing Then
                AdjustFlagsAndWidth([imports])
                Me._imports = [imports]
            End If
            If attributes IsNot Nothing Then
                AdjustFlagsAndWidth(attributes)
                Me._attributes = attributes
            End If
            If members IsNot Nothing Then
                AdjustFlagsAndWidth(members)
                Me._members = members
            End If
            AdjustFlagsAndWidth(endOfFileToken)
            Me._endOfFileToken = endOfFileToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' Represents the list of Option statements at the beginning of a source file.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Options As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of OptionStatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of OptionStatementSyntax)(Me._options)
            End Get
        End Property

        ''' <summary>
        ''' Represents the list of Imports statements at the beginning of a source file.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property [Imports] As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of ImportsStatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of ImportsStatementSyntax)(Me._imports)
            End Get
        End Property

        ''' <summary>
        ''' Represents the list of AttributeStatements at the beginning of a source file
        ''' that contain the Assembly and Module attributes.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Attributes As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AttributesStatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AttributesStatementSyntax)(Me._attributes)
            End Get
        End Property

        ''' <summary>
        ''' Represents the members of the default namespace for this source file: all the
        ''' top-level type and namespace declarations in the file. May also contain
        ''' Statements that are not valid
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Members As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)(Me._members)
            End Get
        End Property

        ''' <summary>
        ''' Represents the end of the source file. This token may have trivia (whitespace,
        ''' comments, ...) attached to it.
        ''' </summary>
        Friend ReadOnly Property EndOfFileToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._endOfFileToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._options
                Case 1
                    Return Me._imports
                Case 2
                    Return Me._attributes
                Case 3
                    Return Me._members
                Case 4
                    Return Me._endOfFileToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new CompilationUnitSyntax(Me.Kind, newErrors, GetAnnotations, _options, _imports, _attributes, _members, _endOfFileToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new CompilationUnitSyntax(Me.Kind, GetDiagnostics, annotations, _options, _imports, _attributes, _members, _endOfFileToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitCompilationUnit(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an Option statement, such as "Option Strict On".
    ''' </summary>
    Friend NotInheritable Class OptionStatementSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _optionKeyword as KeywordSyntax
        Friend ReadOnly _nameKeyword as KeywordSyntax
        Friend ReadOnly _valueKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, optionKeyword As InternalSyntax.KeywordSyntax, nameKeyword As InternalSyntax.KeywordSyntax, valueKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(optionKeyword)
            Me._optionKeyword = optionKeyword
            AdjustFlagsAndWidth(nameKeyword)
            Me._nameKeyword = nameKeyword
            If valueKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(valueKeyword)
                Me._valueKeyword = valueKeyword
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, optionKeyword As InternalSyntax.KeywordSyntax, nameKeyword As InternalSyntax.KeywordSyntax, valueKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(optionKeyword)
            Me._optionKeyword = optionKeyword
            AdjustFlagsAndWidth(nameKeyword)
            Me._nameKeyword = nameKeyword
            If valueKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(valueKeyword)
                Me._valueKeyword = valueKeyword
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), optionKeyword As InternalSyntax.KeywordSyntax, nameKeyword As InternalSyntax.KeywordSyntax, valueKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(optionKeyword)
            Me._optionKeyword = optionKeyword
            AdjustFlagsAndWidth(nameKeyword)
            Me._nameKeyword = nameKeyword
            If valueKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(valueKeyword)
                Me._valueKeyword = valueKeyword
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.OptionStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Option" keyword.
        ''' </summary>
        Friend ReadOnly Property OptionKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._optionKeyword
            End Get
        End Property

        ''' <summary>
        ''' The keyword that identifies the option being set: Explicit, Strict, Compare or
        ''' Infer.
        ''' </summary>
        Friend ReadOnly Property NameKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._nameKeyword
            End Get
        End Property

        ''' <summary>
        ''' The keyword that identifiers the value being set for the option: On, Off, Text
        ''' or Binary.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property ValueKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._valueKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._optionKeyword
                Case 1
                    Return Me._nameKeyword
                Case 2
                    Return Me._valueKeyword
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new OptionStatementSyntax(Me.Kind, newErrors, GetAnnotations, _optionKeyword, _nameKeyword, _valueKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new OptionStatementSyntax(Me.Kind, GetDiagnostics, annotations, _optionKeyword, _nameKeyword, _valueKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitOptionStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an Imports statement, which has one or more imports clauses.
    ''' </summary>
    Friend NotInheritable Class ImportsStatementSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _importsKeyword as KeywordSyntax
        Friend ReadOnly _importsClauses as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, importsKeyword As InternalSyntax.KeywordSyntax, importsClauses As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(importsKeyword)
            Me._importsKeyword = importsKeyword
            If importsClauses IsNot Nothing Then
                AdjustFlagsAndWidth(importsClauses)
                Me._importsClauses = importsClauses
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, importsKeyword As InternalSyntax.KeywordSyntax, importsClauses As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(importsKeyword)
            Me._importsKeyword = importsKeyword
            If importsClauses IsNot Nothing Then
                AdjustFlagsAndWidth(importsClauses)
                Me._importsClauses = importsClauses
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), importsKeyword As InternalSyntax.KeywordSyntax, importsClauses As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(importsKeyword)
            Me._importsKeyword = importsKeyword
            If importsClauses IsNot Nothing Then
                AdjustFlagsAndWidth(importsClauses)
                Me._importsClauses = importsClauses
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Imports" keyword.
        ''' </summary>
        Friend ReadOnly Property ImportsKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._importsKeyword
            End Get
        End Property

        ''' <summary>
        ''' A list of one or more import clauses. Each clause is either an alias, namespace
        ''' or XML namespace import.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property ImportsClauses As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ImportsClauseSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ImportsClauseSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of ImportsClauseSyntax)(Me._importsClauses))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._importsKeyword
                Case 1
                    Return Me._importsClauses
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ImportsStatementSyntax(Me.Kind, newErrors, GetAnnotations, _importsKeyword, _importsClauses)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ImportsStatementSyntax(Me.Kind, GetDiagnostics, annotations, _importsKeyword, _importsClauses)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitImportsStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' The base class for the possible clauses of an Imports statement.
    ''' </summary>
    Friend MustInherit Class ImportsClauseSyntax
        Inherits VisualBasicSyntaxNode


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

    End Class

    ''' <summary>
    ''' Represents the clause of an Imports statement that imports all members of a
    ''' type or namespace or aliases a type or namespace.
    ''' </summary>
    Friend NotInheritable Class SimpleImportsClauseSyntax
        Inherits ImportsClauseSyntax

        Friend ReadOnly _alias as ImportAliasClauseSyntax
        Friend ReadOnly _name as NameSyntax

        Friend Sub New(ByVal kind As SyntaxKind, [alias] As ImportAliasClauseSyntax, name As NameSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            If [alias] IsNot Nothing Then
                AdjustFlagsAndWidth([alias])
                Me._alias = [alias]
            End If
            AdjustFlagsAndWidth(name)
            Me._name = name

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, [alias] As ImportAliasClauseSyntax, name As NameSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            If [alias] IsNot Nothing Then
                AdjustFlagsAndWidth([alias])
                Me._alias = [alias]
            End If
            AdjustFlagsAndWidth(name)
            Me._name = name

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), [alias] As ImportAliasClauseSyntax, name As NameSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            If [alias] IsNot Nothing Then
                AdjustFlagsAndWidth([alias])
                Me._alias = [alias]
            End If
            AdjustFlagsAndWidth(name)
            Me._name = name

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' An optional alias for the namespace or type being imported.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property [Alias] As InternalSyntax.ImportAliasClauseSyntax
            Get
                Return Me._alias
            End Get
        End Property

        ''' <summary>
        ''' The namespace or type being imported.
        ''' </summary>
        Friend ReadOnly Property Name As InternalSyntax.NameSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._alias
                Case 1
                    Return Me._name
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new SimpleImportsClauseSyntax(Me.Kind, newErrors, GetAnnotations, _alias, _name)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new SimpleImportsClauseSyntax(Me.Kind, GetDiagnostics, annotations, _alias, _name)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitSimpleImportsClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an alias identifier followed by an "=" token in an Imports clause.
    ''' </summary>
    Friend NotInheritable Class ImportAliasClauseSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _identifier as IdentifierTokenSyntax
        Friend ReadOnly _equalsToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, identifier As InternalSyntax.IdentifierTokenSyntax, equalsToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, identifier As InternalSyntax.IdentifierTokenSyntax, equalsToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), identifier As InternalSyntax.IdentifierTokenSyntax, equalsToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportAliasClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The identifier being introduced.
        ''' </summary>
        Friend ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' The "=" token.
        ''' </summary>
        Friend ReadOnly Property EqualsToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._equalsToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._identifier
                Case 1
                    Return Me._equalsToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ImportAliasClauseSyntax(Me.Kind, newErrors, GetAnnotations, _identifier, _equalsToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ImportAliasClauseSyntax(Me.Kind, GetDiagnostics, annotations, _identifier, _equalsToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitImportAliasClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Defines a XML namespace for XML expressions.
    ''' </summary>
    Friend NotInheritable Class XmlNamespaceImportsClauseSyntax
        Inherits ImportsClauseSyntax

        Friend ReadOnly _lessThanToken as PunctuationSyntax
        Friend ReadOnly _xmlNamespace as XmlAttributeSyntax
        Friend ReadOnly _greaterThanToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lessThanToken As InternalSyntax.PunctuationSyntax, xmlNamespace As XmlAttributeSyntax, greaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(lessThanToken)
            Me._lessThanToken = lessThanToken
            AdjustFlagsAndWidth(xmlNamespace)
            Me._xmlNamespace = xmlNamespace
            AdjustFlagsAndWidth(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, lessThanToken As InternalSyntax.PunctuationSyntax, xmlNamespace As XmlAttributeSyntax, greaterThanToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(lessThanToken)
            Me._lessThanToken = lessThanToken
            AdjustFlagsAndWidth(xmlNamespace)
            Me._xmlNamespace = xmlNamespace
            AdjustFlagsAndWidth(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lessThanToken As InternalSyntax.PunctuationSyntax, xmlNamespace As XmlAttributeSyntax, greaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(lessThanToken)
            Me._lessThanToken = lessThanToken
            AdjustFlagsAndWidth(xmlNamespace)
            Me._xmlNamespace = xmlNamespace
            AdjustFlagsAndWidth(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNamespaceImportsClauseSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property LessThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._lessThanToken
            End Get
        End Property

        ''' <summary>
        ''' Identifies the XML namespace alias and URI.
        ''' </summary>
        Friend ReadOnly Property XmlNamespace As InternalSyntax.XmlAttributeSyntax
            Get
                Return Me._xmlNamespace
            End Get
        End Property

        Friend ReadOnly Property GreaterThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._greaterThanToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._lessThanToken
                Case 1
                    Return Me._xmlNamespace
                Case 2
                    Return Me._greaterThanToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlNamespaceImportsClauseSyntax(Me.Kind, newErrors, GetAnnotations, _lessThanToken, _xmlNamespace, _greaterThanToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlNamespaceImportsClauseSyntax(Me.Kind, GetDiagnostics, annotations, _lessThanToken, _xmlNamespace, _greaterThanToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitXmlNamespaceImportsClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a Namespace statement, its contents and the End Namespace statement.
    ''' </summary>
    Friend NotInheritable Class NamespaceBlockSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _namespaceStatement as NamespaceStatementSyntax
        Friend ReadOnly _members as GreenNode
        Friend ReadOnly _endNamespaceStatement as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, namespaceStatement As NamespaceStatementSyntax, members As GreenNode, endNamespaceStatement As EndBlockStatementSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(namespaceStatement)
            Me._namespaceStatement = namespaceStatement
            If members IsNot Nothing Then
                AdjustFlagsAndWidth(members)
                Me._members = members
            End If
            AdjustFlagsAndWidth(endNamespaceStatement)
            Me._endNamespaceStatement = endNamespaceStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, namespaceStatement As NamespaceStatementSyntax, members As GreenNode, endNamespaceStatement As EndBlockStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(namespaceStatement)
            Me._namespaceStatement = namespaceStatement
            If members IsNot Nothing Then
                AdjustFlagsAndWidth(members)
                Me._members = members
            End If
            AdjustFlagsAndWidth(endNamespaceStatement)
            Me._endNamespaceStatement = endNamespaceStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), namespaceStatement As NamespaceStatementSyntax, members As GreenNode, endNamespaceStatement As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(namespaceStatement)
            Me._namespaceStatement = namespaceStatement
            If members IsNot Nothing Then
                AdjustFlagsAndWidth(members)
                Me._members = members
            End If
            AdjustFlagsAndWidth(endNamespaceStatement)
            Me._endNamespaceStatement = endNamespaceStatement

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The statement that begins the NamespaceBlock.
        ''' </summary>
        Friend ReadOnly Property NamespaceStatement As InternalSyntax.NamespaceStatementSyntax
            Get
                Return Me._namespaceStatement
            End Get
        End Property

        ''' <summary>
        ''' The declarations contained in the namespace statement.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Members As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)(Me._members)
            End Get
        End Property

        ''' <summary>
        ''' The End Namespace statement that ends the block.
        ''' </summary>
        Friend ReadOnly Property EndNamespaceStatement As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._endNamespaceStatement
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._namespaceStatement
                Case 1
                    Return Me._members
                Case 2
                    Return Me._endNamespaceStatement
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new NamespaceBlockSyntax(Me.Kind, newErrors, GetAnnotations, _namespaceStatement, _members, _endNamespaceStatement)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new NamespaceBlockSyntax(Me.Kind, GetDiagnostics, annotations, _namespaceStatement, _members, _endNamespaceStatement)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitNamespaceBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the beginning statement of a namespace declaration. This node always
    ''' appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
    ''' </summary>
    Friend NotInheritable Class NamespaceStatementSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _namespaceKeyword as KeywordSyntax
        Friend ReadOnly _name as NameSyntax

        Friend Sub New(ByVal kind As SyntaxKind, namespaceKeyword As InternalSyntax.KeywordSyntax, name As NameSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(namespaceKeyword)
            Me._namespaceKeyword = namespaceKeyword
            AdjustFlagsAndWidth(name)
            Me._name = name

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, namespaceKeyword As InternalSyntax.KeywordSyntax, name As NameSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(namespaceKeyword)
            Me._namespaceKeyword = namespaceKeyword
            AdjustFlagsAndWidth(name)
            Me._name = name

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), namespaceKeyword As InternalSyntax.KeywordSyntax, name As NameSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(namespaceKeyword)
            Me._namespaceKeyword = namespaceKeyword
            AdjustFlagsAndWidth(name)
            Me._name = name

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Namespace" keyword.
        ''' </summary>
        Friend ReadOnly Property NamespaceKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._namespaceKeyword
            End Get
        End Property

        ''' <summary>
        ''' A (possibly dotted) name denoting the namespace being declared.
        ''' </summary>
        Friend ReadOnly Property Name As InternalSyntax.NameSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._namespaceKeyword
                Case 1
                    Return Me._name
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new NamespaceStatementSyntax(Me.Kind, newErrors, GetAnnotations, _namespaceKeyword, _name)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new NamespaceStatementSyntax(Me.Kind, GetDiagnostics, annotations, _namespaceKeyword, _name)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitNamespaceStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a declaration of a Class, Interface, Structure, Module, its contents
    ''' and the End statement that ends it.
    ''' </summary>
    Friend MustInherit Class TypeBlockSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _inherits as GreenNode
        Friend ReadOnly _implements as GreenNode
        Friend ReadOnly _members as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, [inherits] As GreenNode, [implements] As GreenNode, members As GreenNode)
            MyBase.New(kind)

            If [inherits] IsNot Nothing Then
                AdjustFlagsAndWidth([inherits])
                Me._inherits = [inherits]
            End If
            If [implements] IsNot Nothing Then
                AdjustFlagsAndWidth([implements])
                Me._implements = [implements]
            End If
            If members IsNot Nothing Then
                AdjustFlagsAndWidth(members)
                Me._members = members
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, [inherits] As GreenNode, [implements] As GreenNode, members As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)

            If [inherits] IsNot Nothing Then
                AdjustFlagsAndWidth([inherits])
                Me._inherits = [inherits]
            End If
            If [implements] IsNot Nothing Then
                AdjustFlagsAndWidth([implements])
                Me._implements = [implements]
            End If
            If members IsNot Nothing Then
                AdjustFlagsAndWidth(members)
                Me._members = members
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), [inherits] As GreenNode, [implements] As GreenNode, members As GreenNode)
            MyBase.New(kind, errors, annotations)

            If [inherits] IsNot Nothing Then
                AdjustFlagsAndWidth([inherits])
                Me._inherits = [inherits]
            End If
            If [implements] IsNot Nothing Then
                AdjustFlagsAndWidth([implements])
                Me._implements = [implements]
            End If
            If members IsNot Nothing Then
                AdjustFlagsAndWidth(members)
                Me._members = members
            End If

        End Sub

        ''' <summary>
        ''' A list of the Inherits declarations for the type.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property [Inherits] As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of InheritsStatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of InheritsStatementSyntax)(Me._inherits)
            End Get
        End Property

        ''' <summary>
        ''' A list of the Implements declarations for the type.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property [Implements] As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of ImplementsStatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of ImplementsStatementSyntax)(Me._implements)
            End Get
        End Property

        ''' <summary>
        ''' The declarations contained in the type or module.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Members As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)(Me._members)
            End Get
        End Property

    End Class

    ''' <summary>
    ''' Represents a declaration of Module, its contents and the End statement that
    ''' ends it.
    ''' </summary>
    Friend NotInheritable Class ModuleBlockSyntax
        Inherits TypeBlockSyntax

        Friend ReadOnly _moduleStatement as ModuleStatementSyntax
        Friend ReadOnly _endModuleStatement as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, moduleStatement As ModuleStatementSyntax, [inherits] As GreenNode, [implements] As GreenNode, members As GreenNode, endModuleStatement As EndBlockStatementSyntax)
            MyBase.New(kind, [inherits], [implements], members)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(moduleStatement)
            Me._moduleStatement = moduleStatement
            AdjustFlagsAndWidth(endModuleStatement)
            Me._endModuleStatement = endModuleStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, moduleStatement As ModuleStatementSyntax, [inherits] As GreenNode, [implements] As GreenNode, members As GreenNode, endModuleStatement As EndBlockStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, [inherits], [implements], members)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(moduleStatement)
            Me._moduleStatement = moduleStatement
            AdjustFlagsAndWidth(endModuleStatement)
            Me._endModuleStatement = endModuleStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), moduleStatement As ModuleStatementSyntax, [inherits] As GreenNode, [implements] As GreenNode, members As GreenNode, endModuleStatement As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations, [inherits], [implements], members)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(moduleStatement)
            Me._moduleStatement = moduleStatement
            AdjustFlagsAndWidth(endModuleStatement)
            Me._endModuleStatement = endModuleStatement

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Module" statement that begins the block.
        ''' </summary>
        Friend ReadOnly Property ModuleStatement As InternalSyntax.ModuleStatementSyntax
            Get
                Return Me._moduleStatement
            End Get
        End Property

        ''' <summary>
        ''' The "End Module" statement that ends the block.
        ''' </summary>
        Friend ReadOnly Property EndModuleStatement As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._endModuleStatement
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._moduleStatement
                Case 1
                    Return Me._inherits
                Case 2
                    Return Me._implements
                Case 3
                    Return Me._members
                Case 4
                    Return Me._endModuleStatement
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ModuleBlockSyntax(Me.Kind, newErrors, GetAnnotations, _moduleStatement, _inherits, _implements, _members, _endModuleStatement)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ModuleBlockSyntax(Me.Kind, GetDiagnostics, annotations, _moduleStatement, _inherits, _implements, _members, _endModuleStatement)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitModuleBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a declaration of a Structure, its contents and the End statement
    ''' that ends it.
    ''' </summary>
    Friend NotInheritable Class StructureBlockSyntax
        Inherits TypeBlockSyntax

        Friend ReadOnly _structureStatement as StructureStatementSyntax
        Friend ReadOnly _endStructureStatement as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, structureStatement As StructureStatementSyntax, [inherits] As GreenNode, [implements] As GreenNode, members As GreenNode, endStructureStatement As EndBlockStatementSyntax)
            MyBase.New(kind, [inherits], [implements], members)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(structureStatement)
            Me._structureStatement = structureStatement
            AdjustFlagsAndWidth(endStructureStatement)
            Me._endStructureStatement = endStructureStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, structureStatement As StructureStatementSyntax, [inherits] As GreenNode, [implements] As GreenNode, members As GreenNode, endStructureStatement As EndBlockStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, [inherits], [implements], members)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(structureStatement)
            Me._structureStatement = structureStatement
            AdjustFlagsAndWidth(endStructureStatement)
            Me._endStructureStatement = endStructureStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), structureStatement As StructureStatementSyntax, [inherits] As GreenNode, [implements] As GreenNode, members As GreenNode, endStructureStatement As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations, [inherits], [implements], members)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(structureStatement)
            Me._structureStatement = structureStatement
            AdjustFlagsAndWidth(endStructureStatement)
            Me._endStructureStatement = endStructureStatement

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Structure" statement that begins the block.
        ''' </summary>
        Friend ReadOnly Property StructureStatement As InternalSyntax.StructureStatementSyntax
            Get
                Return Me._structureStatement
            End Get
        End Property

        ''' <summary>
        ''' The "End Structure" statement that ends the block.
        ''' </summary>
        Friend ReadOnly Property EndStructureStatement As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._endStructureStatement
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._structureStatement
                Case 1
                    Return Me._inherits
                Case 2
                    Return Me._implements
                Case 3
                    Return Me._members
                Case 4
                    Return Me._endStructureStatement
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new StructureBlockSyntax(Me.Kind, newErrors, GetAnnotations, _structureStatement, _inherits, _implements, _members, _endStructureStatement)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new StructureBlockSyntax(Me.Kind, GetDiagnostics, annotations, _structureStatement, _inherits, _implements, _members, _endStructureStatement)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitStructureBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a declaration of a Interface, its contents and the End statement
    ''' that ends it.
    ''' </summary>
    Friend NotInheritable Class InterfaceBlockSyntax
        Inherits TypeBlockSyntax

        Friend ReadOnly _interfaceStatement as InterfaceStatementSyntax
        Friend ReadOnly _endInterfaceStatement as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, interfaceStatement As InterfaceStatementSyntax, [inherits] As GreenNode, [implements] As GreenNode, members As GreenNode, endInterfaceStatement As EndBlockStatementSyntax)
            MyBase.New(kind, [inherits], [implements], members)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(interfaceStatement)
            Me._interfaceStatement = interfaceStatement
            AdjustFlagsAndWidth(endInterfaceStatement)
            Me._endInterfaceStatement = endInterfaceStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, interfaceStatement As InterfaceStatementSyntax, [inherits] As GreenNode, [implements] As GreenNode, members As GreenNode, endInterfaceStatement As EndBlockStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, [inherits], [implements], members)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(interfaceStatement)
            Me._interfaceStatement = interfaceStatement
            AdjustFlagsAndWidth(endInterfaceStatement)
            Me._endInterfaceStatement = endInterfaceStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), interfaceStatement As InterfaceStatementSyntax, [inherits] As GreenNode, [implements] As GreenNode, members As GreenNode, endInterfaceStatement As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations, [inherits], [implements], members)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(interfaceStatement)
            Me._interfaceStatement = interfaceStatement
            AdjustFlagsAndWidth(endInterfaceStatement)
            Me._endInterfaceStatement = endInterfaceStatement

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Interface" statement that begins the block.
        ''' </summary>
        Friend ReadOnly Property InterfaceStatement As InternalSyntax.InterfaceStatementSyntax
            Get
                Return Me._interfaceStatement
            End Get
        End Property

        ''' <summary>
        ''' The "End Interface" statement that ends the block.
        ''' </summary>
        Friend ReadOnly Property EndInterfaceStatement As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._endInterfaceStatement
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._interfaceStatement
                Case 1
                    Return Me._inherits
                Case 2
                    Return Me._implements
                Case 3
                    Return Me._members
                Case 4
                    Return Me._endInterfaceStatement
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new InterfaceBlockSyntax(Me.Kind, newErrors, GetAnnotations, _interfaceStatement, _inherits, _implements, _members, _endInterfaceStatement)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new InterfaceBlockSyntax(Me.Kind, GetDiagnostics, annotations, _interfaceStatement, _inherits, _implements, _members, _endInterfaceStatement)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitInterfaceBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a declaration of a Class its contents and the End statement that
    ''' ends it.
    ''' </summary>
    Friend NotInheritable Class ClassBlockSyntax
        Inherits TypeBlockSyntax

        Friend ReadOnly _classStatement as ClassStatementSyntax
        Friend ReadOnly _endClassStatement as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, classStatement As ClassStatementSyntax, [inherits] As GreenNode, [implements] As GreenNode, members As GreenNode, endClassStatement As EndBlockStatementSyntax)
            MyBase.New(kind, [inherits], [implements], members)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(classStatement)
            Me._classStatement = classStatement
            AdjustFlagsAndWidth(endClassStatement)
            Me._endClassStatement = endClassStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, classStatement As ClassStatementSyntax, [inherits] As GreenNode, [implements] As GreenNode, members As GreenNode, endClassStatement As EndBlockStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, [inherits], [implements], members)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(classStatement)
            Me._classStatement = classStatement
            AdjustFlagsAndWidth(endClassStatement)
            Me._endClassStatement = endClassStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), classStatement As ClassStatementSyntax, [inherits] As GreenNode, [implements] As GreenNode, members As GreenNode, endClassStatement As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations, [inherits], [implements], members)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(classStatement)
            Me._classStatement = classStatement
            AdjustFlagsAndWidth(endClassStatement)
            Me._endClassStatement = endClassStatement

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Class" statement that begins the block.
        ''' </summary>
        Friend ReadOnly Property ClassStatement As InternalSyntax.ClassStatementSyntax
            Get
                Return Me._classStatement
            End Get
        End Property

        ''' <summary>
        ''' The "End Class" statement that ends the block.
        ''' </summary>
        Friend ReadOnly Property EndClassStatement As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._endClassStatement
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._classStatement
                Case 1
                    Return Me._inherits
                Case 2
                    Return Me._implements
                Case 3
                    Return Me._members
                Case 4
                    Return Me._endClassStatement
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ClassBlockSyntax(Me.Kind, newErrors, GetAnnotations, _classStatement, _inherits, _implements, _members, _endClassStatement)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ClassBlockSyntax(Me.Kind, GetDiagnostics, annotations, _classStatement, _inherits, _implements, _members, _endClassStatement)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitClassBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a declaration of an Enum, its contents and the End Enum statement
    ''' that ends it.
    ''' </summary>
    Friend NotInheritable Class EnumBlockSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _enumStatement as EnumStatementSyntax
        Friend ReadOnly _members as GreenNode
        Friend ReadOnly _endEnumStatement as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, enumStatement As EnumStatementSyntax, members As GreenNode, endEnumStatement As EndBlockStatementSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(enumStatement)
            Me._enumStatement = enumStatement
            If members IsNot Nothing Then
                AdjustFlagsAndWidth(members)
                Me._members = members
            End If
            AdjustFlagsAndWidth(endEnumStatement)
            Me._endEnumStatement = endEnumStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, enumStatement As EnumStatementSyntax, members As GreenNode, endEnumStatement As EndBlockStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(enumStatement)
            Me._enumStatement = enumStatement
            If members IsNot Nothing Then
                AdjustFlagsAndWidth(members)
                Me._members = members
            End If
            AdjustFlagsAndWidth(endEnumStatement)
            Me._endEnumStatement = endEnumStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), enumStatement As EnumStatementSyntax, members As GreenNode, endEnumStatement As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(enumStatement)
            Me._enumStatement = enumStatement
            If members IsNot Nothing Then
                AdjustFlagsAndWidth(members)
                Me._members = members
            End If
            AdjustFlagsAndWidth(endEnumStatement)
            Me._endEnumStatement = endEnumStatement

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The statement that begins the type or module.
        ''' </summary>
        Friend ReadOnly Property EnumStatement As InternalSyntax.EnumStatementSyntax
            Get
                Return Me._enumStatement
            End Get
        End Property

        ''' <summary>
        ''' The declarations contained in the enumeration.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Members As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)(Me._members)
            End Get
        End Property

        ''' <summary>
        ''' The End XXX statement that ends the block.
        ''' </summary>
        Friend ReadOnly Property EndEnumStatement As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._endEnumStatement
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._enumStatement
                Case 1
                    Return Me._members
                Case 2
                    Return Me._endEnumStatement
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new EnumBlockSyntax(Me.Kind, newErrors, GetAnnotations, _enumStatement, _members, _endEnumStatement)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new EnumBlockSyntax(Me.Kind, GetDiagnostics, annotations, _enumStatement, _members, _endEnumStatement)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitEnumBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an Inherits or Implements statement in a Class, Structure or
    ''' Interface.
    ''' </summary>
    Friend MustInherit Class InheritsOrImplementsStatementSyntax
        Inherits DeclarationStatementSyntax


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

    End Class

    ''' <summary>
    ''' Represents an Inherits statement in a Class, Structure or Interface.
    ''' </summary>
    Friend NotInheritable Class InheritsStatementSyntax
        Inherits InheritsOrImplementsStatementSyntax

        Friend ReadOnly _inheritsKeyword as KeywordSyntax
        Friend ReadOnly _types as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, inheritsKeyword As InternalSyntax.KeywordSyntax, types As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(inheritsKeyword)
            Me._inheritsKeyword = inheritsKeyword
            If types IsNot Nothing Then
                AdjustFlagsAndWidth(types)
                Me._types = types
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, inheritsKeyword As InternalSyntax.KeywordSyntax, types As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(inheritsKeyword)
            Me._inheritsKeyword = inheritsKeyword
            If types IsNot Nothing Then
                AdjustFlagsAndWidth(types)
                Me._types = types
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), inheritsKeyword As InternalSyntax.KeywordSyntax, types As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(inheritsKeyword)
            Me._inheritsKeyword = inheritsKeyword
            If types IsNot Nothing Then
                AdjustFlagsAndWidth(types)
                Me._types = types
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Inherits" keyword.
        ''' </summary>
        Friend ReadOnly Property InheritsKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._inheritsKeyword
            End Get
        End Property

        ''' <summary>
        ''' A list of the types being inherited.
        ''' </summary>
        Friend ReadOnly Property Types As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of TypeSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of TypeSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of TypeSyntax)(Me._types))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._inheritsKeyword
                Case 1
                    Return Me._types
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new InheritsStatementSyntax(Me.Kind, newErrors, GetAnnotations, _inheritsKeyword, _types)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new InheritsStatementSyntax(Me.Kind, GetDiagnostics, annotations, _inheritsKeyword, _types)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitInheritsStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an Implements statement in a Class or Structure.
    ''' </summary>
    Friend NotInheritable Class ImplementsStatementSyntax
        Inherits InheritsOrImplementsStatementSyntax

        Friend ReadOnly _implementsKeyword as KeywordSyntax
        Friend ReadOnly _types as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, implementsKeyword As InternalSyntax.KeywordSyntax, types As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(implementsKeyword)
            Me._implementsKeyword = implementsKeyword
            If types IsNot Nothing Then
                AdjustFlagsAndWidth(types)
                Me._types = types
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, implementsKeyword As InternalSyntax.KeywordSyntax, types As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(implementsKeyword)
            Me._implementsKeyword = implementsKeyword
            If types IsNot Nothing Then
                AdjustFlagsAndWidth(types)
                Me._types = types
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), implementsKeyword As InternalSyntax.KeywordSyntax, types As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(implementsKeyword)
            Me._implementsKeyword = implementsKeyword
            If types IsNot Nothing Then
                AdjustFlagsAndWidth(types)
                Me._types = types
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Implements" keyword.
        ''' </summary>
        Friend ReadOnly Property ImplementsKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._implementsKeyword
            End Get
        End Property

        ''' <summary>
        ''' A list of the types being implemented.
        ''' </summary>
        Friend ReadOnly Property Types As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of TypeSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of TypeSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of TypeSyntax)(Me._types))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._implementsKeyword
                Case 1
                    Return Me._types
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ImplementsStatementSyntax(Me.Kind, newErrors, GetAnnotations, _implementsKeyword, _types)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ImplementsStatementSyntax(Me.Kind, GetDiagnostics, annotations, _implementsKeyword, _types)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitImplementsStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Abstract class for the beginning statement of a Module, Class, Interface or
    ''' Structure declaration. This node always appears as the Begin of a TypeBlock
    ''' with Kind=ModuleDeclarationBlock, ClassDeclarationBlock,
    ''' InterfaceDeclarationBlock or StructureDeclarationBlock.
    ''' </summary>
    Friend MustInherit Class TypeStatementSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _attributeLists as GreenNode
        Friend ReadOnly _modifiers as GreenNode
        Friend ReadOnly _identifier as IdentifierTokenSyntax
        Friend ReadOnly _typeParameterList as TypeParameterListSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax)
            MyBase.New(kind)

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            If modifiers IsNot Nothing Then
                AdjustFlagsAndWidth(modifiers)
                Me._modifiers = modifiers
            End If
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If typeParameterList IsNot Nothing Then
                AdjustFlagsAndWidth(typeParameterList)
                Me._typeParameterList = typeParameterList
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            If modifiers IsNot Nothing Then
                AdjustFlagsAndWidth(modifiers)
                Me._modifiers = modifiers
            End If
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If typeParameterList IsNot Nothing Then
                AdjustFlagsAndWidth(typeParameterList)
                Me._typeParameterList = typeParameterList
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributeLists As GreenNode, modifiers As GreenNode, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax)
            MyBase.New(kind, errors, annotations)

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            If modifiers IsNot Nothing Then
                AdjustFlagsAndWidth(modifiers)
                Me._modifiers = modifiers
            End If
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If typeParameterList IsNot Nothing Then
                AdjustFlagsAndWidth(typeParameterList)
                Me._typeParameterList = typeParameterList
            End If

        End Sub

        ''' <summary>
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property AttributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AttributeListSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AttributeListSyntax)(Me._attributeLists)
            End Get
        End Property

        ''' <summary>
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of KeywordSyntax)
            Get
                Return New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)(Me._modifiers)
            End Get
        End Property

        ''' <summary>
        ''' The name of the type being declared.
        ''' </summary>
        Friend ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' If present, a type parameter list with generic parameters for this type. If no
        ''' generic parameters were present, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property TypeParameterList As InternalSyntax.TypeParameterListSyntax
            Get
                Return Me._typeParameterList
            End Get
        End Property

    End Class

    ''' <summary>
    ''' Represents the beginning statement of a Module declaration. This node always
    ''' appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
    ''' </summary>
    Friend NotInheritable Class ModuleStatementSyntax
        Inherits TypeStatementSyntax

        Friend ReadOnly _moduleKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, moduleKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax)
            MyBase.New(kind, attributeLists, modifiers, identifier, typeParameterList)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(moduleKeyword)
            Me._moduleKeyword = moduleKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, moduleKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, attributeLists, modifiers, identifier, typeParameterList)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(moduleKeyword)
            Me._moduleKeyword = moduleKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributeLists As GreenNode, modifiers As GreenNode, moduleKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax)
            MyBase.New(kind, errors, annotations, attributeLists, modifiers, identifier, typeParameterList)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(moduleKeyword)
            Me._moduleKeyword = moduleKeyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Module" keyword.
        ''' </summary>
        Friend ReadOnly Property ModuleKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._moduleKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._attributeLists
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._moduleKeyword
                Case 3
                    Return Me._identifier
                Case 4
                    Return Me._typeParameterList
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ModuleStatementSyntax(Me.Kind, newErrors, GetAnnotations, _attributeLists, _modifiers, _moduleKeyword, _identifier, _typeParameterList)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ModuleStatementSyntax(Me.Kind, GetDiagnostics, annotations, _attributeLists, _modifiers, _moduleKeyword, _identifier, _typeParameterList)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitModuleStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the beginning statement of a Structure declaration. This node always
    ''' appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
    ''' </summary>
    Friend NotInheritable Class StructureStatementSyntax
        Inherits TypeStatementSyntax

        Friend ReadOnly _structureKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, structureKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax)
            MyBase.New(kind, attributeLists, modifiers, identifier, typeParameterList)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(structureKeyword)
            Me._structureKeyword = structureKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, structureKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, attributeLists, modifiers, identifier, typeParameterList)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(structureKeyword)
            Me._structureKeyword = structureKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributeLists As GreenNode, modifiers As GreenNode, structureKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax)
            MyBase.New(kind, errors, annotations, attributeLists, modifiers, identifier, typeParameterList)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(structureKeyword)
            Me._structureKeyword = structureKeyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Structure" keyword.
        ''' </summary>
        Friend ReadOnly Property StructureKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._structureKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._attributeLists
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._structureKeyword
                Case 3
                    Return Me._identifier
                Case 4
                    Return Me._typeParameterList
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new StructureStatementSyntax(Me.Kind, newErrors, GetAnnotations, _attributeLists, _modifiers, _structureKeyword, _identifier, _typeParameterList)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new StructureStatementSyntax(Me.Kind, GetDiagnostics, annotations, _attributeLists, _modifiers, _structureKeyword, _identifier, _typeParameterList)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitStructureStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the beginning statement of a Interface declaration. This node always
    ''' appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
    ''' </summary>
    Friend NotInheritable Class InterfaceStatementSyntax
        Inherits TypeStatementSyntax

        Friend ReadOnly _interfaceKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, interfaceKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax)
            MyBase.New(kind, attributeLists, modifiers, identifier, typeParameterList)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(interfaceKeyword)
            Me._interfaceKeyword = interfaceKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, interfaceKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, attributeLists, modifiers, identifier, typeParameterList)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(interfaceKeyword)
            Me._interfaceKeyword = interfaceKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributeLists As GreenNode, modifiers As GreenNode, interfaceKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax)
            MyBase.New(kind, errors, annotations, attributeLists, modifiers, identifier, typeParameterList)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(interfaceKeyword)
            Me._interfaceKeyword = interfaceKeyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Interface" keyword.
        ''' </summary>
        Friend ReadOnly Property InterfaceKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._interfaceKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._attributeLists
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._interfaceKeyword
                Case 3
                    Return Me._identifier
                Case 4
                    Return Me._typeParameterList
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new InterfaceStatementSyntax(Me.Kind, newErrors, GetAnnotations, _attributeLists, _modifiers, _interfaceKeyword, _identifier, _typeParameterList)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new InterfaceStatementSyntax(Me.Kind, GetDiagnostics, annotations, _attributeLists, _modifiers, _interfaceKeyword, _identifier, _typeParameterList)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitInterfaceStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the beginning statement of a Class declaration. This node always
    ''' appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
    ''' </summary>
    Friend NotInheritable Class ClassStatementSyntax
        Inherits TypeStatementSyntax

        Friend ReadOnly _classKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, classKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax)
            MyBase.New(kind, attributeLists, modifiers, identifier, typeParameterList)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(classKeyword)
            Me._classKeyword = classKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, classKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, attributeLists, modifiers, identifier, typeParameterList)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(classKeyword)
            Me._classKeyword = classKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributeLists As GreenNode, modifiers As GreenNode, classKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax)
            MyBase.New(kind, errors, annotations, attributeLists, modifiers, identifier, typeParameterList)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(classKeyword)
            Me._classKeyword = classKeyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Class" keyword.
        ''' </summary>
        Friend ReadOnly Property ClassKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._classKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._attributeLists
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._classKeyword
                Case 3
                    Return Me._identifier
                Case 4
                    Return Me._typeParameterList
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ClassStatementSyntax(Me.Kind, newErrors, GetAnnotations, _attributeLists, _modifiers, _classKeyword, _identifier, _typeParameterList)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ClassStatementSyntax(Me.Kind, GetDiagnostics, annotations, _attributeLists, _modifiers, _classKeyword, _identifier, _typeParameterList)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitClassStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the beginning statement of an Enum declaration. This node always
    ''' appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
    ''' </summary>
    Friend NotInheritable Class EnumStatementSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _attributeLists as GreenNode
        Friend ReadOnly _modifiers as GreenNode
        Friend ReadOnly _enumKeyword as KeywordSyntax
        Friend ReadOnly _identifier as IdentifierTokenSyntax
        Friend ReadOnly _underlyingType as AsClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, enumKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, underlyingType As AsClauseSyntax)
            MyBase.New(kind)
            Me.SlotCount = 5

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            If modifiers IsNot Nothing Then
                AdjustFlagsAndWidth(modifiers)
                Me._modifiers = modifiers
            End If
            AdjustFlagsAndWidth(enumKeyword)
            Me._enumKeyword = enumKeyword
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If underlyingType IsNot Nothing Then
                AdjustFlagsAndWidth(underlyingType)
                Me._underlyingType = underlyingType
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, enumKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, underlyingType As AsClauseSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            If modifiers IsNot Nothing Then
                AdjustFlagsAndWidth(modifiers)
                Me._modifiers = modifiers
            End If
            AdjustFlagsAndWidth(enumKeyword)
            Me._enumKeyword = enumKeyword
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If underlyingType IsNot Nothing Then
                AdjustFlagsAndWidth(underlyingType)
                Me._underlyingType = underlyingType
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributeLists As GreenNode, modifiers As GreenNode, enumKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, underlyingType As AsClauseSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 5

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            If modifiers IsNot Nothing Then
                AdjustFlagsAndWidth(modifiers)
                Me._modifiers = modifiers
            End If
            AdjustFlagsAndWidth(enumKeyword)
            Me._enumKeyword = enumKeyword
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If underlyingType IsNot Nothing Then
                AdjustFlagsAndWidth(underlyingType)
                Me._underlyingType = underlyingType
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property AttributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AttributeListSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AttributeListSyntax)(Me._attributeLists)
            End Get
        End Property

        ''' <summary>
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of KeywordSyntax)
            Get
                Return New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)(Me._modifiers)
            End Get
        End Property

        ''' <summary>
        ''' The "Enum" keyword.
        ''' </summary>
        Friend ReadOnly Property EnumKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._enumKeyword
            End Get
        End Property

        ''' <summary>
        ''' The name of the enum being declared.
        ''' </summary>
        Friend ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' Optional "As XXX" clause describing the underlying type of the enumeration. If
        ''' no As clause was specified, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property UnderlyingType As InternalSyntax.AsClauseSyntax
            Get
                Return Me._underlyingType
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._attributeLists
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._enumKeyword
                Case 3
                    Return Me._identifier
                Case 4
                    Return Me._underlyingType
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new EnumStatementSyntax(Me.Kind, newErrors, GetAnnotations, _attributeLists, _modifiers, _enumKeyword, _identifier, _underlyingType)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new EnumStatementSyntax(Me.Kind, GetDiagnostics, annotations, _attributeLists, _modifiers, _enumKeyword, _identifier, _underlyingType)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitEnumStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the type parameter list in a declaration.
    ''' </summary>
    Friend NotInheritable Class TypeParameterListSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _ofKeyword as KeywordSyntax
        Friend ReadOnly _parameters as GreenNode
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, ofKeyword As InternalSyntax.KeywordSyntax, parameters As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(ofKeyword)
            Me._ofKeyword = ofKeyword
            If parameters IsNot Nothing Then
                AdjustFlagsAndWidth(parameters)
                Me._parameters = parameters
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, ofKeyword As InternalSyntax.KeywordSyntax, parameters As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 4
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(ofKeyword)
            Me._ofKeyword = ofKeyword
            If parameters IsNot Nothing Then
                AdjustFlagsAndWidth(parameters)
                Me._parameters = parameters
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), openParenToken As InternalSyntax.PunctuationSyntax, ofKeyword As InternalSyntax.KeywordSyntax, parameters As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(ofKeyword)
            Me._ofKeyword = ofKeyword
            If parameters IsNot Nothing Then
                AdjustFlagsAndWidth(parameters)
                Me._parameters = parameters
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "(" token.
        ''' </summary>
        Friend ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The "Of" keyword.
        ''' </summary>
        Friend ReadOnly Property OfKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._ofKeyword
            End Get
        End Property

        ''' <summary>
        ''' A list of the type parameters. There must be at least one type parameter in the
        ''' list.
        ''' </summary>
        Friend ReadOnly Property Parameters As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of TypeParameterSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of TypeParameterSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of TypeParameterSyntax)(Me._parameters))
            End Get
        End Property

        ''' <summary>
        ''' The ")" token.
        ''' </summary>
        Friend ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._openParenToken
                Case 1
                    Return Me._ofKeyword
                Case 2
                    Return Me._parameters
                Case 3
                    Return Me._closeParenToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new TypeParameterListSyntax(Me.Kind, newErrors, GetAnnotations, _openParenToken, _ofKeyword, _parameters, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new TypeParameterListSyntax(Me.Kind, GetDiagnostics, annotations, _openParenToken, _ofKeyword, _parameters, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitTypeParameterList(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a type parameter on a generic type declaration.
    ''' </summary>
    Friend NotInheritable Class TypeParameterSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _varianceKeyword as KeywordSyntax
        Friend ReadOnly _identifier as IdentifierTokenSyntax
        Friend ReadOnly _typeParameterConstraintClause as TypeParameterConstraintClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, varianceKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterConstraintClause As TypeParameterConstraintClauseSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            If varianceKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(varianceKeyword)
                Me._varianceKeyword = varianceKeyword
            End If
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If typeParameterConstraintClause IsNot Nothing Then
                AdjustFlagsAndWidth(typeParameterConstraintClause)
                Me._typeParameterConstraintClause = typeParameterConstraintClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, varianceKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterConstraintClause As TypeParameterConstraintClauseSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            If varianceKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(varianceKeyword)
                Me._varianceKeyword = varianceKeyword
            End If
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If typeParameterConstraintClause IsNot Nothing Then
                AdjustFlagsAndWidth(typeParameterConstraintClause)
                Me._typeParameterConstraintClause = typeParameterConstraintClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), varianceKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterConstraintClause As TypeParameterConstraintClauseSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            If varianceKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(varianceKeyword)
                Me._varianceKeyword = varianceKeyword
            End If
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If typeParameterConstraintClause IsNot Nothing Then
                AdjustFlagsAndWidth(typeParameterConstraintClause)
                Me._typeParameterConstraintClause = typeParameterConstraintClause
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' Represents the "In" or "Out" variance keyword on a type parameter, if present.
        ''' If no variance modifier was present, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property VarianceKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._varianceKeyword
            End Get
        End Property

        ''' <summary>
        ''' The name of the type parameter
        ''' </summary>
        Friend ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' The "As" keyword, if any type constraints were supplied. If no type constraints
        ''' were supplied, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property TypeParameterConstraintClause As InternalSyntax.TypeParameterConstraintClauseSyntax
            Get
                Return Me._typeParameterConstraintClause
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._varianceKeyword
                Case 1
                    Return Me._identifier
                Case 2
                    Return Me._typeParameterConstraintClause
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new TypeParameterSyntax(Me.Kind, newErrors, GetAnnotations, _varianceKeyword, _identifier, _typeParameterConstraintClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new TypeParameterSyntax(Me.Kind, GetDiagnostics, annotations, _varianceKeyword, _identifier, _typeParameterConstraintClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitTypeParameter(Me)
        End Function

    End Class

    ''' <summary>
    ''' An abstract node class that is the parent of classes that describe type
    ''' parameter constraint clauses.
    ''' </summary>
    Friend MustInherit Class TypeParameterConstraintClauseSyntax
        Inherits VisualBasicSyntaxNode


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

    End Class

    ''' <summary>
    ''' One of the type parameter constraints clauses. This represents a constraint
    ''' clause in the form of "As Constraint".
    ''' </summary>
    Friend NotInheritable Class TypeParameterSingleConstraintClauseSyntax
        Inherits TypeParameterConstraintClauseSyntax

        Friend ReadOnly _asKeyword as KeywordSyntax
        Friend ReadOnly _constraint as ConstraintSyntax

        Friend Sub New(ByVal kind As SyntaxKind, asKeyword As InternalSyntax.KeywordSyntax, constraint As ConstraintSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(asKeyword)
            Me._asKeyword = asKeyword
            AdjustFlagsAndWidth(constraint)
            Me._constraint = constraint

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, asKeyword As InternalSyntax.KeywordSyntax, constraint As ConstraintSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(asKeyword)
            Me._asKeyword = asKeyword
            AdjustFlagsAndWidth(constraint)
            Me._constraint = constraint

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), asKeyword As InternalSyntax.KeywordSyntax, constraint As ConstraintSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(asKeyword)
            Me._asKeyword = asKeyword
            AdjustFlagsAndWidth(constraint)
            Me._constraint = constraint

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSingleConstraintClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "As" keyword, if any type constraints were supplied. If no type constraints
        ''' were supplied, Nothing is returned.
        ''' </summary>
        Friend ReadOnly Property AsKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._asKeyword
            End Get
        End Property

        ''' <summary>
        ''' A list of the supplied constraints. If no constraints were supplied, Nothing is
        ''' returned.
        ''' </summary>
        Friend ReadOnly Property Constraint As InternalSyntax.ConstraintSyntax
            Get
                Return Me._constraint
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._asKeyword
                Case 1
                    Return Me._constraint
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new TypeParameterSingleConstraintClauseSyntax(Me.Kind, newErrors, GetAnnotations, _asKeyword, _constraint)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new TypeParameterSingleConstraintClauseSyntax(Me.Kind, GetDiagnostics, annotations, _asKeyword, _constraint)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitTypeParameterSingleConstraintClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' One of the type parameter constraints clauses. This represents a constraint
    ''' clause in the form of "As { Constraints }".
    ''' </summary>
    Friend NotInheritable Class TypeParameterMultipleConstraintClauseSyntax
        Inherits TypeParameterConstraintClauseSyntax

        Friend ReadOnly _asKeyword as KeywordSyntax
        Friend ReadOnly _openBraceToken as PunctuationSyntax
        Friend ReadOnly _constraints as GreenNode
        Friend ReadOnly _closeBraceToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, asKeyword As InternalSyntax.KeywordSyntax, openBraceToken As InternalSyntax.PunctuationSyntax, constraints As GreenNode, closeBraceToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(asKeyword)
            Me._asKeyword = asKeyword
            AdjustFlagsAndWidth(openBraceToken)
            Me._openBraceToken = openBraceToken
            If constraints IsNot Nothing Then
                AdjustFlagsAndWidth(constraints)
                Me._constraints = constraints
            End If
            AdjustFlagsAndWidth(closeBraceToken)
            Me._closeBraceToken = closeBraceToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, asKeyword As InternalSyntax.KeywordSyntax, openBraceToken As InternalSyntax.PunctuationSyntax, constraints As GreenNode, closeBraceToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 4
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(asKeyword)
            Me._asKeyword = asKeyword
            AdjustFlagsAndWidth(openBraceToken)
            Me._openBraceToken = openBraceToken
            If constraints IsNot Nothing Then
                AdjustFlagsAndWidth(constraints)
                Me._constraints = constraints
            End If
            AdjustFlagsAndWidth(closeBraceToken)
            Me._closeBraceToken = closeBraceToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), asKeyword As InternalSyntax.KeywordSyntax, openBraceToken As InternalSyntax.PunctuationSyntax, constraints As GreenNode, closeBraceToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(asKeyword)
            Me._asKeyword = asKeyword
            AdjustFlagsAndWidth(openBraceToken)
            Me._openBraceToken = openBraceToken
            If constraints IsNot Nothing Then
                AdjustFlagsAndWidth(constraints)
                Me._constraints = constraints
            End If
            AdjustFlagsAndWidth(closeBraceToken)
            Me._closeBraceToken = closeBraceToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterMultipleConstraintClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "As" keyword.
        ''' </summary>
        Friend ReadOnly Property AsKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._asKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "{" token.
        ''' </summary>
        Friend ReadOnly Property OpenBraceToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openBraceToken
            End Get
        End Property

        ''' <summary>
        ''' A list of the supplied constraints. If no constraints were supplied, an empty
        ''' list is returned.
        ''' </summary>
        Friend ReadOnly Property Constraints As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ConstraintSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ConstraintSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of ConstraintSyntax)(Me._constraints))
            End Get
        End Property

        ''' <summary>
        ''' The "}" token.
        ''' </summary>
        Friend ReadOnly Property CloseBraceToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeBraceToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._asKeyword
                Case 1
                    Return Me._openBraceToken
                Case 2
                    Return Me._constraints
                Case 3
                    Return Me._closeBraceToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new TypeParameterMultipleConstraintClauseSyntax(Me.Kind, newErrors, GetAnnotations, _asKeyword, _openBraceToken, _constraints, _closeBraceToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new TypeParameterMultipleConstraintClauseSyntax(Me.Kind, GetDiagnostics, annotations, _asKeyword, _openBraceToken, _constraints, _closeBraceToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitTypeParameterMultipleConstraintClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' An abstract node class that is the parent of classes that describe type
    ''' parameter constraints.
    ''' </summary>
    Friend MustInherit Class ConstraintSyntax
        Inherits VisualBasicSyntaxNode


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

    End Class

    ''' <summary>
    ''' One of the special type parameter constraints: New, Class or Structure. Which
    ''' kind of special constraint it is can be obtained from the Kind property and is
    ''' one of: NewConstraint, ReferenceConstraint or ValueConstraint.
    ''' </summary>
    Friend NotInheritable Class SpecialConstraintSyntax
        Inherits ConstraintSyntax

        Friend ReadOnly _constraintKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, constraintKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(constraintKeyword)
            Me._constraintKeyword = constraintKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, constraintKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(constraintKeyword)
            Me._constraintKeyword = constraintKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), constraintKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(constraintKeyword)
            Me._constraintKeyword = constraintKeyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SpecialConstraintSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "New", "Class" or "Structure" keyword that denotes the kind of special
        ''' constraint.
        ''' </summary>
        Friend ReadOnly Property ConstraintKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._constraintKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._constraintKeyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new SpecialConstraintSyntax(Me.Kind, newErrors, GetAnnotations, _constraintKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new SpecialConstraintSyntax(Me.Kind, GetDiagnostics, annotations, _constraintKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitSpecialConstraint(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a type parameter constraint that is a type.
    ''' </summary>
    Friend NotInheritable Class TypeConstraintSyntax
        Inherits ConstraintSyntax

        Friend ReadOnly _type as TypeSyntax

        Friend Sub New(ByVal kind As SyntaxKind, type As TypeSyntax)
            MyBase.New(kind)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(type)
            Me._type = type

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, type As TypeSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(type)
            Me._type = type

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), type As TypeSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(type)
            Me._type = type

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeConstraintSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The type describing the constraint.
        ''' </summary>
        Friend ReadOnly Property Type As InternalSyntax.TypeSyntax
            Get
                Return Me._type
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._type
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new TypeConstraintSyntax(Me.Kind, newErrors, GetAnnotations, _type)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new TypeConstraintSyntax(Me.Kind, GetDiagnostics, annotations, _type)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitTypeConstraint(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a name and value in an EnumDeclarationBlock.
    ''' </summary>
    Friend NotInheritable Class EnumMemberDeclarationSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _attributeLists as GreenNode
        Friend ReadOnly _identifier as IdentifierTokenSyntax
        Friend ReadOnly _initializer as EqualsValueSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, identifier As InternalSyntax.IdentifierTokenSyntax, initializer As EqualsValueSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If initializer IsNot Nothing Then
                AdjustFlagsAndWidth(initializer)
                Me._initializer = initializer
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, identifier As InternalSyntax.IdentifierTokenSyntax, initializer As EqualsValueSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If initializer IsNot Nothing Then
                AdjustFlagsAndWidth(initializer)
                Me._initializer = initializer
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributeLists As GreenNode, identifier As InternalSyntax.IdentifierTokenSyntax, initializer As EqualsValueSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If initializer IsNot Nothing Then
                AdjustFlagsAndWidth(initializer)
                Me._initializer = initializer
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax(Me, parent, startLocation)
        End Function

        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property AttributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AttributeListSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AttributeListSyntax)(Me._attributeLists)
            End Get
        End Property

        Friend ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' An optional value for the enum member.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Initializer As InternalSyntax.EqualsValueSyntax
            Get
                Return Me._initializer
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._attributeLists
                Case 1
                    Return Me._identifier
                Case 2
                    Return Me._initializer
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new EnumMemberDeclarationSyntax(Me.Kind, newErrors, GetAnnotations, _attributeLists, _identifier, _initializer)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new EnumMemberDeclarationSyntax(Me.Kind, GetDiagnostics, annotations, _attributeLists, _identifier, _initializer)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitEnumMemberDeclaration(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a block member declaration: A declaration that has a beginning
    ''' declaration, a body of executable statements and an end statement. Examples
    ''' include methods, constructors, operators, property accessors and custom event
    ''' accessors.
    ''' </summary>
    Friend MustInherit Class MethodBlockBaseSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _statements as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, statements As GreenNode)
            MyBase.New(kind)

            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, statements As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)

            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), statements As GreenNode)
            MyBase.New(kind, errors, annotations)

            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If

        End Sub

        ''' <summary>
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)(Me._statements)
            End Get
        End Property

    End Class

    ''' <summary>
    ''' Represents a Function or Sub block declaration: A declaration that has a
    ''' beginning declaration, a body of executable statements and an end statement.
    ''' </summary>
    Friend NotInheritable Class MethodBlockSyntax
        Inherits MethodBlockBaseSyntax

        Friend ReadOnly _subOrFunctionStatement as MethodStatementSyntax
        Friend ReadOnly _endSubOrFunctionStatement as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, subOrFunctionStatement As MethodStatementSyntax, statements As GreenNode, endSubOrFunctionStatement As EndBlockStatementSyntax)
            MyBase.New(kind, statements)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(subOrFunctionStatement)
            Me._subOrFunctionStatement = subOrFunctionStatement
            AdjustFlagsAndWidth(endSubOrFunctionStatement)
            Me._endSubOrFunctionStatement = endSubOrFunctionStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, subOrFunctionStatement As MethodStatementSyntax, statements As GreenNode, endSubOrFunctionStatement As EndBlockStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, statements)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(subOrFunctionStatement)
            Me._subOrFunctionStatement = subOrFunctionStatement
            AdjustFlagsAndWidth(endSubOrFunctionStatement)
            Me._endSubOrFunctionStatement = endSubOrFunctionStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), subOrFunctionStatement As MethodStatementSyntax, statements As GreenNode, endSubOrFunctionStatement As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations, statements)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(subOrFunctionStatement)
            Me._subOrFunctionStatement = subOrFunctionStatement
            AdjustFlagsAndWidth(endSubOrFunctionStatement)
            Me._endSubOrFunctionStatement = endSubOrFunctionStatement

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Sub" or "Function" statement that begins the block.
        ''' </summary>
        Friend ReadOnly Property SubOrFunctionStatement As InternalSyntax.MethodStatementSyntax
            Get
                Return Me._subOrFunctionStatement
            End Get
        End Property

        ''' <summary>
        ''' The "End Sub" or "End Function" statement that ends the block.
        ''' </summary>
        Friend ReadOnly Property EndSubOrFunctionStatement As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._endSubOrFunctionStatement
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._subOrFunctionStatement
                Case 1
                    Return Me._statements
                Case 2
                    Return Me._endSubOrFunctionStatement
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new MethodBlockSyntax(Me.Kind, newErrors, GetAnnotations, _subOrFunctionStatement, _statements, _endSubOrFunctionStatement)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new MethodBlockSyntax(Me.Kind, GetDiagnostics, annotations, _subOrFunctionStatement, _statements, _endSubOrFunctionStatement)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitMethodBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a constructor block declaration: A declaration that has a beginning
    ''' declaration, a body of executable statements and an end statement.
    ''' </summary>
    Friend NotInheritable Class ConstructorBlockSyntax
        Inherits MethodBlockBaseSyntax

        Friend ReadOnly _subNewStatement as SubNewStatementSyntax
        Friend ReadOnly _endSubStatement as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, subNewStatement As SubNewStatementSyntax, statements As GreenNode, endSubStatement As EndBlockStatementSyntax)
            MyBase.New(kind, statements)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(subNewStatement)
            Me._subNewStatement = subNewStatement
            AdjustFlagsAndWidth(endSubStatement)
            Me._endSubStatement = endSubStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, subNewStatement As SubNewStatementSyntax, statements As GreenNode, endSubStatement As EndBlockStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, statements)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(subNewStatement)
            Me._subNewStatement = subNewStatement
            AdjustFlagsAndWidth(endSubStatement)
            Me._endSubStatement = endSubStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), subNewStatement As SubNewStatementSyntax, statements As GreenNode, endSubStatement As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations, statements)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(subNewStatement)
            Me._subNewStatement = subNewStatement
            AdjustFlagsAndWidth(endSubStatement)
            Me._endSubStatement = endSubStatement

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstructorBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Sub New" statement that begins the block.
        ''' </summary>
        Friend ReadOnly Property SubNewStatement As InternalSyntax.SubNewStatementSyntax
            Get
                Return Me._subNewStatement
            End Get
        End Property

        ''' <summary>
        ''' The "End Sub" statement that ends the block declaration.
        ''' </summary>
        Friend ReadOnly Property EndSubStatement As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._endSubStatement
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._subNewStatement
                Case 1
                    Return Me._statements
                Case 2
                    Return Me._endSubStatement
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ConstructorBlockSyntax(Me.Kind, newErrors, GetAnnotations, _subNewStatement, _statements, _endSubStatement)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ConstructorBlockSyntax(Me.Kind, GetDiagnostics, annotations, _subNewStatement, _statements, _endSubStatement)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitConstructorBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an Operator block member declaration: A declaration that has a
    ''' beginning declaration, a body of executable statements and an end statement.
    ''' </summary>
    Friend NotInheritable Class OperatorBlockSyntax
        Inherits MethodBlockBaseSyntax

        Friend ReadOnly _operatorStatement as OperatorStatementSyntax
        Friend ReadOnly _endOperatorStatement as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, operatorStatement As OperatorStatementSyntax, statements As GreenNode, endOperatorStatement As EndBlockStatementSyntax)
            MyBase.New(kind, statements)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(operatorStatement)
            Me._operatorStatement = operatorStatement
            AdjustFlagsAndWidth(endOperatorStatement)
            Me._endOperatorStatement = endOperatorStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, operatorStatement As OperatorStatementSyntax, statements As GreenNode, endOperatorStatement As EndBlockStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, statements)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(operatorStatement)
            Me._operatorStatement = operatorStatement
            AdjustFlagsAndWidth(endOperatorStatement)
            Me._endOperatorStatement = endOperatorStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), operatorStatement As OperatorStatementSyntax, statements As GreenNode, endOperatorStatement As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations, statements)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(operatorStatement)
            Me._operatorStatement = operatorStatement
            AdjustFlagsAndWidth(endOperatorStatement)
            Me._endOperatorStatement = endOperatorStatement

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Operator" statement that begins the block.
        ''' </summary>
        Friend ReadOnly Property OperatorStatement As InternalSyntax.OperatorStatementSyntax
            Get
                Return Me._operatorStatement
            End Get
        End Property

        ''' <summary>
        ''' The "End Operator" statement that ends the block declaration.
        ''' </summary>
        Friend ReadOnly Property EndOperatorStatement As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._endOperatorStatement
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._operatorStatement
                Case 1
                    Return Me._statements
                Case 2
                    Return Me._endOperatorStatement
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new OperatorBlockSyntax(Me.Kind, newErrors, GetAnnotations, _operatorStatement, _statements, _endOperatorStatement)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new OperatorBlockSyntax(Me.Kind, GetDiagnostics, annotations, _operatorStatement, _statements, _endOperatorStatement)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitOperatorBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an accessor block member declaration: A declaration that has a
    ''' beginning declaration, a body of executable statements and an end statement.
    ''' Examples include property accessors and custom event accessors.
    ''' </summary>
    Friend NotInheritable Class AccessorBlockSyntax
        Inherits MethodBlockBaseSyntax

        Friend ReadOnly _accessorStatement as AccessorStatementSyntax
        Friend ReadOnly _endAccessorStatement as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, accessorStatement As AccessorStatementSyntax, statements As GreenNode, endAccessorStatement As EndBlockStatementSyntax)
            MyBase.New(kind, statements)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(accessorStatement)
            Me._accessorStatement = accessorStatement
            AdjustFlagsAndWidth(endAccessorStatement)
            Me._endAccessorStatement = endAccessorStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, accessorStatement As AccessorStatementSyntax, statements As GreenNode, endAccessorStatement As EndBlockStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, statements)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(accessorStatement)
            Me._accessorStatement = accessorStatement
            AdjustFlagsAndWidth(endAccessorStatement)
            Me._endAccessorStatement = endAccessorStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), accessorStatement As AccessorStatementSyntax, statements As GreenNode, endAccessorStatement As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations, statements)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(accessorStatement)
            Me._accessorStatement = accessorStatement
            AdjustFlagsAndWidth(endAccessorStatement)
            Me._endAccessorStatement = endAccessorStatement

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
        ''' begins the accessor block.
        ''' </summary>
        Friend ReadOnly Property AccessorStatement As InternalSyntax.AccessorStatementSyntax
            Get
                Return Me._accessorStatement
            End Get
        End Property

        ''' <summary>
        ''' The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
        ''' RaiseEvent" statement that ends the accessor block.
        ''' </summary>
        Friend ReadOnly Property EndAccessorStatement As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._endAccessorStatement
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._accessorStatement
                Case 1
                    Return Me._statements
                Case 2
                    Return Me._endAccessorStatement
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new AccessorBlockSyntax(Me.Kind, newErrors, GetAnnotations, _accessorStatement, _statements, _endAccessorStatement)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new AccessorBlockSyntax(Me.Kind, GetDiagnostics, annotations, _accessorStatement, _statements, _endAccessorStatement)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitAccessorBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a block property declaration: A declaration that has a beginning
    ''' declaration, some get or set accessor blocks and an end statement.
    ''' </summary>
    Friend NotInheritable Class PropertyBlockSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _propertyStatement as PropertyStatementSyntax
        Friend ReadOnly _accessors as GreenNode
        Friend ReadOnly _endPropertyStatement as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, propertyStatement As PropertyStatementSyntax, accessors As GreenNode, endPropertyStatement As EndBlockStatementSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(propertyStatement)
            Me._propertyStatement = propertyStatement
            If accessors IsNot Nothing Then
                AdjustFlagsAndWidth(accessors)
                Me._accessors = accessors
            End If
            AdjustFlagsAndWidth(endPropertyStatement)
            Me._endPropertyStatement = endPropertyStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, propertyStatement As PropertyStatementSyntax, accessors As GreenNode, endPropertyStatement As EndBlockStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(propertyStatement)
            Me._propertyStatement = propertyStatement
            If accessors IsNot Nothing Then
                AdjustFlagsAndWidth(accessors)
                Me._accessors = accessors
            End If
            AdjustFlagsAndWidth(endPropertyStatement)
            Me._endPropertyStatement = endPropertyStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), propertyStatement As PropertyStatementSyntax, accessors As GreenNode, endPropertyStatement As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(propertyStatement)
            Me._propertyStatement = propertyStatement
            If accessors IsNot Nothing Then
                AdjustFlagsAndWidth(accessors)
                Me._accessors = accessors
            End If
            AdjustFlagsAndWidth(endPropertyStatement)
            Me._endPropertyStatement = endPropertyStatement

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The property declaration that begins the block.
        ''' </summary>
        Friend ReadOnly Property PropertyStatement As InternalSyntax.PropertyStatementSyntax
            Get
                Return Me._propertyStatement
            End Get
        End Property

        ''' <summary>
        ''' The accessor blocks contained in the property, between the Property and the End
        ''' Property statements.
        ''' </summary>
        Friend ReadOnly Property Accessors As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AccessorBlockSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AccessorBlockSyntax)(Me._accessors)
            End Get
        End Property

        ''' <summary>
        ''' The End Property statement that ends the block.
        ''' </summary>
        Friend ReadOnly Property EndPropertyStatement As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._endPropertyStatement
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._propertyStatement
                Case 1
                    Return Me._accessors
                Case 2
                    Return Me._endPropertyStatement
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new PropertyBlockSyntax(Me.Kind, newErrors, GetAnnotations, _propertyStatement, _accessors, _endPropertyStatement)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new PropertyBlockSyntax(Me.Kind, GetDiagnostics, annotations, _propertyStatement, _accessors, _endPropertyStatement)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitPropertyBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a custom event declaration: A declaration that has a beginning event
    ''' declaration, some accessor blocks and an end statement.
    ''' </summary>
    Friend NotInheritable Class EventBlockSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _eventStatement as EventStatementSyntax
        Friend ReadOnly _accessors as GreenNode
        Friend ReadOnly _endEventStatement as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, eventStatement As EventStatementSyntax, accessors As GreenNode, endEventStatement As EndBlockStatementSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(eventStatement)
            Me._eventStatement = eventStatement
            If accessors IsNot Nothing Then
                AdjustFlagsAndWidth(accessors)
                Me._accessors = accessors
            End If
            AdjustFlagsAndWidth(endEventStatement)
            Me._endEventStatement = endEventStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, eventStatement As EventStatementSyntax, accessors As GreenNode, endEventStatement As EndBlockStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(eventStatement)
            Me._eventStatement = eventStatement
            If accessors IsNot Nothing Then
                AdjustFlagsAndWidth(accessors)
                Me._accessors = accessors
            End If
            AdjustFlagsAndWidth(endEventStatement)
            Me._endEventStatement = endEventStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), eventStatement As EventStatementSyntax, accessors As GreenNode, endEventStatement As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(eventStatement)
            Me._eventStatement = eventStatement
            If accessors IsNot Nothing Then
                AdjustFlagsAndWidth(accessors)
                Me._accessors = accessors
            End If
            AdjustFlagsAndWidth(endEventStatement)
            Me._endEventStatement = endEventStatement

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The event declaration that begins the block.
        ''' </summary>
        Friend ReadOnly Property EventStatement As InternalSyntax.EventStatementSyntax
            Get
                Return Me._eventStatement
            End Get
        End Property

        ''' <summary>
        ''' The accessor blocks contained in the custom event declaration, between the
        ''' Event statement and the End Event statement.
        ''' </summary>
        Friend ReadOnly Property Accessors As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AccessorBlockSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AccessorBlockSyntax)(Me._accessors)
            End Get
        End Property

        ''' <summary>
        ''' The End Event statement that ends the block.
        ''' </summary>
        Friend ReadOnly Property EndEventStatement As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._endEventStatement
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._eventStatement
                Case 1
                    Return Me._accessors
                Case 2
                    Return Me._endEventStatement
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new EventBlockSyntax(Me.Kind, newErrors, GetAnnotations, _eventStatement, _accessors, _endEventStatement)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new EventBlockSyntax(Me.Kind, GetDiagnostics, annotations, _eventStatement, _accessors, _endEventStatement)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitEventBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' An abstract node class that is the parent for declarations that are
    ''' "method-like"; i.e., that have a parameter list and return type. This includes
    ''' methods, constructors, properties, events, operators, declares, delegates,
    ''' property accessors and custom event accessors.
    ''' </summary>
    Friend MustInherit Class MethodBaseSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _attributeLists as GreenNode
        Friend ReadOnly _modifiers as GreenNode
        Friend ReadOnly _parameterList as ParameterListSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, parameterList As ParameterListSyntax)
            MyBase.New(kind)

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            If modifiers IsNot Nothing Then
                AdjustFlagsAndWidth(modifiers)
                Me._modifiers = modifiers
            End If
            If parameterList IsNot Nothing Then
                AdjustFlagsAndWidth(parameterList)
                Me._parameterList = parameterList
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, parameterList As ParameterListSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            If modifiers IsNot Nothing Then
                AdjustFlagsAndWidth(modifiers)
                Me._modifiers = modifiers
            End If
            If parameterList IsNot Nothing Then
                AdjustFlagsAndWidth(parameterList)
                Me._parameterList = parameterList
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributeLists As GreenNode, modifiers As GreenNode, parameterList As ParameterListSyntax)
            MyBase.New(kind, errors, annotations)

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            If modifiers IsNot Nothing Then
                AdjustFlagsAndWidth(modifiers)
                Me._modifiers = modifiers
            End If
            If parameterList IsNot Nothing Then
                AdjustFlagsAndWidth(parameterList)
                Me._parameterList = parameterList
            End If

        End Sub

        ''' <summary>
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property AttributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AttributeListSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AttributeListSyntax)(Me._attributeLists)
            End Get
        End Property

        ''' <summary>
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of KeywordSyntax)
            Get
                Return New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)(Me._modifiers)
            End Get
        End Property

        ''' <summary>
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property ParameterList As InternalSyntax.ParameterListSyntax
            Get
                Return Me._parameterList
            End Get
        End Property

    End Class

    ''' <summary>
    ''' Represents the parameter list in a method declaration.
    ''' </summary>
    Friend NotInheritable Class ParameterListSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _parameters as GreenNode
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, parameters As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            If parameters IsNot Nothing Then
                AdjustFlagsAndWidth(parameters)
                Me._parameters = parameters
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, parameters As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            If parameters IsNot Nothing Then
                AdjustFlagsAndWidth(parameters)
                Me._parameters = parameters
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), openParenToken As InternalSyntax.PunctuationSyntax, parameters As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            If parameters IsNot Nothing Then
                AdjustFlagsAndWidth(parameters)
                Me._parameters = parameters
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "(" token that introduces the parameter list. If no parameter list was
        ''' present, Nothing is returned.
        ''' </summary>
        Friend ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The list of parameters. If no parameter list was present, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Parameters As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ParameterSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ParameterSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of ParameterSyntax)(Me._parameters))
            End Get
        End Property

        ''' <summary>
        ''' The ")" token that concludes the parameter list. If no parameter list was
        ''' present, Nothing is returned.
        ''' </summary>
        Friend ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._openParenToken
                Case 1
                    Return Me._parameters
                Case 2
                    Return Me._closeParenToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ParameterListSyntax(Me.Kind, newErrors, GetAnnotations, _openParenToken, _parameters, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ParameterListSyntax(Me.Kind, GetDiagnostics, annotations, _openParenToken, _parameters, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitParameterList(Me)
        End Function

    End Class

    ''' <summary>
    ''' The statement that declares a Sub or Function. If this method has a body, this
    ''' statement will be the Begin of a BlockStatement with
    ''' Kind=MethodDeclarationBlock, and the body of the method will be the Body of
    ''' that BlockStatement.
    ''' </summary>
    Friend NotInheritable Class MethodStatementSyntax
        Inherits MethodBaseSyntax

        Friend ReadOnly _subOrFunctionKeyword as KeywordSyntax
        Friend ReadOnly _identifier as IdentifierTokenSyntax
        Friend ReadOnly _typeParameterList as TypeParameterListSyntax
        Friend ReadOnly _asClause as SimpleAsClauseSyntax
        Friend ReadOnly _handlesClause as HandlesClauseSyntax
        Friend ReadOnly _implementsClause as ImplementsClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, subOrFunctionKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax, handlesClause As HandlesClauseSyntax, implementsClause As ImplementsClauseSyntax)
            MyBase.New(kind, attributeLists, modifiers, parameterList)
            Me.SlotCount = 9

            AdjustFlagsAndWidth(subOrFunctionKeyword)
            Me._subOrFunctionKeyword = subOrFunctionKeyword
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If typeParameterList IsNot Nothing Then
                AdjustFlagsAndWidth(typeParameterList)
                Me._typeParameterList = typeParameterList
            End If
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            If handlesClause IsNot Nothing Then
                AdjustFlagsAndWidth(handlesClause)
                Me._handlesClause = handlesClause
            End If
            If implementsClause IsNot Nothing Then
                AdjustFlagsAndWidth(implementsClause)
                Me._implementsClause = implementsClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, subOrFunctionKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax, handlesClause As HandlesClauseSyntax, implementsClause As ImplementsClauseSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, attributeLists, modifiers, parameterList)
            Me.SlotCount = 9
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(subOrFunctionKeyword)
            Me._subOrFunctionKeyword = subOrFunctionKeyword
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If typeParameterList IsNot Nothing Then
                AdjustFlagsAndWidth(typeParameterList)
                Me._typeParameterList = typeParameterList
            End If
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            If handlesClause IsNot Nothing Then
                AdjustFlagsAndWidth(handlesClause)
                Me._handlesClause = handlesClause
            End If
            If implementsClause IsNot Nothing Then
                AdjustFlagsAndWidth(implementsClause)
                Me._implementsClause = implementsClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributeLists As GreenNode, modifiers As GreenNode, subOrFunctionKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax, handlesClause As HandlesClauseSyntax, implementsClause As ImplementsClauseSyntax)
            MyBase.New(kind, errors, annotations, attributeLists, modifiers, parameterList)
            Me.SlotCount = 9

            AdjustFlagsAndWidth(subOrFunctionKeyword)
            Me._subOrFunctionKeyword = subOrFunctionKeyword
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If typeParameterList IsNot Nothing Then
                AdjustFlagsAndWidth(typeParameterList)
                Me._typeParameterList = typeParameterList
            End If
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            If handlesClause IsNot Nothing Then
                AdjustFlagsAndWidth(handlesClause)
                Me._handlesClause = handlesClause
            End If
            If implementsClause IsNot Nothing Then
                AdjustFlagsAndWidth(implementsClause)
                Me._implementsClause = implementsClause
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Sub" or "Function" keyword that introduces this method declaration.
        ''' </summary>
        Friend ReadOnly Property SubOrFunctionKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._subOrFunctionKeyword
            End Get
        End Property

        ''' <summary>
        ''' The name of the method being declared.
        ''' </summary>
        Friend ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' If present, a type parameter list with generic type parameters for this method.
        ''' If no generic type parameters were present, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property TypeParameterList As InternalSyntax.TypeParameterListSyntax
            Get
                Return Me._typeParameterList
            End Get
        End Property

        ''' <summary>
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property AsClause As InternalSyntax.SimpleAsClauseSyntax
            Get
                Return Me._asClause
            End Get
        End Property

        ''' <summary>
        ''' If present, a Handles clause indicated the events that this method handles.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property HandlesClause As InternalSyntax.HandlesClauseSyntax
            Get
                Return Me._handlesClause
            End Get
        End Property

        ''' <summary>
        ''' If present, an Implements clause indicated the interface methods that this
        ''' method implements.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property ImplementsClause As InternalSyntax.ImplementsClauseSyntax
            Get
                Return Me._implementsClause
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._attributeLists
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._subOrFunctionKeyword
                Case 3
                    Return Me._identifier
                Case 4
                    Return Me._typeParameterList
                Case 5
                    Return Me._parameterList
                Case 6
                    Return Me._asClause
                Case 7
                    Return Me._handlesClause
                Case 8
                    Return Me._implementsClause
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new MethodStatementSyntax(Me.Kind, newErrors, GetAnnotations, _attributeLists, _modifiers, _subOrFunctionKeyword, _identifier, _typeParameterList, _parameterList, _asClause, _handlesClause, _implementsClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new MethodStatementSyntax(Me.Kind, GetDiagnostics, annotations, _attributeLists, _modifiers, _subOrFunctionKeyword, _identifier, _typeParameterList, _parameterList, _asClause, _handlesClause, _implementsClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitMethodStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' A statement that declares a constructor. This statement will be the Begin of a
    ''' BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
    ''' will be the Body of that BlockStatement.
    ''' </summary>
    Friend NotInheritable Class SubNewStatementSyntax
        Inherits MethodBaseSyntax

        Friend ReadOnly _subKeyword as KeywordSyntax
        Friend ReadOnly _newKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, subKeyword As InternalSyntax.KeywordSyntax, newKeyword As InternalSyntax.KeywordSyntax, parameterList As ParameterListSyntax)
            MyBase.New(kind, attributeLists, modifiers, parameterList)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(subKeyword)
            Me._subKeyword = subKeyword
            AdjustFlagsAndWidth(newKeyword)
            Me._newKeyword = newKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, subKeyword As InternalSyntax.KeywordSyntax, newKeyword As InternalSyntax.KeywordSyntax, parameterList As ParameterListSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, attributeLists, modifiers, parameterList)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(subKeyword)
            Me._subKeyword = subKeyword
            AdjustFlagsAndWidth(newKeyword)
            Me._newKeyword = newKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributeLists As GreenNode, modifiers As GreenNode, subKeyword As InternalSyntax.KeywordSyntax, newKeyword As InternalSyntax.KeywordSyntax, parameterList As ParameterListSyntax)
            MyBase.New(kind, errors, annotations, attributeLists, modifiers, parameterList)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(subKeyword)
            Me._subKeyword = subKeyword
            AdjustFlagsAndWidth(newKeyword)
            Me._newKeyword = newKeyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Sub" keyword.
        ''' </summary>
        Friend ReadOnly Property SubKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._subKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "New" keyword in the constructor declaration.
        ''' </summary>
        Friend ReadOnly Property NewKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._newKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._attributeLists
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._subKeyword
                Case 3
                    Return Me._newKeyword
                Case 4
                    Return Me._parameterList
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new SubNewStatementSyntax(Me.Kind, newErrors, GetAnnotations, _attributeLists, _modifiers, _subKeyword, _newKeyword, _parameterList)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new SubNewStatementSyntax(Me.Kind, GetDiagnostics, annotations, _attributeLists, _modifiers, _subKeyword, _newKeyword, _parameterList)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitSubNewStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' A Declare statement that declares an external DLL method.
    ''' </summary>
    Friend NotInheritable Class DeclareStatementSyntax
        Inherits MethodBaseSyntax

        Friend ReadOnly _declareKeyword as KeywordSyntax
        Friend ReadOnly _charsetKeyword as KeywordSyntax
        Friend ReadOnly _subOrFunctionKeyword as KeywordSyntax
        Friend ReadOnly _identifier as IdentifierTokenSyntax
        Friend ReadOnly _libKeyword as KeywordSyntax
        Friend ReadOnly _libraryName as LiteralExpressionSyntax
        Friend ReadOnly _aliasKeyword as KeywordSyntax
        Friend ReadOnly _aliasName as LiteralExpressionSyntax
        Friend ReadOnly _asClause as SimpleAsClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, declareKeyword As InternalSyntax.KeywordSyntax, charsetKeyword As InternalSyntax.KeywordSyntax, subOrFunctionKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, libKeyword As InternalSyntax.KeywordSyntax, libraryName As LiteralExpressionSyntax, aliasKeyword As InternalSyntax.KeywordSyntax, aliasName As LiteralExpressionSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax)
            MyBase.New(kind, attributeLists, modifiers, parameterList)
            Me.SlotCount = 12

            AdjustFlagsAndWidth(declareKeyword)
            Me._declareKeyword = declareKeyword
            If charsetKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(charsetKeyword)
                Me._charsetKeyword = charsetKeyword
            End If
            AdjustFlagsAndWidth(subOrFunctionKeyword)
            Me._subOrFunctionKeyword = subOrFunctionKeyword
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            AdjustFlagsAndWidth(libKeyword)
            Me._libKeyword = libKeyword
            AdjustFlagsAndWidth(libraryName)
            Me._libraryName = libraryName
            If aliasKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(aliasKeyword)
                Me._aliasKeyword = aliasKeyword
            End If
            If aliasName IsNot Nothing Then
                AdjustFlagsAndWidth(aliasName)
                Me._aliasName = aliasName
            End If
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, declareKeyword As InternalSyntax.KeywordSyntax, charsetKeyword As InternalSyntax.KeywordSyntax, subOrFunctionKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, libKeyword As InternalSyntax.KeywordSyntax, libraryName As LiteralExpressionSyntax, aliasKeyword As InternalSyntax.KeywordSyntax, aliasName As LiteralExpressionSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, attributeLists, modifiers, parameterList)
            Me.SlotCount = 12
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(declareKeyword)
            Me._declareKeyword = declareKeyword
            If charsetKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(charsetKeyword)
                Me._charsetKeyword = charsetKeyword
            End If
            AdjustFlagsAndWidth(subOrFunctionKeyword)
            Me._subOrFunctionKeyword = subOrFunctionKeyword
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            AdjustFlagsAndWidth(libKeyword)
            Me._libKeyword = libKeyword
            AdjustFlagsAndWidth(libraryName)
            Me._libraryName = libraryName
            If aliasKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(aliasKeyword)
                Me._aliasKeyword = aliasKeyword
            End If
            If aliasName IsNot Nothing Then
                AdjustFlagsAndWidth(aliasName)
                Me._aliasName = aliasName
            End If
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributeLists As GreenNode, modifiers As GreenNode, declareKeyword As InternalSyntax.KeywordSyntax, charsetKeyword As InternalSyntax.KeywordSyntax, subOrFunctionKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, libKeyword As InternalSyntax.KeywordSyntax, libraryName As LiteralExpressionSyntax, aliasKeyword As InternalSyntax.KeywordSyntax, aliasName As LiteralExpressionSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax)
            MyBase.New(kind, errors, annotations, attributeLists, modifiers, parameterList)
            Me.SlotCount = 12

            AdjustFlagsAndWidth(declareKeyword)
            Me._declareKeyword = declareKeyword
            If charsetKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(charsetKeyword)
                Me._charsetKeyword = charsetKeyword
            End If
            AdjustFlagsAndWidth(subOrFunctionKeyword)
            Me._subOrFunctionKeyword = subOrFunctionKeyword
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            AdjustFlagsAndWidth(libKeyword)
            Me._libKeyword = libKeyword
            AdjustFlagsAndWidth(libraryName)
            Me._libraryName = libraryName
            If aliasKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(aliasKeyword)
                Me._aliasKeyword = aliasKeyword
            End If
            If aliasName IsNot Nothing Then
                AdjustFlagsAndWidth(aliasName)
                Me._aliasName = aliasName
            End If
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Declare" keyword.
        ''' </summary>
        Friend ReadOnly Property DeclareKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._declareKeyword
            End Get
        End Property

        ''' <summary>
        ''' If present, the keyword that defines the string translation semantics of the
        ''' external method.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property CharsetKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._charsetKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "Sub" or "Function" keyword.
        ''' </summary>
        Friend ReadOnly Property SubOrFunctionKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._subOrFunctionKeyword
            End Get
        End Property

        ''' <summary>
        ''' The name of the method being declared.
        ''' </summary>
        Friend ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' The "Lib" keyword.
        ''' </summary>
        Friend ReadOnly Property LibKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._libKeyword
            End Get
        End Property

        ''' <summary>
        ''' The string literal with the library name.
        ''' </summary>
        Friend ReadOnly Property LibraryName As InternalSyntax.LiteralExpressionSyntax
            Get
                Return Me._libraryName
            End Get
        End Property

        ''' <summary>
        ''' If present, the "Alias" keyword. If not present, returns Nothing.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property AliasKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._aliasKeyword
            End Get
        End Property

        ''' <summary>
        ''' The string literal with the alias. If not present, returns Nothing.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property AliasName As InternalSyntax.LiteralExpressionSyntax
            Get
                Return Me._aliasName
            End Get
        End Property

        ''' <summary>
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property AsClause As InternalSyntax.SimpleAsClauseSyntax
            Get
                Return Me._asClause
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._attributeLists
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._declareKeyword
                Case 3
                    Return Me._charsetKeyword
                Case 4
                    Return Me._subOrFunctionKeyword
                Case 5
                    Return Me._identifier
                Case 6
                    Return Me._libKeyword
                Case 7
                    Return Me._libraryName
                Case 8
                    Return Me._aliasKeyword
                Case 9
                    Return Me._aliasName
                Case 10
                    Return Me._parameterList
                Case 11
                    Return Me._asClause
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new DeclareStatementSyntax(Me.Kind, newErrors, GetAnnotations, _attributeLists, _modifiers, _declareKeyword, _charsetKeyword, _subOrFunctionKeyword, _identifier, _libKeyword, _libraryName, _aliasKeyword, _aliasName, _parameterList, _asClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new DeclareStatementSyntax(Me.Kind, GetDiagnostics, annotations, _attributeLists, _modifiers, _declareKeyword, _charsetKeyword, _subOrFunctionKeyword, _identifier, _libKeyword, _libraryName, _aliasKeyword, _aliasName, _parameterList, _asClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitDeclareStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' A statement that declares a delegate type.
    ''' </summary>
    Friend NotInheritable Class DelegateStatementSyntax
        Inherits MethodBaseSyntax

        Friend ReadOnly _delegateKeyword as KeywordSyntax
        Friend ReadOnly _subOrFunctionKeyword as KeywordSyntax
        Friend ReadOnly _identifier as IdentifierTokenSyntax
        Friend ReadOnly _typeParameterList as TypeParameterListSyntax
        Friend ReadOnly _asClause as SimpleAsClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, delegateKeyword As InternalSyntax.KeywordSyntax, subOrFunctionKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax)
            MyBase.New(kind, attributeLists, modifiers, parameterList)
            Me.SlotCount = 8

            AdjustFlagsAndWidth(delegateKeyword)
            Me._delegateKeyword = delegateKeyword
            AdjustFlagsAndWidth(subOrFunctionKeyword)
            Me._subOrFunctionKeyword = subOrFunctionKeyword
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If typeParameterList IsNot Nothing Then
                AdjustFlagsAndWidth(typeParameterList)
                Me._typeParameterList = typeParameterList
            End If
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, delegateKeyword As InternalSyntax.KeywordSyntax, subOrFunctionKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, attributeLists, modifiers, parameterList)
            Me.SlotCount = 8
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(delegateKeyword)
            Me._delegateKeyword = delegateKeyword
            AdjustFlagsAndWidth(subOrFunctionKeyword)
            Me._subOrFunctionKeyword = subOrFunctionKeyword
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If typeParameterList IsNot Nothing Then
                AdjustFlagsAndWidth(typeParameterList)
                Me._typeParameterList = typeParameterList
            End If
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributeLists As GreenNode, modifiers As GreenNode, delegateKeyword As InternalSyntax.KeywordSyntax, subOrFunctionKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax)
            MyBase.New(kind, errors, annotations, attributeLists, modifiers, parameterList)
            Me.SlotCount = 8

            AdjustFlagsAndWidth(delegateKeyword)
            Me._delegateKeyword = delegateKeyword
            AdjustFlagsAndWidth(subOrFunctionKeyword)
            Me._subOrFunctionKeyword = subOrFunctionKeyword
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If typeParameterList IsNot Nothing Then
                AdjustFlagsAndWidth(typeParameterList)
                Me._typeParameterList = typeParameterList
            End If
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Delegate" keyword.
        ''' </summary>
        Friend ReadOnly Property DelegateKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._delegateKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "Sub" or "Function" keyword.
        ''' </summary>
        Friend ReadOnly Property SubOrFunctionKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._subOrFunctionKeyword
            End Get
        End Property

        ''' <summary>
        ''' The name of the delegate being declared.
        ''' </summary>
        Friend ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' If present, a type parameter list with generic type parameters for this
        ''' delegate. If no generic type parameters were present, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property TypeParameterList As InternalSyntax.TypeParameterListSyntax
            Get
                Return Me._typeParameterList
            End Get
        End Property

        ''' <summary>
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property AsClause As InternalSyntax.SimpleAsClauseSyntax
            Get
                Return Me._asClause
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._attributeLists
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._delegateKeyword
                Case 3
                    Return Me._subOrFunctionKeyword
                Case 4
                    Return Me._identifier
                Case 5
                    Return Me._typeParameterList
                Case 6
                    Return Me._parameterList
                Case 7
                    Return Me._asClause
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new DelegateStatementSyntax(Me.Kind, newErrors, GetAnnotations, _attributeLists, _modifiers, _delegateKeyword, _subOrFunctionKeyword, _identifier, _typeParameterList, _parameterList, _asClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new DelegateStatementSyntax(Me.Kind, GetDiagnostics, annotations, _attributeLists, _modifiers, _delegateKeyword, _subOrFunctionKeyword, _identifier, _typeParameterList, _parameterList, _asClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitDelegateStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' A statement that declares an event. If the event being declared is a custom
    ''' event, this statement will be the Begin of a PropertyOrEventBlock, and the
    ''' accessors will be part of the Accessors of that node.
    ''' </summary>
    Friend NotInheritable Class EventStatementSyntax
        Inherits MethodBaseSyntax

        Friend ReadOnly _customKeyword as KeywordSyntax
        Friend ReadOnly _eventKeyword as KeywordSyntax
        Friend ReadOnly _identifier as IdentifierTokenSyntax
        Friend ReadOnly _asClause as SimpleAsClauseSyntax
        Friend ReadOnly _implementsClause as ImplementsClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, customKeyword As InternalSyntax.KeywordSyntax, eventKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax, implementsClause As ImplementsClauseSyntax)
            MyBase.New(kind, attributeLists, modifiers, parameterList)
            Me.SlotCount = 8

            If customKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(customKeyword)
                Me._customKeyword = customKeyword
            End If
            AdjustFlagsAndWidth(eventKeyword)
            Me._eventKeyword = eventKeyword
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            If implementsClause IsNot Nothing Then
                AdjustFlagsAndWidth(implementsClause)
                Me._implementsClause = implementsClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, customKeyword As InternalSyntax.KeywordSyntax, eventKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax, implementsClause As ImplementsClauseSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, attributeLists, modifiers, parameterList)
            Me.SlotCount = 8
            Me.SetFactoryContext(context)

            If customKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(customKeyword)
                Me._customKeyword = customKeyword
            End If
            AdjustFlagsAndWidth(eventKeyword)
            Me._eventKeyword = eventKeyword
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            If implementsClause IsNot Nothing Then
                AdjustFlagsAndWidth(implementsClause)
                Me._implementsClause = implementsClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributeLists As GreenNode, modifiers As GreenNode, customKeyword As InternalSyntax.KeywordSyntax, eventKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax, implementsClause As ImplementsClauseSyntax)
            MyBase.New(kind, errors, annotations, attributeLists, modifiers, parameterList)
            Me.SlotCount = 8

            If customKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(customKeyword)
                Me._customKeyword = customKeyword
            End If
            AdjustFlagsAndWidth(eventKeyword)
            Me._eventKeyword = eventKeyword
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            If implementsClause IsNot Nothing Then
                AdjustFlagsAndWidth(implementsClause)
                Me._implementsClause = implementsClause
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The optional Custom keyword for custom event declarations.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property CustomKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._customKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "Event" keyword that introduces this event declaration.
        ''' </summary>
        Friend ReadOnly Property EventKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._eventKeyword
            End Get
        End Property

        ''' <summary>
        ''' The name of the event being declared.
        ''' </summary>
        Friend ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property AsClause As InternalSyntax.SimpleAsClauseSyntax
            Get
                Return Me._asClause
            End Get
        End Property

        ''' <summary>
        ''' If present, an Implements clause indicates the interface methods that this
        ''' method implements.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property ImplementsClause As InternalSyntax.ImplementsClauseSyntax
            Get
                Return Me._implementsClause
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._attributeLists
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._customKeyword
                Case 3
                    Return Me._eventKeyword
                Case 4
                    Return Me._identifier
                Case 5
                    Return Me._parameterList
                Case 6
                    Return Me._asClause
                Case 7
                    Return Me._implementsClause
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new EventStatementSyntax(Me.Kind, newErrors, GetAnnotations, _attributeLists, _modifiers, _customKeyword, _eventKeyword, _identifier, _parameterList, _asClause, _implementsClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new EventStatementSyntax(Me.Kind, GetDiagnostics, annotations, _attributeLists, _modifiers, _customKeyword, _eventKeyword, _identifier, _parameterList, _asClause, _implementsClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitEventStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' A statement that declares an operator. If this operator has a body, this
    ''' statement will be the Begin of a BlockStatement with
    ''' Kind=MethodDeclarationBlock, and the body of the method will be the Body of
    ''' that BlockStatement.
    ''' </summary>
    Friend NotInheritable Class OperatorStatementSyntax
        Inherits MethodBaseSyntax

        Friend ReadOnly _operatorKeyword as KeywordSyntax
        Friend ReadOnly _operatorToken as SyntaxToken
        Friend ReadOnly _asClause as SimpleAsClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, operatorKeyword As InternalSyntax.KeywordSyntax, operatorToken As InternalSyntax.SyntaxToken, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax)
            MyBase.New(kind, attributeLists, modifiers, parameterList)
            Me.SlotCount = 6

            AdjustFlagsAndWidth(operatorKeyword)
            Me._operatorKeyword = operatorKeyword
            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, operatorKeyword As InternalSyntax.KeywordSyntax, operatorToken As InternalSyntax.SyntaxToken, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, attributeLists, modifiers, parameterList)
            Me.SlotCount = 6
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(operatorKeyword)
            Me._operatorKeyword = operatorKeyword
            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributeLists As GreenNode, modifiers As GreenNode, operatorKeyword As InternalSyntax.KeywordSyntax, operatorToken As InternalSyntax.SyntaxToken, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax)
            MyBase.New(kind, errors, annotations, attributeLists, modifiers, parameterList)
            Me.SlotCount = 6

            AdjustFlagsAndWidth(operatorKeyword)
            Me._operatorKeyword = operatorKeyword
            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Operator" keyword that introduces this operator declaration.
        ''' </summary>
        Friend ReadOnly Property OperatorKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._operatorKeyword
            End Get
        End Property

        ''' <summary>
        ''' The operator being defined.
        ''' </summary>
        Friend ReadOnly Property OperatorToken As InternalSyntax.SyntaxToken
            Get
                Return Me._operatorToken
            End Get
        End Property

        ''' <summary>
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property AsClause As InternalSyntax.SimpleAsClauseSyntax
            Get
                Return Me._asClause
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._attributeLists
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._operatorKeyword
                Case 3
                    Return Me._operatorToken
                Case 4
                    Return Me._parameterList
                Case 5
                    Return Me._asClause
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new OperatorStatementSyntax(Me.Kind, newErrors, GetAnnotations, _attributeLists, _modifiers, _operatorKeyword, _operatorToken, _parameterList, _asClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new OperatorStatementSyntax(Me.Kind, GetDiagnostics, annotations, _attributeLists, _modifiers, _operatorKeyword, _operatorToken, _parameterList, _asClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitOperatorStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Statement that declares a property. If this property has accessors declared,
    ''' this statement will be the Begin of a BlockNode, and the accessors will be the
    ''' Body of that node. Auto properties are property declarations without a
    ''' PropertyBlock.
    ''' </summary>
    Friend NotInheritable Class PropertyStatementSyntax
        Inherits MethodBaseSyntax

        Friend ReadOnly _propertyKeyword as KeywordSyntax
        Friend ReadOnly _identifier as IdentifierTokenSyntax
        Friend ReadOnly _asClause as AsClauseSyntax
        Friend ReadOnly _initializer as EqualsValueSyntax
        Friend ReadOnly _implementsClause as ImplementsClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, propertyKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax, initializer As EqualsValueSyntax, implementsClause As ImplementsClauseSyntax)
            MyBase.New(kind, attributeLists, modifiers, parameterList)
            Me.SlotCount = 8

            AdjustFlagsAndWidth(propertyKeyword)
            Me._propertyKeyword = propertyKeyword
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            If initializer IsNot Nothing Then
                AdjustFlagsAndWidth(initializer)
                Me._initializer = initializer
            End If
            If implementsClause IsNot Nothing Then
                AdjustFlagsAndWidth(implementsClause)
                Me._implementsClause = implementsClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, propertyKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax, initializer As EqualsValueSyntax, implementsClause As ImplementsClauseSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, attributeLists, modifiers, parameterList)
            Me.SlotCount = 8
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(propertyKeyword)
            Me._propertyKeyword = propertyKeyword
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            If initializer IsNot Nothing Then
                AdjustFlagsAndWidth(initializer)
                Me._initializer = initializer
            End If
            If implementsClause IsNot Nothing Then
                AdjustFlagsAndWidth(implementsClause)
                Me._implementsClause = implementsClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributeLists As GreenNode, modifiers As GreenNode, propertyKeyword As InternalSyntax.KeywordSyntax, identifier As InternalSyntax.IdentifierTokenSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax, initializer As EqualsValueSyntax, implementsClause As ImplementsClauseSyntax)
            MyBase.New(kind, errors, annotations, attributeLists, modifiers, parameterList)
            Me.SlotCount = 8

            AdjustFlagsAndWidth(propertyKeyword)
            Me._propertyKeyword = propertyKeyword
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            If initializer IsNot Nothing Then
                AdjustFlagsAndWidth(initializer)
                Me._initializer = initializer
            End If
            If implementsClause IsNot Nothing Then
                AdjustFlagsAndWidth(implementsClause)
                Me._implementsClause = implementsClause
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Property" keyword that introduces this property declaration.
        ''' </summary>
        Friend ReadOnly Property PropertyKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._propertyKeyword
            End Get
        End Property

        ''' <summary>
        ''' The name of the property being declared.
        ''' </summary>
        Friend ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property AsClause As InternalSyntax.AsClauseSyntax
            Get
                Return Me._asClause
            End Get
        End Property

        ''' <summary>
        ''' If present, an "= initial-value" clause describing the initial value of the
        ''' property.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Initializer As InternalSyntax.EqualsValueSyntax
            Get
                Return Me._initializer
            End Get
        End Property

        ''' <summary>
        ''' If present, an Implements clause indicated the interface methods that this
        ''' method implements.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property ImplementsClause As InternalSyntax.ImplementsClauseSyntax
            Get
                Return Me._implementsClause
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._attributeLists
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._propertyKeyword
                Case 3
                    Return Me._identifier
                Case 4
                    Return Me._parameterList
                Case 5
                    Return Me._asClause
                Case 6
                    Return Me._initializer
                Case 7
                    Return Me._implementsClause
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new PropertyStatementSyntax(Me.Kind, newErrors, GetAnnotations, _attributeLists, _modifiers, _propertyKeyword, _identifier, _parameterList, _asClause, _initializer, _implementsClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new PropertyStatementSyntax(Me.Kind, GetDiagnostics, annotations, _attributeLists, _modifiers, _propertyKeyword, _identifier, _parameterList, _asClause, _initializer, _implementsClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitPropertyStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a Get or Set accessor on a property declaration or an AddHandler,
    ''' RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
    ''' the node determines what kind of accessor this is. This statement is always the
    ''' Begin of a BlockNode, and the body of the accessor is the Body of that node.
    ''' </summary>
    Friend NotInheritable Class AccessorStatementSyntax
        Inherits MethodBaseSyntax

        Friend ReadOnly _accessorKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, accessorKeyword As InternalSyntax.KeywordSyntax, parameterList As ParameterListSyntax)
            MyBase.New(kind, attributeLists, modifiers, parameterList)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(accessorKeyword)
            Me._accessorKeyword = accessorKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, accessorKeyword As InternalSyntax.KeywordSyntax, parameterList As ParameterListSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, attributeLists, modifiers, parameterList)
            Me.SlotCount = 4
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(accessorKeyword)
            Me._accessorKeyword = accessorKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributeLists As GreenNode, modifiers As GreenNode, accessorKeyword As InternalSyntax.KeywordSyntax, parameterList As ParameterListSyntax)
            MyBase.New(kind, errors, annotations, attributeLists, modifiers, parameterList)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(accessorKeyword)
            Me._accessorKeyword = accessorKeyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
        ''' introduces this accessor declaration.
        ''' </summary>
        Friend ReadOnly Property AccessorKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._accessorKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._attributeLists
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._accessorKeyword
                Case 3
                    Return Me._parameterList
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new AccessorStatementSyntax(Me.Kind, newErrors, GetAnnotations, _attributeLists, _modifiers, _accessorKeyword, _parameterList)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new AccessorStatementSyntax(Me.Kind, GetDiagnostics, annotations, _attributeLists, _modifiers, _accessorKeyword, _parameterList)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitAccessorStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "Implements ..." clause on a type member, which describes which
    ''' interface members this member implements.
    ''' </summary>
    Friend NotInheritable Class ImplementsClauseSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _implementsKeyword as KeywordSyntax
        Friend ReadOnly _interfaceMembers as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, implementsKeyword As InternalSyntax.KeywordSyntax, interfaceMembers As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(implementsKeyword)
            Me._implementsKeyword = implementsKeyword
            If interfaceMembers IsNot Nothing Then
                AdjustFlagsAndWidth(interfaceMembers)
                Me._interfaceMembers = interfaceMembers
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, implementsKeyword As InternalSyntax.KeywordSyntax, interfaceMembers As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(implementsKeyword)
            Me._implementsKeyword = implementsKeyword
            If interfaceMembers IsNot Nothing Then
                AdjustFlagsAndWidth(interfaceMembers)
                Me._interfaceMembers = interfaceMembers
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), implementsKeyword As InternalSyntax.KeywordSyntax, interfaceMembers As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(implementsKeyword)
            Me._implementsKeyword = implementsKeyword
            If interfaceMembers IsNot Nothing Then
                AdjustFlagsAndWidth(interfaceMembers)
                Me._interfaceMembers = interfaceMembers
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Implements" keyword.
        ''' </summary>
        Friend ReadOnly Property ImplementsKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._implementsKeyword
            End Get
        End Property

        ''' <summary>
        ''' The list of interface members being implemented.
        ''' </summary>
        Friend ReadOnly Property InterfaceMembers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of QualifiedNameSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of QualifiedNameSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of QualifiedNameSyntax)(Me._interfaceMembers))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._implementsKeyword
                Case 1
                    Return Me._interfaceMembers
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ImplementsClauseSyntax(Me.Kind, newErrors, GetAnnotations, _implementsKeyword, _interfaceMembers)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ImplementsClauseSyntax(Me.Kind, GetDiagnostics, annotations, _implementsKeyword, _interfaceMembers)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitImplementsClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "Handles ..." clause on a method declaration that describes
    ''' which events this method handles.
    ''' </summary>
    Friend NotInheritable Class HandlesClauseSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _handlesKeyword as KeywordSyntax
        Friend ReadOnly _events as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, handlesKeyword As InternalSyntax.KeywordSyntax, events As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(handlesKeyword)
            Me._handlesKeyword = handlesKeyword
            If events IsNot Nothing Then
                AdjustFlagsAndWidth(events)
                Me._events = events
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, handlesKeyword As InternalSyntax.KeywordSyntax, events As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(handlesKeyword)
            Me._handlesKeyword = handlesKeyword
            If events IsNot Nothing Then
                AdjustFlagsAndWidth(events)
                Me._events = events
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), handlesKeyword As InternalSyntax.KeywordSyntax, events As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(handlesKeyword)
            Me._handlesKeyword = handlesKeyword
            If events IsNot Nothing Then
                AdjustFlagsAndWidth(events)
                Me._events = events
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Handles" keyword.
        ''' </summary>
        Friend ReadOnly Property HandlesKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._handlesKeyword
            End Get
        End Property

        ''' <summary>
        ''' The list of event members being handled.
        ''' </summary>
        Friend ReadOnly Property Events As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of HandlesClauseItemSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of HandlesClauseItemSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of HandlesClauseItemSyntax)(Me._events))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._handlesKeyword
                Case 1
                    Return Me._events
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new HandlesClauseSyntax(Me.Kind, newErrors, GetAnnotations, _handlesKeyword, _events)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new HandlesClauseSyntax(Me.Kind, GetDiagnostics, annotations, _handlesKeyword, _events)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitHandlesClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents container of an event in a Handles clause item.
    ''' </summary>
    Friend MustInherit Class EventContainerSyntax
        Inherits ExpressionSyntax


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

    End Class

    ''' <summary>
    ''' Represents event container specified through special keywords "Me", "MyBase" or
    ''' "MyClass"..
    ''' </summary>
    Friend NotInheritable Class KeywordEventContainerSyntax
        Inherits EventContainerSyntax

        Friend ReadOnly _keyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(keyword)
            Me._keyword = keyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(keyword)
            Me._keyword = keyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(keyword)
            Me._keyword = keyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.KeywordEventContainerSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The container of the event. This can be one of the special keywords: "Me",
        ''' "MyBase" or "MyClass".
        ''' </summary>
        Friend ReadOnly Property Keyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._keyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._keyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new KeywordEventContainerSyntax(Me.Kind, newErrors, GetAnnotations, _keyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new KeywordEventContainerSyntax(Me.Kind, GetDiagnostics, annotations, _keyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitKeywordEventContainer(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents event container that refers to a WithEvents member.
    ''' </summary>
    Friend NotInheritable Class WithEventsEventContainerSyntax
        Inherits EventContainerSyntax

        Friend ReadOnly _identifier as IdentifierTokenSyntax

        Friend Sub New(ByVal kind As SyntaxKind, identifier As InternalSyntax.IdentifierTokenSyntax)
            MyBase.New(kind)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, identifier As InternalSyntax.IdentifierTokenSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), identifier As InternalSyntax.IdentifierTokenSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsEventContainerSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The container of the event. It is a simple identifier that refers to a
        ''' WithEvents member of the containing type.
        ''' </summary>
        Friend ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._identifier
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new WithEventsEventContainerSyntax(Me.Kind, newErrors, GetAnnotations, _identifier)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new WithEventsEventContainerSyntax(Me.Kind, GetDiagnostics, annotations, _identifier)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitWithEventsEventContainer(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents event container that refers to a WithEvents member's property.
    ''' </summary>
    Friend NotInheritable Class WithEventsPropertyEventContainerSyntax
        Inherits EventContainerSyntax

        Friend ReadOnly _withEventsContainer as WithEventsEventContainerSyntax
        Friend ReadOnly _dotToken as PunctuationSyntax
        Friend ReadOnly _property as IdentifierNameSyntax

        Friend Sub New(ByVal kind As SyntaxKind, withEventsContainer As WithEventsEventContainerSyntax, dotToken As InternalSyntax.PunctuationSyntax, [property] As IdentifierNameSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(withEventsContainer)
            Me._withEventsContainer = withEventsContainer
            AdjustFlagsAndWidth(dotToken)
            Me._dotToken = dotToken
            AdjustFlagsAndWidth([property])
            Me._property = [property]

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, withEventsContainer As WithEventsEventContainerSyntax, dotToken As InternalSyntax.PunctuationSyntax, [property] As IdentifierNameSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(withEventsContainer)
            Me._withEventsContainer = withEventsContainer
            AdjustFlagsAndWidth(dotToken)
            Me._dotToken = dotToken
            AdjustFlagsAndWidth([property])
            Me._property = [property]

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), withEventsContainer As WithEventsEventContainerSyntax, dotToken As InternalSyntax.PunctuationSyntax, [property] As IdentifierNameSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(withEventsContainer)
            Me._withEventsContainer = withEventsContainer
            AdjustFlagsAndWidth(dotToken)
            Me._dotToken = dotToken
            AdjustFlagsAndWidth([property])
            Me._property = [property]

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsPropertyEventContainerSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The container of the event.
        ''' </summary>
        Friend ReadOnly Property WithEventsContainer As InternalSyntax.WithEventsEventContainerSyntax
            Get
                Return Me._withEventsContainer
            End Get
        End Property

        ''' <summary>
        ''' The "." token.
        ''' </summary>
        Friend ReadOnly Property DotToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._dotToken
            End Get
        End Property

        ''' <summary>
        ''' The provider of the event. It is a property of a WithEvents member of the
        ''' containing type.
        ''' </summary>
        Friend ReadOnly Property [Property] As InternalSyntax.IdentifierNameSyntax
            Get
                Return Me._property
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._withEventsContainer
                Case 1
                    Return Me._dotToken
                Case 2
                    Return Me._property
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new WithEventsPropertyEventContainerSyntax(Me.Kind, newErrors, GetAnnotations, _withEventsContainer, _dotToken, _property)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new WithEventsPropertyEventContainerSyntax(Me.Kind, GetDiagnostics, annotations, _withEventsContainer, _dotToken, _property)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitWithEventsPropertyEventContainer(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a single handled event in a "Handles ..." clause.
    ''' </summary>
    Friend NotInheritable Class HandlesClauseItemSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _eventContainer as EventContainerSyntax
        Friend ReadOnly _dotToken as PunctuationSyntax
        Friend ReadOnly _eventMember as IdentifierNameSyntax

        Friend Sub New(ByVal kind As SyntaxKind, eventContainer As EventContainerSyntax, dotToken As InternalSyntax.PunctuationSyntax, eventMember As IdentifierNameSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(eventContainer)
            Me._eventContainer = eventContainer
            AdjustFlagsAndWidth(dotToken)
            Me._dotToken = dotToken
            AdjustFlagsAndWidth(eventMember)
            Me._eventMember = eventMember

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, eventContainer As EventContainerSyntax, dotToken As InternalSyntax.PunctuationSyntax, eventMember As IdentifierNameSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(eventContainer)
            Me._eventContainer = eventContainer
            AdjustFlagsAndWidth(dotToken)
            Me._dotToken = dotToken
            AdjustFlagsAndWidth(eventMember)
            Me._eventMember = eventMember

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), eventContainer As EventContainerSyntax, dotToken As InternalSyntax.PunctuationSyntax, eventMember As IdentifierNameSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(eventContainer)
            Me._eventContainer = eventContainer
            AdjustFlagsAndWidth(dotToken)
            Me._dotToken = dotToken
            AdjustFlagsAndWidth(eventMember)
            Me._eventMember = eventMember

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The container of the event. This can either be a simple identifier (identifying
        ''' a members of the containing type) or one of the special keywords "Me", "MyBase"
        ''' or "MyClass".
        ''' </summary>
        Friend ReadOnly Property EventContainer As InternalSyntax.EventContainerSyntax
            Get
                Return Me._eventContainer
            End Get
        End Property

        ''' <summary>
        ''' The "." token.
        ''' </summary>
        Friend ReadOnly Property DotToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._dotToken
            End Get
        End Property

        ''' <summary>
        ''' The event being handled. This must be a simple identifier.
        ''' </summary>
        Friend ReadOnly Property EventMember As InternalSyntax.IdentifierNameSyntax
            Get
                Return Me._eventMember
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._eventContainer
                Case 1
                    Return Me._dotToken
                Case 2
                    Return Me._eventMember
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new HandlesClauseItemSyntax(Me.Kind, newErrors, GetAnnotations, _eventContainer, _dotToken, _eventMember)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new HandlesClauseItemSyntax(Me.Kind, GetDiagnostics, annotations, _eventContainer, _dotToken, _eventMember)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitHandlesClauseItem(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the beginning of a declaration. However, not enough syntax is
    ''' detected to classify this as a field, method, property or event. This is node
    ''' always represents a syntax error.
    ''' </summary>
    Friend NotInheritable Class IncompleteMemberSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _attributeLists as GreenNode
        Friend ReadOnly _modifiers as GreenNode
        Friend ReadOnly _missingIdentifier as IdentifierTokenSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, missingIdentifier As InternalSyntax.IdentifierTokenSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            If modifiers IsNot Nothing Then
                AdjustFlagsAndWidth(modifiers)
                Me._modifiers = modifiers
            End If
            If missingIdentifier IsNot Nothing Then
                AdjustFlagsAndWidth(missingIdentifier)
                Me._missingIdentifier = missingIdentifier
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, missingIdentifier As InternalSyntax.IdentifierTokenSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            If modifiers IsNot Nothing Then
                AdjustFlagsAndWidth(modifiers)
                Me._modifiers = modifiers
            End If
            If missingIdentifier IsNot Nothing Then
                AdjustFlagsAndWidth(missingIdentifier)
                Me._missingIdentifier = missingIdentifier
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributeLists As GreenNode, modifiers As GreenNode, missingIdentifier As InternalSyntax.IdentifierTokenSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            If modifiers IsNot Nothing Then
                AdjustFlagsAndWidth(modifiers)
                Me._modifiers = modifiers
            End If
            If missingIdentifier IsNot Nothing Then
                AdjustFlagsAndWidth(missingIdentifier)
                Me._missingIdentifier = missingIdentifier
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.IncompleteMemberSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property AttributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AttributeListSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AttributeListSyntax)(Me._attributeLists)
            End Get
        End Property

        ''' <summary>
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of KeywordSyntax)
            Get
                Return New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)(Me._modifiers)
            End Get
        End Property

        ''' <summary>
        ''' The missing identifier token for this incomplete member. Should only be used to
        ''' have a location for error reporting.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property MissingIdentifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._missingIdentifier
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._attributeLists
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._missingIdentifier
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new IncompleteMemberSyntax(Me.Kind, newErrors, GetAnnotations, _attributeLists, _modifiers, _missingIdentifier)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new IncompleteMemberSyntax(Me.Kind, GetDiagnostics, annotations, _attributeLists, _modifiers, _missingIdentifier)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitIncompleteMember(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the declaration of one or more variables or constants, either as
    ''' local variables or as class/structure members. In the case of a constant, it is
    ''' represented by having "Const" in the Modifiers (although technically "Const" is
    ''' not a modifier, it is represented as one in the parse trees.)
    ''' </summary>
    Friend NotInheritable Class FieldDeclarationSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _attributeLists as GreenNode
        Friend ReadOnly _modifiers as GreenNode
        Friend ReadOnly _declarators as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, declarators As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 3

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            If modifiers IsNot Nothing Then
                AdjustFlagsAndWidth(modifiers)
                Me._modifiers = modifiers
            End If
            If declarators IsNot Nothing Then
                AdjustFlagsAndWidth(declarators)
                Me._declarators = declarators
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, declarators As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            If modifiers IsNot Nothing Then
                AdjustFlagsAndWidth(modifiers)
                Me._modifiers = modifiers
            End If
            If declarators IsNot Nothing Then
                AdjustFlagsAndWidth(declarators)
                Me._declarators = declarators
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributeLists As GreenNode, modifiers As GreenNode, declarators As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            If modifiers IsNot Nothing Then
                AdjustFlagsAndWidth(modifiers)
                Me._modifiers = modifiers
            End If
            If declarators IsNot Nothing Then
                AdjustFlagsAndWidth(declarators)
                Me._declarators = declarators
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldDeclarationSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property AttributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AttributeListSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AttributeListSyntax)(Me._attributeLists)
            End Get
        End Property

        ''' <summary>
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of KeywordSyntax)
            Get
                Return New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)(Me._modifiers)
            End Get
        End Property

        ''' <summary>
        ''' The list of variable declarator. Each declarator specifies one or more variable
        ''' names along with a type and/or initializer.
        ''' </summary>
        Friend ReadOnly Property Declarators As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of VariableDeclaratorSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of VariableDeclaratorSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of VariableDeclaratorSyntax)(Me._declarators))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._attributeLists
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._declarators
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new FieldDeclarationSyntax(Me.Kind, newErrors, GetAnnotations, _attributeLists, _modifiers, _declarators)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new FieldDeclarationSyntax(Me.Kind, GetDiagnostics, annotations, _attributeLists, _modifiers, _declarators)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitFieldDeclaration(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the part of a variable or constant declaration statement that
    ''' associated one or more variable names with a type.
    ''' </summary>
    Friend NotInheritable Class VariableDeclaratorSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _names as GreenNode
        Friend ReadOnly _asClause as AsClauseSyntax
        Friend ReadOnly _initializer as EqualsValueSyntax

        Friend Sub New(ByVal kind As SyntaxKind, names As GreenNode, asClause As AsClauseSyntax, initializer As EqualsValueSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            If names IsNot Nothing Then
                AdjustFlagsAndWidth(names)
                Me._names = names
            End If
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            If initializer IsNot Nothing Then
                AdjustFlagsAndWidth(initializer)
                Me._initializer = initializer
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, names As GreenNode, asClause As AsClauseSyntax, initializer As EqualsValueSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            If names IsNot Nothing Then
                AdjustFlagsAndWidth(names)
                Me._names = names
            End If
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            If initializer IsNot Nothing Then
                AdjustFlagsAndWidth(initializer)
                Me._initializer = initializer
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), names As GreenNode, asClause As AsClauseSyntax, initializer As EqualsValueSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            If names IsNot Nothing Then
                AdjustFlagsAndWidth(names)
                Me._names = names
            End If
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            If initializer IsNot Nothing Then
                AdjustFlagsAndWidth(initializer)
                Me._initializer = initializer
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The names of the variables being declared. Each name might have a "?" or "()"
        ''' modifier(s) attached.
        ''' </summary>
        Friend ReadOnly Property Names As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ModifiedIdentifierSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ModifiedIdentifierSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of ModifiedIdentifierSyntax)(Me._names))
            End Get
        End Property

        ''' <summary>
        ''' The "As" clause that describes the return type, and possibly includes "New",
        ''' "With" or "From". If no As clause was present, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property AsClause As InternalSyntax.AsClauseSyntax
            Get
                Return Me._asClause
            End Get
        End Property

        ''' <summary>
        ''' If present, an "= initial-value" clause describing the initial value of the
        ''' variable or the value of the constant.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Initializer As InternalSyntax.EqualsValueSyntax
            Get
                Return Me._initializer
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._names
                Case 1
                    Return Me._asClause
                Case 2
                    Return Me._initializer
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new VariableDeclaratorSyntax(Me.Kind, newErrors, GetAnnotations, _names, _asClause, _initializer)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new VariableDeclaratorSyntax(Me.Kind, GetDiagnostics, annotations, _names, _asClause, _initializer)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitVariableDeclarator(Me)
        End Function

    End Class

    ''' <summary>
    ''' Abstract node class that represents the different kinds of "As {type-name}"
    ''' clauses in a declaration: simple "As" clauses and "As New" clauses. The type
    ''' has optional attributes associated with it, although attributes are not
    ''' permitted in all possible places where this node occurs.
    ''' </summary>
    Friend MustInherit Class AsClauseSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _asKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, asKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)

            AdjustFlagsAndWidth(asKeyword)
            Me._asKeyword = asKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, asKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(asKeyword)
            Me._asKeyword = asKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), asKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)

            AdjustFlagsAndWidth(asKeyword)
            Me._asKeyword = asKeyword

        End Sub

        ''' <summary>
        ''' The "As" keyword.
        ''' </summary>
        Friend ReadOnly Property AsKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._asKeyword
            End Get
        End Property

    End Class

    ''' <summary>
    ''' Represents an "As {type-name}" clause that does not have an initializer or
    ''' "New". The type has optional attributes associated with it, although attributes
    ''' are not permitted in all possible places where this node occurs.
    ''' </summary>
    Friend NotInheritable Class SimpleAsClauseSyntax
        Inherits AsClauseSyntax

        Friend ReadOnly _attributeLists as GreenNode
        Friend ReadOnly _type as TypeSyntax

        Friend Sub New(ByVal kind As SyntaxKind, asKeyword As InternalSyntax.KeywordSyntax, attributeLists As GreenNode, type As TypeSyntax)
            MyBase.New(kind, asKeyword)
            Me.SlotCount = 3

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            AdjustFlagsAndWidth(type)
            Me._type = type

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, asKeyword As InternalSyntax.KeywordSyntax, attributeLists As GreenNode, type As TypeSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, asKeyword)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            AdjustFlagsAndWidth(type)
            Me._type = type

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), asKeyword As InternalSyntax.KeywordSyntax, attributeLists As GreenNode, type As TypeSyntax)
            MyBase.New(kind, errors, annotations, asKeyword)
            Me.SlotCount = 3

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            AdjustFlagsAndWidth(type)
            Me._type = type

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' A list of all attribute lists on the type. If no attributes were specified, an
        ''' empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property AttributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AttributeListSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AttributeListSyntax)(Me._attributeLists)
            End Get
        End Property

        ''' <summary>
        ''' The type-name part of the As clause.
        ''' </summary>
        Friend ReadOnly Property Type As InternalSyntax.TypeSyntax
            Get
                Return Me._type
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._asKeyword
                Case 1
                    Return Me._attributeLists
                Case 2
                    Return Me._type
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new SimpleAsClauseSyntax(Me.Kind, newErrors, GetAnnotations, _asKeyword, _attributeLists, _type)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new SimpleAsClauseSyntax(Me.Kind, GetDiagnostics, annotations, _asKeyword, _attributeLists, _type)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitSimpleAsClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an "As New {type-name} [arguments] [initializers]" clause in a
    ''' declaration. The type has optional attributes associated with it, although
    ''' attributes are not permitted in many places where this node occurs (they are
    ''' permitted, for example, on automatically implemented properties.)
    ''' </summary>
    Friend NotInheritable Class AsNewClauseSyntax
        Inherits AsClauseSyntax

        Friend ReadOnly _newExpression as NewExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, asKeyword As InternalSyntax.KeywordSyntax, newExpression As NewExpressionSyntax)
            MyBase.New(kind, asKeyword)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(newExpression)
            Me._newExpression = newExpression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, asKeyword As InternalSyntax.KeywordSyntax, newExpression As NewExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, asKeyword)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(newExpression)
            Me._newExpression = newExpression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), asKeyword As InternalSyntax.KeywordSyntax, newExpression As NewExpressionSyntax)
            MyBase.New(kind, errors, annotations, asKeyword)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(newExpression)
            Me._newExpression = newExpression

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The New expression
        ''' </summary>
        Friend ReadOnly Property NewExpression As InternalSyntax.NewExpressionSyntax
            Get
                Return Me._newExpression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._asKeyword
                Case 1
                    Return Me._newExpression
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new AsNewClauseSyntax(Me.Kind, newErrors, GetAnnotations, _asKeyword, _newExpression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new AsNewClauseSyntax(Me.Kind, GetDiagnostics, annotations, _asKeyword, _newExpression)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitAsNewClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' An abstract node class that represents a "With" or "From" clause used to
    ''' initialize a new object.
    ''' </summary>
    Friend MustInherit Class ObjectCreationInitializerSyntax
        Inherits VisualBasicSyntaxNode


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

    End Class

    ''' <summary>
    ''' Represents a "With {...} clause used to initialize a new object's members.
    ''' </summary>
    Friend NotInheritable Class ObjectMemberInitializerSyntax
        Inherits ObjectCreationInitializerSyntax

        Friend ReadOnly _withKeyword as KeywordSyntax
        Friend ReadOnly _openBraceToken as PunctuationSyntax
        Friend ReadOnly _initializers as GreenNode
        Friend ReadOnly _closeBraceToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, withKeyword As InternalSyntax.KeywordSyntax, openBraceToken As InternalSyntax.PunctuationSyntax, initializers As GreenNode, closeBraceToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(withKeyword)
            Me._withKeyword = withKeyword
            AdjustFlagsAndWidth(openBraceToken)
            Me._openBraceToken = openBraceToken
            If initializers IsNot Nothing Then
                AdjustFlagsAndWidth(initializers)
                Me._initializers = initializers
            End If
            AdjustFlagsAndWidth(closeBraceToken)
            Me._closeBraceToken = closeBraceToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, withKeyword As InternalSyntax.KeywordSyntax, openBraceToken As InternalSyntax.PunctuationSyntax, initializers As GreenNode, closeBraceToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 4
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(withKeyword)
            Me._withKeyword = withKeyword
            AdjustFlagsAndWidth(openBraceToken)
            Me._openBraceToken = openBraceToken
            If initializers IsNot Nothing Then
                AdjustFlagsAndWidth(initializers)
                Me._initializers = initializers
            End If
            AdjustFlagsAndWidth(closeBraceToken)
            Me._closeBraceToken = closeBraceToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), withKeyword As InternalSyntax.KeywordSyntax, openBraceToken As InternalSyntax.PunctuationSyntax, initializers As GreenNode, closeBraceToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(withKeyword)
            Me._withKeyword = withKeyword
            AdjustFlagsAndWidth(openBraceToken)
            Me._openBraceToken = openBraceToken
            If initializers IsNot Nothing Then
                AdjustFlagsAndWidth(initializers)
                Me._initializers = initializers
            End If
            AdjustFlagsAndWidth(closeBraceToken)
            Me._closeBraceToken = closeBraceToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "With" keyword.
        ''' </summary>
        Friend ReadOnly Property WithKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._withKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "{" token.
        ''' </summary>
        Friend ReadOnly Property OpenBraceToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openBraceToken
            End Get
        End Property

        ''' <summary>
        ''' The comma-separated list of field initializers.
        ''' </summary>
        Friend ReadOnly Property Initializers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of FieldInitializerSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of FieldInitializerSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of FieldInitializerSyntax)(Me._initializers))
            End Get
        End Property

        ''' <summary>
        ''' The "}" token.
        ''' </summary>
        Friend ReadOnly Property CloseBraceToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeBraceToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._withKeyword
                Case 1
                    Return Me._openBraceToken
                Case 2
                    Return Me._initializers
                Case 3
                    Return Me._closeBraceToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ObjectMemberInitializerSyntax(Me.Kind, newErrors, GetAnnotations, _withKeyword, _openBraceToken, _initializers, _closeBraceToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ObjectMemberInitializerSyntax(Me.Kind, GetDiagnostics, annotations, _withKeyword, _openBraceToken, _initializers, _closeBraceToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitObjectMemberInitializer(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "From {...} clause used to initialize a new collection object's
    ''' elements.
    ''' </summary>
    Friend NotInheritable Class ObjectCollectionInitializerSyntax
        Inherits ObjectCreationInitializerSyntax

        Friend ReadOnly _fromKeyword as KeywordSyntax
        Friend ReadOnly _initializer as CollectionInitializerSyntax

        Friend Sub New(ByVal kind As SyntaxKind, fromKeyword As InternalSyntax.KeywordSyntax, initializer As CollectionInitializerSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(fromKeyword)
            Me._fromKeyword = fromKeyword
            AdjustFlagsAndWidth(initializer)
            Me._initializer = initializer

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, fromKeyword As InternalSyntax.KeywordSyntax, initializer As CollectionInitializerSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(fromKeyword)
            Me._fromKeyword = fromKeyword
            AdjustFlagsAndWidth(initializer)
            Me._initializer = initializer

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), fromKeyword As InternalSyntax.KeywordSyntax, initializer As CollectionInitializerSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(fromKeyword)
            Me._fromKeyword = fromKeyword
            AdjustFlagsAndWidth(initializer)
            Me._initializer = initializer

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCollectionInitializerSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "From" keyword.
        ''' </summary>
        Friend ReadOnly Property FromKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._fromKeyword
            End Get
        End Property

        ''' <summary>
        ''' The initializer including the braces.
        ''' </summary>
        Friend ReadOnly Property Initializer As InternalSyntax.CollectionInitializerSyntax
            Get
                Return Me._initializer
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._fromKeyword
                Case 1
                    Return Me._initializer
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ObjectCollectionInitializerSyntax(Me.Kind, newErrors, GetAnnotations, _fromKeyword, _initializer)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ObjectCollectionInitializerSyntax(Me.Kind, GetDiagnostics, annotations, _fromKeyword, _initializer)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitObjectCollectionInitializer(Me)
        End Function

    End Class

    ''' <summary>
    ''' Abstract class that represent a single field initializer used in a "With {...}"
    ''' field initializer list.
    ''' </summary>
    Friend MustInherit Class FieldInitializerSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _keyKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, keyKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)

            If keyKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(keyKeyword)
                Me._keyKeyword = keyKeyword
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, keyKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)

            If keyKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(keyKeyword)
                Me._keyKeyword = keyKeyword
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)

            If keyKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(keyKeyword)
                Me._keyKeyword = keyKeyword
            End If

        End Sub

        ''' <summary>
        ''' The optional "Key" keyword.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property KeyKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._keyKeyword
            End Get
        End Property

    End Class

    ''' <summary>
    ''' Represent a field initializer in a With {...} initializer where the field name
    ''' is inferred from the initializer expression.
    ''' </summary>
    Friend NotInheritable Class InferredFieldInitializerSyntax
        Inherits FieldInitializerSyntax

        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, keyKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, keyKeyword)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, keyKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, keyKeyword)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations, keyKeyword)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.InferredFieldInitializerSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The value being assigned.
        ''' </summary>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._keyKeyword
                Case 1
                    Return Me._expression
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new InferredFieldInitializerSyntax(Me.Kind, newErrors, GetAnnotations, _keyKeyword, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new InferredFieldInitializerSyntax(Me.Kind, GetDiagnostics, annotations, _keyKeyword, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitInferredFieldInitializer(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represent a named field initializer in a With {...} initializer, such as ".x =
    ''' expr".
    ''' </summary>
    Friend NotInheritable Class NamedFieldInitializerSyntax
        Inherits FieldInitializerSyntax

        Friend ReadOnly _dotToken as PunctuationSyntax
        Friend ReadOnly _name as IdentifierNameSyntax
        Friend ReadOnly _equalsToken as PunctuationSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, keyKeyword As InternalSyntax.KeywordSyntax, dotToken As InternalSyntax.PunctuationSyntax, name As IdentifierNameSyntax, equalsToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, keyKeyword)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(dotToken)
            Me._dotToken = dotToken
            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, keyKeyword As InternalSyntax.KeywordSyntax, dotToken As InternalSyntax.PunctuationSyntax, name As IdentifierNameSyntax, equalsToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, keyKeyword)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(dotToken)
            Me._dotToken = dotToken
            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyKeyword As InternalSyntax.KeywordSyntax, dotToken As InternalSyntax.PunctuationSyntax, name As IdentifierNameSyntax, equalsToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations, keyKeyword)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(dotToken)
            Me._dotToken = dotToken
            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "." token.
        ''' </summary>
        Friend ReadOnly Property DotToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._dotToken
            End Get
        End Property

        ''' <summary>
        ''' The name of the field being initialized.
        ''' </summary>
        Friend ReadOnly Property Name As InternalSyntax.IdentifierNameSyntax
            Get
                Return Me._name
            End Get
        End Property

        ''' <summary>
        ''' The "=" token.
        ''' </summary>
        Friend ReadOnly Property EqualsToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._equalsToken
            End Get
        End Property

        ''' <summary>
        ''' The value being assigned to the field.
        ''' </summary>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._keyKeyword
                Case 1
                    Return Me._dotToken
                Case 2
                    Return Me._name
                Case 3
                    Return Me._equalsToken
                Case 4
                    Return Me._expression
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new NamedFieldInitializerSyntax(Me.Kind, newErrors, GetAnnotations, _keyKeyword, _dotToken, _name, _equalsToken, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new NamedFieldInitializerSyntax(Me.Kind, GetDiagnostics, annotations, _keyKeyword, _dotToken, _name, _equalsToken, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitNamedFieldInitializer(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an "= initializer" clause in a declaration for a variable, parameter
    ''' or automatic property.
    ''' </summary>
    Friend NotInheritable Class EqualsValueSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _equalsToken as PunctuationSyntax
        Friend ReadOnly _value as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, equalsToken As InternalSyntax.PunctuationSyntax, value As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken
            AdjustFlagsAndWidth(value)
            Me._value = value

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, equalsToken As InternalSyntax.PunctuationSyntax, value As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken
            AdjustFlagsAndWidth(value)
            Me._value = value

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), equalsToken As InternalSyntax.PunctuationSyntax, value As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken
            AdjustFlagsAndWidth(value)
            Me._value = value

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "=" token.
        ''' </summary>
        Friend ReadOnly Property EqualsToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._equalsToken
            End Get
        End Property

        ''' <summary>
        ''' The expression used as the initial value.
        ''' </summary>
        Friend ReadOnly Property Value As InternalSyntax.ExpressionSyntax
            Get
                Return Me._value
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._equalsToken
                Case 1
                    Return Me._value
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new EqualsValueSyntax(Me.Kind, newErrors, GetAnnotations, _equalsToken, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new EqualsValueSyntax(Me.Kind, GetDiagnostics, annotations, _equalsToken, _value)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitEqualsValue(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represent a parameter to a method, property, constructor, etc.
    ''' </summary>
    Friend NotInheritable Class ParameterSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _attributeLists as GreenNode
        Friend ReadOnly _modifiers as GreenNode
        Friend ReadOnly _identifier as ModifiedIdentifierSyntax
        Friend ReadOnly _asClause as SimpleAsClauseSyntax
        Friend ReadOnly _default as EqualsValueSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, [default] As EqualsValueSyntax)
            MyBase.New(kind)
            Me.SlotCount = 5

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            If modifiers IsNot Nothing Then
                AdjustFlagsAndWidth(modifiers)
                Me._modifiers = modifiers
            End If
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            If [default] IsNot Nothing Then
                AdjustFlagsAndWidth([default])
                Me._default = [default]
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, [default] As EqualsValueSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            If modifiers IsNot Nothing Then
                AdjustFlagsAndWidth(modifiers)
                Me._modifiers = modifiers
            End If
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            If [default] IsNot Nothing Then
                AdjustFlagsAndWidth([default])
                Me._default = [default]
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributeLists As GreenNode, modifiers As GreenNode, identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, [default] As EqualsValueSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 5

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If
            If modifiers IsNot Nothing Then
                AdjustFlagsAndWidth(modifiers)
                Me._modifiers = modifiers
            End If
            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            If [default] IsNot Nothing Then
                AdjustFlagsAndWidth([default])
                Me._default = [default]
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' A list of all attribute lists on this parameter. If no attributes were
        ''' specified, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property AttributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AttributeListSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AttributeListSyntax)(Me._attributeLists)
            End Get
        End Property

        ''' <summary>
        ''' A list of the modifier tokens "ByVal", "ByRef", "Optional" or "ParamArray" that
        ''' modify this parameter.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of KeywordSyntax)
            Get
                Return New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)(Me._modifiers)
            End Get
        End Property

        ''' <summary>
        ''' The name of the parameter, including any "?" or "()" modifiers.
        ''' </summary>
        Friend ReadOnly Property Identifier As InternalSyntax.ModifiedIdentifierSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' If present, the "As type-name" clause describing the type of the parameter. If
        ''' no As clause is present, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property AsClause As InternalSyntax.SimpleAsClauseSyntax
            Get
                Return Me._asClause
            End Get
        End Property

        ''' <summary>
        ''' If present, an initializer with the default value of the parameter. If no
        ''' default value is present, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property [Default] As InternalSyntax.EqualsValueSyntax
            Get
                Return Me._default
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._attributeLists
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._identifier
                Case 3
                    Return Me._asClause
                Case 4
                    Return Me._default
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ParameterSyntax(Me.Kind, newErrors, GetAnnotations, _attributeLists, _modifiers, _identifier, _asClause, _default)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ParameterSyntax(Me.Kind, GetDiagnostics, annotations, _attributeLists, _modifiers, _identifier, _asClause, _default)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitParameter(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
    ''' used in parameter declarations and variable declarations.
    ''' </summary>
    Friend NotInheritable Class ModifiedIdentifierSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _identifier as IdentifierTokenSyntax
        Friend ReadOnly _nullable as PunctuationSyntax
        Friend ReadOnly _arrayBounds as ArgumentListSyntax
        Friend ReadOnly _arrayRankSpecifiers as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, identifier As InternalSyntax.IdentifierTokenSyntax, nullable As InternalSyntax.PunctuationSyntax, arrayBounds As ArgumentListSyntax, arrayRankSpecifiers As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If nullable IsNot Nothing Then
                AdjustFlagsAndWidth(nullable)
                Me._nullable = nullable
            End If
            If arrayBounds IsNot Nothing Then
                AdjustFlagsAndWidth(arrayBounds)
                Me._arrayBounds = arrayBounds
            End If
            If arrayRankSpecifiers IsNot Nothing Then
                AdjustFlagsAndWidth(arrayRankSpecifiers)
                Me._arrayRankSpecifiers = arrayRankSpecifiers
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, identifier As InternalSyntax.IdentifierTokenSyntax, nullable As InternalSyntax.PunctuationSyntax, arrayBounds As ArgumentListSyntax, arrayRankSpecifiers As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 4
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If nullable IsNot Nothing Then
                AdjustFlagsAndWidth(nullable)
                Me._nullable = nullable
            End If
            If arrayBounds IsNot Nothing Then
                AdjustFlagsAndWidth(arrayBounds)
                Me._arrayBounds = arrayBounds
            End If
            If arrayRankSpecifiers IsNot Nothing Then
                AdjustFlagsAndWidth(arrayRankSpecifiers)
                Me._arrayRankSpecifiers = arrayRankSpecifiers
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), identifier As InternalSyntax.IdentifierTokenSyntax, nullable As InternalSyntax.PunctuationSyntax, arrayBounds As ArgumentListSyntax, arrayRankSpecifiers As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If nullable IsNot Nothing Then
                AdjustFlagsAndWidth(nullable)
                Me._nullable = nullable
            End If
            If arrayBounds IsNot Nothing Then
                AdjustFlagsAndWidth(arrayBounds)
                Me._arrayBounds = arrayBounds
            End If
            If arrayRankSpecifiers IsNot Nothing Then
                AdjustFlagsAndWidth(arrayRankSpecifiers)
                Me._arrayRankSpecifiers = arrayRankSpecifiers
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The identifier that names the item being declared.
        ''' </summary>
        Friend ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' The "?" token that indicates a nullable type.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Nullable As InternalSyntax.PunctuationSyntax
            Get
                Return Me._nullable
            End Get
        End Property

        ''' <summary>
        ''' The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property ArrayBounds As InternalSyntax.ArgumentListSyntax
            Get
                Return Me._arrayBounds
            End Get
        End Property

        ''' <summary>
        ''' A list of array modifiers for the type. If no array modifiers were present, an
        ''' empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property ArrayRankSpecifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of ArrayRankSpecifierSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of ArrayRankSpecifierSyntax)(Me._arrayRankSpecifiers)
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._identifier
                Case 1
                    Return Me._nullable
                Case 2
                    Return Me._arrayBounds
                Case 3
                    Return Me._arrayRankSpecifiers
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ModifiedIdentifierSyntax(Me.Kind, newErrors, GetAnnotations, _identifier, _nullable, _arrayBounds, _arrayRankSpecifiers)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ModifiedIdentifierSyntax(Me.Kind, GetDiagnostics, annotations, _identifier, _nullable, _arrayBounds, _arrayRankSpecifiers)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitModifiedIdentifier(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a modifier that describes an array type, without bounds, such as
    ''' "()" or "(,)".
    ''' </summary>
    Friend NotInheritable Class ArrayRankSpecifierSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _commaTokens as GreenNode
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, commaTokens As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            If commaTokens IsNot Nothing Then
                AdjustFlagsAndWidth(commaTokens)
                Me._commaTokens = commaTokens
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, commaTokens As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            If commaTokens IsNot Nothing Then
                AdjustFlagsAndWidth(commaTokens)
                Me._commaTokens = commaTokens
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), openParenToken As InternalSyntax.PunctuationSyntax, commaTokens As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            If commaTokens IsNot Nothing Then
                AdjustFlagsAndWidth(commaTokens)
                Me._commaTokens = commaTokens
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "(" token.
        ''' </summary>
        Friend ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The comma tokens in the array type. There is one less comma than the rank.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property CommaTokens As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of PunctuationSyntax)
            Get
                Return New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)(Me._commaTokens)
            End Get
        End Property

        ''' <summary>
        ''' The ")" token.
        ''' </summary>
        Friend ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._openParenToken
                Case 1
                    Return Me._commaTokens
                Case 2
                    Return Me._closeParenToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ArrayRankSpecifierSyntax(Me.Kind, newErrors, GetAnnotations, _openParenToken, _commaTokens, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ArrayRankSpecifierSyntax(Me.Kind, GetDiagnostics, annotations, _openParenToken, _commaTokens, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitArrayRankSpecifier(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a group of attributes within "&lt;" and "&gt;" brackets.
    ''' </summary>
    Friend NotInheritable Class AttributeListSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _lessThanToken as PunctuationSyntax
        Friend ReadOnly _attributes as GreenNode
        Friend ReadOnly _greaterThanToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lessThanToken As InternalSyntax.PunctuationSyntax, attributes As GreenNode, greaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(lessThanToken)
            Me._lessThanToken = lessThanToken
            If attributes IsNot Nothing Then
                AdjustFlagsAndWidth(attributes)
                Me._attributes = attributes
            End If
            AdjustFlagsAndWidth(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, lessThanToken As InternalSyntax.PunctuationSyntax, attributes As GreenNode, greaterThanToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(lessThanToken)
            Me._lessThanToken = lessThanToken
            If attributes IsNot Nothing Then
                AdjustFlagsAndWidth(attributes)
                Me._attributes = attributes
            End If
            AdjustFlagsAndWidth(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lessThanToken As InternalSyntax.PunctuationSyntax, attributes As GreenNode, greaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(lessThanToken)
            Me._lessThanToken = lessThanToken
            If attributes IsNot Nothing Then
                AdjustFlagsAndWidth(attributes)
                Me._attributes = attributes
            End If
            AdjustFlagsAndWidth(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "&lt;" token.
        ''' </summary>
        Friend ReadOnly Property LessThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._lessThanToken
            End Get
        End Property

        ''' <summary>
        ''' A comma separated list of attribute declarations in this attribute list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Attributes As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of AttributeSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of AttributeSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of AttributeSyntax)(Me._attributes))
            End Get
        End Property

        ''' <summary>
        ''' The "&gt;" token.
        ''' </summary>
        Friend ReadOnly Property GreaterThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._greaterThanToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._lessThanToken
                Case 1
                    Return Me._attributes
                Case 2
                    Return Me._greaterThanToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new AttributeListSyntax(Me.Kind, newErrors, GetAnnotations, _lessThanToken, _attributes, _greaterThanToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new AttributeListSyntax(Me.Kind, GetDiagnostics, annotations, _lessThanToken, _attributes, _greaterThanToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitAttributeList(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a single attribute declaration within an attribute list.
    ''' </summary>
    Friend NotInheritable Class AttributeSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _target as AttributeTargetSyntax
        Friend ReadOnly _name as TypeSyntax
        Friend ReadOnly _argumentList as ArgumentListSyntax

        Friend Sub New(ByVal kind As SyntaxKind, target As AttributeTargetSyntax, name As TypeSyntax, argumentList As ArgumentListSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            If target IsNot Nothing Then
                AdjustFlagsAndWidth(target)
                Me._target = target
            End If
            AdjustFlagsAndWidth(name)
            Me._name = name
            If argumentList IsNot Nothing Then
                AdjustFlagsAndWidth(argumentList)
                Me._argumentList = argumentList
            End If

            SetFlags(NodeFlags.ContainsAttributes)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, target As AttributeTargetSyntax, name As TypeSyntax, argumentList As ArgumentListSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            If target IsNot Nothing Then
                AdjustFlagsAndWidth(target)
                Me._target = target
            End If
            AdjustFlagsAndWidth(name)
            Me._name = name
            If argumentList IsNot Nothing Then
                AdjustFlagsAndWidth(argumentList)
                Me._argumentList = argumentList
            End If

            SetFlags(NodeFlags.ContainsAttributes)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), target As AttributeTargetSyntax, name As TypeSyntax, argumentList As ArgumentListSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            If target IsNot Nothing Then
                AdjustFlagsAndWidth(target)
                Me._target = target
            End If
            AdjustFlagsAndWidth(name)
            Me._name = name
            If argumentList IsNot Nothing Then
                AdjustFlagsAndWidth(argumentList)
                Me._argumentList = argumentList
            End If

            SetFlags(NodeFlags.ContainsAttributes)
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' Optional attribute target. Assembly|Module :
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Target As InternalSyntax.AttributeTargetSyntax
            Get
                Return Me._target
            End Get
        End Property

        ''' <summary>
        ''' The name of the attribute.
        ''' </summary>
        Friend ReadOnly Property Name As InternalSyntax.TypeSyntax
            Get
                Return Me._name
            End Get
        End Property

        ''' <summary>
        ''' The argument list, if present. If no argument list was supplied, Nothing is
        ''' returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property ArgumentList As InternalSyntax.ArgumentListSyntax
            Get
                Return Me._argumentList
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._target
                Case 1
                    Return Me._name
                Case 2
                    Return Me._argumentList
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new AttributeSyntax(Me.Kind, newErrors, GetAnnotations, _target, _name, _argumentList)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new AttributeSyntax(Me.Kind, GetDiagnostics, annotations, _target, _name, _argumentList)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitAttribute(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a single attribute declaration within an attribute list.
    ''' </summary>
    Friend NotInheritable Class AttributeTargetSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _attributeModifier as KeywordSyntax
        Friend ReadOnly _colonToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributeModifier As InternalSyntax.KeywordSyntax, colonToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(attributeModifier)
            Me._attributeModifier = attributeModifier
            AdjustFlagsAndWidth(colonToken)
            Me._colonToken = colonToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, attributeModifier As InternalSyntax.KeywordSyntax, colonToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(attributeModifier)
            Me._attributeModifier = attributeModifier
            AdjustFlagsAndWidth(colonToken)
            Me._colonToken = colonToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributeModifier As InternalSyntax.KeywordSyntax, colonToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(attributeModifier)
            Me._attributeModifier = attributeModifier
            AdjustFlagsAndWidth(colonToken)
            Me._colonToken = colonToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeTargetSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Assembly" or "Module" attribute modifier, is present. If no attribute
        ''' modifier is present, Nothing is returned.
        ''' </summary>
        Friend ReadOnly Property AttributeModifier As InternalSyntax.KeywordSyntax
            Get
                Return Me._attributeModifier
            End Get
        End Property

        ''' <summary>
        ''' The ":" token, if an attribute modifier is present. If no attribute modifier is
        ''' present, Nothing is returned.
        ''' </summary>
        Friend ReadOnly Property ColonToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._colonToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._attributeModifier
                Case 1
                    Return Me._colonToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new AttributeTargetSyntax(Me.Kind, newErrors, GetAnnotations, _attributeModifier, _colonToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new AttributeTargetSyntax(Me.Kind, GetDiagnostics, annotations, _attributeModifier, _colonToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitAttributeTarget(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a file-level attribute, in which the attributes have no other
    ''' syntactic element they are attached to.
    ''' </summary>
    Friend NotInheritable Class AttributesStatementSyntax
        Inherits DeclarationStatementSyntax

        Friend ReadOnly _attributeLists as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 1

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributeLists As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributesStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The list of attribute lists.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property AttributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AttributeListSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AttributeListSyntax)(Me._attributeLists)
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._attributeLists
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new AttributesStatementSyntax(Me.Kind, newErrors, GetAnnotations, _attributeLists)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new AttributesStatementSyntax(Me.Kind, GetDiagnostics, annotations, _attributeLists)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitAttributesStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represent an expression in a statement context. This may only be a invocation
    ''' or await expression in standard code but may be any expression in VB
    ''' Interactive code.
    ''' </summary>
    Friend NotInheritable Class ExpressionStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, expression As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, expression As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The expression.
        ''' </summary>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._expression
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ExpressionStatementSyntax(Me.Kind, newErrors, GetAnnotations, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ExpressionStatementSyntax(Me.Kind, GetDiagnostics, annotations, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitExpressionStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represent a "? expression" "Print" statement in VB Interactive code.
    ''' </summary>
    Friend NotInheritable Class PrintStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _questionToken as PunctuationSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, questionToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(questionToken)
            Me._questionToken = questionToken
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, questionToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(questionToken)
            Me._questionToken = questionToken
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), questionToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(questionToken)
            Me._questionToken = questionToken
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.PrintStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' "?" token.
        ''' </summary>
        Friend ReadOnly Property QuestionToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._questionToken
            End Get
        End Property

        ''' <summary>
        ''' The expression whose value is being output.
        ''' </summary>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._questionToken
                Case 1
                    Return Me._expression
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new PrintStatementSyntax(Me.Kind, newErrors, GetAnnotations, _questionToken, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new PrintStatementSyntax(Me.Kind, GetDiagnostics, annotations, _questionToken, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitPrintStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a While...End While statement, including the While, body and End
    ''' While.
    ''' </summary>
    Friend NotInheritable Class WhileBlockSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _whileStatement as WhileStatementSyntax
        Friend ReadOnly _statements as GreenNode
        Friend ReadOnly _endWhileStatement as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, whileStatement As WhileStatementSyntax, statements As GreenNode, endWhileStatement As EndBlockStatementSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(whileStatement)
            Me._whileStatement = whileStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            AdjustFlagsAndWidth(endWhileStatement)
            Me._endWhileStatement = endWhileStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, whileStatement As WhileStatementSyntax, statements As GreenNode, endWhileStatement As EndBlockStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(whileStatement)
            Me._whileStatement = whileStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            AdjustFlagsAndWidth(endWhileStatement)
            Me._endWhileStatement = endWhileStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), whileStatement As WhileStatementSyntax, statements As GreenNode, endWhileStatement As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(whileStatement)
            Me._whileStatement = whileStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            AdjustFlagsAndWidth(endWhileStatement)
            Me._endWhileStatement = endWhileStatement

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The While statement that begins the block.
        ''' </summary>
        Friend ReadOnly Property WhileStatement As InternalSyntax.WhileStatementSyntax
            Get
                Return Me._whileStatement
            End Get
        End Property

        ''' <summary>
        ''' The statements contained in the While...End While. This might be an empty list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)(Me._statements)
            End Get
        End Property

        ''' <summary>
        ''' The End While statement that ends the block.
        ''' </summary>
        Friend ReadOnly Property EndWhileStatement As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._endWhileStatement
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._whileStatement
                Case 1
                    Return Me._statements
                Case 2
                    Return Me._endWhileStatement
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new WhileBlockSyntax(Me.Kind, newErrors, GetAnnotations, _whileStatement, _statements, _endWhileStatement)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new WhileBlockSyntax(Me.Kind, GetDiagnostics, annotations, _whileStatement, _statements, _endWhileStatement)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitWhileBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an entire Using...End Using statement, including the Using, body and
    ''' End Using statements.
    ''' </summary>
    Friend NotInheritable Class UsingBlockSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _usingStatement as UsingStatementSyntax
        Friend ReadOnly _statements as GreenNode
        Friend ReadOnly _endUsingStatement as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, usingStatement As UsingStatementSyntax, statements As GreenNode, endUsingStatement As EndBlockStatementSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(usingStatement)
            Me._usingStatement = usingStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            AdjustFlagsAndWidth(endUsingStatement)
            Me._endUsingStatement = endUsingStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, usingStatement As UsingStatementSyntax, statements As GreenNode, endUsingStatement As EndBlockStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(usingStatement)
            Me._usingStatement = usingStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            AdjustFlagsAndWidth(endUsingStatement)
            Me._endUsingStatement = endUsingStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), usingStatement As UsingStatementSyntax, statements As GreenNode, endUsingStatement As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(usingStatement)
            Me._usingStatement = usingStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            AdjustFlagsAndWidth(endUsingStatement)
            Me._endUsingStatement = endUsingStatement

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The UsingStatement that begins the Using...End Using block.
        ''' </summary>
        Friend ReadOnly Property UsingStatement As InternalSyntax.UsingStatementSyntax
            Get
                Return Me._usingStatement
            End Get
        End Property

        ''' <summary>
        ''' The statements contained in the Using...End Using block. This might be an empty
        ''' list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)(Me._statements)
            End Get
        End Property

        ''' <summary>
        ''' The End Using statement that ends the block.
        ''' </summary>
        Friend ReadOnly Property EndUsingStatement As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._endUsingStatement
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._usingStatement
                Case 1
                    Return Me._statements
                Case 2
                    Return Me._endUsingStatement
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new UsingBlockSyntax(Me.Kind, newErrors, GetAnnotations, _usingStatement, _statements, _endUsingStatement)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new UsingBlockSyntax(Me.Kind, GetDiagnostics, annotations, _usingStatement, _statements, _endUsingStatement)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitUsingBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a entire SyncLock...End SyncLock block, including the SyncLock
    ''' statement, the enclosed statements, and the End SyncLock statement.
    ''' </summary>
    Friend NotInheritable Class SyncLockBlockSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _syncLockStatement as SyncLockStatementSyntax
        Friend ReadOnly _statements as GreenNode
        Friend ReadOnly _endSyncLockStatement as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, syncLockStatement As SyncLockStatementSyntax, statements As GreenNode, endSyncLockStatement As EndBlockStatementSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(syncLockStatement)
            Me._syncLockStatement = syncLockStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            AdjustFlagsAndWidth(endSyncLockStatement)
            Me._endSyncLockStatement = endSyncLockStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, syncLockStatement As SyncLockStatementSyntax, statements As GreenNode, endSyncLockStatement As EndBlockStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(syncLockStatement)
            Me._syncLockStatement = syncLockStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            AdjustFlagsAndWidth(endSyncLockStatement)
            Me._endSyncLockStatement = endSyncLockStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), syncLockStatement As SyncLockStatementSyntax, statements As GreenNode, endSyncLockStatement As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(syncLockStatement)
            Me._syncLockStatement = syncLockStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            AdjustFlagsAndWidth(endSyncLockStatement)
            Me._endSyncLockStatement = endSyncLockStatement

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The SyncLock statement that begins the block.
        ''' </summary>
        Friend ReadOnly Property SyncLockStatement As InternalSyntax.SyncLockStatementSyntax
            Get
                Return Me._syncLockStatement
            End Get
        End Property

        ''' <summary>
        ''' The statements contained in the SyncLock...End SyncLock statement. This might
        ''' be an empty list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)(Me._statements)
            End Get
        End Property

        ''' <summary>
        ''' The End SyncLock statement that ends the block.
        ''' </summary>
        Friend ReadOnly Property EndSyncLockStatement As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._endSyncLockStatement
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._syncLockStatement
                Case 1
                    Return Me._statements
                Case 2
                    Return Me._endSyncLockStatement
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new SyncLockBlockSyntax(Me.Kind, newErrors, GetAnnotations, _syncLockStatement, _statements, _endSyncLockStatement)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new SyncLockBlockSyntax(Me.Kind, GetDiagnostics, annotations, _syncLockStatement, _statements, _endSyncLockStatement)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitSyncLockBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a With...End With block, include the With statement, the body of the
    ''' block and the End With statement.
    ''' </summary>
    Friend NotInheritable Class WithBlockSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _withStatement as WithStatementSyntax
        Friend ReadOnly _statements as GreenNode
        Friend ReadOnly _endWithStatement as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, withStatement As WithStatementSyntax, statements As GreenNode, endWithStatement As EndBlockStatementSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(withStatement)
            Me._withStatement = withStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            AdjustFlagsAndWidth(endWithStatement)
            Me._endWithStatement = endWithStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, withStatement As WithStatementSyntax, statements As GreenNode, endWithStatement As EndBlockStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(withStatement)
            Me._withStatement = withStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            AdjustFlagsAndWidth(endWithStatement)
            Me._endWithStatement = endWithStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), withStatement As WithStatementSyntax, statements As GreenNode, endWithStatement As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(withStatement)
            Me._withStatement = withStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            AdjustFlagsAndWidth(endWithStatement)
            Me._endWithStatement = endWithStatement

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.WithBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The WithStatement that begins the With...End With block.
        ''' </summary>
        Friend ReadOnly Property WithStatement As InternalSyntax.WithStatementSyntax
            Get
                Return Me._withStatement
            End Get
        End Property

        ''' <summary>
        ''' The statements contained in the With...End With block. This might be an empty
        ''' list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)(Me._statements)
            End Get
        End Property

        ''' <summary>
        ''' The End With statement that ends the block.
        ''' </summary>
        Friend ReadOnly Property EndWithStatement As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._endWithStatement
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._withStatement
                Case 1
                    Return Me._statements
                Case 2
                    Return Me._endWithStatement
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new WithBlockSyntax(Me.Kind, newErrors, GetAnnotations, _withStatement, _statements, _endWithStatement)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new WithBlockSyntax(Me.Kind, GetDiagnostics, annotations, _withStatement, _statements, _endWithStatement)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitWithBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the declaration of one or more local variables or constants.
    ''' </summary>
    Friend NotInheritable Class LocalDeclarationStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _modifiers as GreenNode
        Friend ReadOnly _declarators as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, modifiers As GreenNode, declarators As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 2

            If modifiers IsNot Nothing Then
                AdjustFlagsAndWidth(modifiers)
                Me._modifiers = modifiers
            End If
            If declarators IsNot Nothing Then
                AdjustFlagsAndWidth(declarators)
                Me._declarators = declarators
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, modifiers As GreenNode, declarators As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            If modifiers IsNot Nothing Then
                AdjustFlagsAndWidth(modifiers)
                Me._modifiers = modifiers
            End If
            If declarators IsNot Nothing Then
                AdjustFlagsAndWidth(declarators)
                Me._declarators = declarators
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), modifiers As GreenNode, declarators As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            If modifiers IsNot Nothing Then
                AdjustFlagsAndWidth(modifiers)
                Me._modifiers = modifiers
            End If
            If declarators IsNot Nothing Then
                AdjustFlagsAndWidth(declarators)
                Me._declarators = declarators
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LocalDeclarationStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The modifier token (Static, Dim or Const) that introduces this local variable
        ''' declaration.
        ''' </summary>
        Friend ReadOnly Property Modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of KeywordSyntax)
            Get
                Return New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)(Me._modifiers)
            End Get
        End Property

        ''' <summary>
        ''' The list of variable declarator. Each declarator specifies one or more variable
        ''' names along with a type and/or initializer.
        ''' </summary>
        Friend ReadOnly Property Declarators As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of VariableDeclaratorSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of VariableDeclaratorSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of VariableDeclaratorSyntax)(Me._declarators))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._modifiers
                Case 1
                    Return Me._declarators
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new LocalDeclarationStatementSyntax(Me.Kind, newErrors, GetAnnotations, _modifiers, _declarators)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new LocalDeclarationStatementSyntax(Me.Kind, GetDiagnostics, annotations, _modifiers, _declarators)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitLocalDeclarationStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a label statement.
    ''' </summary>
    Friend NotInheritable Class LabelStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _labelToken as SyntaxToken
        Friend ReadOnly _colonToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, labelToken As InternalSyntax.SyntaxToken, colonToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(labelToken)
            Me._labelToken = labelToken
            AdjustFlagsAndWidth(colonToken)
            Me._colonToken = colonToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, labelToken As InternalSyntax.SyntaxToken, colonToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(labelToken)
            Me._labelToken = labelToken
            AdjustFlagsAndWidth(colonToken)
            Me._colonToken = colonToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), labelToken As InternalSyntax.SyntaxToken, colonToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(labelToken)
            Me._labelToken = labelToken
            AdjustFlagsAndWidth(colonToken)
            Me._colonToken = colonToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The name of the label. If the label is a line number, returns an IntegerLiteral
        ''' that is the line number, otherwise, returns an Identifier.
        ''' </summary>
        Friend ReadOnly Property LabelToken As InternalSyntax.SyntaxToken
            Get
                Return Me._labelToken
            End Get
        End Property

        ''' <summary>
        ''' The ":" token of the label statement.
        ''' </summary>
        Friend ReadOnly Property ColonToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._colonToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._labelToken
                Case 1
                    Return Me._colonToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new LabelStatementSyntax(Me.Kind, newErrors, GetAnnotations, _labelToken, _colonToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new LabelStatementSyntax(Me.Kind, GetDiagnostics, annotations, _labelToken, _colonToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitLabelStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "GoTo" statement.
    ''' </summary>
    Friend NotInheritable Class GoToStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _goToKeyword as KeywordSyntax
        Friend ReadOnly _label as LabelSyntax

        Friend Sub New(ByVal kind As SyntaxKind, goToKeyword As InternalSyntax.KeywordSyntax, label As LabelSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(goToKeyword)
            Me._goToKeyword = goToKeyword
            AdjustFlagsAndWidth(label)
            Me._label = label

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, goToKeyword As InternalSyntax.KeywordSyntax, label As LabelSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(goToKeyword)
            Me._goToKeyword = goToKeyword
            AdjustFlagsAndWidth(label)
            Me._label = label

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), goToKeyword As InternalSyntax.KeywordSyntax, label As LabelSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(goToKeyword)
            Me._goToKeyword = goToKeyword
            AdjustFlagsAndWidth(label)
            Me._label = label

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.GoToStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "GoTo" keyword.
        ''' </summary>
        Friend ReadOnly Property GoToKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._goToKeyword
            End Get
        End Property

        ''' <summary>
        ''' The name of the label. If the label is a line number, wraps an IntegerLiteral
        ''' that is the line number, otherwise, wraps an Identifier.
        ''' </summary>
        Friend ReadOnly Property Label As InternalSyntax.LabelSyntax
            Get
                Return Me._label
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._goToKeyword
                Case 1
                    Return Me._label
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new GoToStatementSyntax(Me.Kind, newErrors, GetAnnotations, _goToKeyword, _label)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new GoToStatementSyntax(Me.Kind, GetDiagnostics, annotations, _goToKeyword, _label)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitGoToStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' A label for a GoTo, Resume, or On Error statement. An identifier, line number,
    ''' or next keyword.
    ''' </summary>
    Friend NotInheritable Class LabelSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _labelToken as SyntaxToken

        Friend Sub New(ByVal kind As SyntaxKind, labelToken As InternalSyntax.SyntaxToken)
            MyBase.New(kind)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(labelToken)
            Me._labelToken = labelToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, labelToken As InternalSyntax.SyntaxToken, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(labelToken)
            Me._labelToken = labelToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), labelToken As InternalSyntax.SyntaxToken)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(labelToken)
            Me._labelToken = labelToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The label name (identifier), line number (integer literal), or next keyword
        ''' token.
        ''' </summary>
        Friend ReadOnly Property LabelToken As InternalSyntax.SyntaxToken
            Get
                Return Me._labelToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._labelToken
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new LabelSyntax(Me.Kind, newErrors, GetAnnotations, _labelToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new LabelSyntax(Me.Kind, GetDiagnostics, annotations, _labelToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitLabel(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "Stop" or "End" statement. The Kind can be used to determine which
    ''' kind of statement this is.
    ''' </summary>
    Friend NotInheritable Class StopOrEndStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _stopOrEndKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, stopOrEndKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(stopOrEndKeyword)
            Me._stopOrEndKeyword = stopOrEndKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, stopOrEndKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(stopOrEndKeyword)
            Me._stopOrEndKeyword = stopOrEndKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), stopOrEndKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(stopOrEndKeyword)
            Me._stopOrEndKeyword = stopOrEndKeyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.StopOrEndStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Stop" or "End" keyword.
        ''' </summary>
        Friend ReadOnly Property StopOrEndKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._stopOrEndKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._stopOrEndKeyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new StopOrEndStatementSyntax(Me.Kind, newErrors, GetAnnotations, _stopOrEndKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new StopOrEndStatementSyntax(Me.Kind, GetDiagnostics, annotations, _stopOrEndKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitStopOrEndStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' An exit statement. The kind of block being exited can be found by examining the
    ''' Kind.
    ''' </summary>
    Friend NotInheritable Class ExitStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _exitKeyword as KeywordSyntax
        Friend ReadOnly _blockKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, exitKeyword As InternalSyntax.KeywordSyntax, blockKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(exitKeyword)
            Me._exitKeyword = exitKeyword
            AdjustFlagsAndWidth(blockKeyword)
            Me._blockKeyword = blockKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, exitKeyword As InternalSyntax.KeywordSyntax, blockKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(exitKeyword)
            Me._exitKeyword = exitKeyword
            AdjustFlagsAndWidth(blockKeyword)
            Me._blockKeyword = blockKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), exitKeyword As InternalSyntax.KeywordSyntax, blockKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(exitKeyword)
            Me._exitKeyword = exitKeyword
            AdjustFlagsAndWidth(blockKeyword)
            Me._blockKeyword = blockKeyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Exit" keyword.
        ''' </summary>
        Friend ReadOnly Property ExitKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._exitKeyword
            End Get
        End Property

        ''' <summary>
        ''' The keyword describing the block to exit.
        ''' </summary>
        Friend ReadOnly Property BlockKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._blockKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._exitKeyword
                Case 1
                    Return Me._blockKeyword
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ExitStatementSyntax(Me.Kind, newErrors, GetAnnotations, _exitKeyword, _blockKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ExitStatementSyntax(Me.Kind, GetDiagnostics, annotations, _exitKeyword, _blockKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitExitStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "Continue (block)" statement. THe kind of block referenced can be
    ''' determined by examining the Kind.
    ''' </summary>
    Friend NotInheritable Class ContinueStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _continueKeyword as KeywordSyntax
        Friend ReadOnly _blockKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, continueKeyword As InternalSyntax.KeywordSyntax, blockKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(continueKeyword)
            Me._continueKeyword = continueKeyword
            AdjustFlagsAndWidth(blockKeyword)
            Me._blockKeyword = blockKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, continueKeyword As InternalSyntax.KeywordSyntax, blockKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(continueKeyword)
            Me._continueKeyword = continueKeyword
            AdjustFlagsAndWidth(blockKeyword)
            Me._blockKeyword = blockKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), continueKeyword As InternalSyntax.KeywordSyntax, blockKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(continueKeyword)
            Me._continueKeyword = continueKeyword
            AdjustFlagsAndWidth(blockKeyword)
            Me._blockKeyword = blockKeyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Continue" keyword.
        ''' </summary>
        Friend ReadOnly Property ContinueKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._continueKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "Do", "For" or "While" keyword that identifies the kind of loop being
        ''' continued.
        ''' </summary>
        Friend ReadOnly Property BlockKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._blockKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._continueKeyword
                Case 1
                    Return Me._blockKeyword
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ContinueStatementSyntax(Me.Kind, newErrors, GetAnnotations, _continueKeyword, _blockKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ContinueStatementSyntax(Me.Kind, GetDiagnostics, annotations, _continueKeyword, _blockKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitContinueStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "Return" statement.
    ''' </summary>
    Friend NotInheritable Class ReturnStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _returnKeyword as KeywordSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, returnKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(returnKeyword)
            Me._returnKeyword = returnKeyword
            If expression IsNot Nothing Then
                AdjustFlagsAndWidth(expression)
                Me._expression = expression
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, returnKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(returnKeyword)
            Me._returnKeyword = returnKeyword
            If expression IsNot Nothing Then
                AdjustFlagsAndWidth(expression)
                Me._expression = expression
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), returnKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(returnKeyword)
            Me._returnKeyword = returnKeyword
            If expression IsNot Nothing Then
                AdjustFlagsAndWidth(expression)
                Me._expression = expression
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ReturnStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Return" keyword.
        ''' </summary>
        Friend ReadOnly Property ReturnKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._returnKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression being returned, if present.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._returnKeyword
                Case 1
                    Return Me._expression
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ReturnStatementSyntax(Me.Kind, newErrors, GetAnnotations, _returnKeyword, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ReturnStatementSyntax(Me.Kind, GetDiagnostics, annotations, _returnKeyword, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitReturnStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a single-line "If ... Then ... Else ..." statement.
    ''' </summary>
    Friend NotInheritable Class SingleLineIfStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _ifKeyword as KeywordSyntax
        Friend ReadOnly _condition as ExpressionSyntax
        Friend ReadOnly _thenKeyword as KeywordSyntax
        Friend ReadOnly _statements as GreenNode
        Friend ReadOnly _elseClause as SingleLineElseClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, ifKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax, thenKeyword As InternalSyntax.KeywordSyntax, statements As GreenNode, elseClause As SingleLineElseClauseSyntax)
            MyBase.New(kind)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(ifKeyword)
            Me._ifKeyword = ifKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition
            AdjustFlagsAndWidth(thenKeyword)
            Me._thenKeyword = thenKeyword
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            If elseClause IsNot Nothing Then
                AdjustFlagsAndWidth(elseClause)
                Me._elseClause = elseClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ifKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax, thenKeyword As InternalSyntax.KeywordSyntax, statements As GreenNode, elseClause As SingleLineElseClauseSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(ifKeyword)
            Me._ifKeyword = ifKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition
            AdjustFlagsAndWidth(thenKeyword)
            Me._thenKeyword = thenKeyword
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            If elseClause IsNot Nothing Then
                AdjustFlagsAndWidth(elseClause)
                Me._elseClause = elseClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), ifKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax, thenKeyword As InternalSyntax.KeywordSyntax, statements As GreenNode, elseClause As SingleLineElseClauseSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(ifKeyword)
            Me._ifKeyword = ifKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition
            AdjustFlagsAndWidth(thenKeyword)
            Me._thenKeyword = thenKeyword
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            If elseClause IsNot Nothing Then
                AdjustFlagsAndWidth(elseClause)
                Me._elseClause = elseClause
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineIfStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "If" keyword.
        ''' </summary>
        Friend ReadOnly Property IfKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._ifKeyword
            End Get
        End Property

        ''' <summary>
        ''' The condition expression to be evaluated.
        ''' </summary>
        Friend ReadOnly Property Condition As InternalSyntax.ExpressionSyntax
            Get
                Return Me._condition
            End Get
        End Property

        ''' <summary>
        ''' The "Then" keyword.
        ''' </summary>
        Friend ReadOnly Property ThenKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._thenKeyword
            End Get
        End Property

        ''' <summary>
        ''' A list of statements to be executed if the condition expression evaluates as
        ''' true. Multiple statements must be separated by colons.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)(Me._statements)
            End Get
        End Property

        ''' <summary>
        ''' An "Else" clause to be executed if the condition expression evaluates as false.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property ElseClause As InternalSyntax.SingleLineElseClauseSyntax
            Get
                Return Me._elseClause
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._ifKeyword
                Case 1
                    Return Me._condition
                Case 2
                    Return Me._thenKeyword
                Case 3
                    Return Me._statements
                Case 4
                    Return Me._elseClause
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new SingleLineIfStatementSyntax(Me.Kind, newErrors, GetAnnotations, _ifKeyword, _condition, _thenKeyword, _statements, _elseClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new SingleLineIfStatementSyntax(Me.Kind, GetDiagnostics, annotations, _ifKeyword, _condition, _thenKeyword, _statements, _elseClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitSingleLineIfStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "Else ..." clause of a single-line "If" statement.
    ''' </summary>
    Friend NotInheritable Class SingleLineElseClauseSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _elseKeyword as KeywordSyntax
        Friend ReadOnly _statements as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, elseKeyword As InternalSyntax.KeywordSyntax, statements As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(elseKeyword)
            Me._elseKeyword = elseKeyword
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, elseKeyword As InternalSyntax.KeywordSyntax, statements As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(elseKeyword)
            Me._elseKeyword = elseKeyword
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), elseKeyword As InternalSyntax.KeywordSyntax, statements As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(elseKeyword)
            Me._elseKeyword = elseKeyword
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineElseClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Else" keyword.
        ''' </summary>
        Friend ReadOnly Property ElseKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._elseKeyword
            End Get
        End Property

        ''' <summary>
        ''' A list of statements to be executed. Multiple statements must be separated by
        ''' colons.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)(Me._statements)
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._elseKeyword
                Case 1
                    Return Me._statements
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new SingleLineElseClauseSyntax(Me.Kind, newErrors, GetAnnotations, _elseKeyword, _statements)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new SingleLineElseClauseSyntax(Me.Kind, GetDiagnostics, annotations, _elseKeyword, _statements)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitSingleLineElseClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a multi-line "If ... Then ... ElseIf ... Then ... Else ... End If"
    ''' block.
    ''' </summary>
    Friend NotInheritable Class MultiLineIfBlockSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _ifStatement as IfStatementSyntax
        Friend ReadOnly _statements as GreenNode
        Friend ReadOnly _elseIfBlocks as GreenNode
        Friend ReadOnly _elseBlock as ElseBlockSyntax
        Friend ReadOnly _endIfStatement as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, ifStatement As IfStatementSyntax, statements As GreenNode, elseIfBlocks As GreenNode, elseBlock As ElseBlockSyntax, endIfStatement As EndBlockStatementSyntax)
            MyBase.New(kind)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(ifStatement)
            Me._ifStatement = ifStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            If elseIfBlocks IsNot Nothing Then
                AdjustFlagsAndWidth(elseIfBlocks)
                Me._elseIfBlocks = elseIfBlocks
            End If
            If elseBlock IsNot Nothing Then
                AdjustFlagsAndWidth(elseBlock)
                Me._elseBlock = elseBlock
            End If
            AdjustFlagsAndWidth(endIfStatement)
            Me._endIfStatement = endIfStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ifStatement As IfStatementSyntax, statements As GreenNode, elseIfBlocks As GreenNode, elseBlock As ElseBlockSyntax, endIfStatement As EndBlockStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(ifStatement)
            Me._ifStatement = ifStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            If elseIfBlocks IsNot Nothing Then
                AdjustFlagsAndWidth(elseIfBlocks)
                Me._elseIfBlocks = elseIfBlocks
            End If
            If elseBlock IsNot Nothing Then
                AdjustFlagsAndWidth(elseBlock)
                Me._elseBlock = elseBlock
            End If
            AdjustFlagsAndWidth(endIfStatement)
            Me._endIfStatement = endIfStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), ifStatement As IfStatementSyntax, statements As GreenNode, elseIfBlocks As GreenNode, elseBlock As ElseBlockSyntax, endIfStatement As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(ifStatement)
            Me._ifStatement = ifStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            If elseIfBlocks IsNot Nothing Then
                AdjustFlagsAndWidth(elseIfBlocks)
                Me._elseIfBlocks = elseIfBlocks
            End If
            If elseBlock IsNot Nothing Then
                AdjustFlagsAndWidth(elseBlock)
                Me._elseBlock = elseBlock
            End If
            AdjustFlagsAndWidth(endIfStatement)
            Me._endIfStatement = endIfStatement

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineIfBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "If" statement that begins the "If" block.
        ''' </summary>
        Friend ReadOnly Property IfStatement As InternalSyntax.IfStatementSyntax
            Get
                Return Me._ifStatement
            End Get
        End Property

        ''' <summary>
        ''' A list of statements to be executed if the condition expression evaluates as
        ''' true.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)(Me._statements)
            End Get
        End Property

        ''' <summary>
        ''' A list of "ElseIf" blocks to be evaluated, in order, if the condition
        ''' expression of the "If" statement evaluates as false.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property ElseIfBlocks As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of ElseIfBlockSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of ElseIfBlockSyntax)(Me._elseIfBlocks)
            End Get
        End Property

        ''' <summary>
        ''' An "Else" block to be executed if the condition expression of the "If"
        ''' statement and all "ElseIf" blocks evaluate as false.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property ElseBlock As InternalSyntax.ElseBlockSyntax
            Get
                Return Me._elseBlock
            End Get
        End Property

        ''' <summary>
        ''' Then "End If" statement.
        ''' </summary>
        Friend ReadOnly Property EndIfStatement As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._endIfStatement
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._ifStatement
                Case 1
                    Return Me._statements
                Case 2
                    Return Me._elseIfBlocks
                Case 3
                    Return Me._elseBlock
                Case 4
                    Return Me._endIfStatement
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new MultiLineIfBlockSyntax(Me.Kind, newErrors, GetAnnotations, _ifStatement, _statements, _elseIfBlocks, _elseBlock, _endIfStatement)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new MultiLineIfBlockSyntax(Me.Kind, GetDiagnostics, annotations, _ifStatement, _statements, _elseIfBlocks, _elseBlock, _endIfStatement)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitMultiLineIfBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "If ... Then" statement that begins a multi-line "If" block.
    ''' </summary>
    Friend NotInheritable Class IfStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _ifKeyword as KeywordSyntax
        Friend ReadOnly _condition as ExpressionSyntax
        Friend ReadOnly _thenKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, ifKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax, thenKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(ifKeyword)
            Me._ifKeyword = ifKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition
            If thenKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(thenKeyword)
                Me._thenKeyword = thenKeyword
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ifKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax, thenKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(ifKeyword)
            Me._ifKeyword = ifKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition
            If thenKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(thenKeyword)
                Me._thenKeyword = thenKeyword
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), ifKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax, thenKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(ifKeyword)
            Me._ifKeyword = ifKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition
            If thenKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(thenKeyword)
                Me._thenKeyword = thenKeyword
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.IfStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "If" keyword.
        ''' </summary>
        Friend ReadOnly Property IfKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._ifKeyword
            End Get
        End Property

        ''' <summary>
        ''' The condition expression to be evaluated.
        ''' </summary>
        Friend ReadOnly Property Condition As InternalSyntax.ExpressionSyntax
            Get
                Return Me._condition
            End Get
        End Property

        ''' <summary>
        ''' The "Then" keyword.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property ThenKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._thenKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._ifKeyword
                Case 1
                    Return Me._condition
                Case 2
                    Return Me._thenKeyword
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new IfStatementSyntax(Me.Kind, newErrors, GetAnnotations, _ifKeyword, _condition, _thenKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new IfStatementSyntax(Me.Kind, GetDiagnostics, annotations, _ifKeyword, _condition, _thenKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitIfStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an "ElseIf ... Then ..." block.
    ''' </summary>
    Friend NotInheritable Class ElseIfBlockSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _elseIfStatement as ElseIfStatementSyntax
        Friend ReadOnly _statements as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, elseIfStatement As ElseIfStatementSyntax, statements As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(elseIfStatement)
            Me._elseIfStatement = elseIfStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, elseIfStatement As ElseIfStatementSyntax, statements As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(elseIfStatement)
            Me._elseIfStatement = elseIfStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), elseIfStatement As ElseIfStatementSyntax, statements As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(elseIfStatement)
            Me._elseIfStatement = elseIfStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "ElseIf ... Then" statement the begins the "ElseIf" block.
        ''' </summary>
        Friend ReadOnly Property ElseIfStatement As InternalSyntax.ElseIfStatementSyntax
            Get
                Return Me._elseIfStatement
            End Get
        End Property

        ''' <summary>
        ''' A list of statements to be executed if the condition expression of the "ElseIf"
        ''' statement evaluates as true.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)(Me._statements)
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._elseIfStatement
                Case 1
                    Return Me._statements
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ElseIfBlockSyntax(Me.Kind, newErrors, GetAnnotations, _elseIfStatement, _statements)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ElseIfBlockSyntax(Me.Kind, GetDiagnostics, annotations, _elseIfStatement, _statements)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitElseIfBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "ElseIf ... Then" statement that begins an "ElseIf" block.
    ''' </summary>
    Friend NotInheritable Class ElseIfStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _elseIfKeyword as KeywordSyntax
        Friend ReadOnly _condition as ExpressionSyntax
        Friend ReadOnly _thenKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, elseIfKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax, thenKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(elseIfKeyword)
            Me._elseIfKeyword = elseIfKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition
            If thenKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(thenKeyword)
                Me._thenKeyword = thenKeyword
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, elseIfKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax, thenKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(elseIfKeyword)
            Me._elseIfKeyword = elseIfKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition
            If thenKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(thenKeyword)
                Me._thenKeyword = thenKeyword
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), elseIfKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax, thenKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(elseIfKeyword)
            Me._elseIfKeyword = elseIfKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition
            If thenKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(thenKeyword)
                Me._thenKeyword = thenKeyword
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "ElseIf" keyword.
        ''' </summary>
        Friend ReadOnly Property ElseIfKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._elseIfKeyword
            End Get
        End Property

        ''' <summary>
        ''' The condition expression to be evaluated.
        ''' </summary>
        Friend ReadOnly Property Condition As InternalSyntax.ExpressionSyntax
            Get
                Return Me._condition
            End Get
        End Property

        ''' <summary>
        ''' The "Then" keyword.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property ThenKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._thenKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._elseIfKeyword
                Case 1
                    Return Me._condition
                Case 2
                    Return Me._thenKeyword
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ElseIfStatementSyntax(Me.Kind, newErrors, GetAnnotations, _elseIfKeyword, _condition, _thenKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ElseIfStatementSyntax(Me.Kind, GetDiagnostics, annotations, _elseIfKeyword, _condition, _thenKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitElseIfStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an "Else ..." block.
    ''' </summary>
    Friend NotInheritable Class ElseBlockSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _elseStatement as ElseStatementSyntax
        Friend ReadOnly _statements as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, elseStatement As ElseStatementSyntax, statements As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(elseStatement)
            Me._elseStatement = elseStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, elseStatement As ElseStatementSyntax, statements As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(elseStatement)
            Me._elseStatement = elseStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), elseStatement As ElseStatementSyntax, statements As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(elseStatement)
            Me._elseStatement = elseStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Else" statement that begins the "Else" block.
        ''' </summary>
        Friend ReadOnly Property ElseStatement As InternalSyntax.ElseStatementSyntax
            Get
                Return Me._elseStatement
            End Get
        End Property

        ''' <summary>
        ''' A list of statements to be executed.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)(Me._statements)
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._elseStatement
                Case 1
                    Return Me._statements
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ElseBlockSyntax(Me.Kind, newErrors, GetAnnotations, _elseStatement, _statements)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ElseBlockSyntax(Me.Kind, GetDiagnostics, annotations, _elseStatement, _statements)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitElseBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "Else" statement that begins an "Else" block.
    ''' </summary>
    Friend NotInheritable Class ElseStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _elseKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, elseKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(elseKeyword)
            Me._elseKeyword = elseKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, elseKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(elseKeyword)
            Me._elseKeyword = elseKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), elseKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(elseKeyword)
            Me._elseKeyword = elseKeyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Else" keyword.
        ''' </summary>
        Friend ReadOnly Property ElseKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._elseKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._elseKeyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ElseStatementSyntax(Me.Kind, newErrors, GetAnnotations, _elseKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ElseStatementSyntax(Me.Kind, GetDiagnostics, annotations, _elseKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitElseStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "Try ... Catch ... Finally ... End Try" block.
    ''' </summary>
    Friend NotInheritable Class TryBlockSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _tryStatement as TryStatementSyntax
        Friend ReadOnly _statements as GreenNode
        Friend ReadOnly _catchBlocks as GreenNode
        Friend ReadOnly _finallyBlock as FinallyBlockSyntax
        Friend ReadOnly _endTryStatement as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, tryStatement As TryStatementSyntax, statements As GreenNode, catchBlocks As GreenNode, finallyBlock As FinallyBlockSyntax, endTryStatement As EndBlockStatementSyntax)
            MyBase.New(kind)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(tryStatement)
            Me._tryStatement = tryStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            If catchBlocks IsNot Nothing Then
                AdjustFlagsAndWidth(catchBlocks)
                Me._catchBlocks = catchBlocks
            End If
            If finallyBlock IsNot Nothing Then
                AdjustFlagsAndWidth(finallyBlock)
                Me._finallyBlock = finallyBlock
            End If
            AdjustFlagsAndWidth(endTryStatement)
            Me._endTryStatement = endTryStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, tryStatement As TryStatementSyntax, statements As GreenNode, catchBlocks As GreenNode, finallyBlock As FinallyBlockSyntax, endTryStatement As EndBlockStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(tryStatement)
            Me._tryStatement = tryStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            If catchBlocks IsNot Nothing Then
                AdjustFlagsAndWidth(catchBlocks)
                Me._catchBlocks = catchBlocks
            End If
            If finallyBlock IsNot Nothing Then
                AdjustFlagsAndWidth(finallyBlock)
                Me._finallyBlock = finallyBlock
            End If
            AdjustFlagsAndWidth(endTryStatement)
            Me._endTryStatement = endTryStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), tryStatement As TryStatementSyntax, statements As GreenNode, catchBlocks As GreenNode, finallyBlock As FinallyBlockSyntax, endTryStatement As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(tryStatement)
            Me._tryStatement = tryStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            If catchBlocks IsNot Nothing Then
                AdjustFlagsAndWidth(catchBlocks)
                Me._catchBlocks = catchBlocks
            End If
            If finallyBlock IsNot Nothing Then
                AdjustFlagsAndWidth(finallyBlock)
                Me._finallyBlock = finallyBlock
            End If
            AdjustFlagsAndWidth(endTryStatement)
            Me._endTryStatement = endTryStatement

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TryBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Try" statement that begins the "Try" block.
        ''' </summary>
        Friend ReadOnly Property TryStatement As InternalSyntax.TryStatementSyntax
            Get
                Return Me._tryStatement
            End Get
        End Property

        ''' <summary>
        ''' A list of statements to be executed.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)(Me._statements)
            End Get
        End Property

        ''' <summary>
        ''' A list of "Catch" blocks which may be executed if an exception is thrown while
        ''' executing the statements in the "Try" block.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property CatchBlocks As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of CatchBlockSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of CatchBlockSyntax)(Me._catchBlocks)
            End Get
        End Property

        ''' <summary>
        ''' A "Finally" block to be executed before execution leaves the "Try" block.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property FinallyBlock As InternalSyntax.FinallyBlockSyntax
            Get
                Return Me._finallyBlock
            End Get
        End Property

        ''' <summary>
        ''' The "End Try" statement.
        ''' </summary>
        Friend ReadOnly Property EndTryStatement As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._endTryStatement
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._tryStatement
                Case 1
                    Return Me._statements
                Case 2
                    Return Me._catchBlocks
                Case 3
                    Return Me._finallyBlock
                Case 4
                    Return Me._endTryStatement
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new TryBlockSyntax(Me.Kind, newErrors, GetAnnotations, _tryStatement, _statements, _catchBlocks, _finallyBlock, _endTryStatement)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new TryBlockSyntax(Me.Kind, GetDiagnostics, annotations, _tryStatement, _statements, _catchBlocks, _finallyBlock, _endTryStatement)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitTryBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "Try" statement that begins a "Try" block.
    ''' </summary>
    Friend NotInheritable Class TryStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _tryKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, tryKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(tryKeyword)
            Me._tryKeyword = tryKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, tryKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(tryKeyword)
            Me._tryKeyword = tryKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), tryKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(tryKeyword)
            Me._tryKeyword = tryKeyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TryStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Try" keyword.
        ''' </summary>
        Friend ReadOnly Property TryKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._tryKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._tryKeyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new TryStatementSyntax(Me.Kind, newErrors, GetAnnotations, _tryKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new TryStatementSyntax(Me.Kind, GetDiagnostics, annotations, _tryKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitTryStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "Catch ..." block.
    ''' </summary>
    Friend NotInheritable Class CatchBlockSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _catchStatement as CatchStatementSyntax
        Friend ReadOnly _statements as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, catchStatement As CatchStatementSyntax, statements As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(catchStatement)
            Me._catchStatement = catchStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, catchStatement As CatchStatementSyntax, statements As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(catchStatement)
            Me._catchStatement = catchStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), catchStatement As CatchStatementSyntax, statements As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(catchStatement)
            Me._catchStatement = catchStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Catch" statement that begins the "Catch" block.
        ''' </summary>
        Friend ReadOnly Property CatchStatement As InternalSyntax.CatchStatementSyntax
            Get
                Return Me._catchStatement
            End Get
        End Property

        ''' <summary>
        ''' A list of statements to be executed if an exception is caught by the "Catch"
        ''' block.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)(Me._statements)
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._catchStatement
                Case 1
                    Return Me._statements
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new CatchBlockSyntax(Me.Kind, newErrors, GetAnnotations, _catchStatement, _statements)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new CatchBlockSyntax(Me.Kind, GetDiagnostics, annotations, _catchStatement, _statements)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitCatchBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "Catch ... When ..." statement that begins a "Catch" block.
    ''' </summary>
    Friend NotInheritable Class CatchStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _catchKeyword as KeywordSyntax
        Friend ReadOnly _identifierName as IdentifierNameSyntax
        Friend ReadOnly _asClause as SimpleAsClauseSyntax
        Friend ReadOnly _whenClause as CatchFilterClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, catchKeyword As InternalSyntax.KeywordSyntax, identifierName As IdentifierNameSyntax, asClause As SimpleAsClauseSyntax, whenClause As CatchFilterClauseSyntax)
            MyBase.New(kind)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(catchKeyword)
            Me._catchKeyword = catchKeyword
            If identifierName IsNot Nothing Then
                AdjustFlagsAndWidth(identifierName)
                Me._identifierName = identifierName
            End If
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            If whenClause IsNot Nothing Then
                AdjustFlagsAndWidth(whenClause)
                Me._whenClause = whenClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, catchKeyword As InternalSyntax.KeywordSyntax, identifierName As IdentifierNameSyntax, asClause As SimpleAsClauseSyntax, whenClause As CatchFilterClauseSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 4
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(catchKeyword)
            Me._catchKeyword = catchKeyword
            If identifierName IsNot Nothing Then
                AdjustFlagsAndWidth(identifierName)
                Me._identifierName = identifierName
            End If
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            If whenClause IsNot Nothing Then
                AdjustFlagsAndWidth(whenClause)
                Me._whenClause = whenClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), catchKeyword As InternalSyntax.KeywordSyntax, identifierName As IdentifierNameSyntax, asClause As SimpleAsClauseSyntax, whenClause As CatchFilterClauseSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(catchKeyword)
            Me._catchKeyword = catchKeyword
            If identifierName IsNot Nothing Then
                AdjustFlagsAndWidth(identifierName)
                Me._identifierName = identifierName
            End If
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            If whenClause IsNot Nothing Then
                AdjustFlagsAndWidth(whenClause)
                Me._whenClause = whenClause
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Catch" keyword.
        ''' </summary>
        Friend ReadOnly Property CatchKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._catchKeyword
            End Get
        End Property

        ''' <summary>
        ''' An identifier declaring a new variable or naming an existing variable to store
        ''' the exception caught by the "Catch" statement.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property IdentifierName As InternalSyntax.IdentifierNameSyntax
            Get
                Return Me._identifierName
            End Get
        End Property

        ''' <summary>
        ''' A simple "As" clause specifying the type of exception to catch.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property AsClause As InternalSyntax.SimpleAsClauseSyntax
            Get
                Return Me._asClause
            End Get
        End Property

        ''' <summary>
        ''' A "When" clause to filter exceptions before catching.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property WhenClause As InternalSyntax.CatchFilterClauseSyntax
            Get
                Return Me._whenClause
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._catchKeyword
                Case 1
                    Return Me._identifierName
                Case 2
                    Return Me._asClause
                Case 3
                    Return Me._whenClause
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new CatchStatementSyntax(Me.Kind, newErrors, GetAnnotations, _catchKeyword, _identifierName, _asClause, _whenClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new CatchStatementSyntax(Me.Kind, GetDiagnostics, annotations, _catchKeyword, _identifierName, _asClause, _whenClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitCatchStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "When ..." clause of a "Catch" statement.
    ''' </summary>
    Friend NotInheritable Class CatchFilterClauseSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _whenKeyword as KeywordSyntax
        Friend ReadOnly _filter as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, whenKeyword As InternalSyntax.KeywordSyntax, filter As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(whenKeyword)
            Me._whenKeyword = whenKeyword
            AdjustFlagsAndWidth(filter)
            Me._filter = filter

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, whenKeyword As InternalSyntax.KeywordSyntax, filter As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(whenKeyword)
            Me._whenKeyword = whenKeyword
            AdjustFlagsAndWidth(filter)
            Me._filter = filter

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), whenKeyword As InternalSyntax.KeywordSyntax, filter As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(whenKeyword)
            Me._whenKeyword = whenKeyword
            AdjustFlagsAndWidth(filter)
            Me._filter = filter

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchFilterClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "When" keyword.
        ''' </summary>
        Friend ReadOnly Property WhenKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._whenKeyword
            End Get
        End Property

        ''' <summary>
        ''' The filter expression to be evaluated.
        ''' </summary>
        Friend ReadOnly Property Filter As InternalSyntax.ExpressionSyntax
            Get
                Return Me._filter
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._whenKeyword
                Case 1
                    Return Me._filter
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new CatchFilterClauseSyntax(Me.Kind, newErrors, GetAnnotations, _whenKeyword, _filter)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new CatchFilterClauseSyntax(Me.Kind, GetDiagnostics, annotations, _whenKeyword, _filter)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitCatchFilterClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "Finally ..." block of a "Try" block.
    ''' </summary>
    Friend NotInheritable Class FinallyBlockSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _finallyStatement as FinallyStatementSyntax
        Friend ReadOnly _statements as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, finallyStatement As FinallyStatementSyntax, statements As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(finallyStatement)
            Me._finallyStatement = finallyStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, finallyStatement As FinallyStatementSyntax, statements As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(finallyStatement)
            Me._finallyStatement = finallyStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), finallyStatement As FinallyStatementSyntax, statements As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(finallyStatement)
            Me._finallyStatement = finallyStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Finally" statement that begins the "Finally" block.
        ''' </summary>
        Friend ReadOnly Property FinallyStatement As InternalSyntax.FinallyStatementSyntax
            Get
                Return Me._finallyStatement
            End Get
        End Property

        ''' <summary>
        ''' A list of statements to be executed.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)(Me._statements)
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._finallyStatement
                Case 1
                    Return Me._statements
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new FinallyBlockSyntax(Me.Kind, newErrors, GetAnnotations, _finallyStatement, _statements)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new FinallyBlockSyntax(Me.Kind, GetDiagnostics, annotations, _finallyStatement, _statements)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitFinallyBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "Finally" statement that begins a "Finally" block.
    ''' </summary>
    Friend NotInheritable Class FinallyStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _finallyKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, finallyKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(finallyKeyword)
            Me._finallyKeyword = finallyKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, finallyKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(finallyKeyword)
            Me._finallyKeyword = finallyKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), finallyKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(finallyKeyword)
            Me._finallyKeyword = finallyKeyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Finally" keyword.
        ''' </summary>
        Friend ReadOnly Property FinallyKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._finallyKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._finallyKeyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new FinallyStatementSyntax(Me.Kind, newErrors, GetAnnotations, _finallyKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new FinallyStatementSyntax(Me.Kind, GetDiagnostics, annotations, _finallyKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitFinallyStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "Error" statement.
    ''' </summary>
    Friend NotInheritable Class ErrorStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _errorKeyword as KeywordSyntax
        Friend ReadOnly _errorNumber as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, errorKeyword As InternalSyntax.KeywordSyntax, errorNumber As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(errorKeyword)
            Me._errorKeyword = errorKeyword
            AdjustFlagsAndWidth(errorNumber)
            Me._errorNumber = errorNumber

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, errorKeyword As InternalSyntax.KeywordSyntax, errorNumber As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(errorKeyword)
            Me._errorKeyword = errorKeyword
            AdjustFlagsAndWidth(errorNumber)
            Me._errorNumber = errorNumber

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), errorKeyword As InternalSyntax.KeywordSyntax, errorNumber As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(errorKeyword)
            Me._errorKeyword = errorKeyword
            AdjustFlagsAndWidth(errorNumber)
            Me._errorNumber = errorNumber

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ErrorStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Error" keyword.
        ''' </summary>
        Friend ReadOnly Property ErrorKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._errorKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression that represents the error number.
        ''' </summary>
        Friend ReadOnly Property ErrorNumber As InternalSyntax.ExpressionSyntax
            Get
                Return Me._errorNumber
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._errorKeyword
                Case 1
                    Return Me._errorNumber
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ErrorStatementSyntax(Me.Kind, newErrors, GetAnnotations, _errorKeyword, _errorNumber)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ErrorStatementSyntax(Me.Kind, GetDiagnostics, annotations, _errorKeyword, _errorNumber)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitErrorStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an OnError Goto statement.
    ''' </summary>
    Friend NotInheritable Class OnErrorGoToStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _onKeyword as KeywordSyntax
        Friend ReadOnly _errorKeyword as KeywordSyntax
        Friend ReadOnly _goToKeyword as KeywordSyntax
        Friend ReadOnly _minus as PunctuationSyntax
        Friend ReadOnly _label as LabelSyntax

        Friend Sub New(ByVal kind As SyntaxKind, onKeyword As InternalSyntax.KeywordSyntax, errorKeyword As InternalSyntax.KeywordSyntax, goToKeyword As InternalSyntax.KeywordSyntax, minus As InternalSyntax.PunctuationSyntax, label As LabelSyntax)
            MyBase.New(kind)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(onKeyword)
            Me._onKeyword = onKeyword
            AdjustFlagsAndWidth(errorKeyword)
            Me._errorKeyword = errorKeyword
            AdjustFlagsAndWidth(goToKeyword)
            Me._goToKeyword = goToKeyword
            If minus IsNot Nothing Then
                AdjustFlagsAndWidth(minus)
                Me._minus = minus
            End If
            AdjustFlagsAndWidth(label)
            Me._label = label

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, onKeyword As InternalSyntax.KeywordSyntax, errorKeyword As InternalSyntax.KeywordSyntax, goToKeyword As InternalSyntax.KeywordSyntax, minus As InternalSyntax.PunctuationSyntax, label As LabelSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(onKeyword)
            Me._onKeyword = onKeyword
            AdjustFlagsAndWidth(errorKeyword)
            Me._errorKeyword = errorKeyword
            AdjustFlagsAndWidth(goToKeyword)
            Me._goToKeyword = goToKeyword
            If minus IsNot Nothing Then
                AdjustFlagsAndWidth(minus)
                Me._minus = minus
            End If
            AdjustFlagsAndWidth(label)
            Me._label = label

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), onKeyword As InternalSyntax.KeywordSyntax, errorKeyword As InternalSyntax.KeywordSyntax, goToKeyword As InternalSyntax.KeywordSyntax, minus As InternalSyntax.PunctuationSyntax, label As LabelSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(onKeyword)
            Me._onKeyword = onKeyword
            AdjustFlagsAndWidth(errorKeyword)
            Me._errorKeyword = errorKeyword
            AdjustFlagsAndWidth(goToKeyword)
            Me._goToKeyword = goToKeyword
            If minus IsNot Nothing Then
                AdjustFlagsAndWidth(minus)
                Me._minus = minus
            End If
            AdjustFlagsAndWidth(label)
            Me._label = label

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "On" keyword
        ''' </summary>
        Friend ReadOnly Property OnKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._onKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "Error" keyword.
        ''' </summary>
        Friend ReadOnly Property ErrorKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._errorKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "GoTo" keyword
        ''' </summary>
        Friend ReadOnly Property GoToKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._goToKeyword
            End Get
        End Property

        ''' <summary>
        ''' An optional minus for On Error Goto -1
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Minus As InternalSyntax.PunctuationSyntax
            Get
                Return Me._minus
            End Get
        End Property

        ''' <summary>
        ''' The name of the label. If the label is a line number, 0 or -1, wraps an
        ''' IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
        ''' </summary>
        Friend ReadOnly Property Label As InternalSyntax.LabelSyntax
            Get
                Return Me._label
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._onKeyword
                Case 1
                    Return Me._errorKeyword
                Case 2
                    Return Me._goToKeyword
                Case 3
                    Return Me._minus
                Case 4
                    Return Me._label
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new OnErrorGoToStatementSyntax(Me.Kind, newErrors, GetAnnotations, _onKeyword, _errorKeyword, _goToKeyword, _minus, _label)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new OnErrorGoToStatementSyntax(Me.Kind, GetDiagnostics, annotations, _onKeyword, _errorKeyword, _goToKeyword, _minus, _label)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitOnErrorGoToStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an OnError Resume Next statement.
    ''' </summary>
    Friend NotInheritable Class OnErrorResumeNextStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _onKeyword as KeywordSyntax
        Friend ReadOnly _errorKeyword as KeywordSyntax
        Friend ReadOnly _resumeKeyword as KeywordSyntax
        Friend ReadOnly _nextKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, onKeyword As InternalSyntax.KeywordSyntax, errorKeyword As InternalSyntax.KeywordSyntax, resumeKeyword As InternalSyntax.KeywordSyntax, nextKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(onKeyword)
            Me._onKeyword = onKeyword
            AdjustFlagsAndWidth(errorKeyword)
            Me._errorKeyword = errorKeyword
            AdjustFlagsAndWidth(resumeKeyword)
            Me._resumeKeyword = resumeKeyword
            AdjustFlagsAndWidth(nextKeyword)
            Me._nextKeyword = nextKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, onKeyword As InternalSyntax.KeywordSyntax, errorKeyword As InternalSyntax.KeywordSyntax, resumeKeyword As InternalSyntax.KeywordSyntax, nextKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 4
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(onKeyword)
            Me._onKeyword = onKeyword
            AdjustFlagsAndWidth(errorKeyword)
            Me._errorKeyword = errorKeyword
            AdjustFlagsAndWidth(resumeKeyword)
            Me._resumeKeyword = resumeKeyword
            AdjustFlagsAndWidth(nextKeyword)
            Me._nextKeyword = nextKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), onKeyword As InternalSyntax.KeywordSyntax, errorKeyword As InternalSyntax.KeywordSyntax, resumeKeyword As InternalSyntax.KeywordSyntax, nextKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(onKeyword)
            Me._onKeyword = onKeyword
            AdjustFlagsAndWidth(errorKeyword)
            Me._errorKeyword = errorKeyword
            AdjustFlagsAndWidth(resumeKeyword)
            Me._resumeKeyword = resumeKeyword
            AdjustFlagsAndWidth(nextKeyword)
            Me._nextKeyword = nextKeyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorResumeNextStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "On" keyword
        ''' </summary>
        Friend ReadOnly Property OnKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._onKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "Error" keyword.
        ''' </summary>
        Friend ReadOnly Property ErrorKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._errorKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "Resume" keyword.
        ''' </summary>
        Friend ReadOnly Property ResumeKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._resumeKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "Next"
        ''' </summary>
        Friend ReadOnly Property NextKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._nextKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._onKeyword
                Case 1
                    Return Me._errorKeyword
                Case 2
                    Return Me._resumeKeyword
                Case 3
                    Return Me._nextKeyword
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new OnErrorResumeNextStatementSyntax(Me.Kind, newErrors, GetAnnotations, _onKeyword, _errorKeyword, _resumeKeyword, _nextKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new OnErrorResumeNextStatementSyntax(Me.Kind, GetDiagnostics, annotations, _onKeyword, _errorKeyword, _resumeKeyword, _nextKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitOnErrorResumeNextStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "Resume" statement. The Kind property can be used to determine if
    ''' this is a "Resume", "Resume Next" or "Resume label" statement.
    ''' </summary>
    Friend NotInheritable Class ResumeStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _resumeKeyword as KeywordSyntax
        Friend ReadOnly _label as LabelSyntax

        Friend Sub New(ByVal kind As SyntaxKind, resumeKeyword As InternalSyntax.KeywordSyntax, label As LabelSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(resumeKeyword)
            Me._resumeKeyword = resumeKeyword
            If label IsNot Nothing Then
                AdjustFlagsAndWidth(label)
                Me._label = label
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, resumeKeyword As InternalSyntax.KeywordSyntax, label As LabelSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(resumeKeyword)
            Me._resumeKeyword = resumeKeyword
            If label IsNot Nothing Then
                AdjustFlagsAndWidth(label)
                Me._label = label
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), resumeKeyword As InternalSyntax.KeywordSyntax, label As LabelSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(resumeKeyword)
            Me._resumeKeyword = resumeKeyword
            If label IsNot Nothing Then
                AdjustFlagsAndWidth(label)
                Me._label = label
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Resume" keyword.
        ''' </summary>
        Friend ReadOnly Property ResumeKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._resumeKeyword
            End Get
        End Property

        ''' <summary>
        ''' The label. The value of this depends on the Kind. If Kind=Resume, returns
        ''' Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
        ''' wraps an Identifier or IntegerLiteralToken with the label or line number.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Label As InternalSyntax.LabelSyntax
            Get
                Return Me._label
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._resumeKeyword
                Case 1
                    Return Me._label
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ResumeStatementSyntax(Me.Kind, newErrors, GetAnnotations, _resumeKeyword, _label)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ResumeStatementSyntax(Me.Kind, GetDiagnostics, annotations, _resumeKeyword, _label)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitResumeStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a Select Case block, including the Select Case that begins it, the
    ''' contains Case blocks and the End Select.
    ''' </summary>
    Friend NotInheritable Class SelectBlockSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _selectStatement as SelectStatementSyntax
        Friend ReadOnly _caseBlocks as GreenNode
        Friend ReadOnly _endSelectStatement as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, selectStatement As SelectStatementSyntax, caseBlocks As GreenNode, endSelectStatement As EndBlockStatementSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(selectStatement)
            Me._selectStatement = selectStatement
            If caseBlocks IsNot Nothing Then
                AdjustFlagsAndWidth(caseBlocks)
                Me._caseBlocks = caseBlocks
            End If
            AdjustFlagsAndWidth(endSelectStatement)
            Me._endSelectStatement = endSelectStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, selectStatement As SelectStatementSyntax, caseBlocks As GreenNode, endSelectStatement As EndBlockStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(selectStatement)
            Me._selectStatement = selectStatement
            If caseBlocks IsNot Nothing Then
                AdjustFlagsAndWidth(caseBlocks)
                Me._caseBlocks = caseBlocks
            End If
            AdjustFlagsAndWidth(endSelectStatement)
            Me._endSelectStatement = endSelectStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), selectStatement As SelectStatementSyntax, caseBlocks As GreenNode, endSelectStatement As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(selectStatement)
            Me._selectStatement = selectStatement
            If caseBlocks IsNot Nothing Then
                AdjustFlagsAndWidth(caseBlocks)
                Me._caseBlocks = caseBlocks
            End If
            AdjustFlagsAndWidth(endSelectStatement)
            Me._endSelectStatement = endSelectStatement

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The Select Case statement that begins the block.
        ''' </summary>
        Friend ReadOnly Property SelectStatement As InternalSyntax.SelectStatementSyntax
            Get
                Return Me._selectStatement
            End Get
        End Property

        ''' <summary>
        ''' A list of the contained Case blocks.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property CaseBlocks As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of CaseBlockSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of CaseBlockSyntax)(Me._caseBlocks)
            End Get
        End Property

        ''' <summary>
        ''' The End Select statement that ends the block.
        ''' </summary>
        Friend ReadOnly Property EndSelectStatement As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._endSelectStatement
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._selectStatement
                Case 1
                    Return Me._caseBlocks
                Case 2
                    Return Me._endSelectStatement
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new SelectBlockSyntax(Me.Kind, newErrors, GetAnnotations, _selectStatement, _caseBlocks, _endSelectStatement)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new SelectBlockSyntax(Me.Kind, GetDiagnostics, annotations, _selectStatement, _caseBlocks, _endSelectStatement)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitSelectBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a Select Case statement. This statement always occurs as the Begin
    ''' of a SelectBlock.
    ''' </summary>
    Friend NotInheritable Class SelectStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _selectKeyword as KeywordSyntax
        Friend ReadOnly _caseKeyword as KeywordSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, selectKeyword As InternalSyntax.KeywordSyntax, caseKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(selectKeyword)
            Me._selectKeyword = selectKeyword
            If caseKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(caseKeyword)
                Me._caseKeyword = caseKeyword
            End If
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, selectKeyword As InternalSyntax.KeywordSyntax, caseKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(selectKeyword)
            Me._selectKeyword = selectKeyword
            If caseKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(caseKeyword)
                Me._caseKeyword = caseKeyword
            End If
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), selectKeyword As InternalSyntax.KeywordSyntax, caseKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(selectKeyword)
            Me._selectKeyword = selectKeyword
            If caseKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(caseKeyword)
                Me._caseKeyword = caseKeyword
            End If
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Select" keyword.
        ''' </summary>
        Friend ReadOnly Property SelectKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._selectKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "Case" keyword, if present.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property CaseKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._caseKeyword
            End Get
        End Property

        ''' <summary>
        ''' The value that branching is based on.
        ''' </summary>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._selectKeyword
                Case 1
                    Return Me._caseKeyword
                Case 2
                    Return Me._expression
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new SelectStatementSyntax(Me.Kind, newErrors, GetAnnotations, _selectKeyword, _caseKeyword, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new SelectStatementSyntax(Me.Kind, GetDiagnostics, annotations, _selectKeyword, _caseKeyword, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitSelectStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a case statement and its subsequent block.
    ''' </summary>
    Friend NotInheritable Class CaseBlockSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _caseStatement as CaseStatementSyntax
        Friend ReadOnly _statements as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, caseStatement As CaseStatementSyntax, statements As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(caseStatement)
            Me._caseStatement = caseStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, caseStatement As CaseStatementSyntax, statements As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(caseStatement)
            Me._caseStatement = caseStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), caseStatement As CaseStatementSyntax, statements As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(caseStatement)
            Me._caseStatement = caseStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The statement that begins the case block.
        ''' </summary>
        Friend ReadOnly Property CaseStatement As InternalSyntax.CaseStatementSyntax
            Get
                Return Me._caseStatement
            End Get
        End Property

        ''' <summary>
        ''' The statements contained in the case block. This might be an empty list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)(Me._statements)
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._caseStatement
                Case 1
                    Return Me._statements
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new CaseBlockSyntax(Me.Kind, newErrors, GetAnnotations, _caseStatement, _statements)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new CaseBlockSyntax(Me.Kind, GetDiagnostics, annotations, _caseStatement, _statements)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitCaseBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a Case or Case Else statement. This statement is always the Begin of
    ''' a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
    ''' Kind=Case.
    ''' </summary>
    Friend NotInheritable Class CaseStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _caseKeyword as KeywordSyntax
        Friend ReadOnly _cases as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, caseKeyword As InternalSyntax.KeywordSyntax, cases As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(caseKeyword)
            Me._caseKeyword = caseKeyword
            If cases IsNot Nothing Then
                AdjustFlagsAndWidth(cases)
                Me._cases = cases
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, caseKeyword As InternalSyntax.KeywordSyntax, cases As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(caseKeyword)
            Me._caseKeyword = caseKeyword
            If cases IsNot Nothing Then
                AdjustFlagsAndWidth(cases)
                Me._cases = cases
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), caseKeyword As InternalSyntax.KeywordSyntax, cases As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(caseKeyword)
            Me._caseKeyword = caseKeyword
            If cases IsNot Nothing Then
                AdjustFlagsAndWidth(cases)
                Me._cases = cases
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Case" keyword
        ''' </summary>
        Friend ReadOnly Property CaseKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._caseKeyword
            End Get
        End Property

        ''' <summary>
        ''' A list of clauses associated with this Case. If Kind=CaseElse, then this list
        ''' has exactly one child, which is a ElseCaseClause.
        ''' </summary>
        Friend ReadOnly Property Cases As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of CaseClauseSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of CaseClauseSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of CaseClauseSyntax)(Me._cases))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._caseKeyword
                Case 1
                    Return Me._cases
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new CaseStatementSyntax(Me.Kind, newErrors, GetAnnotations, _caseKeyword, _cases)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new CaseStatementSyntax(Me.Kind, GetDiagnostics, annotations, _caseKeyword, _cases)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitCaseStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a single clause in a case statement. An abstract node that is the
    ''' parent of different kinds of Case clauses.
    ''' </summary>
    Friend MustInherit Class CaseClauseSyntax
        Inherits VisualBasicSyntaxNode


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

    End Class

    ''' <summary>
    ''' The "Else" part in a Case Else statement.
    ''' </summary>
    Friend NotInheritable Class ElseCaseClauseSyntax
        Inherits CaseClauseSyntax

        Friend ReadOnly _elseKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, elseKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(elseKeyword)
            Me._elseKeyword = elseKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, elseKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(elseKeyword)
            Me._elseKeyword = elseKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), elseKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(elseKeyword)
            Me._elseKeyword = elseKeyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseCaseClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Else" keyword.
        ''' </summary>
        Friend ReadOnly Property ElseKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._elseKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._elseKeyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ElseCaseClauseSyntax(Me.Kind, newErrors, GetAnnotations, _elseKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ElseCaseClauseSyntax(Me.Kind, GetDiagnostics, annotations, _elseKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitElseCaseClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a single value in a Case.
    ''' </summary>
    Friend NotInheritable Class SimpleCaseClauseSyntax
        Inherits CaseClauseSyntax

        Friend ReadOnly _value as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, value As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(value)
            Me._value = value

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, value As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(value)
            Me._value = value

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), value As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(value)
            Me._value = value

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleCaseClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The expression that denotes the value being tested against.
        ''' </summary>
        Friend ReadOnly Property Value As InternalSyntax.ExpressionSyntax
            Get
                Return Me._value
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._value
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new SimpleCaseClauseSyntax(Me.Kind, newErrors, GetAnnotations, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new SimpleCaseClauseSyntax(Me.Kind, GetDiagnostics, annotations, _value)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitSimpleCaseClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a range "expression To expression" in a Case.
    ''' </summary>
    Friend NotInheritable Class RangeCaseClauseSyntax
        Inherits CaseClauseSyntax

        Friend ReadOnly _lowerBound as ExpressionSyntax
        Friend ReadOnly _toKeyword as KeywordSyntax
        Friend ReadOnly _upperBound as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lowerBound As ExpressionSyntax, toKeyword As InternalSyntax.KeywordSyntax, upperBound As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(lowerBound)
            Me._lowerBound = lowerBound
            AdjustFlagsAndWidth(toKeyword)
            Me._toKeyword = toKeyword
            AdjustFlagsAndWidth(upperBound)
            Me._upperBound = upperBound

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, lowerBound As ExpressionSyntax, toKeyword As InternalSyntax.KeywordSyntax, upperBound As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(lowerBound)
            Me._lowerBound = lowerBound
            AdjustFlagsAndWidth(toKeyword)
            Me._toKeyword = toKeyword
            AdjustFlagsAndWidth(upperBound)
            Me._upperBound = upperBound

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lowerBound As ExpressionSyntax, toKeyword As InternalSyntax.KeywordSyntax, upperBound As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(lowerBound)
            Me._lowerBound = lowerBound
            AdjustFlagsAndWidth(toKeyword)
            Me._toKeyword = toKeyword
            AdjustFlagsAndWidth(upperBound)
            Me._upperBound = upperBound

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeCaseClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The lower bound of the range.
        ''' </summary>
        Friend ReadOnly Property LowerBound As InternalSyntax.ExpressionSyntax
            Get
                Return Me._lowerBound
            End Get
        End Property

        ''' <summary>
        ''' The "To" keyword
        ''' </summary>
        Friend ReadOnly Property ToKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._toKeyword
            End Get
        End Property

        ''' <summary>
        ''' The upper bound of the range.
        ''' </summary>
        Friend ReadOnly Property UpperBound As InternalSyntax.ExpressionSyntax
            Get
                Return Me._upperBound
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._lowerBound
                Case 1
                    Return Me._toKeyword
                Case 2
                    Return Me._upperBound
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new RangeCaseClauseSyntax(Me.Kind, newErrors, GetAnnotations, _lowerBound, _toKeyword, _upperBound)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new RangeCaseClauseSyntax(Me.Kind, GetDiagnostics, annotations, _lowerBound, _toKeyword, _upperBound)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitRangeCaseClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a relation clause in a Case statement, such as "Is &gt; expression".
    ''' </summary>
    Friend NotInheritable Class RelationalCaseClauseSyntax
        Inherits CaseClauseSyntax

        Friend ReadOnly _isKeyword as KeywordSyntax
        Friend ReadOnly _operatorToken as PunctuationSyntax
        Friend ReadOnly _value as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, isKeyword As InternalSyntax.KeywordSyntax, operatorToken As InternalSyntax.PunctuationSyntax, value As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            If isKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(isKeyword)
                Me._isKeyword = isKeyword
            End If
            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken
            AdjustFlagsAndWidth(value)
            Me._value = value

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, isKeyword As InternalSyntax.KeywordSyntax, operatorToken As InternalSyntax.PunctuationSyntax, value As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            If isKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(isKeyword)
                Me._isKeyword = isKeyword
            End If
            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken
            AdjustFlagsAndWidth(value)
            Me._value = value

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), isKeyword As InternalSyntax.KeywordSyntax, operatorToken As InternalSyntax.PunctuationSyntax, value As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            If isKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(isKeyword)
                Me._isKeyword = isKeyword
            End If
            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken
            AdjustFlagsAndWidth(value)
            Me._value = value

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Is" keyword, if present.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property IsKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._isKeyword
            End Get
        End Property

        ''' <summary>
        ''' The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
        ''' "&gt;=".
        ''' </summary>
        Friend ReadOnly Property OperatorToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._operatorToken
            End Get
        End Property

        ''' <summary>
        ''' The expression that denotes the value being tested against.
        ''' </summary>
        Friend ReadOnly Property Value As InternalSyntax.ExpressionSyntax
            Get
                Return Me._value
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._isKeyword
                Case 1
                    Return Me._operatorToken
                Case 2
                    Return Me._value
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new RelationalCaseClauseSyntax(Me.Kind, newErrors, GetAnnotations, _isKeyword, _operatorToken, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new RelationalCaseClauseSyntax(Me.Kind, GetDiagnostics, annotations, _isKeyword, _operatorToken, _value)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitRelationalCaseClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "SyncLock" statement. This statement always occurs as the Begin
    ''' of a SyncLockBlock.
    ''' </summary>
    Friend NotInheritable Class SyncLockStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _syncLockKeyword as KeywordSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, syncLockKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(syncLockKeyword)
            Me._syncLockKeyword = syncLockKeyword
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, syncLockKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(syncLockKeyword)
            Me._syncLockKeyword = syncLockKeyword
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), syncLockKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(syncLockKeyword)
            Me._syncLockKeyword = syncLockKeyword
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "SyncLock" keyword.
        ''' </summary>
        Friend ReadOnly Property SyncLockKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._syncLockKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression being synchronized on.
        ''' </summary>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._syncLockKeyword
                Case 1
                    Return Me._expression
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new SyncLockStatementSyntax(Me.Kind, newErrors, GetAnnotations, _syncLockKeyword, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new SyncLockStatementSyntax(Me.Kind, GetDiagnostics, annotations, _syncLockKeyword, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitSyncLockStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a Do-Loop block. The Kind property can be used to determine if this
    ''' is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
    ''' </summary>
    Friend NotInheritable Class DoLoopBlockSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _doStatement as DoStatementSyntax
        Friend ReadOnly _statements as GreenNode
        Friend ReadOnly _loopStatement as LoopStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, doStatement As DoStatementSyntax, statements As GreenNode, loopStatement As LoopStatementSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(doStatement)
            Me._doStatement = doStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            AdjustFlagsAndWidth(loopStatement)
            Me._loopStatement = loopStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, doStatement As DoStatementSyntax, statements As GreenNode, loopStatement As LoopStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(doStatement)
            Me._doStatement = doStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            AdjustFlagsAndWidth(loopStatement)
            Me._loopStatement = loopStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), doStatement As DoStatementSyntax, statements As GreenNode, loopStatement As LoopStatementSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(doStatement)
            Me._doStatement = doStatement
            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            AdjustFlagsAndWidth(loopStatement)
            Me._loopStatement = loopStatement

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The Do statement that begins the block.
        ''' </summary>
        Friend ReadOnly Property DoStatement As InternalSyntax.DoStatementSyntax
            Get
                Return Me._doStatement
            End Get
        End Property

        ''' <summary>
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)(Me._statements)
            End Get
        End Property

        ''' <summary>
        ''' The Loop statement that ends the block.
        ''' </summary>
        Friend ReadOnly Property LoopStatement As InternalSyntax.LoopStatementSyntax
            Get
                Return Me._loopStatement
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._doStatement
                Case 1
                    Return Me._statements
                Case 2
                    Return Me._loopStatement
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new DoLoopBlockSyntax(Me.Kind, newErrors, GetAnnotations, _doStatement, _statements, _loopStatement)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new DoLoopBlockSyntax(Me.Kind, GetDiagnostics, annotations, _doStatement, _statements, _loopStatement)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitDoLoopBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' The Do statement that begins a Do-Loop block.
    ''' </summary>
    Friend NotInheritable Class DoStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _doKeyword as KeywordSyntax
        Friend ReadOnly _whileOrUntilClause as WhileOrUntilClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, doKeyword As InternalSyntax.KeywordSyntax, whileOrUntilClause As WhileOrUntilClauseSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(doKeyword)
            Me._doKeyword = doKeyword
            If whileOrUntilClause IsNot Nothing Then
                AdjustFlagsAndWidth(whileOrUntilClause)
                Me._whileOrUntilClause = whileOrUntilClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, doKeyword As InternalSyntax.KeywordSyntax, whileOrUntilClause As WhileOrUntilClauseSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(doKeyword)
            Me._doKeyword = doKeyword
            If whileOrUntilClause IsNot Nothing Then
                AdjustFlagsAndWidth(whileOrUntilClause)
                Me._whileOrUntilClause = whileOrUntilClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), doKeyword As InternalSyntax.KeywordSyntax, whileOrUntilClause As WhileOrUntilClauseSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(doKeyword)
            Me._doKeyword = doKeyword
            If whileOrUntilClause IsNot Nothing Then
                AdjustFlagsAndWidth(whileOrUntilClause)
                Me._whileOrUntilClause = whileOrUntilClause
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Do" keyword.
        ''' </summary>
        Friend ReadOnly Property DoKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._doKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "While expression" or "Until expression" clause of the Do statement, if
        ''' present.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property WhileOrUntilClause As InternalSyntax.WhileOrUntilClauseSyntax
            Get
                Return Me._whileOrUntilClause
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._doKeyword
                Case 1
                    Return Me._whileOrUntilClause
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new DoStatementSyntax(Me.Kind, newErrors, GetAnnotations, _doKeyword, _whileOrUntilClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new DoStatementSyntax(Me.Kind, GetDiagnostics, annotations, _doKeyword, _whileOrUntilClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitDoStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' The Loop statement that begins a Do-Loop block.
    ''' </summary>
    Friend NotInheritable Class LoopStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _loopKeyword as KeywordSyntax
        Friend ReadOnly _whileOrUntilClause as WhileOrUntilClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, loopKeyword As InternalSyntax.KeywordSyntax, whileOrUntilClause As WhileOrUntilClauseSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(loopKeyword)
            Me._loopKeyword = loopKeyword
            If whileOrUntilClause IsNot Nothing Then
                AdjustFlagsAndWidth(whileOrUntilClause)
                Me._whileOrUntilClause = whileOrUntilClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, loopKeyword As InternalSyntax.KeywordSyntax, whileOrUntilClause As WhileOrUntilClauseSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(loopKeyword)
            Me._loopKeyword = loopKeyword
            If whileOrUntilClause IsNot Nothing Then
                AdjustFlagsAndWidth(whileOrUntilClause)
                Me._whileOrUntilClause = whileOrUntilClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), loopKeyword As InternalSyntax.KeywordSyntax, whileOrUntilClause As WhileOrUntilClauseSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(loopKeyword)
            Me._loopKeyword = loopKeyword
            If whileOrUntilClause IsNot Nothing Then
                AdjustFlagsAndWidth(whileOrUntilClause)
                Me._whileOrUntilClause = whileOrUntilClause
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Loop" keyword.
        ''' </summary>
        Friend ReadOnly Property LoopKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._loopKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "While expression" or "Until expression" clause of the Loop statement, if
        ''' present.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property WhileOrUntilClause As InternalSyntax.WhileOrUntilClauseSyntax
            Get
                Return Me._whileOrUntilClause
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._loopKeyword
                Case 1
                    Return Me._whileOrUntilClause
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new LoopStatementSyntax(Me.Kind, newErrors, GetAnnotations, _loopKeyword, _whileOrUntilClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new LoopStatementSyntax(Me.Kind, GetDiagnostics, annotations, _loopKeyword, _whileOrUntilClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitLoopStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "While expression" or "Until expression" in a Do or Loop
    ''' statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
    ''' indicate which kind of clause.
    ''' </summary>
    Friend NotInheritable Class WhileOrUntilClauseSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _whileOrUntilKeyword as KeywordSyntax
        Friend ReadOnly _condition as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, whileOrUntilKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(whileOrUntilKeyword)
            Me._whileOrUntilKeyword = whileOrUntilKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, whileOrUntilKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(whileOrUntilKeyword)
            Me._whileOrUntilKeyword = whileOrUntilKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), whileOrUntilKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(whileOrUntilKeyword)
            Me._whileOrUntilKeyword = whileOrUntilKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "While" or "Until" keyword.
        ''' </summary>
        Friend ReadOnly Property WhileOrUntilKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._whileOrUntilKeyword
            End Get
        End Property

        ''' <summary>
        ''' The boolean expression after the While or Until.
        ''' </summary>
        Friend ReadOnly Property Condition As InternalSyntax.ExpressionSyntax
            Get
                Return Me._condition
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._whileOrUntilKeyword
                Case 1
                    Return Me._condition
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new WhileOrUntilClauseSyntax(Me.Kind, newErrors, GetAnnotations, _whileOrUntilKeyword, _condition)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new WhileOrUntilClauseSyntax(Me.Kind, GetDiagnostics, annotations, _whileOrUntilKeyword, _condition)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitWhileOrUntilClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' The While statement that begins a While...End While block. This statement
    ''' always occurs as the Begin of a WhileBlock.
    ''' </summary>
    Friend NotInheritable Class WhileStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _whileKeyword as KeywordSyntax
        Friend ReadOnly _condition as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, whileKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(whileKeyword)
            Me._whileKeyword = whileKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, whileKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(whileKeyword)
            Me._whileKeyword = whileKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), whileKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(whileKeyword)
            Me._whileKeyword = whileKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "While" keyword.
        ''' </summary>
        Friend ReadOnly Property WhileKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._whileKeyword
            End Get
        End Property

        ''' <summary>
        ''' The boolean expression that controls the While loop.
        ''' </summary>
        Friend ReadOnly Property Condition As InternalSyntax.ExpressionSyntax
            Get
                Return Me._condition
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._whileKeyword
                Case 1
                    Return Me._condition
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new WhileStatementSyntax(Me.Kind, newErrors, GetAnnotations, _whileKeyword, _condition)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new WhileStatementSyntax(Me.Kind, GetDiagnostics, annotations, _whileKeyword, _condition)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitWhileStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a For or For Each block.
    ''' </summary>
    Friend MustInherit Class ForOrForEachBlockSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _statements as GreenNode
        Friend ReadOnly _nextStatement as NextStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, statements As GreenNode, nextStatement As NextStatementSyntax)
            MyBase.New(kind)

            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            If nextStatement IsNot Nothing Then
                AdjustFlagsAndWidth(nextStatement)
                Me._nextStatement = nextStatement
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, statements As GreenNode, nextStatement As NextStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)

            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            If nextStatement IsNot Nothing Then
                AdjustFlagsAndWidth(nextStatement)
                Me._nextStatement = nextStatement
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), statements As GreenNode, nextStatement As NextStatementSyntax)
            MyBase.New(kind, errors, annotations)

            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            If nextStatement IsNot Nothing Then
                AdjustFlagsAndWidth(nextStatement)
                Me._nextStatement = nextStatement
            End If

        End Sub

        ''' <summary>
        ''' The statements contained in the For or For Each loop. This might be an empty
        ''' list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)(Me._statements)
            End Get
        End Property

        ''' <summary>
        ''' The Next statement that ends the block. If two For or For Each statements are
        ''' ended by a single Next statement, the inner For will not have a Next statement.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property NextStatement As InternalSyntax.NextStatementSyntax
            Get
                Return Me._nextStatement
            End Get
        End Property

    End Class

    ''' <summary>
    ''' Represents a For block, including the introducing statement, the body and the
    ''' "Next" (which can be omitted if a containing For has a Next with multiple
    ''' variables).
    ''' </summary>
    Friend NotInheritable Class ForBlockSyntax
        Inherits ForOrForEachBlockSyntax

        Friend ReadOnly _forStatement as ForStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, forStatement As ForStatementSyntax, statements As GreenNode, nextStatement As NextStatementSyntax)
            MyBase.New(kind, statements, nextStatement)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(forStatement)
            Me._forStatement = forStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, forStatement As ForStatementSyntax, statements As GreenNode, nextStatement As NextStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, statements, nextStatement)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(forStatement)
            Me._forStatement = forStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), forStatement As ForStatementSyntax, statements As GreenNode, nextStatement As NextStatementSyntax)
            MyBase.New(kind, errors, annotations, statements, nextStatement)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(forStatement)
            Me._forStatement = forStatement

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ForBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The For statement that begins the block.
        ''' </summary>
        Friend ReadOnly Property ForStatement As InternalSyntax.ForStatementSyntax
            Get
                Return Me._forStatement
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._forStatement
                Case 1
                    Return Me._statements
                Case 2
                    Return Me._nextStatement
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ForBlockSyntax(Me.Kind, newErrors, GetAnnotations, _forStatement, _statements, _nextStatement)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ForBlockSyntax(Me.Kind, GetDiagnostics, annotations, _forStatement, _statements, _nextStatement)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitForBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a For Each block, including the introducing statement, the body and
    ''' the "Next" (which can be omitted if a containing For has a Next with multiple
    ''' variables).
    ''' </summary>
    Friend NotInheritable Class ForEachBlockSyntax
        Inherits ForOrForEachBlockSyntax

        Friend ReadOnly _forEachStatement as ForEachStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, forEachStatement As ForEachStatementSyntax, statements As GreenNode, nextStatement As NextStatementSyntax)
            MyBase.New(kind, statements, nextStatement)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(forEachStatement)
            Me._forEachStatement = forEachStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, forEachStatement As ForEachStatementSyntax, statements As GreenNode, nextStatement As NextStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, statements, nextStatement)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(forEachStatement)
            Me._forEachStatement = forEachStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), forEachStatement As ForEachStatementSyntax, statements As GreenNode, nextStatement As NextStatementSyntax)
            MyBase.New(kind, errors, annotations, statements, nextStatement)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(forEachStatement)
            Me._forEachStatement = forEachStatement

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The For Each statement that begins the block.
        ''' </summary>
        Friend ReadOnly Property ForEachStatement As InternalSyntax.ForEachStatementSyntax
            Get
                Return Me._forEachStatement
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._forEachStatement
                Case 1
                    Return Me._statements
                Case 2
                    Return Me._nextStatement
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ForEachBlockSyntax(Me.Kind, newErrors, GetAnnotations, _forEachStatement, _statements, _nextStatement)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ForEachBlockSyntax(Me.Kind, GetDiagnostics, annotations, _forEachStatement, _statements, _nextStatement)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitForEachBlock(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a For or For Each statement.
    ''' </summary>
    Friend MustInherit Class ForOrForEachStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _forKeyword as KeywordSyntax
        Friend ReadOnly _controlVariable as VisualBasicSyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, forKeyword As InternalSyntax.KeywordSyntax, controlVariable As VisualBasicSyntaxNode)
            MyBase.New(kind)

            AdjustFlagsAndWidth(forKeyword)
            Me._forKeyword = forKeyword
            AdjustFlagsAndWidth(controlVariable)
            Me._controlVariable = controlVariable

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, forKeyword As InternalSyntax.KeywordSyntax, controlVariable As VisualBasicSyntaxNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(forKeyword)
            Me._forKeyword = forKeyword
            AdjustFlagsAndWidth(controlVariable)
            Me._controlVariable = controlVariable

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), forKeyword As InternalSyntax.KeywordSyntax, controlVariable As VisualBasicSyntaxNode)
            MyBase.New(kind, errors, annotations)

            AdjustFlagsAndWidth(forKeyword)
            Me._forKeyword = forKeyword
            AdjustFlagsAndWidth(controlVariable)
            Me._controlVariable = controlVariable

        End Sub

        ''' <summary>
        ''' The "For" keyword.
        ''' </summary>
        Friend ReadOnly Property ForKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._forKeyword
            End Get
        End Property

        ''' <summary>
        ''' If the For or For Each statement is of a form that does not declare a new loop
        ''' control variable, this is the expression that denotes the loop control
        ''' variable. If this loop is of a form that does declare a new control variable,
        ''' this is a VariableDeclarator that has the variable being declared.
        ''' </summary>
        Friend ReadOnly Property ControlVariable As InternalSyntax.VisualBasicSyntaxNode
            Get
                Return Me._controlVariable
            End Get
        End Property

    End Class

    ''' <summary>
    ''' The For statement that begins a For-Next block. This statement always occurs as
    ''' the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
    ''' corresponding Next statement. However, multiple nested For statements are ended
    ''' by a single Next statement with multiple variables, then the inner For
    ''' statements will have End set to Nothing, and the Next statement is the End of
    ''' the outermost For statement that is being ended.
    ''' </summary>
    Friend NotInheritable Class ForStatementSyntax
        Inherits ForOrForEachStatementSyntax

        Friend ReadOnly _equalsToken as PunctuationSyntax
        Friend ReadOnly _fromValue as ExpressionSyntax
        Friend ReadOnly _toKeyword as KeywordSyntax
        Friend ReadOnly _toValue as ExpressionSyntax
        Friend ReadOnly _stepClause as ForStepClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, forKeyword As InternalSyntax.KeywordSyntax, controlVariable As VisualBasicSyntaxNode, equalsToken As InternalSyntax.PunctuationSyntax, fromValue As ExpressionSyntax, toKeyword As InternalSyntax.KeywordSyntax, toValue As ExpressionSyntax, stepClause As ForStepClauseSyntax)
            MyBase.New(kind, forKeyword, controlVariable)
            Me.SlotCount = 7

            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken
            AdjustFlagsAndWidth(fromValue)
            Me._fromValue = fromValue
            AdjustFlagsAndWidth(toKeyword)
            Me._toKeyword = toKeyword
            AdjustFlagsAndWidth(toValue)
            Me._toValue = toValue
            If stepClause IsNot Nothing Then
                AdjustFlagsAndWidth(stepClause)
                Me._stepClause = stepClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, forKeyword As InternalSyntax.KeywordSyntax, controlVariable As VisualBasicSyntaxNode, equalsToken As InternalSyntax.PunctuationSyntax, fromValue As ExpressionSyntax, toKeyword As InternalSyntax.KeywordSyntax, toValue As ExpressionSyntax, stepClause As ForStepClauseSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, forKeyword, controlVariable)
            Me.SlotCount = 7
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken
            AdjustFlagsAndWidth(fromValue)
            Me._fromValue = fromValue
            AdjustFlagsAndWidth(toKeyword)
            Me._toKeyword = toKeyword
            AdjustFlagsAndWidth(toValue)
            Me._toValue = toValue
            If stepClause IsNot Nothing Then
                AdjustFlagsAndWidth(stepClause)
                Me._stepClause = stepClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), forKeyword As InternalSyntax.KeywordSyntax, controlVariable As VisualBasicSyntaxNode, equalsToken As InternalSyntax.PunctuationSyntax, fromValue As ExpressionSyntax, toKeyword As InternalSyntax.KeywordSyntax, toValue As ExpressionSyntax, stepClause As ForStepClauseSyntax)
            MyBase.New(kind, errors, annotations, forKeyword, controlVariable)
            Me.SlotCount = 7

            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken
            AdjustFlagsAndWidth(fromValue)
            Me._fromValue = fromValue
            AdjustFlagsAndWidth(toKeyword)
            Me._toKeyword = toKeyword
            AdjustFlagsAndWidth(toValue)
            Me._toValue = toValue
            If stepClause IsNot Nothing Then
                AdjustFlagsAndWidth(stepClause)
                Me._stepClause = stepClause
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "=" token.
        ''' </summary>
        Friend ReadOnly Property EqualsToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._equalsToken
            End Get
        End Property

        ''' <summary>
        ''' The expression denoting the initial value of the iteration.
        ''' </summary>
        Friend ReadOnly Property FromValue As InternalSyntax.ExpressionSyntax
            Get
                Return Me._fromValue
            End Get
        End Property

        ''' <summary>
        ''' The "To" keyword.
        ''' </summary>
        Friend ReadOnly Property ToKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._toKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression denoting the final value of the iteration.
        ''' </summary>
        Friend ReadOnly Property ToValue As InternalSyntax.ExpressionSyntax
            Get
                Return Me._toValue
            End Get
        End Property

        ''' <summary>
        ''' The optional Step clause.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property StepClause As InternalSyntax.ForStepClauseSyntax
            Get
                Return Me._stepClause
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._forKeyword
                Case 1
                    Return Me._controlVariable
                Case 2
                    Return Me._equalsToken
                Case 3
                    Return Me._fromValue
                Case 4
                    Return Me._toKeyword
                Case 5
                    Return Me._toValue
                Case 6
                    Return Me._stepClause
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ForStatementSyntax(Me.Kind, newErrors, GetAnnotations, _forKeyword, _controlVariable, _equalsToken, _fromValue, _toKeyword, _toValue, _stepClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ForStatementSyntax(Me.Kind, GetDiagnostics, annotations, _forKeyword, _controlVariable, _equalsToken, _fromValue, _toKeyword, _toValue, _stepClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitForStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' The Step clause in a For Statement.
    ''' </summary>
    Friend NotInheritable Class ForStepClauseSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _stepKeyword as KeywordSyntax
        Friend ReadOnly _stepValue as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, stepKeyword As InternalSyntax.KeywordSyntax, stepValue As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(stepKeyword)
            Me._stepKeyword = stepKeyword
            AdjustFlagsAndWidth(stepValue)
            Me._stepValue = stepValue

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, stepKeyword As InternalSyntax.KeywordSyntax, stepValue As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(stepKeyword)
            Me._stepKeyword = stepKeyword
            AdjustFlagsAndWidth(stepValue)
            Me._stepValue = stepValue

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), stepKeyword As InternalSyntax.KeywordSyntax, stepValue As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(stepKeyword)
            Me._stepKeyword = stepKeyword
            AdjustFlagsAndWidth(stepValue)
            Me._stepValue = stepValue

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Step" keyword.
        ''' </summary>
        Friend ReadOnly Property StepKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._stepKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression denoting the step increment.
        ''' </summary>
        Friend ReadOnly Property StepValue As InternalSyntax.ExpressionSyntax
            Get
                Return Me._stepValue
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._stepKeyword
                Case 1
                    Return Me._stepValue
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ForStepClauseSyntax(Me.Kind, newErrors, GetAnnotations, _stepKeyword, _stepValue)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ForStepClauseSyntax(Me.Kind, GetDiagnostics, annotations, _stepKeyword, _stepValue)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitForStepClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' The For Each statement that begins a For Each-Next block. This statement always
    ''' occurs as the Begin of a ForBlock, and the body of the For Each-Next is the
    ''' Body of that ForBlock. Most of the time, the End of that ForBlock is the
    ''' corresponding Next statement. However, multiple nested For statements are ended
    ''' by a single Next statement with multiple variables, then the inner For
    ''' statements will have End set to Nothing, and the Next statement is the End of
    ''' the outermost For statement that is being ended.
    ''' </summary>
    Friend NotInheritable Class ForEachStatementSyntax
        Inherits ForOrForEachStatementSyntax

        Friend ReadOnly _eachKeyword as KeywordSyntax
        Friend ReadOnly _inKeyword as KeywordSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, forKeyword As InternalSyntax.KeywordSyntax, eachKeyword As InternalSyntax.KeywordSyntax, controlVariable As VisualBasicSyntaxNode, inKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, forKeyword, controlVariable)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(eachKeyword)
            Me._eachKeyword = eachKeyword
            AdjustFlagsAndWidth(inKeyword)
            Me._inKeyword = inKeyword
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, forKeyword As InternalSyntax.KeywordSyntax, eachKeyword As InternalSyntax.KeywordSyntax, controlVariable As VisualBasicSyntaxNode, inKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, forKeyword, controlVariable)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(eachKeyword)
            Me._eachKeyword = eachKeyword
            AdjustFlagsAndWidth(inKeyword)
            Me._inKeyword = inKeyword
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), forKeyword As InternalSyntax.KeywordSyntax, eachKeyword As InternalSyntax.KeywordSyntax, controlVariable As VisualBasicSyntaxNode, inKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations, forKeyword, controlVariable)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(eachKeyword)
            Me._eachKeyword = eachKeyword
            AdjustFlagsAndWidth(inKeyword)
            Me._inKeyword = inKeyword
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Each" keyword.
        ''' </summary>
        Friend ReadOnly Property EachKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._eachKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "In" keyword.
        ''' </summary>
        Friend ReadOnly Property InKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._inKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression denoting the collection to iterate over.
        ''' </summary>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._forKeyword
                Case 1
                    Return Me._eachKeyword
                Case 2
                    Return Me._controlVariable
                Case 3
                    Return Me._inKeyword
                Case 4
                    Return Me._expression
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ForEachStatementSyntax(Me.Kind, newErrors, GetAnnotations, _forKeyword, _eachKeyword, _controlVariable, _inKeyword, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ForEachStatementSyntax(Me.Kind, GetDiagnostics, annotations, _forKeyword, _eachKeyword, _controlVariable, _inKeyword, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitForEachStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' The Next statement that ends a For-Next or For Each-Next block. This statement
    ''' always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
    ''' and the body of the For-Next is the Body of that ForBlock. The Begin of that
    ''' ForBlock has the corresponding For or For Each statement.
    ''' </summary>
    Friend NotInheritable Class NextStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _nextKeyword as KeywordSyntax
        Friend ReadOnly _controlVariables as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, nextKeyword As InternalSyntax.KeywordSyntax, controlVariables As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(nextKeyword)
            Me._nextKeyword = nextKeyword
            If controlVariables IsNot Nothing Then
                AdjustFlagsAndWidth(controlVariables)
                Me._controlVariables = controlVariables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, nextKeyword As InternalSyntax.KeywordSyntax, controlVariables As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(nextKeyword)
            Me._nextKeyword = nextKeyword
            If controlVariables IsNot Nothing Then
                AdjustFlagsAndWidth(controlVariables)
                Me._controlVariables = controlVariables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), nextKeyword As InternalSyntax.KeywordSyntax, controlVariables As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(nextKeyword)
            Me._nextKeyword = nextKeyword
            If controlVariables IsNot Nothing Then
                AdjustFlagsAndWidth(controlVariables)
                Me._controlVariables = controlVariables
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.NextStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Next" keyword.
        ''' </summary>
        Friend ReadOnly Property NextKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._nextKeyword
            End Get
        End Property

        ''' <summary>
        ''' The variables in the Next statement, if present
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property ControlVariables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ExpressionSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ExpressionSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of ExpressionSyntax)(Me._controlVariables))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._nextKeyword
                Case 1
                    Return Me._controlVariables
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new NextStatementSyntax(Me.Kind, newErrors, GetAnnotations, _nextKeyword, _controlVariables)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new NextStatementSyntax(Me.Kind, GetDiagnostics, annotations, _nextKeyword, _controlVariables)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitNextStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' The Using statement that begins a Using block. This statement always occurs as
    ''' the Begin of a UsingBlock, and the body of the Using is the Body of that
    ''' UsingBlock.
    ''' </summary>
    Friend NotInheritable Class UsingStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _usingKeyword as KeywordSyntax
        Friend ReadOnly _expression as ExpressionSyntax
        Friend ReadOnly _variables as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, usingKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax, variables As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(usingKeyword)
            Me._usingKeyword = usingKeyword
            If expression IsNot Nothing Then
                AdjustFlagsAndWidth(expression)
                Me._expression = expression
            End If
            If variables IsNot Nothing Then
                AdjustFlagsAndWidth(variables)
                Me._variables = variables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, usingKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax, variables As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(usingKeyword)
            Me._usingKeyword = usingKeyword
            If expression IsNot Nothing Then
                AdjustFlagsAndWidth(expression)
                Me._expression = expression
            End If
            If variables IsNot Nothing Then
                AdjustFlagsAndWidth(variables)
                Me._variables = variables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), usingKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax, variables As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(usingKeyword)
            Me._usingKeyword = usingKeyword
            If expression IsNot Nothing Then
                AdjustFlagsAndWidth(expression)
                Me._expression = expression
            End If
            If variables IsNot Nothing Then
                AdjustFlagsAndWidth(variables)
                Me._variables = variables
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Using" keyword.
        ''' </summary>
        Friend ReadOnly Property UsingKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._usingKeyword
            End Get
        End Property

        ''' <summary>
        ''' If the Using statement is of a form that does not declare a new variable, this
        ''' is the expression used in the using. Otherwise, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        ''' <summary>
        ''' If the Using statement is of a form that declares one or more new variables,
        ''' this is the list of variable declarations. Otherwise, Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Variables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of VariableDeclaratorSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of VariableDeclaratorSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of VariableDeclaratorSyntax)(Me._variables))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._usingKeyword
                Case 1
                    Return Me._expression
                Case 2
                    Return Me._variables
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new UsingStatementSyntax(Me.Kind, newErrors, GetAnnotations, _usingKeyword, _expression, _variables)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new UsingStatementSyntax(Me.Kind, GetDiagnostics, annotations, _usingKeyword, _expression, _variables)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitUsingStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a Throw statement.
    ''' </summary>
    Friend NotInheritable Class ThrowStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _throwKeyword as KeywordSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, throwKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(throwKeyword)
            Me._throwKeyword = throwKeyword
            If expression IsNot Nothing Then
                AdjustFlagsAndWidth(expression)
                Me._expression = expression
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, throwKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(throwKeyword)
            Me._throwKeyword = throwKeyword
            If expression IsNot Nothing Then
                AdjustFlagsAndWidth(expression)
                Me._expression = expression
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), throwKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(throwKeyword)
            Me._throwKeyword = throwKeyword
            If expression IsNot Nothing Then
                AdjustFlagsAndWidth(expression)
                Me._expression = expression
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ThrowStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Throw" keyword
        ''' </summary>
        Friend ReadOnly Property ThrowKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._throwKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression denoting the value being thrown.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._throwKeyword
                Case 1
                    Return Me._expression
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ThrowStatementSyntax(Me.Kind, newErrors, GetAnnotations, _throwKeyword, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ThrowStatementSyntax(Me.Kind, GetDiagnostics, annotations, _throwKeyword, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitThrowStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a simple, compound, or Mid assignment statement. Which one can be
    ''' determined by checking the Kind.
    ''' </summary>
    Friend NotInheritable Class AssignmentStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _left as ExpressionSyntax
        Friend ReadOnly _operatorToken as PunctuationSyntax
        Friend ReadOnly _right as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, left As ExpressionSyntax, operatorToken As InternalSyntax.PunctuationSyntax, right As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(left)
            Me._left = left
            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken
            AdjustFlagsAndWidth(right)
            Me._right = right

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, left As ExpressionSyntax, operatorToken As InternalSyntax.PunctuationSyntax, right As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(left)
            Me._left = left
            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken
            AdjustFlagsAndWidth(right)
            Me._right = right

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), left As ExpressionSyntax, operatorToken As InternalSyntax.PunctuationSyntax, right As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(left)
            Me._left = left
            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken
            AdjustFlagsAndWidth(right)
            Me._right = right

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The target (left hand side) of the assignment.
        ''' </summary>
        Friend ReadOnly Property Left As InternalSyntax.ExpressionSyntax
            Get
                Return Me._left
            End Get
        End Property

        ''' <summary>
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </summary>
        Friend ReadOnly Property OperatorToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._operatorToken
            End Get
        End Property

        ''' <summary>
        ''' The source (right hand side) of the assignment.
        ''' </summary>
        Friend ReadOnly Property Right As InternalSyntax.ExpressionSyntax
            Get
                Return Me._right
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._left
                Case 1
                    Return Me._operatorToken
                Case 2
                    Return Me._right
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new AssignmentStatementSyntax(Me.Kind, newErrors, GetAnnotations, _left, _operatorToken, _right)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new AssignmentStatementSyntax(Me.Kind, GetDiagnostics, annotations, _left, _operatorToken, _right)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitAssignmentStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a left-hand side of a MidAssignment statement.
    ''' </summary>
    Friend NotInheritable Class MidExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _mid as IdentifierTokenSyntax
        Friend ReadOnly _argumentList as ArgumentListSyntax

        Friend Sub New(ByVal kind As SyntaxKind, mid As InternalSyntax.IdentifierTokenSyntax, argumentList As ArgumentListSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(mid)
            Me._mid = mid
            AdjustFlagsAndWidth(argumentList)
            Me._argumentList = argumentList

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, mid As InternalSyntax.IdentifierTokenSyntax, argumentList As ArgumentListSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(mid)
            Me._mid = mid
            AdjustFlagsAndWidth(argumentList)
            Me._argumentList = argumentList

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), mid As InternalSyntax.IdentifierTokenSyntax, argumentList As ArgumentListSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(mid)
            Me._mid = mid
            AdjustFlagsAndWidth(argumentList)
            Me._argumentList = argumentList

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Mid" possibly followed by a type character.
        ''' </summary>
        Friend ReadOnly Property Mid As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._mid
            End Get
        End Property

        ''' <summary>
        ''' The argument list.
        ''' </summary>
        Friend ReadOnly Property ArgumentList As InternalSyntax.ArgumentListSyntax
            Get
                Return Me._argumentList
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._mid
                Case 1
                    Return Me._argumentList
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new MidExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _mid, _argumentList)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new MidExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _mid, _argumentList)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitMidExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represent a call statement (also known as a invocation statement).
    ''' </summary>
    Friend NotInheritable Class CallStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _callKeyword as KeywordSyntax
        Friend ReadOnly _invocation as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, callKeyword As InternalSyntax.KeywordSyntax, invocation As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(callKeyword)
            Me._callKeyword = callKeyword
            AdjustFlagsAndWidth(invocation)
            Me._invocation = invocation

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, callKeyword As InternalSyntax.KeywordSyntax, invocation As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(callKeyword)
            Me._callKeyword = callKeyword
            AdjustFlagsAndWidth(invocation)
            Me._invocation = invocation

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), callKeyword As InternalSyntax.KeywordSyntax, invocation As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(callKeyword)
            Me._callKeyword = callKeyword
            AdjustFlagsAndWidth(invocation)
            Me._invocation = invocation

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CallStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Call" keyword.
        ''' </summary>
        Friend ReadOnly Property CallKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._callKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression denoting the call. This could be an Invocation or a MemberAccess
        ''' (in the case where no parentheses were supplied.)
        ''' </summary>
        Friend ReadOnly Property Invocation As InternalSyntax.ExpressionSyntax
            Get
                Return Me._invocation
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._callKeyword
                Case 1
                    Return Me._invocation
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new CallStatementSyntax(Me.Kind, newErrors, GetAnnotations, _callKeyword, _invocation)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new CallStatementSyntax(Me.Kind, GetDiagnostics, annotations, _callKeyword, _invocation)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitCallStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an AddHandler or RemoveHandler statement. The Kind property
    ''' determines which one.
    ''' </summary>
    Friend NotInheritable Class AddRemoveHandlerStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _addHandlerOrRemoveHandlerKeyword as KeywordSyntax
        Friend ReadOnly _eventExpression as ExpressionSyntax
        Friend ReadOnly _commaToken as PunctuationSyntax
        Friend ReadOnly _delegateExpression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, addHandlerOrRemoveHandlerKeyword As InternalSyntax.KeywordSyntax, eventExpression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, delegateExpression As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(addHandlerOrRemoveHandlerKeyword)
            Me._addHandlerOrRemoveHandlerKeyword = addHandlerOrRemoveHandlerKeyword
            AdjustFlagsAndWidth(eventExpression)
            Me._eventExpression = eventExpression
            AdjustFlagsAndWidth(commaToken)
            Me._commaToken = commaToken
            AdjustFlagsAndWidth(delegateExpression)
            Me._delegateExpression = delegateExpression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, addHandlerOrRemoveHandlerKeyword As InternalSyntax.KeywordSyntax, eventExpression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, delegateExpression As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 4
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(addHandlerOrRemoveHandlerKeyword)
            Me._addHandlerOrRemoveHandlerKeyword = addHandlerOrRemoveHandlerKeyword
            AdjustFlagsAndWidth(eventExpression)
            Me._eventExpression = eventExpression
            AdjustFlagsAndWidth(commaToken)
            Me._commaToken = commaToken
            AdjustFlagsAndWidth(delegateExpression)
            Me._delegateExpression = delegateExpression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), addHandlerOrRemoveHandlerKeyword As InternalSyntax.KeywordSyntax, eventExpression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, delegateExpression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(addHandlerOrRemoveHandlerKeyword)
            Me._addHandlerOrRemoveHandlerKeyword = addHandlerOrRemoveHandlerKeyword
            AdjustFlagsAndWidth(eventExpression)
            Me._eventExpression = eventExpression
            AdjustFlagsAndWidth(commaToken)
            Me._commaToken = commaToken
            AdjustFlagsAndWidth(delegateExpression)
            Me._delegateExpression = delegateExpression

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "AddHandler" or "RemoveHandler" keyword.
        ''' </summary>
        Friend ReadOnly Property AddHandlerOrRemoveHandlerKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._addHandlerOrRemoveHandlerKeyword
            End Get
        End Property

        ''' <summary>
        ''' The event being accessed.
        ''' </summary>
        Friend ReadOnly Property EventExpression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._eventExpression
            End Get
        End Property

        ''' <summary>
        ''' The "," token.
        ''' </summary>
        Friend ReadOnly Property CommaToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._commaToken
            End Get
        End Property

        ''' <summary>
        ''' The delegate being added or removed.
        ''' </summary>
        Friend ReadOnly Property DelegateExpression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._delegateExpression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._addHandlerOrRemoveHandlerKeyword
                Case 1
                    Return Me._eventExpression
                Case 2
                    Return Me._commaToken
                Case 3
                    Return Me._delegateExpression
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new AddRemoveHandlerStatementSyntax(Me.Kind, newErrors, GetAnnotations, _addHandlerOrRemoveHandlerKeyword, _eventExpression, _commaToken, _delegateExpression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new AddRemoveHandlerStatementSyntax(Me.Kind, GetDiagnostics, annotations, _addHandlerOrRemoveHandlerKeyword, _eventExpression, _commaToken, _delegateExpression)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitAddRemoveHandlerStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represent a RaiseEvent statement.
    ''' </summary>
    Friend NotInheritable Class RaiseEventStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _raiseEventKeyword as KeywordSyntax
        Friend ReadOnly _name as IdentifierNameSyntax
        Friend ReadOnly _argumentList as ArgumentListSyntax

        Friend Sub New(ByVal kind As SyntaxKind, raiseEventKeyword As InternalSyntax.KeywordSyntax, name As IdentifierNameSyntax, argumentList As ArgumentListSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(raiseEventKeyword)
            Me._raiseEventKeyword = raiseEventKeyword
            AdjustFlagsAndWidth(name)
            Me._name = name
            If argumentList IsNot Nothing Then
                AdjustFlagsAndWidth(argumentList)
                Me._argumentList = argumentList
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, raiseEventKeyword As InternalSyntax.KeywordSyntax, name As IdentifierNameSyntax, argumentList As ArgumentListSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(raiseEventKeyword)
            Me._raiseEventKeyword = raiseEventKeyword
            AdjustFlagsAndWidth(name)
            Me._name = name
            If argumentList IsNot Nothing Then
                AdjustFlagsAndWidth(argumentList)
                Me._argumentList = argumentList
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), raiseEventKeyword As InternalSyntax.KeywordSyntax, name As IdentifierNameSyntax, argumentList As ArgumentListSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(raiseEventKeyword)
            Me._raiseEventKeyword = raiseEventKeyword
            AdjustFlagsAndWidth(name)
            Me._name = name
            If argumentList IsNot Nothing Then
                AdjustFlagsAndWidth(argumentList)
                Me._argumentList = argumentList
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.RaiseEventStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "RaiseEvent" keyword
        ''' </summary>
        Friend ReadOnly Property RaiseEventKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._raiseEventKeyword
            End Get
        End Property

        ''' <summary>
        ''' The name of the event being raised.
        ''' </summary>
        Friend ReadOnly Property Name As InternalSyntax.IdentifierNameSyntax
            Get
                Return Me._name
            End Get
        End Property

        ''' <summary>
        ''' The argument list, if present.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property ArgumentList As InternalSyntax.ArgumentListSyntax
            Get
                Return Me._argumentList
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._raiseEventKeyword
                Case 1
                    Return Me._name
                Case 2
                    Return Me._argumentList
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new RaiseEventStatementSyntax(Me.Kind, newErrors, GetAnnotations, _raiseEventKeyword, _name, _argumentList)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new RaiseEventStatementSyntax(Me.Kind, GetDiagnostics, annotations, _raiseEventKeyword, _name, _argumentList)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitRaiseEventStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "With" statement. This statement always occurs as the
    ''' BeginStatement of a WithBlock, and the body of the With is the Body of that
    ''' WithBlock.
    ''' </summary>
    Friend NotInheritable Class WithStatementSyntax
        Inherits StatementSyntax

        Friend ReadOnly _withKeyword as KeywordSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, withKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(withKeyword)
            Me._withKeyword = withKeyword
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, withKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(withKeyword)
            Me._withKeyword = withKeyword
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), withKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(withKeyword)
            Me._withKeyword = withKeyword
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.WithStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "With" keyword.
        ''' </summary>
        Friend ReadOnly Property WithKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._withKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression that is the operand of the With statement.
        ''' </summary>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._withKeyword
                Case 1
                    Return Me._expression
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new WithStatementSyntax(Me.Kind, newErrors, GetAnnotations, _withKeyword, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new WithStatementSyntax(Me.Kind, GetDiagnostics, annotations, _withKeyword, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitWithStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a ReDim statement.
    ''' </summary>
    Friend NotInheritable Class ReDimStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _reDimKeyword as KeywordSyntax
        Friend ReadOnly _preserveKeyword as KeywordSyntax
        Friend ReadOnly _clauses as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, reDimKeyword As InternalSyntax.KeywordSyntax, preserveKeyword As InternalSyntax.KeywordSyntax, clauses As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(reDimKeyword)
            Me._reDimKeyword = reDimKeyword
            If preserveKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(preserveKeyword)
                Me._preserveKeyword = preserveKeyword
            End If
            If clauses IsNot Nothing Then
                AdjustFlagsAndWidth(clauses)
                Me._clauses = clauses
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, reDimKeyword As InternalSyntax.KeywordSyntax, preserveKeyword As InternalSyntax.KeywordSyntax, clauses As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(reDimKeyword)
            Me._reDimKeyword = reDimKeyword
            If preserveKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(preserveKeyword)
                Me._preserveKeyword = preserveKeyword
            End If
            If clauses IsNot Nothing Then
                AdjustFlagsAndWidth(clauses)
                Me._clauses = clauses
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), reDimKeyword As InternalSyntax.KeywordSyntax, preserveKeyword As InternalSyntax.KeywordSyntax, clauses As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(reDimKeyword)
            Me._reDimKeyword = reDimKeyword
            If preserveKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(preserveKeyword)
                Me._preserveKeyword = preserveKeyword
            End If
            If clauses IsNot Nothing Then
                AdjustFlagsAndWidth(clauses)
                Me._clauses = clauses
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "ReDim" keyword.
        ''' </summary>
        Friend ReadOnly Property ReDimKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._reDimKeyword
            End Get
        End Property

        ''' <summary>
        ''' Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
        ''' Kind=RedimPreserve.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property PreserveKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._preserveKeyword
            End Get
        End Property

        ''' <summary>
        ''' The list of ReDim clauses.
        ''' </summary>
        Friend ReadOnly Property Clauses As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of RedimClauseSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of RedimClauseSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of RedimClauseSyntax)(Me._clauses))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._reDimKeyword
                Case 1
                    Return Me._preserveKeyword
                Case 2
                    Return Me._clauses
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ReDimStatementSyntax(Me.Kind, newErrors, GetAnnotations, _reDimKeyword, _preserveKeyword, _clauses)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ReDimStatementSyntax(Me.Kind, GetDiagnostics, annotations, _reDimKeyword, _preserveKeyword, _clauses)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitReDimStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a ReDim statement clause.
    ''' </summary>
    Friend NotInheritable Class RedimClauseSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _expression as ExpressionSyntax
        Friend ReadOnly _arrayBounds as ArgumentListSyntax

        Friend Sub New(ByVal kind As SyntaxKind, expression As ExpressionSyntax, arrayBounds As ArgumentListSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            AdjustFlagsAndWidth(arrayBounds)
            Me._arrayBounds = arrayBounds

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, expression As ExpressionSyntax, arrayBounds As ArgumentListSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            AdjustFlagsAndWidth(arrayBounds)
            Me._arrayBounds = arrayBounds

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), expression As ExpressionSyntax, arrayBounds As ArgumentListSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            AdjustFlagsAndWidth(arrayBounds)
            Me._arrayBounds = arrayBounds

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The target of the ReDim statement.
        ''' </summary>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        ''' <summary>
        ''' The ArraySizeInitializationModifier.
        ''' </summary>
        Friend ReadOnly Property ArrayBounds As InternalSyntax.ArgumentListSyntax
            Get
                Return Me._arrayBounds
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._expression
                Case 1
                    Return Me._arrayBounds
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new RedimClauseSyntax(Me.Kind, newErrors, GetAnnotations, _expression, _arrayBounds)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new RedimClauseSyntax(Me.Kind, GetDiagnostics, annotations, _expression, _arrayBounds)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitRedimClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an "Erase" statement.
    ''' </summary>
    Friend NotInheritable Class EraseStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _eraseKeyword as KeywordSyntax
        Friend ReadOnly _expressions as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, eraseKeyword As InternalSyntax.KeywordSyntax, expressions As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(eraseKeyword)
            Me._eraseKeyword = eraseKeyword
            If expressions IsNot Nothing Then
                AdjustFlagsAndWidth(expressions)
                Me._expressions = expressions
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, eraseKeyword As InternalSyntax.KeywordSyntax, expressions As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(eraseKeyword)
            Me._eraseKeyword = eraseKeyword
            If expressions IsNot Nothing Then
                AdjustFlagsAndWidth(expressions)
                Me._expressions = expressions
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), eraseKeyword As InternalSyntax.KeywordSyntax, expressions As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(eraseKeyword)
            Me._eraseKeyword = eraseKeyword
            If expressions IsNot Nothing Then
                AdjustFlagsAndWidth(expressions)
                Me._expressions = expressions
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EraseStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Erase" keyword.
        ''' </summary>
        Friend ReadOnly Property EraseKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._eraseKeyword
            End Get
        End Property

        ''' <summary>
        ''' A list of expressions denoting the arrays to erase.
        ''' </summary>
        Friend ReadOnly Property Expressions As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ExpressionSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ExpressionSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of ExpressionSyntax)(Me._expressions))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._eraseKeyword
                Case 1
                    Return Me._expressions
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new EraseStatementSyntax(Me.Kind, newErrors, GetAnnotations, _eraseKeyword, _expressions)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new EraseStatementSyntax(Me.Kind, GetDiagnostics, annotations, _eraseKeyword, _expressions)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitEraseStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' An abstract base class for all node classes that define expressions.
    ''' </summary>
    Friend MustInherit Class ExpressionSyntax
        Inherits VisualBasicSyntaxNode


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

    End Class

    ''' <summary>
    ''' Represents a literal. The kind of literal is determined by the Kind property:
    ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
    ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
    ''' determined by casting the associated Token to the correct type and getting the
    ''' value from the token.
    ''' </summary>
    Friend NotInheritable Class LiteralExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _token as SyntaxToken

        Friend Sub New(ByVal kind As SyntaxKind, token As InternalSyntax.SyntaxToken)
            MyBase.New(kind)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(token)
            Me._token = token

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, token As InternalSyntax.SyntaxToken, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(token)
            Me._token = token

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), token As InternalSyntax.SyntaxToken)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(token)
            Me._token = token

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </summary>
        Friend ReadOnly Property Token As InternalSyntax.SyntaxToken
            Get
                Return Me._token
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._token
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new LiteralExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _token)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new LiteralExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _token)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitLiteralExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a parenthesized expression.
    ''' </summary>
    Friend NotInheritable Class ParenthesizedExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _expression as ExpressionSyntax
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ParenthesizedExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "(" token
        ''' </summary>
        Friend ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The expression inside the parentheses.
        ''' </summary>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        ''' <summary>
        ''' The ")" token
        ''' </summary>
        Friend ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._openParenToken
                Case 1
                    Return Me._expression
                Case 2
                    Return Me._closeParenToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ParenthesizedExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _openParenToken, _expression, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ParenthesizedExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _openParenToken, _expression, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitParenthesizedExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a tuple literal expression.
    ''' </summary>
    Friend NotInheritable Class TupleExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _arguments as GreenNode
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, arguments As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            If arguments IsNot Nothing Then
                AdjustFlagsAndWidth(arguments)
                Me._arguments = arguments
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, arguments As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            If arguments IsNot Nothing Then
                AdjustFlagsAndWidth(arguments)
                Me._arguments = arguments
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), openParenToken As InternalSyntax.PunctuationSyntax, arguments As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            If arguments IsNot Nothing Then
                AdjustFlagsAndWidth(arguments)
                Me._arguments = arguments
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "(" token
        ''' </summary>
        Friend ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The list of tuple arguments.
        ''' </summary>
        Friend ReadOnly Property Arguments As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of SimpleArgumentSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of SimpleArgumentSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of SimpleArgumentSyntax)(Me._arguments))
            End Get
        End Property

        ''' <summary>
        ''' The ")" token
        ''' </summary>
        Friend ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._openParenToken
                Case 1
                    Return Me._arguments
                Case 2
                    Return Me._closeParenToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new TupleExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _openParenToken, _arguments, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new TupleExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _openParenToken, _arguments, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitTupleExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a tuple type expression.
    ''' </summary>
    Friend NotInheritable Class TupleTypeSyntax
        Inherits TypeSyntax

        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _elements as GreenNode
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, elements As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            If elements IsNot Nothing Then
                AdjustFlagsAndWidth(elements)
                Me._elements = elements
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, elements As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            If elements IsNot Nothing Then
                AdjustFlagsAndWidth(elements)
                Me._elements = elements
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), openParenToken As InternalSyntax.PunctuationSyntax, elements As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            If elements IsNot Nothing Then
                AdjustFlagsAndWidth(elements)
                Me._elements = elements
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TupleTypeSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "(" token
        ''' </summary>
        Friend ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The list of tuple elements.
        ''' </summary>
        Friend ReadOnly Property Elements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of TupleElementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of TupleElementSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of TupleElementSyntax)(Me._elements))
            End Get
        End Property

        ''' <summary>
        ''' The ")" token
        ''' </summary>
        Friend ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._openParenToken
                Case 1
                    Return Me._elements
                Case 2
                    Return Me._closeParenToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new TupleTypeSyntax(Me.Kind, newErrors, GetAnnotations, _openParenToken, _elements, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new TupleTypeSyntax(Me.Kind, GetDiagnostics, annotations, _openParenToken, _elements, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitTupleType(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a single declaration of a tuple element.
    ''' </summary>
    Friend MustInherit Class TupleElementSyntax
        Inherits VisualBasicSyntaxNode


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

    End Class

    ''' <summary>
    ''' Represents a single declaration of a tuple element supplying only the type.
    ''' </summary>
    Friend NotInheritable Class TypedTupleElementSyntax
        Inherits TupleElementSyntax

        Friend ReadOnly _type as TypeSyntax

        Friend Sub New(ByVal kind As SyntaxKind, type As TypeSyntax)
            MyBase.New(kind)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(type)
            Me._type = type

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, type As TypeSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(type)
            Me._type = type

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), type As TypeSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(type)
            Me._type = type

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TypedTupleElementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The type-name part of the tuple element syntax.
        ''' </summary>
        Friend ReadOnly Property Type As InternalSyntax.TypeSyntax
            Get
                Return Me._type
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._type
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new TypedTupleElementSyntax(Me.Kind, newErrors, GetAnnotations, _type)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new TypedTupleElementSyntax(Me.Kind, GetDiagnostics, annotations, _type)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitTypedTupleElement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a single declaration of a tuple element supplying element name and
    ''' optionally a type.
    ''' </summary>
    Friend NotInheritable Class NamedTupleElementSyntax
        Inherits TupleElementSyntax

        Friend ReadOnly _identifier as IdentifierTokenSyntax
        Friend ReadOnly _asClause as SimpleAsClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, identifier As InternalSyntax.IdentifierTokenSyntax, asClause As SimpleAsClauseSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, identifier As InternalSyntax.IdentifierTokenSyntax, asClause As SimpleAsClauseSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), identifier As InternalSyntax.IdentifierTokenSyntax, asClause As SimpleAsClauseSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedTupleElementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The name of the element.
        ''' </summary>
        Friend ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' A simple "As" clause specifying the type of the tuple element.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property AsClause As InternalSyntax.SimpleAsClauseSyntax
            Get
                Return Me._asClause
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._identifier
                Case 1
                    Return Me._asClause
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new NamedTupleElementSyntax(Me.Kind, newErrors, GetAnnotations, _identifier, _asClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new NamedTupleElementSyntax(Me.Kind, GetDiagnostics, annotations, _identifier, _asClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitNamedTupleElement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Identifies one of the special instances "Me", "MyClass" or "MyBase". The Kind
    ''' property identifies which.
    ''' </summary>
    Friend MustInherit Class InstanceExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _keyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)

            AdjustFlagsAndWidth(keyword)
            Me._keyword = keyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(keyword)
            Me._keyword = keyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)

            AdjustFlagsAndWidth(keyword)
            Me._keyword = keyword

        End Sub

        ''' <summary>
        ''' The "Me", "MyClass" or "MyBase" keyword.
        ''' </summary>
        Friend ReadOnly Property Keyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._keyword
            End Get
        End Property

    End Class

    ''' <summary>
    ''' Identifies the special instance "Me"
    ''' </summary>
    Friend NotInheritable Class MeExpressionSyntax
        Inherits InstanceExpressionSyntax


        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, keyword)
            Me.SlotCount = 1
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, keyword)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations, keyword)
            Me.SlotCount = 1
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MeExpressionSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._keyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new MeExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _keyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new MeExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _keyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitMeExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Identifies the special instance "MyBase"
    ''' </summary>
    Friend NotInheritable Class MyBaseExpressionSyntax
        Inherits InstanceExpressionSyntax


        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, keyword)
            Me.SlotCount = 1
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, keyword)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations, keyword)
            Me.SlotCount = 1
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MyBaseExpressionSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._keyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new MyBaseExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _keyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new MyBaseExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _keyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitMyBaseExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Identifies the special instance "MyClass"
    ''' </summary>
    Friend NotInheritable Class MyClassExpressionSyntax
        Inherits InstanceExpressionSyntax


        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, keyword)
            Me.SlotCount = 1
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, keyword)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations, keyword)
            Me.SlotCount = 1
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MyClassExpressionSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._keyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new MyClassExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _keyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new MyClassExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _keyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitMyClassExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a GetType expression.
    ''' </summary>
    Friend NotInheritable Class GetTypeExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _getTypeKeyword as KeywordSyntax
        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _type as TypeSyntax
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, getTypeKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(getTypeKeyword)
            Me._getTypeKeyword = getTypeKeyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(type)
            Me._type = type
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, getTypeKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 4
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(getTypeKeyword)
            Me._getTypeKeyword = getTypeKeyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(type)
            Me._type = type
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), getTypeKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(getTypeKeyword)
            Me._getTypeKeyword = getTypeKeyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(type)
            Me._type = type
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.GetTypeExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "GetType" keyword.
        ''' </summary>
        Friend ReadOnly Property GetTypeKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._getTypeKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "(" token.
        ''' </summary>
        Friend ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The type to get the Type object for. This can be an open generic type.
        ''' </summary>
        Friend ReadOnly Property Type As InternalSyntax.TypeSyntax
            Get
                Return Me._type
            End Get
        End Property

        ''' <summary>
        ''' The ")" token.
        ''' </summary>
        Friend ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._getTypeKeyword
                Case 1
                    Return Me._openParenToken
                Case 2
                    Return Me._type
                Case 3
                    Return Me._closeParenToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new GetTypeExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _getTypeKeyword, _openParenToken, _type, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new GetTypeExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _getTypeKeyword, _openParenToken, _type, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitGetTypeExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a TypeOf...Is or IsNot expression.
    ''' </summary>
    Friend NotInheritable Class TypeOfExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _typeOfKeyword as KeywordSyntax
        Friend ReadOnly _expression as ExpressionSyntax
        Friend ReadOnly _operatorToken as KeywordSyntax
        Friend ReadOnly _type as TypeSyntax

        Friend Sub New(ByVal kind As SyntaxKind, typeOfKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax, operatorToken As InternalSyntax.KeywordSyntax, type As TypeSyntax)
            MyBase.New(kind)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(typeOfKeyword)
            Me._typeOfKeyword = typeOfKeyword
            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken
            AdjustFlagsAndWidth(type)
            Me._type = type

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, typeOfKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax, operatorToken As InternalSyntax.KeywordSyntax, type As TypeSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 4
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(typeOfKeyword)
            Me._typeOfKeyword = typeOfKeyword
            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken
            AdjustFlagsAndWidth(type)
            Me._type = type

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), typeOfKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax, operatorToken As InternalSyntax.KeywordSyntax, type As TypeSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(typeOfKeyword)
            Me._typeOfKeyword = typeOfKeyword
            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken
            AdjustFlagsAndWidth(type)
            Me._type = type

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "TypeOf" keyword.
        ''' </summary>
        Friend ReadOnly Property TypeOfKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._typeOfKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression being tested.
        ''' </summary>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        ''' <summary>
        ''' The "Is" or "IsNot" keyword.
        ''' </summary>
        Friend ReadOnly Property OperatorToken As InternalSyntax.KeywordSyntax
            Get
                Return Me._operatorToken
            End Get
        End Property

        ''' <summary>
        ''' The name of the type being tested against.
        ''' </summary>
        Friend ReadOnly Property Type As InternalSyntax.TypeSyntax
            Get
                Return Me._type
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._typeOfKeyword
                Case 1
                    Return Me._expression
                Case 2
                    Return Me._operatorToken
                Case 3
                    Return Me._type
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new TypeOfExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _typeOfKeyword, _expression, _operatorToken, _type)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new TypeOfExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _typeOfKeyword, _expression, _operatorToken, _type)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitTypeOfExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a GetXmlNamespace expression.
    ''' </summary>
    Friend NotInheritable Class GetXmlNamespaceExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _getXmlNamespaceKeyword as KeywordSyntax
        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _name as XmlPrefixNameSyntax
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, getXmlNamespaceKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, name As XmlPrefixNameSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(getXmlNamespaceKeyword)
            Me._getXmlNamespaceKeyword = getXmlNamespaceKeyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            If name IsNot Nothing Then
                AdjustFlagsAndWidth(name)
                Me._name = name
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, getXmlNamespaceKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, name As XmlPrefixNameSyntax, closeParenToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 4
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(getXmlNamespaceKeyword)
            Me._getXmlNamespaceKeyword = getXmlNamespaceKeyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            If name IsNot Nothing Then
                AdjustFlagsAndWidth(name)
                Me._name = name
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), getXmlNamespaceKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, name As XmlPrefixNameSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(getXmlNamespaceKeyword)
            Me._getXmlNamespaceKeyword = getXmlNamespaceKeyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            If name IsNot Nothing Then
                AdjustFlagsAndWidth(name)
                Me._name = name
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.GetXmlNamespaceExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "GetXmlNamespace" keyword.
        ''' </summary>
        Friend ReadOnly Property GetXmlNamespaceKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._getXmlNamespaceKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "(" token.
        ''' </summary>
        Friend ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The Xml namespace name being referenced.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Name As InternalSyntax.XmlPrefixNameSyntax
            Get
                Return Me._name
            End Get
        End Property

        ''' <summary>
        ''' The ")" token.
        ''' </summary>
        Friend ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._getXmlNamespaceKeyword
                Case 1
                    Return Me._openParenToken
                Case 2
                    Return Me._name
                Case 3
                    Return Me._closeParenToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new GetXmlNamespaceExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _getXmlNamespaceKeyword, _openParenToken, _name, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new GetXmlNamespaceExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _getXmlNamespaceKeyword, _openParenToken, _name, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitGetXmlNamespaceExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents member access (.name) or dictionary access (!name). The Kind
    ''' property determines which kind of access.
    ''' </summary>
    Friend NotInheritable Class MemberAccessExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _expression as ExpressionSyntax
        Friend ReadOnly _operatorToken as PunctuationSyntax
        Friend ReadOnly _name as SimpleNameSyntax

        Friend Sub New(ByVal kind As SyntaxKind, expression As ExpressionSyntax, operatorToken As InternalSyntax.PunctuationSyntax, name As SimpleNameSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            If expression IsNot Nothing Then
                AdjustFlagsAndWidth(expression)
                Me._expression = expression
            End If
            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken
            AdjustFlagsAndWidth(name)
            Me._name = name

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, expression As ExpressionSyntax, operatorToken As InternalSyntax.PunctuationSyntax, name As SimpleNameSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            If expression IsNot Nothing Then
                AdjustFlagsAndWidth(expression)
                Me._expression = expression
            End If
            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken
            AdjustFlagsAndWidth(name)
            Me._name = name

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), expression As ExpressionSyntax, operatorToken As InternalSyntax.PunctuationSyntax, name As SimpleNameSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            If expression IsNot Nothing Then
                AdjustFlagsAndWidth(expression)
                Me._expression = expression
            End If
            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken
            AdjustFlagsAndWidth(name)
            Me._name = name

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The expression on the left-hand-side of the "." or "!" token.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        ''' <summary>
        ''' The "." or "!" token.
        ''' </summary>
        Friend ReadOnly Property OperatorToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._operatorToken
            End Get
        End Property

        ''' <summary>
        ''' The identifier after the "." or "!" token.
        ''' </summary>
        Friend ReadOnly Property Name As InternalSyntax.SimpleNameSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._expression
                Case 1
                    Return Me._operatorToken
                Case 2
                    Return Me._name
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new MemberAccessExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _expression, _operatorToken, _name)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new MemberAccessExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _expression, _operatorToken, _name)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitMemberAccessExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an XML member element access (node.&lt;Element&gt;), attribute
    ''' access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
    ''' Kind property determines which kind of access.
    ''' </summary>
    Friend NotInheritable Class XmlMemberAccessExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _base as ExpressionSyntax
        Friend ReadOnly _token1 as PunctuationSyntax
        Friend ReadOnly _token2 as PunctuationSyntax
        Friend ReadOnly _token3 as PunctuationSyntax
        Friend ReadOnly _name as XmlNodeSyntax

        Friend Sub New(ByVal kind As SyntaxKind, base As ExpressionSyntax, token1 As InternalSyntax.PunctuationSyntax, token2 As InternalSyntax.PunctuationSyntax, token3 As InternalSyntax.PunctuationSyntax, name As XmlNodeSyntax)
            MyBase.New(kind)
            Me.SlotCount = 5

            If base IsNot Nothing Then
                AdjustFlagsAndWidth(base)
                Me._base = base
            End If
            AdjustFlagsAndWidth(token1)
            Me._token1 = token1
            If token2 IsNot Nothing Then
                AdjustFlagsAndWidth(token2)
                Me._token2 = token2
            End If
            If token3 IsNot Nothing Then
                AdjustFlagsAndWidth(token3)
                Me._token3 = token3
            End If
            AdjustFlagsAndWidth(name)
            Me._name = name

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, base As ExpressionSyntax, token1 As InternalSyntax.PunctuationSyntax, token2 As InternalSyntax.PunctuationSyntax, token3 As InternalSyntax.PunctuationSyntax, name As XmlNodeSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            If base IsNot Nothing Then
                AdjustFlagsAndWidth(base)
                Me._base = base
            End If
            AdjustFlagsAndWidth(token1)
            Me._token1 = token1
            If token2 IsNot Nothing Then
                AdjustFlagsAndWidth(token2)
                Me._token2 = token2
            End If
            If token3 IsNot Nothing Then
                AdjustFlagsAndWidth(token3)
                Me._token3 = token3
            End If
            AdjustFlagsAndWidth(name)
            Me._name = name

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), base As ExpressionSyntax, token1 As InternalSyntax.PunctuationSyntax, token2 As InternalSyntax.PunctuationSyntax, token3 As InternalSyntax.PunctuationSyntax, name As XmlNodeSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 5

            If base IsNot Nothing Then
                AdjustFlagsAndWidth(base)
                Me._base = base
            End If
            AdjustFlagsAndWidth(token1)
            Me._token1 = token1
            If token2 IsNot Nothing Then
                AdjustFlagsAndWidth(token2)
                Me._token2 = token2
            End If
            If token3 IsNot Nothing Then
                AdjustFlagsAndWidth(token3)
                Me._token3 = token3
            End If
            AdjustFlagsAndWidth(name)
            Me._name = name

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The expression on the left-hand-side of the ".", ".@" or "..." .
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Base As InternalSyntax.ExpressionSyntax
            Get
                Return Me._base
            End Get
        End Property

        ''' <summary>
        ''' The initial dot "." part of the separator.
        ''' </summary>
        Friend ReadOnly Property Token1 As InternalSyntax.PunctuationSyntax
            Get
                Return Me._token1
            End Get
        End Property

        ''' <summary>
        ''' The "@" part of .@ or the second "." of "...".
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Token2 As InternalSyntax.PunctuationSyntax
            Get
                Return Me._token2
            End Get
        End Property

        ''' <summary>
        ''' The third "." in a "..." separator.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Token3 As InternalSyntax.PunctuationSyntax
            Get
                Return Me._token3
            End Get
        End Property

        ''' <summary>
        ''' The identifier after the ".", ".@" or "..."
        ''' </summary>
        Friend ReadOnly Property Name As InternalSyntax.XmlNodeSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._base
                Case 1
                    Return Me._token1
                Case 2
                    Return Me._token2
                Case 3
                    Return Me._token3
                Case 4
                    Return Me._name
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlMemberAccessExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _base, _token1, _token2, _token3, _name)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlMemberAccessExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _base, _token1, _token2, _token3, _name)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitXmlMemberAccessExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an invocation expression consisting of an invocation target and an
    ''' optional argument list or an array, parameterized property or object default
    ''' property index.
    ''' </summary>
    Friend NotInheritable Class InvocationExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _expression as ExpressionSyntax
        Friend ReadOnly _argumentList as ArgumentListSyntax

        Friend Sub New(ByVal kind As SyntaxKind, expression As ExpressionSyntax, argumentList As ArgumentListSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            If expression IsNot Nothing Then
                AdjustFlagsAndWidth(expression)
                Me._expression = expression
            End If
            If argumentList IsNot Nothing Then
                AdjustFlagsAndWidth(argumentList)
                Me._argumentList = argumentList
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, expression As ExpressionSyntax, argumentList As ArgumentListSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            If expression IsNot Nothing Then
                AdjustFlagsAndWidth(expression)
                Me._expression = expression
            End If
            If argumentList IsNot Nothing Then
                AdjustFlagsAndWidth(argumentList)
                Me._argumentList = argumentList
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), expression As ExpressionSyntax, argumentList As ArgumentListSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            If expression IsNot Nothing Then
                AdjustFlagsAndWidth(expression)
                Me._expression = expression
            End If
            If argumentList IsNot Nothing Then
                AdjustFlagsAndWidth(argumentList)
                Me._argumentList = argumentList
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The target of the call or index expression.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        ''' <summary>
        ''' The argument list.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property ArgumentList As InternalSyntax.ArgumentListSyntax
            Get
                Return Me._argumentList
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._expression
                Case 1
                    Return Me._argumentList
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new InvocationExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _expression, _argumentList)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new InvocationExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _expression, _argumentList)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitInvocationExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Base class for object, array and anonymous object creation expressions
    ''' </summary>
    Partial Friend MustInherit Class NewExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _newKeyword as KeywordSyntax
        Friend ReadOnly _attributeLists as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, newKeyword As InternalSyntax.KeywordSyntax, attributeLists As GreenNode)
            MyBase.New(kind)

            AdjustFlagsAndWidth(newKeyword)
            Me._newKeyword = newKeyword
            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, newKeyword As InternalSyntax.KeywordSyntax, attributeLists As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(newKeyword)
            Me._newKeyword = newKeyword
            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), newKeyword As InternalSyntax.KeywordSyntax, attributeLists As GreenNode)
            MyBase.New(kind, errors, annotations)

            AdjustFlagsAndWidth(newKeyword)
            Me._newKeyword = newKeyword
            If attributeLists IsNot Nothing Then
                AdjustFlagsAndWidth(attributeLists)
                Me._attributeLists = attributeLists
            End If

        End Sub

        ''' <summary>
        ''' The "New" keyword.
        ''' </summary>
        Friend ReadOnly Property NewKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._newKeyword
            End Get
        End Property

        ''' <summary>
        ''' A list of all attribute lists on the type. If no attributes were specified, an
        ''' empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property AttributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AttributeListSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of AttributeListSyntax)(Me._attributeLists)
            End Get
        End Property

    End Class

    ''' <summary>
    ''' Represents a New expression that creates a new non-array object, possibly with
    ''' a "With" or "From" clause.
    ''' </summary>
    Friend NotInheritable Class ObjectCreationExpressionSyntax
        Inherits NewExpressionSyntax

        Friend ReadOnly _type as TypeSyntax
        Friend ReadOnly _argumentList as ArgumentListSyntax
        Friend ReadOnly _initializer as ObjectCreationInitializerSyntax

        Friend Sub New(ByVal kind As SyntaxKind, newKeyword As InternalSyntax.KeywordSyntax, attributeLists As GreenNode, type As TypeSyntax, argumentList As ArgumentListSyntax, initializer As ObjectCreationInitializerSyntax)
            MyBase.New(kind, newKeyword, attributeLists)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(type)
            Me._type = type
            If argumentList IsNot Nothing Then
                AdjustFlagsAndWidth(argumentList)
                Me._argumentList = argumentList
            End If
            If initializer IsNot Nothing Then
                AdjustFlagsAndWidth(initializer)
                Me._initializer = initializer
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, newKeyword As InternalSyntax.KeywordSyntax, attributeLists As GreenNode, type As TypeSyntax, argumentList As ArgumentListSyntax, initializer As ObjectCreationInitializerSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, newKeyword, attributeLists)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(type)
            Me._type = type
            If argumentList IsNot Nothing Then
                AdjustFlagsAndWidth(argumentList)
                Me._argumentList = argumentList
            End If
            If initializer IsNot Nothing Then
                AdjustFlagsAndWidth(initializer)
                Me._initializer = initializer
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), newKeyword As InternalSyntax.KeywordSyntax, attributeLists As GreenNode, type As TypeSyntax, argumentList As ArgumentListSyntax, initializer As ObjectCreationInitializerSyntax)
            MyBase.New(kind, errors, annotations, newKeyword, attributeLists)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(type)
            Me._type = type
            If argumentList IsNot Nothing Then
                AdjustFlagsAndWidth(argumentList)
                Me._argumentList = argumentList
            End If
            If initializer IsNot Nothing Then
                AdjustFlagsAndWidth(initializer)
                Me._initializer = initializer
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The type of the object being initialized.
        ''' </summary>
        Friend ReadOnly Property Type As InternalSyntax.TypeSyntax
            Get
                Return Me._type
            End Get
        End Property

        ''' <summary>
        ''' The argument list, if present. If no argument list was supplied, Nothing is
        ''' returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property ArgumentList As InternalSyntax.ArgumentListSyntax
            Get
                Return Me._argumentList
            End Get
        End Property

        ''' <summary>
        ''' An optional From or With clause to initialize the new object.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Initializer As InternalSyntax.ObjectCreationInitializerSyntax
            Get
                Return Me._initializer
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._newKeyword
                Case 1
                    Return Me._attributeLists
                Case 2
                    Return Me._type
                Case 3
                    Return Me._argumentList
                Case 4
                    Return Me._initializer
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ObjectCreationExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _newKeyword, _attributeLists, _type, _argumentList, _initializer)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ObjectCreationExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _newKeyword, _attributeLists, _type, _argumentList, _initializer)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitObjectCreationExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a New expression that create an object of anonymous type.
    ''' </summary>
    Friend NotInheritable Class AnonymousObjectCreationExpressionSyntax
        Inherits NewExpressionSyntax

        Friend ReadOnly _initializer as ObjectMemberInitializerSyntax

        Friend Sub New(ByVal kind As SyntaxKind, newKeyword As InternalSyntax.KeywordSyntax, attributeLists As GreenNode, initializer As ObjectMemberInitializerSyntax)
            MyBase.New(kind, newKeyword, attributeLists)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(initializer)
            Me._initializer = initializer

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, newKeyword As InternalSyntax.KeywordSyntax, attributeLists As GreenNode, initializer As ObjectMemberInitializerSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, newKeyword, attributeLists)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(initializer)
            Me._initializer = initializer

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), newKeyword As InternalSyntax.KeywordSyntax, attributeLists As GreenNode, initializer As ObjectMemberInitializerSyntax)
            MyBase.New(kind, errors, annotations, newKeyword, attributeLists)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(initializer)
            Me._initializer = initializer

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The With clause to initialize the new object.
        ''' </summary>
        Friend ReadOnly Property Initializer As InternalSyntax.ObjectMemberInitializerSyntax
            Get
                Return Me._initializer
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._newKeyword
                Case 1
                    Return Me._attributeLists
                Case 2
                    Return Me._initializer
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new AnonymousObjectCreationExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _newKeyword, _attributeLists, _initializer)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new AnonymousObjectCreationExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _newKeyword, _attributeLists, _initializer)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitAnonymousObjectCreationExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an expression that creates a new array.
    ''' </summary>
    Friend NotInheritable Class ArrayCreationExpressionSyntax
        Inherits NewExpressionSyntax

        Friend ReadOnly _type as TypeSyntax
        Friend ReadOnly _arrayBounds as ArgumentListSyntax
        Friend ReadOnly _rankSpecifiers as GreenNode
        Friend ReadOnly _initializer as CollectionInitializerSyntax

        Friend Sub New(ByVal kind As SyntaxKind, newKeyword As InternalSyntax.KeywordSyntax, attributeLists As GreenNode, type As TypeSyntax, arrayBounds As ArgumentListSyntax, rankSpecifiers As GreenNode, initializer As CollectionInitializerSyntax)
            MyBase.New(kind, newKeyword, attributeLists)
            Me.SlotCount = 6

            AdjustFlagsAndWidth(type)
            Me._type = type
            If arrayBounds IsNot Nothing Then
                AdjustFlagsAndWidth(arrayBounds)
                Me._arrayBounds = arrayBounds
            End If
            If rankSpecifiers IsNot Nothing Then
                AdjustFlagsAndWidth(rankSpecifiers)
                Me._rankSpecifiers = rankSpecifiers
            End If
            AdjustFlagsAndWidth(initializer)
            Me._initializer = initializer

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, newKeyword As InternalSyntax.KeywordSyntax, attributeLists As GreenNode, type As TypeSyntax, arrayBounds As ArgumentListSyntax, rankSpecifiers As GreenNode, initializer As CollectionInitializerSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, newKeyword, attributeLists)
            Me.SlotCount = 6
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(type)
            Me._type = type
            If arrayBounds IsNot Nothing Then
                AdjustFlagsAndWidth(arrayBounds)
                Me._arrayBounds = arrayBounds
            End If
            If rankSpecifiers IsNot Nothing Then
                AdjustFlagsAndWidth(rankSpecifiers)
                Me._rankSpecifiers = rankSpecifiers
            End If
            AdjustFlagsAndWidth(initializer)
            Me._initializer = initializer

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), newKeyword As InternalSyntax.KeywordSyntax, attributeLists As GreenNode, type As TypeSyntax, arrayBounds As ArgumentListSyntax, rankSpecifiers As GreenNode, initializer As CollectionInitializerSyntax)
            MyBase.New(kind, errors, annotations, newKeyword, attributeLists)
            Me.SlotCount = 6

            AdjustFlagsAndWidth(type)
            Me._type = type
            If arrayBounds IsNot Nothing Then
                AdjustFlagsAndWidth(arrayBounds)
                Me._arrayBounds = arrayBounds
            End If
            If rankSpecifiers IsNot Nothing Then
                AdjustFlagsAndWidth(rankSpecifiers)
                Me._rankSpecifiers = rankSpecifiers
            End If
            AdjustFlagsAndWidth(initializer)
            Me._initializer = initializer

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The element type of the array being created.
        ''' </summary>
        Friend ReadOnly Property Type As InternalSyntax.TypeSyntax
            Get
                Return Me._type
            End Get
        End Property

        ''' <summary>
        ''' The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property ArrayBounds As InternalSyntax.ArgumentListSyntax
            Get
                Return Me._arrayBounds
            End Get
        End Property

        ''' <summary>
        ''' A list of array modifiers such as "()" or "(,)". If no array modifiers were
        ''' present, an empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property RankSpecifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of ArrayRankSpecifierSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of ArrayRankSpecifierSyntax)(Me._rankSpecifiers)
            End Get
        End Property

        ''' <summary>
        ''' The initializer including the braces.
        ''' </summary>
        Friend ReadOnly Property Initializer As InternalSyntax.CollectionInitializerSyntax
            Get
                Return Me._initializer
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._newKeyword
                Case 1
                    Return Me._attributeLists
                Case 2
                    Return Me._type
                Case 3
                    Return Me._arrayBounds
                Case 4
                    Return Me._rankSpecifiers
                Case 5
                    Return Me._initializer
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ArrayCreationExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _newKeyword, _attributeLists, _type, _arrayBounds, _rankSpecifiers, _initializer)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ArrayCreationExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _newKeyword, _attributeLists, _type, _arrayBounds, _rankSpecifiers, _initializer)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitArrayCreationExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an expression that creates a new array without naming the element
    ''' type.
    ''' </summary>
    Friend NotInheritable Class CollectionInitializerSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _openBraceToken as PunctuationSyntax
        Friend ReadOnly _initializers as GreenNode
        Friend ReadOnly _closeBraceToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, openBraceToken As InternalSyntax.PunctuationSyntax, initializers As GreenNode, closeBraceToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(openBraceToken)
            Me._openBraceToken = openBraceToken
            If initializers IsNot Nothing Then
                AdjustFlagsAndWidth(initializers)
                Me._initializers = initializers
            End If
            AdjustFlagsAndWidth(closeBraceToken)
            Me._closeBraceToken = closeBraceToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, openBraceToken As InternalSyntax.PunctuationSyntax, initializers As GreenNode, closeBraceToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(openBraceToken)
            Me._openBraceToken = openBraceToken
            If initializers IsNot Nothing Then
                AdjustFlagsAndWidth(initializers)
                Me._initializers = initializers
            End If
            AdjustFlagsAndWidth(closeBraceToken)
            Me._closeBraceToken = closeBraceToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), openBraceToken As InternalSyntax.PunctuationSyntax, initializers As GreenNode, closeBraceToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(openBraceToken)
            Me._openBraceToken = openBraceToken
            If initializers IsNot Nothing Then
                AdjustFlagsAndWidth(initializers)
                Me._initializers = initializers
            End If
            AdjustFlagsAndWidth(closeBraceToken)
            Me._closeBraceToken = closeBraceToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "{" token.
        ''' </summary>
        Friend ReadOnly Property OpenBraceToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openBraceToken
            End Get
        End Property

        ''' <summary>
        ''' The list of initializers between the braces.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Initializers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ExpressionSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ExpressionSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of ExpressionSyntax)(Me._initializers))
            End Get
        End Property

        ''' <summary>
        ''' The "}" token.
        ''' </summary>
        Friend ReadOnly Property CloseBraceToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeBraceToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._openBraceToken
                Case 1
                    Return Me._initializers
                Case 2
                    Return Me._closeBraceToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new CollectionInitializerSyntax(Me.Kind, newErrors, GetAnnotations, _openBraceToken, _initializers, _closeBraceToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new CollectionInitializerSyntax(Me.Kind, GetDiagnostics, annotations, _openBraceToken, _initializers, _closeBraceToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitCollectionInitializer(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a CType, DirectCast or TryCast conversion expression. The Kind
    ''' property determines which kind of cast it is.
    ''' </summary>
    Friend MustInherit Class CastExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _keyword as KeywordSyntax
        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _expression as ExpressionSyntax
        Friend ReadOnly _commaToken as PunctuationSyntax
        Friend ReadOnly _type as TypeSyntax
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            AdjustFlagsAndWidth(keyword)
            Me._keyword = keyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            AdjustFlagsAndWidth(commaToken)
            Me._commaToken = commaToken
            AdjustFlagsAndWidth(type)
            Me._type = type
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(keyword)
            Me._keyword = keyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            AdjustFlagsAndWidth(commaToken)
            Me._commaToken = commaToken
            AdjustFlagsAndWidth(type)
            Me._type = type
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            AdjustFlagsAndWidth(keyword)
            Me._keyword = keyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            AdjustFlagsAndWidth(commaToken)
            Me._commaToken = commaToken
            AdjustFlagsAndWidth(type)
            Me._type = type
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        ''' <summary>
        ''' The "CType", "DirectCast" or "TryCast" keyword.
        ''' </summary>
        Friend ReadOnly Property Keyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._keyword
            End Get
        End Property

        ''' <summary>
        ''' The "(" token.
        ''' </summary>
        Friend ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The expression being cast.
        ''' </summary>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        ''' <summary>
        ''' The "," token.
        ''' </summary>
        Friend ReadOnly Property CommaToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._commaToken
            End Get
        End Property

        ''' <summary>
        ''' The type the expression is being cast to.
        ''' </summary>
        Friend ReadOnly Property Type As InternalSyntax.TypeSyntax
            Get
                Return Me._type
            End Get
        End Property

        ''' <summary>
        ''' The ")" token.
        ''' </summary>
        Friend ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

    End Class

    Friend NotInheritable Class CTypeExpressionSyntax
        Inherits CastExpressionSyntax


        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, keyword, openParenToken, expression, commaToken, type, closeParenToken)
            Me.SlotCount = 6
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, keyword, openParenToken, expression, commaToken, type, closeParenToken)
            Me.SlotCount = 6
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations, keyword, openParenToken, expression, commaToken, type, closeParenToken)
            Me.SlotCount = 6
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CTypeExpressionSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._keyword
                Case 1
                    Return Me._openParenToken
                Case 2
                    Return Me._expression
                Case 3
                    Return Me._commaToken
                Case 4
                    Return Me._type
                Case 5
                    Return Me._closeParenToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new CTypeExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _keyword, _openParenToken, _expression, _commaToken, _type, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new CTypeExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _keyword, _openParenToken, _expression, _commaToken, _type, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitCTypeExpression(Me)
        End Function

    End Class

    Friend NotInheritable Class DirectCastExpressionSyntax
        Inherits CastExpressionSyntax


        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, keyword, openParenToken, expression, commaToken, type, closeParenToken)
            Me.SlotCount = 6
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, keyword, openParenToken, expression, commaToken, type, closeParenToken)
            Me.SlotCount = 6
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations, keyword, openParenToken, expression, commaToken, type, closeParenToken)
            Me.SlotCount = 6
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectCastExpressionSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._keyword
                Case 1
                    Return Me._openParenToken
                Case 2
                    Return Me._expression
                Case 3
                    Return Me._commaToken
                Case 4
                    Return Me._type
                Case 5
                    Return Me._closeParenToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new DirectCastExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _keyword, _openParenToken, _expression, _commaToken, _type, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new DirectCastExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _keyword, _openParenToken, _expression, _commaToken, _type, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitDirectCastExpression(Me)
        End Function

    End Class

    Friend NotInheritable Class TryCastExpressionSyntax
        Inherits CastExpressionSyntax


        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, keyword, openParenToken, expression, commaToken, type, closeParenToken)
            Me.SlotCount = 6
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, keyword, openParenToken, expression, commaToken, type, closeParenToken)
            Me.SlotCount = 6
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, type As TypeSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations, keyword, openParenToken, expression, commaToken, type, closeParenToken)
            Me.SlotCount = 6
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TryCastExpressionSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._keyword
                Case 1
                    Return Me._openParenToken
                Case 2
                    Return Me._expression
                Case 3
                    Return Me._commaToken
                Case 4
                    Return Me._type
                Case 5
                    Return Me._closeParenToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new TryCastExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _keyword, _openParenToken, _expression, _commaToken, _type, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new TryCastExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _keyword, _openParenToken, _expression, _commaToken, _type, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitTryCastExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a cast to a pre-defined type using a pre-defined cast expression,
    ''' such as CInt or CLng.
    ''' </summary>
    Friend NotInheritable Class PredefinedCastExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _keyword as KeywordSyntax
        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _expression as ExpressionSyntax
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(keyword)
            Me._keyword = keyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 4
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(keyword)
            Me._keyword = keyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(keyword)
            Me._keyword = keyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedCastExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The keyword that was used in the cast operation.
        ''' </summary>
        Friend ReadOnly Property Keyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._keyword
            End Get
        End Property

        ''' <summary>
        ''' The "(" token.
        ''' </summary>
        Friend ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The expression being cast.
        ''' </summary>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        ''' <summary>
        ''' The ")" token.
        ''' </summary>
        Friend ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._keyword
                Case 1
                    Return Me._openParenToken
                Case 2
                    Return Me._expression
                Case 3
                    Return Me._closeParenToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new PredefinedCastExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _keyword, _openParenToken, _expression, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new PredefinedCastExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _keyword, _openParenToken, _expression, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitPredefinedCastExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a binary operator. The Kind property classifies the operators into
    ''' similar kind of operators (arithmetic, relational, logical or string); the
    ''' exact operation being performed is determined by the Operator property.
    ''' </summary>
    Friend NotInheritable Class BinaryExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _left as ExpressionSyntax
        Friend ReadOnly _operatorToken as SyntaxToken
        Friend ReadOnly _right as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, left As ExpressionSyntax, operatorToken As InternalSyntax.SyntaxToken, right As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(left)
            Me._left = left
            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken
            AdjustFlagsAndWidth(right)
            Me._right = right

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, left As ExpressionSyntax, operatorToken As InternalSyntax.SyntaxToken, right As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(left)
            Me._left = left
            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken
            AdjustFlagsAndWidth(right)
            Me._right = right

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), left As ExpressionSyntax, operatorToken As InternalSyntax.SyntaxToken, right As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(left)
            Me._left = left
            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken
            AdjustFlagsAndWidth(right)
            Me._right = right

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The left operand.
        ''' </summary>
        Friend ReadOnly Property Left As InternalSyntax.ExpressionSyntax
            Get
                Return Me._left
            End Get
        End Property

        Friend ReadOnly Property OperatorToken As InternalSyntax.SyntaxToken
            Get
                Return Me._operatorToken
            End Get
        End Property

        ''' <summary>
        ''' The right operand.
        ''' </summary>
        Friend ReadOnly Property Right As InternalSyntax.ExpressionSyntax
            Get
                Return Me._right
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._left
                Case 1
                    Return Me._operatorToken
                Case 2
                    Return Me._right
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new BinaryExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _left, _operatorToken, _right)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new BinaryExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _left, _operatorToken, _right)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitBinaryExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Describes a unary operator: Plus, Negate, Not or AddressOf.
    ''' </summary>
    Friend NotInheritable Class UnaryExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _operatorToken as SyntaxToken
        Friend ReadOnly _operand as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, operatorToken As InternalSyntax.SyntaxToken, operand As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken
            AdjustFlagsAndWidth(operand)
            Me._operand = operand

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, operatorToken As InternalSyntax.SyntaxToken, operand As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken
            AdjustFlagsAndWidth(operand)
            Me._operand = operand

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), operatorToken As InternalSyntax.SyntaxToken, operand As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken
            AdjustFlagsAndWidth(operand)
            Me._operand = operand

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The token that is the operator.
        ''' </summary>
        Friend ReadOnly Property OperatorToken As InternalSyntax.SyntaxToken
            Get
                Return Me._operatorToken
            End Get
        End Property

        ''' <summary>
        ''' The expression being operated on.
        ''' </summary>
        Friend ReadOnly Property Operand As InternalSyntax.ExpressionSyntax
            Get
                Return Me._operand
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._operatorToken
                Case 1
                    Return Me._operand
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new UnaryExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _operatorToken, _operand)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new UnaryExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _operatorToken, _operand)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitUnaryExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a conditional expression, If(condition, true-expr, false-expr) or
    ''' If(expr, nothing-expr).
    ''' </summary>
    Friend NotInheritable Class BinaryConditionalExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _ifKeyword as KeywordSyntax
        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _firstExpression as ExpressionSyntax
        Friend ReadOnly _commaToken as PunctuationSyntax
        Friend ReadOnly _secondExpression as ExpressionSyntax
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, ifKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, firstExpression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, secondExpression As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 6

            AdjustFlagsAndWidth(ifKeyword)
            Me._ifKeyword = ifKeyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(firstExpression)
            Me._firstExpression = firstExpression
            AdjustFlagsAndWidth(commaToken)
            Me._commaToken = commaToken
            AdjustFlagsAndWidth(secondExpression)
            Me._secondExpression = secondExpression
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ifKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, firstExpression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, secondExpression As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 6
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(ifKeyword)
            Me._ifKeyword = ifKeyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(firstExpression)
            Me._firstExpression = firstExpression
            AdjustFlagsAndWidth(commaToken)
            Me._commaToken = commaToken
            AdjustFlagsAndWidth(secondExpression)
            Me._secondExpression = secondExpression
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), ifKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, firstExpression As ExpressionSyntax, commaToken As InternalSyntax.PunctuationSyntax, secondExpression As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 6

            AdjustFlagsAndWidth(ifKeyword)
            Me._ifKeyword = ifKeyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(firstExpression)
            Me._firstExpression = firstExpression
            AdjustFlagsAndWidth(commaToken)
            Me._commaToken = commaToken
            AdjustFlagsAndWidth(secondExpression)
            Me._secondExpression = secondExpression
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "If" keyword
        ''' </summary>
        Friend ReadOnly Property IfKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._ifKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "(" token
        ''' </summary>
        Friend ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The first expression inside the parentheses.
        ''' </summary>
        Friend ReadOnly Property FirstExpression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._firstExpression
            End Get
        End Property

        ''' <summary>
        ''' The "," token.
        ''' </summary>
        Friend ReadOnly Property CommaToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._commaToken
            End Get
        End Property

        ''' <summary>
        ''' The second expression inside the parentheses.
        ''' </summary>
        Friend ReadOnly Property SecondExpression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._secondExpression
            End Get
        End Property

        ''' <summary>
        ''' The ")" token
        ''' </summary>
        Friend ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._ifKeyword
                Case 1
                    Return Me._openParenToken
                Case 2
                    Return Me._firstExpression
                Case 3
                    Return Me._commaToken
                Case 4
                    Return Me._secondExpression
                Case 5
                    Return Me._closeParenToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new BinaryConditionalExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _ifKeyword, _openParenToken, _firstExpression, _commaToken, _secondExpression, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new BinaryConditionalExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _ifKeyword, _openParenToken, _firstExpression, _commaToken, _secondExpression, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitBinaryConditionalExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a conditional expression, If(condition, true-expr, false-expr) or
    ''' If(expr, nothing-expr).
    ''' </summary>
    Friend NotInheritable Class TernaryConditionalExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _ifKeyword as KeywordSyntax
        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _condition as ExpressionSyntax
        Friend ReadOnly _firstCommaToken as PunctuationSyntax
        Friend ReadOnly _whenTrue as ExpressionSyntax
        Friend ReadOnly _secondCommaToken as PunctuationSyntax
        Friend ReadOnly _whenFalse as ExpressionSyntax
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, ifKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, condition As ExpressionSyntax, firstCommaToken As InternalSyntax.PunctuationSyntax, whenTrue As ExpressionSyntax, secondCommaToken As InternalSyntax.PunctuationSyntax, whenFalse As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 8

            AdjustFlagsAndWidth(ifKeyword)
            Me._ifKeyword = ifKeyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(condition)
            Me._condition = condition
            AdjustFlagsAndWidth(firstCommaToken)
            Me._firstCommaToken = firstCommaToken
            AdjustFlagsAndWidth(whenTrue)
            Me._whenTrue = whenTrue
            AdjustFlagsAndWidth(secondCommaToken)
            Me._secondCommaToken = secondCommaToken
            AdjustFlagsAndWidth(whenFalse)
            Me._whenFalse = whenFalse
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ifKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, condition As ExpressionSyntax, firstCommaToken As InternalSyntax.PunctuationSyntax, whenTrue As ExpressionSyntax, secondCommaToken As InternalSyntax.PunctuationSyntax, whenFalse As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 8
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(ifKeyword)
            Me._ifKeyword = ifKeyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(condition)
            Me._condition = condition
            AdjustFlagsAndWidth(firstCommaToken)
            Me._firstCommaToken = firstCommaToken
            AdjustFlagsAndWidth(whenTrue)
            Me._whenTrue = whenTrue
            AdjustFlagsAndWidth(secondCommaToken)
            Me._secondCommaToken = secondCommaToken
            AdjustFlagsAndWidth(whenFalse)
            Me._whenFalse = whenFalse
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), ifKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, condition As ExpressionSyntax, firstCommaToken As InternalSyntax.PunctuationSyntax, whenTrue As ExpressionSyntax, secondCommaToken As InternalSyntax.PunctuationSyntax, whenFalse As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 8

            AdjustFlagsAndWidth(ifKeyword)
            Me._ifKeyword = ifKeyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(condition)
            Me._condition = condition
            AdjustFlagsAndWidth(firstCommaToken)
            Me._firstCommaToken = firstCommaToken
            AdjustFlagsAndWidth(whenTrue)
            Me._whenTrue = whenTrue
            AdjustFlagsAndWidth(secondCommaToken)
            Me._secondCommaToken = secondCommaToken
            AdjustFlagsAndWidth(whenFalse)
            Me._whenFalse = whenFalse
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "If" keyword
        ''' </summary>
        Friend ReadOnly Property IfKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._ifKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "(" token
        ''' </summary>
        Friend ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The first expression inside the parentheses.
        ''' </summary>
        Friend ReadOnly Property Condition As InternalSyntax.ExpressionSyntax
            Get
                Return Me._condition
            End Get
        End Property

        ''' <summary>
        ''' The "," token.
        ''' </summary>
        Friend ReadOnly Property FirstCommaToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._firstCommaToken
            End Get
        End Property

        ''' <summary>
        ''' The second expression inside the parentheses.
        ''' </summary>
        Friend ReadOnly Property WhenTrue As InternalSyntax.ExpressionSyntax
            Get
                Return Me._whenTrue
            End Get
        End Property

        ''' <summary>
        ''' The "," token.
        ''' </summary>
        Friend ReadOnly Property SecondCommaToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._secondCommaToken
            End Get
        End Property

        ''' <summary>
        ''' The second expression inside the parentheses.
        ''' </summary>
        Friend ReadOnly Property WhenFalse As InternalSyntax.ExpressionSyntax
            Get
                Return Me._whenFalse
            End Get
        End Property

        ''' <summary>
        ''' The ")" token
        ''' </summary>
        Friend ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._ifKeyword
                Case 1
                    Return Me._openParenToken
                Case 2
                    Return Me._condition
                Case 3
                    Return Me._firstCommaToken
                Case 4
                    Return Me._whenTrue
                Case 5
                    Return Me._secondCommaToken
                Case 6
                    Return Me._whenFalse
                Case 7
                    Return Me._closeParenToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new TernaryConditionalExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _ifKeyword, _openParenToken, _condition, _firstCommaToken, _whenTrue, _secondCommaToken, _whenFalse, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new TernaryConditionalExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _ifKeyword, _openParenToken, _condition, _firstCommaToken, _whenTrue, _secondCommaToken, _whenFalse, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitTernaryConditionalExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a lambda expression, either single line or multi-line.
    ''' </summary>
    Friend MustInherit Class LambdaExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _subOrFunctionHeader as LambdaHeaderSyntax

        Friend Sub New(ByVal kind As SyntaxKind, subOrFunctionHeader As LambdaHeaderSyntax)
            MyBase.New(kind)

            AdjustFlagsAndWidth(subOrFunctionHeader)
            Me._subOrFunctionHeader = subOrFunctionHeader

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, subOrFunctionHeader As LambdaHeaderSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(subOrFunctionHeader)
            Me._subOrFunctionHeader = subOrFunctionHeader

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), subOrFunctionHeader As LambdaHeaderSyntax)
            MyBase.New(kind, errors, annotations)

            AdjustFlagsAndWidth(subOrFunctionHeader)
            Me._subOrFunctionHeader = subOrFunctionHeader

        End Sub

        ''' <summary>
        ''' The header part of the lambda that includes the "Sub" or "Function" keyword,
        ''' the argument list and return type.
        ''' </summary>
        Friend ReadOnly Property SubOrFunctionHeader As InternalSyntax.LambdaHeaderSyntax
            Get
                Return Me._subOrFunctionHeader
            End Get
        End Property

    End Class

    ''' <summary>
    ''' Represents a single line lambda expression.
    ''' </summary>
    Friend NotInheritable Class SingleLineLambdaExpressionSyntax
        Inherits LambdaExpressionSyntax

        Friend ReadOnly _body as VisualBasicSyntaxNode

        Friend Sub New(ByVal kind As SyntaxKind, subOrFunctionHeader As LambdaHeaderSyntax, body As VisualBasicSyntaxNode)
            MyBase.New(kind, subOrFunctionHeader)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(body)
            Me._body = body

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, subOrFunctionHeader As LambdaHeaderSyntax, body As VisualBasicSyntaxNode, context As ISyntaxFactoryContext)
            MyBase.New(kind, subOrFunctionHeader)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(body)
            Me._body = body

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), subOrFunctionHeader As LambdaHeaderSyntax, body As VisualBasicSyntaxNode)
            MyBase.New(kind, errors, annotations, subOrFunctionHeader)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(body)
            Me._body = body

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineLambdaExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The body of the lambda. Depending on the kind of lambda, this is either a
        ''' Statement (single-line Sub lambda) or Expression (single-line Function).
        ''' </summary>
        Friend ReadOnly Property Body As InternalSyntax.VisualBasicSyntaxNode
            Get
                Return Me._body
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._subOrFunctionHeader
                Case 1
                    Return Me._body
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new SingleLineLambdaExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _subOrFunctionHeader, _body)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new SingleLineLambdaExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _subOrFunctionHeader, _body)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitSingleLineLambdaExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a multi-line lambda expression.
    ''' </summary>
    Friend NotInheritable Class MultiLineLambdaExpressionSyntax
        Inherits LambdaExpressionSyntax

        Friend ReadOnly _statements as GreenNode
        Friend ReadOnly _endSubOrFunctionStatement as EndBlockStatementSyntax

        Friend Sub New(ByVal kind As SyntaxKind, subOrFunctionHeader As LambdaHeaderSyntax, statements As GreenNode, endSubOrFunctionStatement As EndBlockStatementSyntax)
            MyBase.New(kind, subOrFunctionHeader)
            Me.SlotCount = 3

            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            AdjustFlagsAndWidth(endSubOrFunctionStatement)
            Me._endSubOrFunctionStatement = endSubOrFunctionStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, subOrFunctionHeader As LambdaHeaderSyntax, statements As GreenNode, endSubOrFunctionStatement As EndBlockStatementSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, subOrFunctionHeader)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            AdjustFlagsAndWidth(endSubOrFunctionStatement)
            Me._endSubOrFunctionStatement = endSubOrFunctionStatement

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), subOrFunctionHeader As LambdaHeaderSyntax, statements As GreenNode, endSubOrFunctionStatement As EndBlockStatementSyntax)
            MyBase.New(kind, errors, annotations, subOrFunctionHeader)
            Me.SlotCount = 3

            If statements IsNot Nothing Then
                AdjustFlagsAndWidth(statements)
                Me._statements = statements
            End If
            AdjustFlagsAndWidth(endSubOrFunctionStatement)
            Me._endSubOrFunctionStatement = endSubOrFunctionStatement

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineLambdaExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The body of the lambda. Depending on the kind of lambda, this is either a
        ''' StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
        ''' Expression (single-line Function). This might be an empty list.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of StatementSyntax)(Me._statements)
            End Get
        End Property

        ''' <summary>
        ''' Returns the "End Sub" or "End Function" statement if this is a multi-line
        ''' lambda.
        ''' </summary>
        Friend ReadOnly Property EndSubOrFunctionStatement As InternalSyntax.EndBlockStatementSyntax
            Get
                Return Me._endSubOrFunctionStatement
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._subOrFunctionHeader
                Case 1
                    Return Me._statements
                Case 2
                    Return Me._endSubOrFunctionStatement
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new MultiLineLambdaExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _subOrFunctionHeader, _statements, _endSubOrFunctionStatement)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new MultiLineLambdaExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _subOrFunctionHeader, _statements, _endSubOrFunctionStatement)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitMultiLineLambdaExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the header part of a lambda expression
    ''' </summary>
    Friend NotInheritable Class LambdaHeaderSyntax
        Inherits MethodBaseSyntax

        Friend ReadOnly _subOrFunctionKeyword as KeywordSyntax
        Friend ReadOnly _asClause as SimpleAsClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, subOrFunctionKeyword As InternalSyntax.KeywordSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax)
            MyBase.New(kind, attributeLists, modifiers, parameterList)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(subOrFunctionKeyword)
            Me._subOrFunctionKeyword = subOrFunctionKeyword
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, attributeLists As GreenNode, modifiers As GreenNode, subOrFunctionKeyword As InternalSyntax.KeywordSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, attributeLists, modifiers, parameterList)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(subOrFunctionKeyword)
            Me._subOrFunctionKeyword = subOrFunctionKeyword
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), attributeLists As GreenNode, modifiers As GreenNode, subOrFunctionKeyword As InternalSyntax.KeywordSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax)
            MyBase.New(kind, errors, annotations, attributeLists, modifiers, parameterList)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(subOrFunctionKeyword)
            Me._subOrFunctionKeyword = subOrFunctionKeyword
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Sub" or "Function" keyword that introduces this lambda expression.
        ''' </summary>
        Friend ReadOnly Property SubOrFunctionKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._subOrFunctionKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property AsClause As InternalSyntax.SimpleAsClauseSyntax
            Get
                Return Me._asClause
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._attributeLists
                Case 1
                    Return Me._modifiers
                Case 2
                    Return Me._subOrFunctionKeyword
                Case 3
                    Return Me._parameterList
                Case 4
                    Return Me._asClause
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new LambdaHeaderSyntax(Me.Kind, newErrors, GetAnnotations, _attributeLists, _modifiers, _subOrFunctionKeyword, _parameterList, _asClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new LambdaHeaderSyntax(Me.Kind, GetDiagnostics, annotations, _attributeLists, _modifiers, _subOrFunctionKeyword, _parameterList, _asClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitLambdaHeader(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a parenthesized argument list.
    ''' </summary>
    Friend NotInheritable Class ArgumentListSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _arguments as GreenNode
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, arguments As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            If arguments IsNot Nothing Then
                AdjustFlagsAndWidth(arguments)
                Me._arguments = arguments
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, arguments As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            If arguments IsNot Nothing Then
                AdjustFlagsAndWidth(arguments)
                Me._arguments = arguments
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), openParenToken As InternalSyntax.PunctuationSyntax, arguments As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            If arguments IsNot Nothing Then
                AdjustFlagsAndWidth(arguments)
                Me._arguments = arguments
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "(" token.
        ''' </summary>
        Friend ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The list of arguments. This may be empty. Omitted argument are represented by
        ''' an OmittedArgumentSyntax node.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Arguments As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ArgumentSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ArgumentSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of ArgumentSyntax)(Me._arguments))
            End Get
        End Property

        ''' <summary>
        ''' The ")" token.
        ''' </summary>
        Friend ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._openParenToken
                Case 1
                    Return Me._arguments
                Case 2
                    Return Me._closeParenToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ArgumentListSyntax(Me.Kind, newErrors, GetAnnotations, _openParenToken, _arguments, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ArgumentListSyntax(Me.Kind, GetDiagnostics, annotations, _openParenToken, _arguments, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitArgumentList(Me)
        End Function

    End Class

    ''' <summary>
    ''' Base class for the possible kinds of arguments that can appear in an argument
    ''' list.
    ''' </summary>
    Friend MustInherit Class ArgumentSyntax
        Inherits VisualBasicSyntaxNode


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

    End Class

    ''' <summary>
    ''' Represents an omitted argument in an argument list. An omitted argument is not
    ''' considered a syntax error but a valid case when no argument is required.
    ''' </summary>
    Friend NotInheritable Class OmittedArgumentSyntax
        Inherits ArgumentSyntax

        Friend ReadOnly _empty as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, empty As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(empty)
            Me._empty = empty

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, empty As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(empty)
            Me._empty = empty

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), empty As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(empty)
            Me._empty = empty

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.OmittedArgumentSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' An empty token because all non terminals must have a token.
        ''' </summary>
        Friend ReadOnly Property Empty As InternalSyntax.PunctuationSyntax
            Get
                Return Me._empty
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._empty
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new OmittedArgumentSyntax(Me.Kind, newErrors, GetAnnotations, _empty)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new OmittedArgumentSyntax(Me.Kind, GetDiagnostics, annotations, _empty)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitOmittedArgument(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an argument that is just an optional argument name and an
    ''' expression.
    ''' </summary>
    Friend NotInheritable Class SimpleArgumentSyntax
        Inherits ArgumentSyntax

        Friend ReadOnly _nameColonEquals as NameColonEqualsSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, nameColonEquals As NameColonEqualsSyntax, expression As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            If nameColonEquals IsNot Nothing Then
                AdjustFlagsAndWidth(nameColonEquals)
                Me._nameColonEquals = nameColonEquals
            End If
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, nameColonEquals As NameColonEqualsSyntax, expression As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            If nameColonEquals IsNot Nothing Then
                AdjustFlagsAndWidth(nameColonEquals)
                Me._nameColonEquals = nameColonEquals
            End If
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), nameColonEquals As NameColonEqualsSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            If nameColonEquals IsNot Nothing Then
                AdjustFlagsAndWidth(nameColonEquals)
                Me._nameColonEquals = nameColonEquals
            End If
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The optional name and ":=" prefix of a named argument.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property NameColonEquals As InternalSyntax.NameColonEqualsSyntax
            Get
                Return Me._nameColonEquals
            End Get
        End Property

        ''' <summary>
        ''' The expression that is the argument.
        ''' </summary>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._nameColonEquals
                Case 1
                    Return Me._expression
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new SimpleArgumentSyntax(Me.Kind, newErrors, GetAnnotations, _nameColonEquals, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new SimpleArgumentSyntax(Me.Kind, GetDiagnostics, annotations, _nameColonEquals, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitSimpleArgument(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an identifier name followed by a ":=" token in a named argument.
    ''' </summary>
    Friend NotInheritable Class NameColonEqualsSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _name as IdentifierNameSyntax
        Friend ReadOnly _colonEqualsToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, name As IdentifierNameSyntax, colonEqualsToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(colonEqualsToken)
            Me._colonEqualsToken = colonEqualsToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, name As IdentifierNameSyntax, colonEqualsToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(colonEqualsToken)
            Me._colonEqualsToken = colonEqualsToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), name As IdentifierNameSyntax, colonEqualsToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(colonEqualsToken)
            Me._colonEqualsToken = colonEqualsToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.NameColonEqualsSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The name used to identify the named argument.
        ''' </summary>
        Friend ReadOnly Property Name As InternalSyntax.IdentifierNameSyntax
            Get
                Return Me._name
            End Get
        End Property

        ''' <summary>
        ''' The ":=" token.
        ''' </summary>
        Friend ReadOnly Property ColonEqualsToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._colonEqualsToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._name
                Case 1
                    Return Me._colonEqualsToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new NameColonEqualsSyntax(Me.Kind, newErrors, GetAnnotations, _name, _colonEqualsToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new NameColonEqualsSyntax(Me.Kind, GetDiagnostics, annotations, _name, _colonEqualsToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitNameColonEquals(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a range argument, such as "0 to 5", used in array bounds. The
    ''' "Value" property represents the upper bound of the range.
    ''' </summary>
    Friend NotInheritable Class RangeArgumentSyntax
        Inherits ArgumentSyntax

        Friend ReadOnly _lowerBound as ExpressionSyntax
        Friend ReadOnly _toKeyword as KeywordSyntax
        Friend ReadOnly _upperBound as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lowerBound As ExpressionSyntax, toKeyword As InternalSyntax.KeywordSyntax, upperBound As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(lowerBound)
            Me._lowerBound = lowerBound
            AdjustFlagsAndWidth(toKeyword)
            Me._toKeyword = toKeyword
            AdjustFlagsAndWidth(upperBound)
            Me._upperBound = upperBound

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, lowerBound As ExpressionSyntax, toKeyword As InternalSyntax.KeywordSyntax, upperBound As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(lowerBound)
            Me._lowerBound = lowerBound
            AdjustFlagsAndWidth(toKeyword)
            Me._toKeyword = toKeyword
            AdjustFlagsAndWidth(upperBound)
            Me._upperBound = upperBound

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lowerBound As ExpressionSyntax, toKeyword As InternalSyntax.KeywordSyntax, upperBound As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(lowerBound)
            Me._lowerBound = lowerBound
            AdjustFlagsAndWidth(toKeyword)
            Me._toKeyword = toKeyword
            AdjustFlagsAndWidth(upperBound)
            Me._upperBound = upperBound

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The lower bound of the range. This is typically the integer constant zero.
        ''' </summary>
        Friend ReadOnly Property LowerBound As InternalSyntax.ExpressionSyntax
            Get
                Return Me._lowerBound
            End Get
        End Property

        ''' <summary>
        ''' The "To" keyword.
        ''' </summary>
        Friend ReadOnly Property ToKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._toKeyword
            End Get
        End Property

        ''' <summary>
        ''' The upper bound of the range.
        ''' </summary>
        Friend ReadOnly Property UpperBound As InternalSyntax.ExpressionSyntax
            Get
                Return Me._upperBound
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._lowerBound
                Case 1
                    Return Me._toKeyword
                Case 2
                    Return Me._upperBound
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new RangeArgumentSyntax(Me.Kind, newErrors, GetAnnotations, _lowerBound, _toKeyword, _upperBound)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new RangeArgumentSyntax(Me.Kind, GetDiagnostics, annotations, _lowerBound, _toKeyword, _upperBound)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitRangeArgument(Me)
        End Function

    End Class

    ''' <summary>
    ''' This class represents a query expression. A query expression is composed of one
    ''' or more query operators in a row. The first query operator must be a From or
    ''' Aggregate.
    ''' </summary>
    Friend NotInheritable Class QueryExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _clauses as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, clauses As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 1

            If clauses IsNot Nothing Then
                AdjustFlagsAndWidth(clauses)
                Me._clauses = clauses
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, clauses As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            If clauses IsNot Nothing Then
                AdjustFlagsAndWidth(clauses)
                Me._clauses = clauses
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), clauses As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            If clauses IsNot Nothing Then
                AdjustFlagsAndWidth(clauses)
                Me._clauses = clauses
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' A list of all the query operators in this query expression. This list always
        ''' contains at least one operator.
        ''' </summary>
        Friend ReadOnly Property Clauses As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of QueryClauseSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of QueryClauseSyntax)(Me._clauses)
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._clauses
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new QueryExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _clauses)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new QueryExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _clauses)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitQueryExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' This is a base class for all query operators.
    ''' </summary>
    Friend MustInherit Class QueryClauseSyntax
        Inherits VisualBasicSyntaxNode


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

    End Class

    ''' <summary>
    ''' Describes a single variable of the form "x [As Type] In expression" for use in
    ''' query expressions.
    ''' </summary>
    Friend NotInheritable Class CollectionRangeVariableSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _identifier as ModifiedIdentifierSyntax
        Friend ReadOnly _asClause as SimpleAsClauseSyntax
        Friend ReadOnly _inKeyword as KeywordSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, inKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            AdjustFlagsAndWidth(inKeyword)
            Me._inKeyword = inKeyword
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, inKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 4
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            AdjustFlagsAndWidth(inKeyword)
            Me._inKeyword = inKeyword
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, inKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            AdjustFlagsAndWidth(inKeyword)
            Me._inKeyword = inKeyword
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The name of the range variable being defined.
        ''' </summary>
        Friend ReadOnly Property Identifier As InternalSyntax.ModifiedIdentifierSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' Describes the type of the variable being defined.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property AsClause As InternalSyntax.SimpleAsClauseSyntax
            Get
                Return Me._asClause
            End Get
        End Property

        ''' <summary>
        ''' The "In" keyword.
        ''' </summary>
        Friend ReadOnly Property InKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._inKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression that serves as the source of items for the range variable.
        ''' </summary>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._identifier
                Case 1
                    Return Me._asClause
                Case 2
                    Return Me._inKeyword
                Case 3
                    Return Me._expression
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new CollectionRangeVariableSyntax(Me.Kind, newErrors, GetAnnotations, _identifier, _asClause, _inKeyword, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new CollectionRangeVariableSyntax(Me.Kind, GetDiagnostics, annotations, _identifier, _asClause, _inKeyword, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitCollectionRangeVariable(Me)
        End Function

    End Class

    ''' <summary>
    ''' Describes a single variable of the form "[x [As Type] =] expression" for use in
    ''' query expressions.
    ''' </summary>
    Friend NotInheritable Class ExpressionRangeVariableSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _nameEquals as VariableNameEqualsSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, nameEquals As VariableNameEqualsSyntax, expression As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            If nameEquals IsNot Nothing Then
                AdjustFlagsAndWidth(nameEquals)
                Me._nameEquals = nameEquals
            End If
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, nameEquals As VariableNameEqualsSyntax, expression As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            If nameEquals IsNot Nothing Then
                AdjustFlagsAndWidth(nameEquals)
                Me._nameEquals = nameEquals
            End If
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), nameEquals As VariableNameEqualsSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            If nameEquals IsNot Nothing Then
                AdjustFlagsAndWidth(nameEquals)
                Me._nameEquals = nameEquals
            End If
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The optional name and type of the expression range variable. If omitted, the
        ''' name of the expression range variable is inferred from the expression.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property NameEquals As InternalSyntax.VariableNameEqualsSyntax
            Get
                Return Me._nameEquals
            End Get
        End Property

        ''' <summary>
        ''' The expression used to initialize the expression variable.
        ''' </summary>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._nameEquals
                Case 1
                    Return Me._expression
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ExpressionRangeVariableSyntax(Me.Kind, newErrors, GetAnnotations, _nameEquals, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ExpressionRangeVariableSyntax(Me.Kind, GetDiagnostics, annotations, _nameEquals, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitExpressionRangeVariable(Me)
        End Function

    End Class

    ''' <summary>
    ''' Describes a single variable of the form "[x [As Type] =] aggregation-function"
    ''' for use in the Into clause of Aggregate or Group By or Group Join query
    ''' operators.
    ''' </summary>
    Friend NotInheritable Class AggregationRangeVariableSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _nameEquals as VariableNameEqualsSyntax
        Friend ReadOnly _aggregation as AggregationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, nameEquals As VariableNameEqualsSyntax, aggregation As AggregationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            If nameEquals IsNot Nothing Then
                AdjustFlagsAndWidth(nameEquals)
                Me._nameEquals = nameEquals
            End If
            AdjustFlagsAndWidth(aggregation)
            Me._aggregation = aggregation

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, nameEquals As VariableNameEqualsSyntax, aggregation As AggregationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            If nameEquals IsNot Nothing Then
                AdjustFlagsAndWidth(nameEquals)
                Me._nameEquals = nameEquals
            End If
            AdjustFlagsAndWidth(aggregation)
            Me._aggregation = aggregation

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), nameEquals As VariableNameEqualsSyntax, aggregation As AggregationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            If nameEquals IsNot Nothing Then
                AdjustFlagsAndWidth(nameEquals)
                Me._nameEquals = nameEquals
            End If
            AdjustFlagsAndWidth(aggregation)
            Me._aggregation = aggregation

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The optional name and type of the expression range variable. If omitted, the
        ''' name of the expression range variable is inferred from the aggregation
        ''' expression.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property NameEquals As InternalSyntax.VariableNameEqualsSyntax
            Get
                Return Me._nameEquals
            End Get
        End Property

        ''' <summary>
        ''' The name of the aggregation function. The "Group" aggregation function is
        ''' represented by the identifier "Group".
        ''' </summary>
        Friend ReadOnly Property Aggregation As InternalSyntax.AggregationSyntax
            Get
                Return Me._aggregation
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._nameEquals
                Case 1
                    Return Me._aggregation
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new AggregationRangeVariableSyntax(Me.Kind, newErrors, GetAnnotations, _nameEquals, _aggregation)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new AggregationRangeVariableSyntax(Me.Kind, GetDiagnostics, annotations, _nameEquals, _aggregation)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitAggregationRangeVariable(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the name and optional type of an expression range variable.
    ''' </summary>
    Friend NotInheritable Class VariableNameEqualsSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _identifier as ModifiedIdentifierSyntax
        Friend ReadOnly _asClause as SimpleAsClauseSyntax
        Friend ReadOnly _equalsToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, equalsToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, equalsToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, equalsToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If
            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The name of the variable being defined.
        ''' </summary>
        Friend ReadOnly Property Identifier As InternalSyntax.ModifiedIdentifierSyntax
            Get
                Return Me._identifier
            End Get
        End Property

        ''' <summary>
        ''' Describes the type of the variable being defined.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property AsClause As InternalSyntax.SimpleAsClauseSyntax
            Get
                Return Me._asClause
            End Get
        End Property

        ''' <summary>
        ''' The "=" token.
        ''' </summary>
        Friend ReadOnly Property EqualsToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._equalsToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._identifier
                Case 1
                    Return Me._asClause
                Case 2
                    Return Me._equalsToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new VariableNameEqualsSyntax(Me.Kind, newErrors, GetAnnotations, _identifier, _asClause, _equalsToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new VariableNameEqualsSyntax(Me.Kind, GetDiagnostics, annotations, _identifier, _asClause, _equalsToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitVariableNameEquals(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents aggregation in aggregation range variable declaration of a Group By,
    ''' Group Join or Aggregate query operator.
    ''' </summary>
    Friend MustInherit Class AggregationSyntax
        Inherits ExpressionSyntax


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

    End Class

    ''' <summary>
    ''' Represents an invocation of an Aggregation function in the aggregation range
    ''' variable declaration of a Group By, Group Join or Aggregate query operator.
    ''' </summary>
    Friend NotInheritable Class FunctionAggregationSyntax
        Inherits AggregationSyntax

        Friend ReadOnly _functionName as IdentifierTokenSyntax
        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _argument as ExpressionSyntax
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, functionName As InternalSyntax.IdentifierTokenSyntax, openParenToken As InternalSyntax.PunctuationSyntax, argument As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(functionName)
            Me._functionName = functionName
            If openParenToken IsNot Nothing Then
                AdjustFlagsAndWidth(openParenToken)
                Me._openParenToken = openParenToken
            End If
            If argument IsNot Nothing Then
                AdjustFlagsAndWidth(argument)
                Me._argument = argument
            End If
            If closeParenToken IsNot Nothing Then
                AdjustFlagsAndWidth(closeParenToken)
                Me._closeParenToken = closeParenToken
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, functionName As InternalSyntax.IdentifierTokenSyntax, openParenToken As InternalSyntax.PunctuationSyntax, argument As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 4
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(functionName)
            Me._functionName = functionName
            If openParenToken IsNot Nothing Then
                AdjustFlagsAndWidth(openParenToken)
                Me._openParenToken = openParenToken
            End If
            If argument IsNot Nothing Then
                AdjustFlagsAndWidth(argument)
                Me._argument = argument
            End If
            If closeParenToken IsNot Nothing Then
                AdjustFlagsAndWidth(closeParenToken)
                Me._closeParenToken = closeParenToken
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), functionName As InternalSyntax.IdentifierTokenSyntax, openParenToken As InternalSyntax.PunctuationSyntax, argument As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(functionName)
            Me._functionName = functionName
            If openParenToken IsNot Nothing Then
                AdjustFlagsAndWidth(openParenToken)
                Me._openParenToken = openParenToken
            End If
            If argument IsNot Nothing Then
                AdjustFlagsAndWidth(argument)
                Me._argument = argument
            End If
            If closeParenToken IsNot Nothing Then
                AdjustFlagsAndWidth(closeParenToken)
                Me._closeParenToken = closeParenToken
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The name of the aggregation function.
        ''' </summary>
        Friend ReadOnly Property FunctionName As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._functionName
            End Get
        End Property

        ''' <summary>
        ''' The "(" token if present.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The argument to the aggregation function.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Argument As InternalSyntax.ExpressionSyntax
            Get
                Return Me._argument
            End Get
        End Property

        ''' <summary>
        ''' The ")" token, if present.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._functionName
                Case 1
                    Return Me._openParenToken
                Case 2
                    Return Me._argument
                Case 3
                    Return Me._closeParenToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new FunctionAggregationSyntax(Me.Kind, newErrors, GetAnnotations, _functionName, _openParenToken, _argument, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new FunctionAggregationSyntax(Me.Kind, GetDiagnostics, annotations, _functionName, _openParenToken, _argument, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitFunctionAggregation(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the use of "Group" as the aggregation function in the in the
    ''' aggregation range variable declaration of a Group By or Group Join query
    ''' operator.
    ''' </summary>
    Friend NotInheritable Class GroupAggregationSyntax
        Inherits AggregationSyntax

        Friend ReadOnly _groupKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, groupKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(groupKeyword)
            Me._groupKeyword = groupKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, groupKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(groupKeyword)
            Me._groupKeyword = groupKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), groupKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(groupKeyword)
            Me._groupKeyword = groupKeyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupAggregationSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Group" keyword.
        ''' </summary>
        Friend ReadOnly Property GroupKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._groupKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._groupKeyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new GroupAggregationSyntax(Me.Kind, newErrors, GetAnnotations, _groupKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new GroupAggregationSyntax(Me.Kind, GetDiagnostics, annotations, _groupKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitGroupAggregation(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "From" query operator. If this is the beginning of a query, the
    ''' Source will be Nothing. Otherwise, the Source will be the part of the query to
    ''' the left of the From.
    ''' </summary>
    Friend NotInheritable Class FromClauseSyntax
        Inherits QueryClauseSyntax

        Friend ReadOnly _fromKeyword as KeywordSyntax
        Friend ReadOnly _variables as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, fromKeyword As InternalSyntax.KeywordSyntax, variables As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(fromKeyword)
            Me._fromKeyword = fromKeyword
            If variables IsNot Nothing Then
                AdjustFlagsAndWidth(variables)
                Me._variables = variables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, fromKeyword As InternalSyntax.KeywordSyntax, variables As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(fromKeyword)
            Me._fromKeyword = fromKeyword
            If variables IsNot Nothing Then
                AdjustFlagsAndWidth(variables)
                Me._variables = variables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), fromKeyword As InternalSyntax.KeywordSyntax, variables As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(fromKeyword)
            Me._fromKeyword = fromKeyword
            If variables IsNot Nothing Then
                AdjustFlagsAndWidth(variables)
                Me._variables = variables
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "From" keyword.
        ''' </summary>
        Friend ReadOnly Property FromKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._fromKeyword
            End Get
        End Property

        ''' <summary>
        ''' The list of collection variables declared by this From operator.
        ''' </summary>
        Friend ReadOnly Property Variables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of CollectionRangeVariableSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of CollectionRangeVariableSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of CollectionRangeVariableSyntax)(Me._variables))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._fromKeyword
                Case 1
                    Return Me._variables
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new FromClauseSyntax(Me.Kind, newErrors, GetAnnotations, _fromKeyword, _variables)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new FromClauseSyntax(Me.Kind, GetDiagnostics, annotations, _fromKeyword, _variables)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitFromClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "Let" query operator.
    ''' </summary>
    Friend NotInheritable Class LetClauseSyntax
        Inherits QueryClauseSyntax

        Friend ReadOnly _letKeyword as KeywordSyntax
        Friend ReadOnly _variables as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, letKeyword As InternalSyntax.KeywordSyntax, variables As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(letKeyword)
            Me._letKeyword = letKeyword
            If variables IsNot Nothing Then
                AdjustFlagsAndWidth(variables)
                Me._variables = variables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, letKeyword As InternalSyntax.KeywordSyntax, variables As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(letKeyword)
            Me._letKeyword = letKeyword
            If variables IsNot Nothing Then
                AdjustFlagsAndWidth(variables)
                Me._variables = variables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), letKeyword As InternalSyntax.KeywordSyntax, variables As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(letKeyword)
            Me._letKeyword = letKeyword
            If variables IsNot Nothing Then
                AdjustFlagsAndWidth(variables)
                Me._variables = variables
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Let" keyword.
        ''' </summary>
        Friend ReadOnly Property LetKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._letKeyword
            End Get
        End Property

        ''' <summary>
        ''' The list of expression range variable being defined by the Let operator.
        ''' </summary>
        Friend ReadOnly Property Variables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ExpressionRangeVariableSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ExpressionRangeVariableSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of ExpressionRangeVariableSyntax)(Me._variables))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._letKeyword
                Case 1
                    Return Me._variables
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new LetClauseSyntax(Me.Kind, newErrors, GetAnnotations, _letKeyword, _variables)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new LetClauseSyntax(Me.Kind, GetDiagnostics, annotations, _letKeyword, _variables)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitLetClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an Aggregate query operator.
    ''' </summary>
    Friend NotInheritable Class AggregateClauseSyntax
        Inherits QueryClauseSyntax

        Friend ReadOnly _aggregateKeyword as KeywordSyntax
        Friend ReadOnly _variables as GreenNode
        Friend ReadOnly _additionalQueryOperators as GreenNode
        Friend ReadOnly _intoKeyword as KeywordSyntax
        Friend ReadOnly _aggregationVariables as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, aggregateKeyword As InternalSyntax.KeywordSyntax, variables As GreenNode, additionalQueryOperators As GreenNode, intoKeyword As InternalSyntax.KeywordSyntax, aggregationVariables As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(aggregateKeyword)
            Me._aggregateKeyword = aggregateKeyword
            If variables IsNot Nothing Then
                AdjustFlagsAndWidth(variables)
                Me._variables = variables
            End If
            If additionalQueryOperators IsNot Nothing Then
                AdjustFlagsAndWidth(additionalQueryOperators)
                Me._additionalQueryOperators = additionalQueryOperators
            End If
            AdjustFlagsAndWidth(intoKeyword)
            Me._intoKeyword = intoKeyword
            If aggregationVariables IsNot Nothing Then
                AdjustFlagsAndWidth(aggregationVariables)
                Me._aggregationVariables = aggregationVariables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, aggregateKeyword As InternalSyntax.KeywordSyntax, variables As GreenNode, additionalQueryOperators As GreenNode, intoKeyword As InternalSyntax.KeywordSyntax, aggregationVariables As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(aggregateKeyword)
            Me._aggregateKeyword = aggregateKeyword
            If variables IsNot Nothing Then
                AdjustFlagsAndWidth(variables)
                Me._variables = variables
            End If
            If additionalQueryOperators IsNot Nothing Then
                AdjustFlagsAndWidth(additionalQueryOperators)
                Me._additionalQueryOperators = additionalQueryOperators
            End If
            AdjustFlagsAndWidth(intoKeyword)
            Me._intoKeyword = intoKeyword
            If aggregationVariables IsNot Nothing Then
                AdjustFlagsAndWidth(aggregationVariables)
                Me._aggregationVariables = aggregationVariables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), aggregateKeyword As InternalSyntax.KeywordSyntax, variables As GreenNode, additionalQueryOperators As GreenNode, intoKeyword As InternalSyntax.KeywordSyntax, aggregationVariables As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(aggregateKeyword)
            Me._aggregateKeyword = aggregateKeyword
            If variables IsNot Nothing Then
                AdjustFlagsAndWidth(variables)
                Me._variables = variables
            End If
            If additionalQueryOperators IsNot Nothing Then
                AdjustFlagsAndWidth(additionalQueryOperators)
                Me._additionalQueryOperators = additionalQueryOperators
            End If
            AdjustFlagsAndWidth(intoKeyword)
            Me._intoKeyword = intoKeyword
            If aggregationVariables IsNot Nothing Then
                AdjustFlagsAndWidth(aggregationVariables)
                Me._aggregationVariables = aggregationVariables
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Aggregate" keyword.
        ''' </summary>
        Friend ReadOnly Property AggregateKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._aggregateKeyword
            End Get
        End Property

        ''' <summary>
        ''' The list of collection range variables declared by this Aggregate operator.
        ''' </summary>
        Friend ReadOnly Property Variables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of CollectionRangeVariableSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of CollectionRangeVariableSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of CollectionRangeVariableSyntax)(Me._variables))
            End Get
        End Property

        ''' <summary>
        ''' A list of additional query operators. It may be empty.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property AdditionalQueryOperators As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of QueryClauseSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of QueryClauseSyntax)(Me._additionalQueryOperators)
            End Get
        End Property

        ''' <summary>
        ''' The "Into" keyword.
        ''' </summary>
        Friend ReadOnly Property IntoKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._intoKeyword
            End Get
        End Property

        ''' <summary>
        ''' The list of new variables being defined by the aggregation.
        ''' </summary>
        Friend ReadOnly Property AggregationVariables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of AggregationRangeVariableSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of AggregationRangeVariableSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of AggregationRangeVariableSyntax)(Me._aggregationVariables))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._aggregateKeyword
                Case 1
                    Return Me._variables
                Case 2
                    Return Me._additionalQueryOperators
                Case 3
                    Return Me._intoKeyword
                Case 4
                    Return Me._aggregationVariables
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new AggregateClauseSyntax(Me.Kind, newErrors, GetAnnotations, _aggregateKeyword, _variables, _additionalQueryOperators, _intoKeyword, _aggregationVariables)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new AggregateClauseSyntax(Me.Kind, GetDiagnostics, annotations, _aggregateKeyword, _variables, _additionalQueryOperators, _intoKeyword, _aggregationVariables)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitAggregateClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "Distinct" query operator.
    ''' </summary>
    Friend NotInheritable Class DistinctClauseSyntax
        Inherits QueryClauseSyntax

        Friend ReadOnly _distinctKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, distinctKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(distinctKeyword)
            Me._distinctKeyword = distinctKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, distinctKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(distinctKeyword)
            Me._distinctKeyword = distinctKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), distinctKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(distinctKeyword)
            Me._distinctKeyword = distinctKeyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DistinctClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Distinct" keyword.
        ''' </summary>
        Friend ReadOnly Property DistinctKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._distinctKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._distinctKeyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new DistinctClauseSyntax(Me.Kind, newErrors, GetAnnotations, _distinctKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new DistinctClauseSyntax(Me.Kind, GetDiagnostics, annotations, _distinctKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitDistinctClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "Where" query operator.
    ''' </summary>
    Friend NotInheritable Class WhereClauseSyntax
        Inherits QueryClauseSyntax

        Friend ReadOnly _whereKeyword as KeywordSyntax
        Friend ReadOnly _condition as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, whereKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(whereKeyword)
            Me._whereKeyword = whereKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, whereKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(whereKeyword)
            Me._whereKeyword = whereKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), whereKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(whereKeyword)
            Me._whereKeyword = whereKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.WhereClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Where" keyword.
        ''' </summary>
        Friend ReadOnly Property WhereKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._whereKeyword
            End Get
        End Property

        ''' <summary>
        ''' The boolean expression used for filtering.
        ''' </summary>
        Friend ReadOnly Property Condition As InternalSyntax.ExpressionSyntax
            Get
                Return Me._condition
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._whereKeyword
                Case 1
                    Return Me._condition
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new WhereClauseSyntax(Me.Kind, newErrors, GetAnnotations, _whereKeyword, _condition)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new WhereClauseSyntax(Me.Kind, GetDiagnostics, annotations, _whereKeyword, _condition)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitWhereClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "Skip While" or "Take While" query operator. The Kind property
    ''' tells which.
    ''' </summary>
    Friend NotInheritable Class PartitionWhileClauseSyntax
        Inherits QueryClauseSyntax

        Friend ReadOnly _skipOrTakeKeyword as KeywordSyntax
        Friend ReadOnly _whileKeyword as KeywordSyntax
        Friend ReadOnly _condition as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, skipOrTakeKeyword As InternalSyntax.KeywordSyntax, whileKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(skipOrTakeKeyword)
            Me._skipOrTakeKeyword = skipOrTakeKeyword
            AdjustFlagsAndWidth(whileKeyword)
            Me._whileKeyword = whileKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, skipOrTakeKeyword As InternalSyntax.KeywordSyntax, whileKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(skipOrTakeKeyword)
            Me._skipOrTakeKeyword = skipOrTakeKeyword
            AdjustFlagsAndWidth(whileKeyword)
            Me._whileKeyword = whileKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), skipOrTakeKeyword As InternalSyntax.KeywordSyntax, whileKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(skipOrTakeKeyword)
            Me._skipOrTakeKeyword = skipOrTakeKeyword
            AdjustFlagsAndWidth(whileKeyword)
            Me._whileKeyword = whileKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Skip" or "Take" keyword.
        ''' </summary>
        Friend ReadOnly Property SkipOrTakeKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._skipOrTakeKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "While" keyword.
        ''' </summary>
        Friend ReadOnly Property WhileKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._whileKeyword
            End Get
        End Property

        ''' <summary>
        ''' The boolean expression used for partitioning.
        ''' </summary>
        Friend ReadOnly Property Condition As InternalSyntax.ExpressionSyntax
            Get
                Return Me._condition
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._skipOrTakeKeyword
                Case 1
                    Return Me._whileKeyword
                Case 2
                    Return Me._condition
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new PartitionWhileClauseSyntax(Me.Kind, newErrors, GetAnnotations, _skipOrTakeKeyword, _whileKeyword, _condition)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new PartitionWhileClauseSyntax(Me.Kind, GetDiagnostics, annotations, _skipOrTakeKeyword, _whileKeyword, _condition)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitPartitionWhileClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a "Skip" or "Take" query operator. The Kind property tells which.
    ''' </summary>
    Friend NotInheritable Class PartitionClauseSyntax
        Inherits QueryClauseSyntax

        Friend ReadOnly _skipOrTakeKeyword as KeywordSyntax
        Friend ReadOnly _count as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, skipOrTakeKeyword As InternalSyntax.KeywordSyntax, count As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(skipOrTakeKeyword)
            Me._skipOrTakeKeyword = skipOrTakeKeyword
            AdjustFlagsAndWidth(count)
            Me._count = count

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, skipOrTakeKeyword As InternalSyntax.KeywordSyntax, count As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(skipOrTakeKeyword)
            Me._skipOrTakeKeyword = skipOrTakeKeyword
            AdjustFlagsAndWidth(count)
            Me._count = count

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), skipOrTakeKeyword As InternalSyntax.KeywordSyntax, count As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(skipOrTakeKeyword)
            Me._skipOrTakeKeyword = skipOrTakeKeyword
            AdjustFlagsAndWidth(count)
            Me._count = count

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Skip" or "Take" keyword.
        ''' </summary>
        Friend ReadOnly Property SkipOrTakeKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._skipOrTakeKeyword
            End Get
        End Property

        ''' <summary>
        ''' Represents the expression with the number of items to take or skip.
        ''' </summary>
        Friend ReadOnly Property Count As InternalSyntax.ExpressionSyntax
            Get
                Return Me._count
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._skipOrTakeKeyword
                Case 1
                    Return Me._count
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new PartitionClauseSyntax(Me.Kind, newErrors, GetAnnotations, _skipOrTakeKeyword, _count)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new PartitionClauseSyntax(Me.Kind, GetDiagnostics, annotations, _skipOrTakeKeyword, _count)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitPartitionClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "Group By" query operator.
    ''' </summary>
    Friend NotInheritable Class GroupByClauseSyntax
        Inherits QueryClauseSyntax

        Friend ReadOnly _groupKeyword as KeywordSyntax
        Friend ReadOnly _items as GreenNode
        Friend ReadOnly _byKeyword as KeywordSyntax
        Friend ReadOnly _keys as GreenNode
        Friend ReadOnly _intoKeyword as KeywordSyntax
        Friend ReadOnly _aggregationVariables as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, groupKeyword As InternalSyntax.KeywordSyntax, items As GreenNode, byKeyword As InternalSyntax.KeywordSyntax, keys As GreenNode, intoKeyword As InternalSyntax.KeywordSyntax, aggregationVariables As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 6

            AdjustFlagsAndWidth(groupKeyword)
            Me._groupKeyword = groupKeyword
            If items IsNot Nothing Then
                AdjustFlagsAndWidth(items)
                Me._items = items
            End If
            AdjustFlagsAndWidth(byKeyword)
            Me._byKeyword = byKeyword
            If keys IsNot Nothing Then
                AdjustFlagsAndWidth(keys)
                Me._keys = keys
            End If
            AdjustFlagsAndWidth(intoKeyword)
            Me._intoKeyword = intoKeyword
            If aggregationVariables IsNot Nothing Then
                AdjustFlagsAndWidth(aggregationVariables)
                Me._aggregationVariables = aggregationVariables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, groupKeyword As InternalSyntax.KeywordSyntax, items As GreenNode, byKeyword As InternalSyntax.KeywordSyntax, keys As GreenNode, intoKeyword As InternalSyntax.KeywordSyntax, aggregationVariables As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 6
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(groupKeyword)
            Me._groupKeyword = groupKeyword
            If items IsNot Nothing Then
                AdjustFlagsAndWidth(items)
                Me._items = items
            End If
            AdjustFlagsAndWidth(byKeyword)
            Me._byKeyword = byKeyword
            If keys IsNot Nothing Then
                AdjustFlagsAndWidth(keys)
                Me._keys = keys
            End If
            AdjustFlagsAndWidth(intoKeyword)
            Me._intoKeyword = intoKeyword
            If aggregationVariables IsNot Nothing Then
                AdjustFlagsAndWidth(aggregationVariables)
                Me._aggregationVariables = aggregationVariables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), groupKeyword As InternalSyntax.KeywordSyntax, items As GreenNode, byKeyword As InternalSyntax.KeywordSyntax, keys As GreenNode, intoKeyword As InternalSyntax.KeywordSyntax, aggregationVariables As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 6

            AdjustFlagsAndWidth(groupKeyword)
            Me._groupKeyword = groupKeyword
            If items IsNot Nothing Then
                AdjustFlagsAndWidth(items)
                Me._items = items
            End If
            AdjustFlagsAndWidth(byKeyword)
            Me._byKeyword = byKeyword
            If keys IsNot Nothing Then
                AdjustFlagsAndWidth(keys)
                Me._keys = keys
            End If
            AdjustFlagsAndWidth(intoKeyword)
            Me._intoKeyword = intoKeyword
            If aggregationVariables IsNot Nothing Then
                AdjustFlagsAndWidth(aggregationVariables)
                Me._aggregationVariables = aggregationVariables
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Group" keyword.
        ''' </summary>
        Friend ReadOnly Property GroupKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._groupKeyword
            End Get
        End Property

        ''' <summary>
        ''' The optional list of variables being grouped; the contents of the Group clause.
        ''' If none were specified, an empty list is returned.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Items As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ExpressionRangeVariableSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ExpressionRangeVariableSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of ExpressionRangeVariableSyntax)(Me._items))
            End Get
        End Property

        ''' <summary>
        ''' The "By" keyword.
        ''' </summary>
        Friend ReadOnly Property ByKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._byKeyword
            End Get
        End Property

        ''' <summary>
        ''' The key values being used for grouping.
        ''' </summary>
        Friend ReadOnly Property Keys As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ExpressionRangeVariableSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ExpressionRangeVariableSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of ExpressionRangeVariableSyntax)(Me._keys))
            End Get
        End Property

        Friend ReadOnly Property IntoKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._intoKeyword
            End Get
        End Property

        ''' <summary>
        ''' The list of new variables that calculate aggregations.
        ''' </summary>
        Friend ReadOnly Property AggregationVariables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of AggregationRangeVariableSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of AggregationRangeVariableSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of AggregationRangeVariableSyntax)(Me._aggregationVariables))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._groupKeyword
                Case 1
                    Return Me._items
                Case 2
                    Return Me._byKeyword
                Case 3
                    Return Me._keys
                Case 4
                    Return Me._intoKeyword
                Case 5
                    Return Me._aggregationVariables
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new GroupByClauseSyntax(Me.Kind, newErrors, GetAnnotations, _groupKeyword, _items, _byKeyword, _keys, _intoKeyword, _aggregationVariables)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new GroupByClauseSyntax(Me.Kind, GetDiagnostics, annotations, _groupKeyword, _items, _byKeyword, _keys, _intoKeyword, _aggregationVariables)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitGroupByClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a Join or a Group Join query operator.
    ''' </summary>
    Friend MustInherit Class JoinClauseSyntax
        Inherits QueryClauseSyntax

        Friend ReadOnly _joinKeyword as KeywordSyntax
        Friend ReadOnly _joinedVariables as GreenNode
        Friend ReadOnly _additionalJoins as GreenNode
        Friend ReadOnly _onKeyword as KeywordSyntax
        Friend ReadOnly _joinConditions as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, joinKeyword As InternalSyntax.KeywordSyntax, joinedVariables As GreenNode, additionalJoins As GreenNode, onKeyword As InternalSyntax.KeywordSyntax, joinConditions As GreenNode)
            MyBase.New(kind)

            AdjustFlagsAndWidth(joinKeyword)
            Me._joinKeyword = joinKeyword
            If joinedVariables IsNot Nothing Then
                AdjustFlagsAndWidth(joinedVariables)
                Me._joinedVariables = joinedVariables
            End If
            If additionalJoins IsNot Nothing Then
                AdjustFlagsAndWidth(additionalJoins)
                Me._additionalJoins = additionalJoins
            End If
            AdjustFlagsAndWidth(onKeyword)
            Me._onKeyword = onKeyword
            If joinConditions IsNot Nothing Then
                AdjustFlagsAndWidth(joinConditions)
                Me._joinConditions = joinConditions
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, joinKeyword As InternalSyntax.KeywordSyntax, joinedVariables As GreenNode, additionalJoins As GreenNode, onKeyword As InternalSyntax.KeywordSyntax, joinConditions As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(joinKeyword)
            Me._joinKeyword = joinKeyword
            If joinedVariables IsNot Nothing Then
                AdjustFlagsAndWidth(joinedVariables)
                Me._joinedVariables = joinedVariables
            End If
            If additionalJoins IsNot Nothing Then
                AdjustFlagsAndWidth(additionalJoins)
                Me._additionalJoins = additionalJoins
            End If
            AdjustFlagsAndWidth(onKeyword)
            Me._onKeyword = onKeyword
            If joinConditions IsNot Nothing Then
                AdjustFlagsAndWidth(joinConditions)
                Me._joinConditions = joinConditions
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), joinKeyword As InternalSyntax.KeywordSyntax, joinedVariables As GreenNode, additionalJoins As GreenNode, onKeyword As InternalSyntax.KeywordSyntax, joinConditions As GreenNode)
            MyBase.New(kind, errors, annotations)

            AdjustFlagsAndWidth(joinKeyword)
            Me._joinKeyword = joinKeyword
            If joinedVariables IsNot Nothing Then
                AdjustFlagsAndWidth(joinedVariables)
                Me._joinedVariables = joinedVariables
            End If
            If additionalJoins IsNot Nothing Then
                AdjustFlagsAndWidth(additionalJoins)
                Me._additionalJoins = additionalJoins
            End If
            AdjustFlagsAndWidth(onKeyword)
            Me._onKeyword = onKeyword
            If joinConditions IsNot Nothing Then
                AdjustFlagsAndWidth(joinConditions)
                Me._joinConditions = joinConditions
            End If

        End Sub

        ''' <summary>
        ''' The "Join" keyword.
        ''' </summary>
        Friend ReadOnly Property JoinKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._joinKeyword
            End Get
        End Property

        ''' <summary>
        ''' Defines the collection range variables being joined to.
        ''' </summary>
        Friend ReadOnly Property JoinedVariables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of CollectionRangeVariableSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of CollectionRangeVariableSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of CollectionRangeVariableSyntax)(Me._joinedVariables))
            End Get
        End Property

        ''' <summary>
        ''' An additional Join or Group Join query operator.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property AdditionalJoins As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of JoinClauseSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of JoinClauseSyntax)(Me._additionalJoins)
            End Get
        End Property

        ''' <summary>
        ''' The "On" keyword.
        ''' </summary>
        Friend ReadOnly Property OnKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._onKeyword
            End Get
        End Property

        ''' <summary>
        ''' The conditions indicating what expressions to compare during the join. Each
        ''' condition is a JoinCondition, and the separators are "And" keywords.
        ''' </summary>
        Friend ReadOnly Property JoinConditions As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of JoinConditionSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of JoinConditionSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of JoinConditionSyntax)(Me._joinConditions))
            End Get
        End Property

    End Class

    ''' <summary>
    ''' Represents the "expression Equals expression" condition in a Join.
    ''' </summary>
    Friend NotInheritable Class JoinConditionSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _left as ExpressionSyntax
        Friend ReadOnly _equalsKeyword as KeywordSyntax
        Friend ReadOnly _right as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, left As ExpressionSyntax, equalsKeyword As InternalSyntax.KeywordSyntax, right As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(left)
            Me._left = left
            AdjustFlagsAndWidth(equalsKeyword)
            Me._equalsKeyword = equalsKeyword
            AdjustFlagsAndWidth(right)
            Me._right = right

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, left As ExpressionSyntax, equalsKeyword As InternalSyntax.KeywordSyntax, right As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(left)
            Me._left = left
            AdjustFlagsAndWidth(equalsKeyword)
            Me._equalsKeyword = equalsKeyword
            AdjustFlagsAndWidth(right)
            Me._right = right

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), left As ExpressionSyntax, equalsKeyword As InternalSyntax.KeywordSyntax, right As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(left)
            Me._left = left
            AdjustFlagsAndWidth(equalsKeyword)
            Me._equalsKeyword = equalsKeyword
            AdjustFlagsAndWidth(right)
            Me._right = right

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The left expression in the Join condition.
        ''' </summary>
        Friend ReadOnly Property Left As InternalSyntax.ExpressionSyntax
            Get
                Return Me._left
            End Get
        End Property

        ''' <summary>
        ''' The "Equals" keyword.
        ''' </summary>
        Friend ReadOnly Property EqualsKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._equalsKeyword
            End Get
        End Property

        ''' <summary>
        ''' The right expression in the Join condition.
        ''' </summary>
        Friend ReadOnly Property Right As InternalSyntax.ExpressionSyntax
            Get
                Return Me._right
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._left
                Case 1
                    Return Me._equalsKeyword
                Case 2
                    Return Me._right
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new JoinConditionSyntax(Me.Kind, newErrors, GetAnnotations, _left, _equalsKeyword, _right)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new JoinConditionSyntax(Me.Kind, GetDiagnostics, annotations, _left, _equalsKeyword, _right)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitJoinCondition(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a Join query operator.
    ''' </summary>
    Friend NotInheritable Class SimpleJoinClauseSyntax
        Inherits JoinClauseSyntax


        Friend Sub New(ByVal kind As SyntaxKind, joinKeyword As InternalSyntax.KeywordSyntax, joinedVariables As GreenNode, additionalJoins As GreenNode, onKeyword As InternalSyntax.KeywordSyntax, joinConditions As GreenNode)
            MyBase.New(kind, joinKeyword, joinedVariables, additionalJoins, onKeyword, joinConditions)
            Me.SlotCount = 5
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, joinKeyword As InternalSyntax.KeywordSyntax, joinedVariables As GreenNode, additionalJoins As GreenNode, onKeyword As InternalSyntax.KeywordSyntax, joinConditions As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind, joinKeyword, joinedVariables, additionalJoins, onKeyword, joinConditions)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), joinKeyword As InternalSyntax.KeywordSyntax, joinedVariables As GreenNode, additionalJoins As GreenNode, onKeyword As InternalSyntax.KeywordSyntax, joinConditions As GreenNode)
            MyBase.New(kind, errors, annotations, joinKeyword, joinedVariables, additionalJoins, onKeyword, joinConditions)
            Me.SlotCount = 5
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._joinKeyword
                Case 1
                    Return Me._joinedVariables
                Case 2
                    Return Me._additionalJoins
                Case 3
                    Return Me._onKeyword
                Case 4
                    Return Me._joinConditions
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new SimpleJoinClauseSyntax(Me.Kind, newErrors, GetAnnotations, _joinKeyword, _joinedVariables, _additionalJoins, _onKeyword, _joinConditions)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new SimpleJoinClauseSyntax(Me.Kind, GetDiagnostics, annotations, _joinKeyword, _joinedVariables, _additionalJoins, _onKeyword, _joinConditions)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitSimpleJoinClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "Group Join" query operator.
    ''' </summary>
    Friend NotInheritable Class GroupJoinClauseSyntax
        Inherits JoinClauseSyntax

        Friend ReadOnly _groupKeyword as KeywordSyntax
        Friend ReadOnly _intoKeyword as KeywordSyntax
        Friend ReadOnly _aggregationVariables as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, groupKeyword As InternalSyntax.KeywordSyntax, joinKeyword As InternalSyntax.KeywordSyntax, joinedVariables As GreenNode, additionalJoins As GreenNode, onKeyword As InternalSyntax.KeywordSyntax, joinConditions As GreenNode, intoKeyword As InternalSyntax.KeywordSyntax, aggregationVariables As GreenNode)
            MyBase.New(kind, joinKeyword, joinedVariables, additionalJoins, onKeyword, joinConditions)
            Me.SlotCount = 8

            AdjustFlagsAndWidth(groupKeyword)
            Me._groupKeyword = groupKeyword
            AdjustFlagsAndWidth(intoKeyword)
            Me._intoKeyword = intoKeyword
            If aggregationVariables IsNot Nothing Then
                AdjustFlagsAndWidth(aggregationVariables)
                Me._aggregationVariables = aggregationVariables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, groupKeyword As InternalSyntax.KeywordSyntax, joinKeyword As InternalSyntax.KeywordSyntax, joinedVariables As GreenNode, additionalJoins As GreenNode, onKeyword As InternalSyntax.KeywordSyntax, joinConditions As GreenNode, intoKeyword As InternalSyntax.KeywordSyntax, aggregationVariables As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind, joinKeyword, joinedVariables, additionalJoins, onKeyword, joinConditions)
            Me.SlotCount = 8
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(groupKeyword)
            Me._groupKeyword = groupKeyword
            AdjustFlagsAndWidth(intoKeyword)
            Me._intoKeyword = intoKeyword
            If aggregationVariables IsNot Nothing Then
                AdjustFlagsAndWidth(aggregationVariables)
                Me._aggregationVariables = aggregationVariables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), groupKeyword As InternalSyntax.KeywordSyntax, joinKeyword As InternalSyntax.KeywordSyntax, joinedVariables As GreenNode, additionalJoins As GreenNode, onKeyword As InternalSyntax.KeywordSyntax, joinConditions As GreenNode, intoKeyword As InternalSyntax.KeywordSyntax, aggregationVariables As GreenNode)
            MyBase.New(kind, errors, annotations, joinKeyword, joinedVariables, additionalJoins, onKeyword, joinConditions)
            Me.SlotCount = 8

            AdjustFlagsAndWidth(groupKeyword)
            Me._groupKeyword = groupKeyword
            AdjustFlagsAndWidth(intoKeyword)
            Me._intoKeyword = intoKeyword
            If aggregationVariables IsNot Nothing Then
                AdjustFlagsAndWidth(aggregationVariables)
                Me._aggregationVariables = aggregationVariables
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Group" keyword.
        ''' </summary>
        Friend ReadOnly Property GroupKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._groupKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "Into" keyword.
        ''' </summary>
        Friend ReadOnly Property IntoKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._intoKeyword
            End Get
        End Property

        ''' <summary>
        ''' The list of new variables that calculate aggregations.
        ''' </summary>
        Friend ReadOnly Property AggregationVariables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of AggregationRangeVariableSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of AggregationRangeVariableSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of AggregationRangeVariableSyntax)(Me._aggregationVariables))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._groupKeyword
                Case 1
                    Return Me._joinKeyword
                Case 2
                    Return Me._joinedVariables
                Case 3
                    Return Me._additionalJoins
                Case 4
                    Return Me._onKeyword
                Case 5
                    Return Me._joinConditions
                Case 6
                    Return Me._intoKeyword
                Case 7
                    Return Me._aggregationVariables
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new GroupJoinClauseSyntax(Me.Kind, newErrors, GetAnnotations, _groupKeyword, _joinKeyword, _joinedVariables, _additionalJoins, _onKeyword, _joinConditions, _intoKeyword, _aggregationVariables)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new GroupJoinClauseSyntax(Me.Kind, GetDiagnostics, annotations, _groupKeyword, _joinKeyword, _joinedVariables, _additionalJoins, _onKeyword, _joinConditions, _intoKeyword, _aggregationVariables)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitGroupJoinClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "Order By" query operator.
    ''' </summary>
    Friend NotInheritable Class OrderByClauseSyntax
        Inherits QueryClauseSyntax

        Friend ReadOnly _orderKeyword as KeywordSyntax
        Friend ReadOnly _byKeyword as KeywordSyntax
        Friend ReadOnly _orderings as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, orderKeyword As InternalSyntax.KeywordSyntax, byKeyword As InternalSyntax.KeywordSyntax, orderings As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(orderKeyword)
            Me._orderKeyword = orderKeyword
            AdjustFlagsAndWidth(byKeyword)
            Me._byKeyword = byKeyword
            If orderings IsNot Nothing Then
                AdjustFlagsAndWidth(orderings)
                Me._orderings = orderings
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, orderKeyword As InternalSyntax.KeywordSyntax, byKeyword As InternalSyntax.KeywordSyntax, orderings As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(orderKeyword)
            Me._orderKeyword = orderKeyword
            AdjustFlagsAndWidth(byKeyword)
            Me._byKeyword = byKeyword
            If orderings IsNot Nothing Then
                AdjustFlagsAndWidth(orderings)
                Me._orderings = orderings
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), orderKeyword As InternalSyntax.KeywordSyntax, byKeyword As InternalSyntax.KeywordSyntax, orderings As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(orderKeyword)
            Me._orderKeyword = orderKeyword
            AdjustFlagsAndWidth(byKeyword)
            Me._byKeyword = byKeyword
            If orderings IsNot Nothing Then
                AdjustFlagsAndWidth(orderings)
                Me._orderings = orderings
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderByClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Order" keyword
        ''' </summary>
        Friend ReadOnly Property OrderKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._orderKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "By" keyword.
        ''' </summary>
        Friend ReadOnly Property ByKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._byKeyword
            End Get
        End Property

        ''' <summary>
        ''' The list of OrderExpression's to sort by.
        ''' </summary>
        Friend ReadOnly Property Orderings As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of OrderingSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of OrderingSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of OrderingSyntax)(Me._orderings))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._orderKeyword
                Case 1
                    Return Me._byKeyword
                Case 2
                    Return Me._orderings
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new OrderByClauseSyntax(Me.Kind, newErrors, GetAnnotations, _orderKeyword, _byKeyword, _orderings)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new OrderByClauseSyntax(Me.Kind, GetDiagnostics, annotations, _orderKeyword, _byKeyword, _orderings)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitOrderByClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' An expression to order by, plus an optional ordering. The Kind indicates
    ''' whether to order in ascending or descending order.
    ''' </summary>
    Friend NotInheritable Class OrderingSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _expression as ExpressionSyntax
        Friend ReadOnly _ascendingOrDescendingKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, expression As ExpressionSyntax, ascendingOrDescendingKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            If ascendingOrDescendingKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(ascendingOrDescendingKeyword)
                Me._ascendingOrDescendingKeyword = ascendingOrDescendingKeyword
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, expression As ExpressionSyntax, ascendingOrDescendingKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            If ascendingOrDescendingKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(ascendingOrDescendingKeyword)
                Me._ascendingOrDescendingKeyword = ascendingOrDescendingKeyword
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), expression As ExpressionSyntax, ascendingOrDescendingKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            If ascendingOrDescendingKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(ascendingOrDescendingKeyword)
                Me._ascendingOrDescendingKeyword = ascendingOrDescendingKeyword
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The expression to sort by.
        ''' </summary>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        ''' <summary>
        ''' The "Ascending" or "Descending" keyword, if present. To determine whether to
        ''' sort in ascending or descending order, checking the Kind property is easier.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property AscendingOrDescendingKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._ascendingOrDescendingKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._expression
                Case 1
                    Return Me._ascendingOrDescendingKeyword
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new OrderingSyntax(Me.Kind, newErrors, GetAnnotations, _expression, _ascendingOrDescendingKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new OrderingSyntax(Me.Kind, GetDiagnostics, annotations, _expression, _ascendingOrDescendingKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitOrdering(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the "Select" query operator.
    ''' </summary>
    Friend NotInheritable Class SelectClauseSyntax
        Inherits QueryClauseSyntax

        Friend ReadOnly _selectKeyword as KeywordSyntax
        Friend ReadOnly _variables as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, selectKeyword As InternalSyntax.KeywordSyntax, variables As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(selectKeyword)
            Me._selectKeyword = selectKeyword
            If variables IsNot Nothing Then
                AdjustFlagsAndWidth(variables)
                Me._variables = variables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, selectKeyword As InternalSyntax.KeywordSyntax, variables As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(selectKeyword)
            Me._selectKeyword = selectKeyword
            If variables IsNot Nothing Then
                AdjustFlagsAndWidth(variables)
                Me._variables = variables
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), selectKeyword As InternalSyntax.KeywordSyntax, variables As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(selectKeyword)
            Me._selectKeyword = selectKeyword
            If variables IsNot Nothing Then
                AdjustFlagsAndWidth(variables)
                Me._variables = variables
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Select" keyword.
        ''' </summary>
        Friend ReadOnly Property SelectKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._selectKeyword
            End Get
        End Property

        ''' <summary>
        ''' The list of expression range variables being defined by the Select query
        ''' operator.
        ''' </summary>
        Friend ReadOnly Property Variables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ExpressionRangeVariableSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of ExpressionRangeVariableSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of ExpressionRangeVariableSyntax)(Me._variables))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._selectKeyword
                Case 1
                    Return Me._variables
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new SelectClauseSyntax(Me.Kind, newErrors, GetAnnotations, _selectKeyword, _variables)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new SelectClauseSyntax(Me.Kind, GetDiagnostics, annotations, _selectKeyword, _variables)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitSelectClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' This is the base class for all XML expression syntax nodes (XmlDocument and
    ''' XmlElement).
    ''' </summary>
    Friend MustInherit Class XmlNodeSyntax
        Inherits ExpressionSyntax


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

    End Class

    ''' <summary>
    ''' Represents an XML Document literal expression.
    ''' </summary>
    Friend NotInheritable Class XmlDocumentSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _declaration as XmlDeclarationSyntax
        Friend ReadOnly _precedingMisc as GreenNode
        Friend ReadOnly _root as XmlNodeSyntax
        Friend ReadOnly _followingMisc as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, declaration As XmlDeclarationSyntax, precedingMisc As GreenNode, root As XmlNodeSyntax, followingMisc As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(declaration)
            Me._declaration = declaration
            If precedingMisc IsNot Nothing Then
                AdjustFlagsAndWidth(precedingMisc)
                Me._precedingMisc = precedingMisc
            End If
            AdjustFlagsAndWidth(root)
            Me._root = root
            If followingMisc IsNot Nothing Then
                AdjustFlagsAndWidth(followingMisc)
                Me._followingMisc = followingMisc
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, declaration As XmlDeclarationSyntax, precedingMisc As GreenNode, root As XmlNodeSyntax, followingMisc As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 4
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(declaration)
            Me._declaration = declaration
            If precedingMisc IsNot Nothing Then
                AdjustFlagsAndWidth(precedingMisc)
                Me._precedingMisc = precedingMisc
            End If
            AdjustFlagsAndWidth(root)
            Me._root = root
            If followingMisc IsNot Nothing Then
                AdjustFlagsAndWidth(followingMisc)
                Me._followingMisc = followingMisc
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), declaration As XmlDeclarationSyntax, precedingMisc As GreenNode, root As XmlNodeSyntax, followingMisc As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(declaration)
            Me._declaration = declaration
            If precedingMisc IsNot Nothing Then
                AdjustFlagsAndWidth(precedingMisc)
                Me._precedingMisc = precedingMisc
            End If
            AdjustFlagsAndWidth(root)
            Me._root = root
            If followingMisc IsNot Nothing Then
                AdjustFlagsAndWidth(followingMisc)
                Me._followingMisc = followingMisc
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDocumentSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property Declaration As InternalSyntax.XmlDeclarationSyntax
            Get
                Return Me._declaration
            End Get
        End Property

        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property PrecedingMisc As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of XmlNodeSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of XmlNodeSyntax)(Me._precedingMisc)
            End Get
        End Property

        Friend ReadOnly Property Root As InternalSyntax.XmlNodeSyntax
            Get
                Return Me._root
            End Get
        End Property

        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property FollowingMisc As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of XmlNodeSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of XmlNodeSyntax)(Me._followingMisc)
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._declaration
                Case 1
                    Return Me._precedingMisc
                Case 2
                    Return Me._root
                Case 3
                    Return Me._followingMisc
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlDocumentSyntax(Me.Kind, newErrors, GetAnnotations, _declaration, _precedingMisc, _root, _followingMisc)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlDocumentSyntax(Me.Kind, GetDiagnostics, annotations, _declaration, _precedingMisc, _root, _followingMisc)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitXmlDocument(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the XML declaration prologue in an XML literal expression.
    ''' </summary>
    Friend NotInheritable Class XmlDeclarationSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _lessThanQuestionToken as PunctuationSyntax
        Friend ReadOnly _xmlKeyword as KeywordSyntax
        Friend ReadOnly _version as XmlDeclarationOptionSyntax
        Friend ReadOnly _encoding as XmlDeclarationOptionSyntax
        Friend ReadOnly _standalone as XmlDeclarationOptionSyntax
        Friend ReadOnly _questionGreaterThanToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lessThanQuestionToken As InternalSyntax.PunctuationSyntax, xmlKeyword As InternalSyntax.KeywordSyntax, version As XmlDeclarationOptionSyntax, encoding As XmlDeclarationOptionSyntax, standalone As XmlDeclarationOptionSyntax, questionGreaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 6

            AdjustFlagsAndWidth(lessThanQuestionToken)
            Me._lessThanQuestionToken = lessThanQuestionToken
            AdjustFlagsAndWidth(xmlKeyword)
            Me._xmlKeyword = xmlKeyword
            AdjustFlagsAndWidth(version)
            Me._version = version
            If encoding IsNot Nothing Then
                AdjustFlagsAndWidth(encoding)
                Me._encoding = encoding
            End If
            If standalone IsNot Nothing Then
                AdjustFlagsAndWidth(standalone)
                Me._standalone = standalone
            End If
            AdjustFlagsAndWidth(questionGreaterThanToken)
            Me._questionGreaterThanToken = questionGreaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, lessThanQuestionToken As InternalSyntax.PunctuationSyntax, xmlKeyword As InternalSyntax.KeywordSyntax, version As XmlDeclarationOptionSyntax, encoding As XmlDeclarationOptionSyntax, standalone As XmlDeclarationOptionSyntax, questionGreaterThanToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 6
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(lessThanQuestionToken)
            Me._lessThanQuestionToken = lessThanQuestionToken
            AdjustFlagsAndWidth(xmlKeyword)
            Me._xmlKeyword = xmlKeyword
            AdjustFlagsAndWidth(version)
            Me._version = version
            If encoding IsNot Nothing Then
                AdjustFlagsAndWidth(encoding)
                Me._encoding = encoding
            End If
            If standalone IsNot Nothing Then
                AdjustFlagsAndWidth(standalone)
                Me._standalone = standalone
            End If
            AdjustFlagsAndWidth(questionGreaterThanToken)
            Me._questionGreaterThanToken = questionGreaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lessThanQuestionToken As InternalSyntax.PunctuationSyntax, xmlKeyword As InternalSyntax.KeywordSyntax, version As XmlDeclarationOptionSyntax, encoding As XmlDeclarationOptionSyntax, standalone As XmlDeclarationOptionSyntax, questionGreaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 6

            AdjustFlagsAndWidth(lessThanQuestionToken)
            Me._lessThanQuestionToken = lessThanQuestionToken
            AdjustFlagsAndWidth(xmlKeyword)
            Me._xmlKeyword = xmlKeyword
            AdjustFlagsAndWidth(version)
            Me._version = version
            If encoding IsNot Nothing Then
                AdjustFlagsAndWidth(encoding)
                Me._encoding = encoding
            End If
            If standalone IsNot Nothing Then
                AdjustFlagsAndWidth(standalone)
                Me._standalone = standalone
            End If
            AdjustFlagsAndWidth(questionGreaterThanToken)
            Me._questionGreaterThanToken = questionGreaterThanToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property LessThanQuestionToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._lessThanQuestionToken
            End Get
        End Property

        Friend ReadOnly Property XmlKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._xmlKeyword
            End Get
        End Property

        Friend ReadOnly Property Version As InternalSyntax.XmlDeclarationOptionSyntax
            Get
                Return Me._version
            End Get
        End Property

        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Encoding As InternalSyntax.XmlDeclarationOptionSyntax
            Get
                Return Me._encoding
            End Get
        End Property

        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Standalone As InternalSyntax.XmlDeclarationOptionSyntax
            Get
                Return Me._standalone
            End Get
        End Property

        Friend ReadOnly Property QuestionGreaterThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._questionGreaterThanToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._lessThanQuestionToken
                Case 1
                    Return Me._xmlKeyword
                Case 2
                    Return Me._version
                Case 3
                    Return Me._encoding
                Case 4
                    Return Me._standalone
                Case 5
                    Return Me._questionGreaterThanToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlDeclarationSyntax(Me.Kind, newErrors, GetAnnotations, _lessThanQuestionToken, _xmlKeyword, _version, _encoding, _standalone, _questionGreaterThanToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlDeclarationSyntax(Me.Kind, GetDiagnostics, annotations, _lessThanQuestionToken, _xmlKeyword, _version, _encoding, _standalone, _questionGreaterThanToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitXmlDeclaration(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an XML document prologue option - version, encoding, standalone or
    ''' whitespace in an XML literal expression.
    ''' </summary>
    Friend NotInheritable Class XmlDeclarationOptionSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _name as XmlNameTokenSyntax
        Friend ReadOnly _equals as PunctuationSyntax
        Friend ReadOnly _value as XmlStringSyntax

        Friend Sub New(ByVal kind As SyntaxKind, name As InternalSyntax.XmlNameTokenSyntax, equals As InternalSyntax.PunctuationSyntax, value As XmlStringSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(equals)
            Me._equals = equals
            AdjustFlagsAndWidth(value)
            Me._value = value

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, name As InternalSyntax.XmlNameTokenSyntax, equals As InternalSyntax.PunctuationSyntax, value As XmlStringSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(equals)
            Me._equals = equals
            AdjustFlagsAndWidth(value)
            Me._value = value

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), name As InternalSyntax.XmlNameTokenSyntax, equals As InternalSyntax.PunctuationSyntax, value As XmlStringSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(equals)
            Me._equals = equals
            AdjustFlagsAndWidth(value)
            Me._value = value

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property Name As InternalSyntax.XmlNameTokenSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend Shadows ReadOnly Property Equals As InternalSyntax.PunctuationSyntax
            Get
                Return Me._equals
            End Get
        End Property

        Friend ReadOnly Property Value As InternalSyntax.XmlStringSyntax
            Get
                Return Me._value
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._name
                Case 1
                    Return Me._equals
                Case 2
                    Return Me._value
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlDeclarationOptionSyntax(Me.Kind, newErrors, GetAnnotations, _name, _equals, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlDeclarationOptionSyntax(Me.Kind, GetDiagnostics, annotations, _name, _equals, _value)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitXmlDeclarationOption(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an XML element with content in an XML literal expression.
    ''' </summary>
    Friend NotInheritable Class XmlElementSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _startTag as XmlElementStartTagSyntax
        Friend ReadOnly _content as GreenNode
        Friend ReadOnly _endTag as XmlElementEndTagSyntax

        Friend Sub New(ByVal kind As SyntaxKind, startTag As XmlElementStartTagSyntax, content As GreenNode, endTag As XmlElementEndTagSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(startTag)
            Me._startTag = startTag
            If content IsNot Nothing Then
                AdjustFlagsAndWidth(content)
                Me._content = content
            End If
            AdjustFlagsAndWidth(endTag)
            Me._endTag = endTag

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, startTag As XmlElementStartTagSyntax, content As GreenNode, endTag As XmlElementEndTagSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(startTag)
            Me._startTag = startTag
            If content IsNot Nothing Then
                AdjustFlagsAndWidth(content)
                Me._content = content
            End If
            AdjustFlagsAndWidth(endTag)
            Me._endTag = endTag

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), startTag As XmlElementStartTagSyntax, content As GreenNode, endTag As XmlElementEndTagSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(startTag)
            Me._startTag = startTag
            If content IsNot Nothing Then
                AdjustFlagsAndWidth(content)
                Me._content = content
            End If
            AdjustFlagsAndWidth(endTag)
            Me._endTag = endTag

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property StartTag As InternalSyntax.XmlElementStartTagSyntax
            Get
                Return Me._startTag
            End Get
        End Property

        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Content As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of XmlNodeSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of XmlNodeSyntax)(Me._content)
            End Get
        End Property

        Friend ReadOnly Property EndTag As InternalSyntax.XmlElementEndTagSyntax
            Get
                Return Me._endTag
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._startTag
                Case 1
                    Return Me._content
                Case 2
                    Return Me._endTag
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlElementSyntax(Me.Kind, newErrors, GetAnnotations, _startTag, _content, _endTag)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlElementSyntax(Me.Kind, GetDiagnostics, annotations, _startTag, _content, _endTag)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitXmlElement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents Xml text.
    ''' </summary>
    Friend NotInheritable Class XmlTextSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _textTokens as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, textTokens As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 1

            If textTokens IsNot Nothing Then
                AdjustFlagsAndWidth(textTokens)
                Me._textTokens = textTokens
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, textTokens As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            If textTokens IsNot Nothing Then
                AdjustFlagsAndWidth(textTokens)
                Me._textTokens = textTokens
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), textTokens As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            If textTokens IsNot Nothing Then
                AdjustFlagsAndWidth(textTokens)
                Me._textTokens = textTokens
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlTextSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' A list of all the text tokens in the Xml text. This list always contains at
        ''' least one token.
        ''' </summary>
        Friend ReadOnly Property TextTokens As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of XmlTextTokenSyntax)
            Get
                Return New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)(Me._textTokens)
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._textTokens
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlTextSyntax(Me.Kind, newErrors, GetAnnotations, _textTokens)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlTextSyntax(Me.Kind, GetDiagnostics, annotations, _textTokens)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitXmlText(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the start tag of an XML element of the form &lt;element&gt;.
    ''' </summary>
    Friend NotInheritable Class XmlElementStartTagSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _lessThanToken as PunctuationSyntax
        Friend ReadOnly _name as XmlNodeSyntax
        Friend ReadOnly _attributes as GreenNode
        Friend ReadOnly _greaterThanToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lessThanToken As InternalSyntax.PunctuationSyntax, name As XmlNodeSyntax, attributes As GreenNode, greaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(lessThanToken)
            Me._lessThanToken = lessThanToken
            AdjustFlagsAndWidth(name)
            Me._name = name
            If attributes IsNot Nothing Then
                AdjustFlagsAndWidth(attributes)
                Me._attributes = attributes
            End If
            AdjustFlagsAndWidth(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, lessThanToken As InternalSyntax.PunctuationSyntax, name As XmlNodeSyntax, attributes As GreenNode, greaterThanToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 4
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(lessThanToken)
            Me._lessThanToken = lessThanToken
            AdjustFlagsAndWidth(name)
            Me._name = name
            If attributes IsNot Nothing Then
                AdjustFlagsAndWidth(attributes)
                Me._attributes = attributes
            End If
            AdjustFlagsAndWidth(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lessThanToken As InternalSyntax.PunctuationSyntax, name As XmlNodeSyntax, attributes As GreenNode, greaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(lessThanToken)
            Me._lessThanToken = lessThanToken
            AdjustFlagsAndWidth(name)
            Me._name = name
            If attributes IsNot Nothing Then
                AdjustFlagsAndWidth(attributes)
                Me._attributes = attributes
            End If
            AdjustFlagsAndWidth(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementStartTagSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property LessThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._lessThanToken
            End Get
        End Property

        Friend ReadOnly Property Name As InternalSyntax.XmlNodeSyntax
            Get
                Return Me._name
            End Get
        End Property

        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Attributes As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of XmlNodeSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of XmlNodeSyntax)(Me._attributes)
            End Get
        End Property

        Friend ReadOnly Property GreaterThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._greaterThanToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._lessThanToken
                Case 1
                    Return Me._name
                Case 2
                    Return Me._attributes
                Case 3
                    Return Me._greaterThanToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlElementStartTagSyntax(Me.Kind, newErrors, GetAnnotations, _lessThanToken, _name, _attributes, _greaterThanToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlElementStartTagSyntax(Me.Kind, GetDiagnostics, annotations, _lessThanToken, _name, _attributes, _greaterThanToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitXmlElementStartTag(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the end tag of an XML element of the form &lt;/element&gt;.
    ''' </summary>
    Friend NotInheritable Class XmlElementEndTagSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _lessThanSlashToken as PunctuationSyntax
        Friend ReadOnly _name as XmlNameSyntax
        Friend ReadOnly _greaterThanToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lessThanSlashToken As InternalSyntax.PunctuationSyntax, name As XmlNameSyntax, greaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(lessThanSlashToken)
            Me._lessThanSlashToken = lessThanSlashToken
            If name IsNot Nothing Then
                AdjustFlagsAndWidth(name)
                Me._name = name
            End If
            AdjustFlagsAndWidth(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, lessThanSlashToken As InternalSyntax.PunctuationSyntax, name As XmlNameSyntax, greaterThanToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(lessThanSlashToken)
            Me._lessThanSlashToken = lessThanSlashToken
            If name IsNot Nothing Then
                AdjustFlagsAndWidth(name)
                Me._name = name
            End If
            AdjustFlagsAndWidth(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lessThanSlashToken As InternalSyntax.PunctuationSyntax, name As XmlNameSyntax, greaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(lessThanSlashToken)
            Me._lessThanSlashToken = lessThanSlashToken
            If name IsNot Nothing Then
                AdjustFlagsAndWidth(name)
                Me._name = name
            End If
            AdjustFlagsAndWidth(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementEndTagSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property LessThanSlashToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._lessThanSlashToken
            End Get
        End Property

        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Name As InternalSyntax.XmlNameSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend ReadOnly Property GreaterThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._greaterThanToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._lessThanSlashToken
                Case 1
                    Return Me._name
                Case 2
                    Return Me._greaterThanToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlElementEndTagSyntax(Me.Kind, newErrors, GetAnnotations, _lessThanSlashToken, _name, _greaterThanToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlElementEndTagSyntax(Me.Kind, GetDiagnostics, annotations, _lessThanSlashToken, _name, _greaterThanToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitXmlElementEndTag(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an empty XML element of the form &lt;element /&gt;
    ''' </summary>
    Friend NotInheritable Class XmlEmptyElementSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _lessThanToken as PunctuationSyntax
        Friend ReadOnly _name as XmlNodeSyntax
        Friend ReadOnly _attributes as GreenNode
        Friend ReadOnly _slashGreaterThanToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lessThanToken As InternalSyntax.PunctuationSyntax, name As XmlNodeSyntax, attributes As GreenNode, slashGreaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(lessThanToken)
            Me._lessThanToken = lessThanToken
            AdjustFlagsAndWidth(name)
            Me._name = name
            If attributes IsNot Nothing Then
                AdjustFlagsAndWidth(attributes)
                Me._attributes = attributes
            End If
            AdjustFlagsAndWidth(slashGreaterThanToken)
            Me._slashGreaterThanToken = slashGreaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, lessThanToken As InternalSyntax.PunctuationSyntax, name As XmlNodeSyntax, attributes As GreenNode, slashGreaterThanToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 4
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(lessThanToken)
            Me._lessThanToken = lessThanToken
            AdjustFlagsAndWidth(name)
            Me._name = name
            If attributes IsNot Nothing Then
                AdjustFlagsAndWidth(attributes)
                Me._attributes = attributes
            End If
            AdjustFlagsAndWidth(slashGreaterThanToken)
            Me._slashGreaterThanToken = slashGreaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lessThanToken As InternalSyntax.PunctuationSyntax, name As XmlNodeSyntax, attributes As GreenNode, slashGreaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(lessThanToken)
            Me._lessThanToken = lessThanToken
            AdjustFlagsAndWidth(name)
            Me._name = name
            If attributes IsNot Nothing Then
                AdjustFlagsAndWidth(attributes)
                Me._attributes = attributes
            End If
            AdjustFlagsAndWidth(slashGreaterThanToken)
            Me._slashGreaterThanToken = slashGreaterThanToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property LessThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._lessThanToken
            End Get
        End Property

        Friend ReadOnly Property Name As InternalSyntax.XmlNodeSyntax
            Get
                Return Me._name
            End Get
        End Property

        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Attributes As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of XmlNodeSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of XmlNodeSyntax)(Me._attributes)
            End Get
        End Property

        Friend ReadOnly Property SlashGreaterThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._slashGreaterThanToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._lessThanToken
                Case 1
                    Return Me._name
                Case 2
                    Return Me._attributes
                Case 3
                    Return Me._slashGreaterThanToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlEmptyElementSyntax(Me.Kind, newErrors, GetAnnotations, _lessThanToken, _name, _attributes, _slashGreaterThanToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlEmptyElementSyntax(Me.Kind, GetDiagnostics, annotations, _lessThanToken, _name, _attributes, _slashGreaterThanToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitXmlEmptyElement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an XML attribute in an XML literal expression.
    ''' </summary>
    Friend NotInheritable Class XmlAttributeSyntax
        Inherits BaseXmlAttributeSyntax

        Friend ReadOnly _name as XmlNodeSyntax
        Friend ReadOnly _equalsToken as PunctuationSyntax
        Friend ReadOnly _value as XmlNodeSyntax

        Friend Sub New(ByVal kind As SyntaxKind, name As XmlNodeSyntax, equalsToken As InternalSyntax.PunctuationSyntax, value As XmlNodeSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken
            AdjustFlagsAndWidth(value)
            Me._value = value

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, name As XmlNodeSyntax, equalsToken As InternalSyntax.PunctuationSyntax, value As XmlNodeSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken
            AdjustFlagsAndWidth(value)
            Me._value = value

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), name As XmlNodeSyntax, equalsToken As InternalSyntax.PunctuationSyntax, value As XmlNodeSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken
            AdjustFlagsAndWidth(value)
            Me._value = value

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property Name As InternalSyntax.XmlNodeSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend ReadOnly Property EqualsToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._equalsToken
            End Get
        End Property

        Friend ReadOnly Property Value As InternalSyntax.XmlNodeSyntax
            Get
                Return Me._value
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._name
                Case 1
                    Return Me._equalsToken
                Case 2
                    Return Me._value
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlAttributeSyntax(Me.Kind, newErrors, GetAnnotations, _name, _equalsToken, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlAttributeSyntax(Me.Kind, GetDiagnostics, annotations, _name, _equalsToken, _value)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitXmlAttribute(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an XML attribute in an XML literal expression.
    ''' </summary>
    Friend MustInherit Class BaseXmlAttributeSyntax
        Inherits XmlNodeSyntax


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

    End Class

    ''' <summary>
    ''' Represents a string of XML characters embedded as the content of an XML
    ''' element.
    ''' </summary>
    Friend NotInheritable Class XmlStringSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _startQuoteToken as PunctuationSyntax
        Friend ReadOnly _textTokens as GreenNode
        Friend ReadOnly _endQuoteToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, startQuoteToken As InternalSyntax.PunctuationSyntax, textTokens As GreenNode, endQuoteToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(startQuoteToken)
            Me._startQuoteToken = startQuoteToken
            If textTokens IsNot Nothing Then
                AdjustFlagsAndWidth(textTokens)
                Me._textTokens = textTokens
            End If
            AdjustFlagsAndWidth(endQuoteToken)
            Me._endQuoteToken = endQuoteToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, startQuoteToken As InternalSyntax.PunctuationSyntax, textTokens As GreenNode, endQuoteToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(startQuoteToken)
            Me._startQuoteToken = startQuoteToken
            If textTokens IsNot Nothing Then
                AdjustFlagsAndWidth(textTokens)
                Me._textTokens = textTokens
            End If
            AdjustFlagsAndWidth(endQuoteToken)
            Me._endQuoteToken = endQuoteToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), startQuoteToken As InternalSyntax.PunctuationSyntax, textTokens As GreenNode, endQuoteToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(startQuoteToken)
            Me._startQuoteToken = startQuoteToken
            If textTokens IsNot Nothing Then
                AdjustFlagsAndWidth(textTokens)
                Me._textTokens = textTokens
            End If
            AdjustFlagsAndWidth(endQuoteToken)
            Me._endQuoteToken = endQuoteToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlStringSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property StartQuoteToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._startQuoteToken
            End Get
        End Property

        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property TextTokens As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of XmlTextTokenSyntax)
            Get
                Return New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)(Me._textTokens)
            End Get
        End Property

        Friend ReadOnly Property EndQuoteToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._endQuoteToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._startQuoteToken
                Case 1
                    Return Me._textTokens
                Case 2
                    Return Me._endQuoteToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlStringSyntax(Me.Kind, newErrors, GetAnnotations, _startQuoteToken, _textTokens, _endQuoteToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlStringSyntax(Me.Kind, GetDiagnostics, annotations, _startQuoteToken, _textTokens, _endQuoteToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitXmlString(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an XML name of the form 'name' appearing in GetXmlNamespace().
    ''' </summary>
    Friend NotInheritable Class XmlPrefixNameSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _name as XmlNameTokenSyntax

        Friend Sub New(ByVal kind As SyntaxKind, name As InternalSyntax.XmlNameTokenSyntax)
            MyBase.New(kind)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(name)
            Me._name = name

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, name As InternalSyntax.XmlNameTokenSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(name)
            Me._name = name

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), name As InternalSyntax.XmlNameTokenSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(name)
            Me._name = name

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixNameSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property Name As InternalSyntax.XmlNameTokenSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._name
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlPrefixNameSyntax(Me.Kind, newErrors, GetAnnotations, _name)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlPrefixNameSyntax(Me.Kind, GetDiagnostics, annotations, _name)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitXmlPrefixName(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an XML name of the form 'name' or 'namespace:name' appearing in
    ''' source as part of an XML literal or member access expression or an XML
    ''' namespace import clause.
    ''' </summary>
    Friend NotInheritable Class XmlNameSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _prefix as XmlPrefixSyntax
        Friend ReadOnly _localName as XmlNameTokenSyntax

        Friend Sub New(ByVal kind As SyntaxKind, prefix As XmlPrefixSyntax, localName As InternalSyntax.XmlNameTokenSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            If prefix IsNot Nothing Then
                AdjustFlagsAndWidth(prefix)
                Me._prefix = prefix
            End If
            AdjustFlagsAndWidth(localName)
            Me._localName = localName

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, prefix As XmlPrefixSyntax, localName As InternalSyntax.XmlNameTokenSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            If prefix IsNot Nothing Then
                AdjustFlagsAndWidth(prefix)
                Me._prefix = prefix
            End If
            AdjustFlagsAndWidth(localName)
            Me._localName = localName

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), prefix As XmlPrefixSyntax, localName As InternalSyntax.XmlNameTokenSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            If prefix IsNot Nothing Then
                AdjustFlagsAndWidth(prefix)
                Me._prefix = prefix
            End If
            AdjustFlagsAndWidth(localName)
            Me._localName = localName

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax(Me, parent, startLocation)
        End Function

        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Prefix As InternalSyntax.XmlPrefixSyntax
            Get
                Return Me._prefix
            End Get
        End Property

        Friend ReadOnly Property LocalName As InternalSyntax.XmlNameTokenSyntax
            Get
                Return Me._localName
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._prefix
                Case 1
                    Return Me._localName
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlNameSyntax(Me.Kind, newErrors, GetAnnotations, _prefix, _localName)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlNameSyntax(Me.Kind, GetDiagnostics, annotations, _prefix, _localName)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitXmlName(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an XML name of the form &lt;xml-name&gt; appearing in source as part
    ''' of an XML literal or member access expression or an XML namespace import
    ''' clause.
    ''' </summary>
    Friend NotInheritable Class XmlBracketedNameSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _lessThanToken as PunctuationSyntax
        Friend ReadOnly _name as XmlNameSyntax
        Friend ReadOnly _greaterThanToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lessThanToken As InternalSyntax.PunctuationSyntax, name As XmlNameSyntax, greaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(lessThanToken)
            Me._lessThanToken = lessThanToken
            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, lessThanToken As InternalSyntax.PunctuationSyntax, name As XmlNameSyntax, greaterThanToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(lessThanToken)
            Me._lessThanToken = lessThanToken
            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lessThanToken As InternalSyntax.PunctuationSyntax, name As XmlNameSyntax, greaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(lessThanToken)
            Me._lessThanToken = lessThanToken
            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(greaterThanToken)
            Me._greaterThanToken = greaterThanToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlBracketedNameSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property LessThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._lessThanToken
            End Get
        End Property

        Friend ReadOnly Property Name As InternalSyntax.XmlNameSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend ReadOnly Property GreaterThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._greaterThanToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._lessThanToken
                Case 1
                    Return Me._name
                Case 2
                    Return Me._greaterThanToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlBracketedNameSyntax(Me.Kind, newErrors, GetAnnotations, _lessThanToken, _name, _greaterThanToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlBracketedNameSyntax(Me.Kind, GetDiagnostics, annotations, _lessThanToken, _name, _greaterThanToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitXmlBracketedName(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an XML namespace prefix of the form 'prefix:' as in xml:ns="".
    ''' </summary>
    Friend NotInheritable Class XmlPrefixSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _name as XmlNameTokenSyntax
        Friend ReadOnly _colonToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, name As InternalSyntax.XmlNameTokenSyntax, colonToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(colonToken)
            Me._colonToken = colonToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, name As InternalSyntax.XmlNameTokenSyntax, colonToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(colonToken)
            Me._colonToken = colonToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), name As InternalSyntax.XmlNameTokenSyntax, colonToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(colonToken)
            Me._colonToken = colonToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property Name As InternalSyntax.XmlNameTokenSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend ReadOnly Property ColonToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._colonToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._name
                Case 1
                    Return Me._colonToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlPrefixSyntax(Me.Kind, newErrors, GetAnnotations, _name, _colonToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlPrefixSyntax(Me.Kind, GetDiagnostics, annotations, _name, _colonToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitXmlPrefix(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an XML comment of the form &lt;!-- Comment --&gt; appearing in an
    ''' XML literal expression.
    ''' </summary>
    Friend NotInheritable Class XmlCommentSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _lessThanExclamationMinusMinusToken as PunctuationSyntax
        Friend ReadOnly _textTokens as GreenNode
        Friend ReadOnly _minusMinusGreaterThanToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lessThanExclamationMinusMinusToken As InternalSyntax.PunctuationSyntax, textTokens As GreenNode, minusMinusGreaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken)
            Me._lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken
            If textTokens IsNot Nothing Then
                AdjustFlagsAndWidth(textTokens)
                Me._textTokens = textTokens
            End If
            AdjustFlagsAndWidth(minusMinusGreaterThanToken)
            Me._minusMinusGreaterThanToken = minusMinusGreaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, lessThanExclamationMinusMinusToken As InternalSyntax.PunctuationSyntax, textTokens As GreenNode, minusMinusGreaterThanToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken)
            Me._lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken
            If textTokens IsNot Nothing Then
                AdjustFlagsAndWidth(textTokens)
                Me._textTokens = textTokens
            End If
            AdjustFlagsAndWidth(minusMinusGreaterThanToken)
            Me._minusMinusGreaterThanToken = minusMinusGreaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lessThanExclamationMinusMinusToken As InternalSyntax.PunctuationSyntax, textTokens As GreenNode, minusMinusGreaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken)
            Me._lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken
            If textTokens IsNot Nothing Then
                AdjustFlagsAndWidth(textTokens)
                Me._textTokens = textTokens
            End If
            AdjustFlagsAndWidth(minusMinusGreaterThanToken)
            Me._minusMinusGreaterThanToken = minusMinusGreaterThanToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCommentSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property LessThanExclamationMinusMinusToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._lessThanExclamationMinusMinusToken
            End Get
        End Property

        Friend ReadOnly Property TextTokens As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of XmlTextTokenSyntax)
            Get
                Return New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)(Me._textTokens)
            End Get
        End Property

        Friend ReadOnly Property MinusMinusGreaterThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._minusMinusGreaterThanToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._lessThanExclamationMinusMinusToken
                Case 1
                    Return Me._textTokens
                Case 2
                    Return Me._minusMinusGreaterThanToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlCommentSyntax(Me.Kind, newErrors, GetAnnotations, _lessThanExclamationMinusMinusToken, _textTokens, _minusMinusGreaterThanToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlCommentSyntax(Me.Kind, GetDiagnostics, annotations, _lessThanExclamationMinusMinusToken, _textTokens, _minusMinusGreaterThanToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitXmlComment(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an XML processing instruction of the form '&lt;? XMLProcessingTarget
    ''' XMLProcessingValue ?&gt;'.
    ''' </summary>
    Friend NotInheritable Class XmlProcessingInstructionSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _lessThanQuestionToken as PunctuationSyntax
        Friend ReadOnly _name as XmlNameTokenSyntax
        Friend ReadOnly _textTokens as GreenNode
        Friend ReadOnly _questionGreaterThanToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lessThanQuestionToken As InternalSyntax.PunctuationSyntax, name As InternalSyntax.XmlNameTokenSyntax, textTokens As GreenNode, questionGreaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(lessThanQuestionToken)
            Me._lessThanQuestionToken = lessThanQuestionToken
            AdjustFlagsAndWidth(name)
            Me._name = name
            If textTokens IsNot Nothing Then
                AdjustFlagsAndWidth(textTokens)
                Me._textTokens = textTokens
            End If
            AdjustFlagsAndWidth(questionGreaterThanToken)
            Me._questionGreaterThanToken = questionGreaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, lessThanQuestionToken As InternalSyntax.PunctuationSyntax, name As InternalSyntax.XmlNameTokenSyntax, textTokens As GreenNode, questionGreaterThanToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 4
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(lessThanQuestionToken)
            Me._lessThanQuestionToken = lessThanQuestionToken
            AdjustFlagsAndWidth(name)
            Me._name = name
            If textTokens IsNot Nothing Then
                AdjustFlagsAndWidth(textTokens)
                Me._textTokens = textTokens
            End If
            AdjustFlagsAndWidth(questionGreaterThanToken)
            Me._questionGreaterThanToken = questionGreaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lessThanQuestionToken As InternalSyntax.PunctuationSyntax, name As InternalSyntax.XmlNameTokenSyntax, textTokens As GreenNode, questionGreaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(lessThanQuestionToken)
            Me._lessThanQuestionToken = lessThanQuestionToken
            AdjustFlagsAndWidth(name)
            Me._name = name
            If textTokens IsNot Nothing Then
                AdjustFlagsAndWidth(textTokens)
                Me._textTokens = textTokens
            End If
            AdjustFlagsAndWidth(questionGreaterThanToken)
            Me._questionGreaterThanToken = questionGreaterThanToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlProcessingInstructionSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property LessThanQuestionToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._lessThanQuestionToken
            End Get
        End Property

        Friend ReadOnly Property Name As InternalSyntax.XmlNameTokenSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend ReadOnly Property TextTokens As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of XmlTextTokenSyntax)
            Get
                Return New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)(Me._textTokens)
            End Get
        End Property

        Friend ReadOnly Property QuestionGreaterThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._questionGreaterThanToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._lessThanQuestionToken
                Case 1
                    Return Me._name
                Case 2
                    Return Me._textTokens
                Case 3
                    Return Me._questionGreaterThanToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlProcessingInstructionSyntax(Me.Kind, newErrors, GetAnnotations, _lessThanQuestionToken, _name, _textTokens, _questionGreaterThanToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlProcessingInstructionSyntax(Me.Kind, GetDiagnostics, annotations, _lessThanQuestionToken, _name, _textTokens, _questionGreaterThanToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitXmlProcessingInstruction(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an XML CDATA section in an XML literal expression.
    ''' </summary>
    Friend NotInheritable Class XmlCDataSectionSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _beginCDataToken as PunctuationSyntax
        Friend ReadOnly _textTokens as GreenNode
        Friend ReadOnly _endCDataToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, beginCDataToken As InternalSyntax.PunctuationSyntax, textTokens As GreenNode, endCDataToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(beginCDataToken)
            Me._beginCDataToken = beginCDataToken
            If textTokens IsNot Nothing Then
                AdjustFlagsAndWidth(textTokens)
                Me._textTokens = textTokens
            End If
            AdjustFlagsAndWidth(endCDataToken)
            Me._endCDataToken = endCDataToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, beginCDataToken As InternalSyntax.PunctuationSyntax, textTokens As GreenNode, endCDataToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(beginCDataToken)
            Me._beginCDataToken = beginCDataToken
            If textTokens IsNot Nothing Then
                AdjustFlagsAndWidth(textTokens)
                Me._textTokens = textTokens
            End If
            AdjustFlagsAndWidth(endCDataToken)
            Me._endCDataToken = endCDataToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), beginCDataToken As InternalSyntax.PunctuationSyntax, textTokens As GreenNode, endCDataToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(beginCDataToken)
            Me._beginCDataToken = beginCDataToken
            If textTokens IsNot Nothing Then
                AdjustFlagsAndWidth(textTokens)
                Me._textTokens = textTokens
            End If
            AdjustFlagsAndWidth(endCDataToken)
            Me._endCDataToken = endCDataToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCDataSectionSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property BeginCDataToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._beginCDataToken
            End Get
        End Property

        Friend ReadOnly Property TextTokens As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of XmlTextTokenSyntax)
            Get
                Return New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)(Me._textTokens)
            End Get
        End Property

        Friend ReadOnly Property EndCDataToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._endCDataToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._beginCDataToken
                Case 1
                    Return Me._textTokens
                Case 2
                    Return Me._endCDataToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlCDataSectionSyntax(Me.Kind, newErrors, GetAnnotations, _beginCDataToken, _textTokens, _endCDataToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlCDataSectionSyntax(Me.Kind, GetDiagnostics, annotations, _beginCDataToken, _textTokens, _endCDataToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitXmlCDataSection(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an embedded expression in an XML literal e.g. '&lt;name&gt;&lt;%=
    ''' obj.Name =%&gt;&lt;/name&gt;'.
    ''' </summary>
    Friend NotInheritable Class XmlEmbeddedExpressionSyntax
        Inherits XmlNodeSyntax

        Friend ReadOnly _lessThanPercentEqualsToken as PunctuationSyntax
        Friend ReadOnly _expression as ExpressionSyntax
        Friend ReadOnly _percentGreaterThanToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, lessThanPercentEqualsToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, percentGreaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(lessThanPercentEqualsToken)
            Me._lessThanPercentEqualsToken = lessThanPercentEqualsToken
            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            AdjustFlagsAndWidth(percentGreaterThanToken)
            Me._percentGreaterThanToken = percentGreaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, lessThanPercentEqualsToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, percentGreaterThanToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(lessThanPercentEqualsToken)
            Me._lessThanPercentEqualsToken = lessThanPercentEqualsToken
            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            AdjustFlagsAndWidth(percentGreaterThanToken)
            Me._percentGreaterThanToken = percentGreaterThanToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), lessThanPercentEqualsToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, percentGreaterThanToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(lessThanPercentEqualsToken)
            Me._lessThanPercentEqualsToken = lessThanPercentEqualsToken
            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            AdjustFlagsAndWidth(percentGreaterThanToken)
            Me._percentGreaterThanToken = percentGreaterThanToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property LessThanPercentEqualsToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._lessThanPercentEqualsToken
            End Get
        End Property

        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend ReadOnly Property PercentGreaterThanToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._percentGreaterThanToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._lessThanPercentEqualsToken
                Case 1
                    Return Me._expression
                Case 2
                    Return Me._percentGreaterThanToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlEmbeddedExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _lessThanPercentEqualsToken, _expression, _percentGreaterThanToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlEmbeddedExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _lessThanPercentEqualsToken, _expression, _percentGreaterThanToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitXmlEmbeddedExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Abstract node class that represents the textual description of a type, possibly
    ''' include generic type arguments, qualified names, array specifiers, nullable
    ''' specifier and the like.
    ''' </summary>
    Friend MustInherit Class TypeSyntax
        Inherits ExpressionSyntax


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

    End Class

    ''' <summary>
    ''' Represents an array type, such as "A() or "A(,)", without bounds specified for
    ''' the array.
    ''' </summary>
    Friend NotInheritable Class ArrayTypeSyntax
        Inherits TypeSyntax

        Friend ReadOnly _elementType as TypeSyntax
        Friend ReadOnly _rankSpecifiers as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, elementType As TypeSyntax, rankSpecifiers As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(elementType)
            Me._elementType = elementType
            If rankSpecifiers IsNot Nothing Then
                AdjustFlagsAndWidth(rankSpecifiers)
                Me._rankSpecifiers = rankSpecifiers
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, elementType As TypeSyntax, rankSpecifiers As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(elementType)
            Me._elementType = elementType
            If rankSpecifiers IsNot Nothing Then
                AdjustFlagsAndWidth(rankSpecifiers)
                Me._rankSpecifiers = rankSpecifiers
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), elementType As TypeSyntax, rankSpecifiers As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(elementType)
            Me._elementType = elementType
            If rankSpecifiers IsNot Nothing Then
                AdjustFlagsAndWidth(rankSpecifiers)
                Me._rankSpecifiers = rankSpecifiers
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayTypeSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The type of the elements of the array.
        ''' </summary>
        Friend ReadOnly Property ElementType As InternalSyntax.TypeSyntax
            Get
                Return Me._elementType
            End Get
        End Property

        ''' <summary>
        ''' Represents the list of "()" or "(,,)" modifiers on the array type.
        ''' </summary>
        Friend ReadOnly Property RankSpecifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of ArrayRankSpecifierSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of ArrayRankSpecifierSyntax)(Me._rankSpecifiers)
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._elementType
                Case 1
                    Return Me._rankSpecifiers
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ArrayTypeSyntax(Me.Kind, newErrors, GetAnnotations, _elementType, _rankSpecifiers)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ArrayTypeSyntax(Me.Kind, GetDiagnostics, annotations, _elementType, _rankSpecifiers)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitArrayType(Me)
        End Function

    End Class

    ''' <summary>
    ''' A type name that represents a nullable type, such as "Integer?".
    ''' </summary>
    Friend NotInheritable Class NullableTypeSyntax
        Inherits TypeSyntax

        Friend ReadOnly _elementType as TypeSyntax
        Friend ReadOnly _questionMarkToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, elementType As TypeSyntax, questionMarkToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(elementType)
            Me._elementType = elementType
            AdjustFlagsAndWidth(questionMarkToken)
            Me._questionMarkToken = questionMarkToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, elementType As TypeSyntax, questionMarkToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(elementType)
            Me._elementType = elementType
            AdjustFlagsAndWidth(questionMarkToken)
            Me._questionMarkToken = questionMarkToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), elementType As TypeSyntax, questionMarkToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(elementType)
            Me._elementType = elementType
            AdjustFlagsAndWidth(questionMarkToken)
            Me._questionMarkToken = questionMarkToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.NullableTypeSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The kind of type that is this type is a nullable of. Cannot be an array type or
        ''' a nullable type.
        ''' </summary>
        Friend ReadOnly Property ElementType As InternalSyntax.TypeSyntax
            Get
                Return Me._elementType
            End Get
        End Property

        ''' <summary>
        ''' The "?" token.
        ''' </summary>
        Friend ReadOnly Property QuestionMarkToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._questionMarkToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._elementType
                Case 1
                    Return Me._questionMarkToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new NullableTypeSyntax(Me.Kind, newErrors, GetAnnotations, _elementType, _questionMarkToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new NullableTypeSyntax(Me.Kind, GetDiagnostics, annotations, _elementType, _questionMarkToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitNullableType(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an occurrence of a Visual Basic built-in type such as Integer or
    ''' String in source code.
    ''' </summary>
    Friend NotInheritable Class PredefinedTypeSyntax
        Inherits TypeSyntax

        Friend ReadOnly _keyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(keyword)
            Me._keyword = keyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, keyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(keyword)
            Me._keyword = keyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), keyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(keyword)
            Me._keyword = keyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedTypeSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The keyword that was used to describe the built-in type.
        ''' </summary>
        Friend ReadOnly Property Keyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._keyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._keyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new PredefinedTypeSyntax(Me.Kind, newErrors, GetAnnotations, _keyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new PredefinedTypeSyntax(Me.Kind, GetDiagnostics, annotations, _keyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitPredefinedType(Me)
        End Function

    End Class

    ''' <summary>
    ''' Abstract node class that represents a name, possibly include generic arguments
    ''' and qualified names.
    ''' </summary>
    Friend MustInherit Class NameSyntax
        Inherits TypeSyntax


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

    End Class

    ''' <summary>
    ''' Abstract node class that represents a name, possibly include generic arguments.
    ''' </summary>
    Friend MustInherit Class SimpleNameSyntax
        Inherits NameSyntax

        Friend ReadOnly _identifier as IdentifierTokenSyntax

        Friend Sub New(ByVal kind As SyntaxKind, identifier As InternalSyntax.IdentifierTokenSyntax)
            MyBase.New(kind)

            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, identifier As InternalSyntax.IdentifierTokenSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), identifier As InternalSyntax.IdentifierTokenSyntax)
            MyBase.New(kind, errors, annotations)

            AdjustFlagsAndWidth(identifier)
            Me._identifier = identifier

        End Sub

        ''' <summary>
        ''' The identifier in the name.
        ''' </summary>
        Friend ReadOnly Property Identifier As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._identifier
            End Get
        End Property

    End Class

    ''' <summary>
    ''' Represents a type name consisting of a single identifier (which might include
    ''' brackets or a type character).
    ''' </summary>
    Friend NotInheritable Class IdentifierNameSyntax
        Inherits SimpleNameSyntax


        Friend Sub New(ByVal kind As SyntaxKind, identifier As InternalSyntax.IdentifierTokenSyntax)
            MyBase.New(kind, identifier)
            Me.SlotCount = 1
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, identifier As InternalSyntax.IdentifierTokenSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, identifier)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), identifier As InternalSyntax.IdentifierTokenSyntax)
            MyBase.New(kind, errors, annotations, identifier)
            Me.SlotCount = 1
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._identifier
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new IdentifierNameSyntax(Me.Kind, newErrors, GetAnnotations, _identifier)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new IdentifierNameSyntax(Me.Kind, GetDiagnostics, annotations, _identifier)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitIdentifierName(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a simple type name with one or more generic arguments, such as "X(Of
    ''' Y, Z).
    ''' </summary>
    Friend NotInheritable Class GenericNameSyntax
        Inherits SimpleNameSyntax

        Friend ReadOnly _typeArgumentList as TypeArgumentListSyntax

        Friend Sub New(ByVal kind As SyntaxKind, identifier As InternalSyntax.IdentifierTokenSyntax, typeArgumentList As TypeArgumentListSyntax)
            MyBase.New(kind, identifier)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(typeArgumentList)
            Me._typeArgumentList = typeArgumentList

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, identifier As InternalSyntax.IdentifierTokenSyntax, typeArgumentList As TypeArgumentListSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, identifier)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(typeArgumentList)
            Me._typeArgumentList = typeArgumentList

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), identifier As InternalSyntax.IdentifierTokenSyntax, typeArgumentList As TypeArgumentListSyntax)
            MyBase.New(kind, errors, annotations, identifier)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(typeArgumentList)
            Me._typeArgumentList = typeArgumentList

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The generic argument list.
        ''' </summary>
        Friend ReadOnly Property TypeArgumentList As InternalSyntax.TypeArgumentListSyntax
            Get
                Return Me._typeArgumentList
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._identifier
                Case 1
                    Return Me._typeArgumentList
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new GenericNameSyntax(Me.Kind, newErrors, GetAnnotations, _identifier, _typeArgumentList)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new GenericNameSyntax(Me.Kind, GetDiagnostics, annotations, _identifier, _typeArgumentList)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitGenericName(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a qualified type name, for example X.Y or X(Of Z).Y.
    ''' </summary>
    Friend NotInheritable Class QualifiedNameSyntax
        Inherits NameSyntax

        Friend ReadOnly _left as NameSyntax
        Friend ReadOnly _dotToken as PunctuationSyntax
        Friend ReadOnly _right as SimpleNameSyntax

        Friend Sub New(ByVal kind As SyntaxKind, left As NameSyntax, dotToken As InternalSyntax.PunctuationSyntax, right As SimpleNameSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(left)
            Me._left = left
            AdjustFlagsAndWidth(dotToken)
            Me._dotToken = dotToken
            AdjustFlagsAndWidth(right)
            Me._right = right

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, left As NameSyntax, dotToken As InternalSyntax.PunctuationSyntax, right As SimpleNameSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(left)
            Me._left = left
            AdjustFlagsAndWidth(dotToken)
            Me._dotToken = dotToken
            AdjustFlagsAndWidth(right)
            Me._right = right

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), left As NameSyntax, dotToken As InternalSyntax.PunctuationSyntax, right As SimpleNameSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(left)
            Me._left = left
            AdjustFlagsAndWidth(dotToken)
            Me._dotToken = dotToken
            AdjustFlagsAndWidth(right)
            Me._right = right

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The part of the name that appears to the left of the dot. This can itself be
        ''' any name.
        ''' </summary>
        Friend ReadOnly Property Left As InternalSyntax.NameSyntax
            Get
                Return Me._left
            End Get
        End Property

        ''' <summary>
        ''' The "." token that separates the names.
        ''' </summary>
        Friend ReadOnly Property DotToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._dotToken
            End Get
        End Property

        ''' <summary>
        ''' The part of the name that appears to the right of the dot. This must be a
        ''' simple identifier.
        ''' </summary>
        Friend ReadOnly Property Right As InternalSyntax.SimpleNameSyntax
            Get
                Return Me._right
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._left
                Case 1
                    Return Me._dotToken
                Case 2
                    Return Me._right
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new QualifiedNameSyntax(Me.Kind, newErrors, GetAnnotations, _left, _dotToken, _right)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new QualifiedNameSyntax(Me.Kind, GetDiagnostics, annotations, _left, _dotToken, _right)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitQualifiedName(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a name in the global namespace.
    ''' </summary>
    Friend NotInheritable Class GlobalNameSyntax
        Inherits NameSyntax

        Friend ReadOnly _globalKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, globalKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(globalKeyword)
            Me._globalKeyword = globalKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, globalKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(globalKeyword)
            Me._globalKeyword = globalKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), globalKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(globalKeyword)
            Me._globalKeyword = globalKeyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.GlobalNameSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Global" keyword.
        ''' </summary>
        Friend ReadOnly Property GlobalKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._globalKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._globalKeyword
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new GlobalNameSyntax(Me.Kind, newErrors, GetAnnotations, _globalKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new GlobalNameSyntax(Me.Kind, GetDiagnostics, annotations, _globalKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitGlobalName(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a parenthesized list of generic type arguments.
    ''' </summary>
    Friend NotInheritable Class TypeArgumentListSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _ofKeyword as KeywordSyntax
        Friend ReadOnly _arguments as GreenNode
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, ofKeyword As InternalSyntax.KeywordSyntax, arguments As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(ofKeyword)
            Me._ofKeyword = ofKeyword
            If arguments IsNot Nothing Then
                AdjustFlagsAndWidth(arguments)
                Me._arguments = arguments
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, ofKeyword As InternalSyntax.KeywordSyntax, arguments As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 4
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(ofKeyword)
            Me._ofKeyword = ofKeyword
            If arguments IsNot Nothing Then
                AdjustFlagsAndWidth(arguments)
                Me._arguments = arguments
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), openParenToken As InternalSyntax.PunctuationSyntax, ofKeyword As InternalSyntax.KeywordSyntax, arguments As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(ofKeyword)
            Me._ofKeyword = ofKeyword
            If arguments IsNot Nothing Then
                AdjustFlagsAndWidth(arguments)
                Me._arguments = arguments
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "(" token.
        ''' </summary>
        Friend ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The "Of" keyword.
        ''' </summary>
        Friend ReadOnly Property OfKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._ofKeyword
            End Get
        End Property

        ''' <summary>
        ''' A list of all the type arguments.
        ''' </summary>
        Friend ReadOnly Property Arguments As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of TypeSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of TypeSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of TypeSyntax)(Me._arguments))
            End Get
        End Property

        ''' <summary>
        ''' The ")" token.
        ''' </summary>
        Friend ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._openParenToken
                Case 1
                    Return Me._ofKeyword
                Case 2
                    Return Me._arguments
                Case 3
                    Return Me._closeParenToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new TypeArgumentListSyntax(Me.Kind, newErrors, GetAnnotations, _openParenToken, _ofKeyword, _arguments, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new TypeArgumentListSyntax(Me.Kind, GetDiagnostics, annotations, _openParenToken, _ofKeyword, _arguments, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitTypeArgumentList(Me)
        End Function

    End Class

    ''' <summary>
    ''' Syntax node class that represents a value of 'cref' attribute inside
    ''' documentation comment trivia.
    ''' </summary>
    Friend NotInheritable Class CrefReferenceSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _name as TypeSyntax
        Friend ReadOnly _signature as CrefSignatureSyntax
        Friend ReadOnly _asClause as SimpleAsClauseSyntax

        Friend Sub New(ByVal kind As SyntaxKind, name As TypeSyntax, signature As CrefSignatureSyntax, asClause As SimpleAsClauseSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(name)
            Me._name = name
            If signature IsNot Nothing Then
                AdjustFlagsAndWidth(signature)
                Me._signature = signature
            End If
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, name As TypeSyntax, signature As CrefSignatureSyntax, asClause As SimpleAsClauseSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(name)
            Me._name = name
            If signature IsNot Nothing Then
                AdjustFlagsAndWidth(signature)
                Me._signature = signature
            End If
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), name As TypeSyntax, signature As CrefSignatureSyntax, asClause As SimpleAsClauseSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(name)
            Me._name = name
            If signature IsNot Nothing Then
                AdjustFlagsAndWidth(signature)
                Me._signature = signature
            End If
            If asClause IsNot Nothing Then
                AdjustFlagsAndWidth(asClause)
                Me._asClause = asClause
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property Name As InternalSyntax.TypeSyntax
            Get
                Return Me._name
            End Get
        End Property

        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Signature As InternalSyntax.CrefSignatureSyntax
            Get
                Return Me._signature
            End Get
        End Property

        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property AsClause As InternalSyntax.SimpleAsClauseSyntax
            Get
                Return Me._asClause
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._name
                Case 1
                    Return Me._signature
                Case 2
                    Return Me._asClause
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new CrefReferenceSyntax(Me.Kind, newErrors, GetAnnotations, _name, _signature, _asClause)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new CrefReferenceSyntax(Me.Kind, GetDiagnostics, annotations, _name, _signature, _asClause)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitCrefReference(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a parenthesized list of argument types for a signature inside
    ''' CrefReferenceSyntax syntax.
    ''' </summary>
    Friend NotInheritable Class CrefSignatureSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _argumentTypes as GreenNode
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, argumentTypes As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            If argumentTypes IsNot Nothing Then
                AdjustFlagsAndWidth(argumentTypes)
                Me._argumentTypes = argumentTypes
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, openParenToken As InternalSyntax.PunctuationSyntax, argumentTypes As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            If argumentTypes IsNot Nothing Then
                AdjustFlagsAndWidth(argumentTypes)
                Me._argumentTypes = argumentTypes
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), openParenToken As InternalSyntax.PunctuationSyntax, argumentTypes As GreenNode, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            If argumentTypes IsNot Nothing Then
                AdjustFlagsAndWidth(argumentTypes)
                Me._argumentTypes = argumentTypes
            End If
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignatureSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        Friend ReadOnly Property ArgumentTypes As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of CrefSignaturePartSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of CrefSignaturePartSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of CrefSignaturePartSyntax)(Me._argumentTypes))
            End Get
        End Property

        Friend ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._openParenToken
                Case 1
                    Return Me._argumentTypes
                Case 2
                    Return Me._closeParenToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new CrefSignatureSyntax(Me.Kind, newErrors, GetAnnotations, _openParenToken, _argumentTypes, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new CrefSignatureSyntax(Me.Kind, GetDiagnostics, annotations, _openParenToken, _argumentTypes, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitCrefSignature(Me)
        End Function

    End Class

    Friend NotInheritable Class CrefSignaturePartSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _modifier as KeywordSyntax
        Friend ReadOnly _type as TypeSyntax

        Friend Sub New(ByVal kind As SyntaxKind, modifier As InternalSyntax.KeywordSyntax, type As TypeSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            If modifier IsNot Nothing Then
                AdjustFlagsAndWidth(modifier)
                Me._modifier = modifier
            End If
            If type IsNot Nothing Then
                AdjustFlagsAndWidth(type)
                Me._type = type
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, modifier As InternalSyntax.KeywordSyntax, type As TypeSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            If modifier IsNot Nothing Then
                AdjustFlagsAndWidth(modifier)
                Me._modifier = modifier
            End If
            If type IsNot Nothing Then
                AdjustFlagsAndWidth(type)
                Me._type = type
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), modifier As InternalSyntax.KeywordSyntax, type As TypeSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            If modifier IsNot Nothing Then
                AdjustFlagsAndWidth(modifier)
                Me._modifier = modifier
            End If
            If type IsNot Nothing Then
                AdjustFlagsAndWidth(type)
                Me._type = type
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignaturePartSyntax(Me, parent, startLocation)
        End Function

        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Modifier As InternalSyntax.KeywordSyntax
            Get
                Return Me._modifier
            End Get
        End Property

        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Type As InternalSyntax.TypeSyntax
            Get
                Return Me._type
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._modifier
                Case 1
                    Return Me._type
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new CrefSignaturePartSyntax(Me.Kind, newErrors, GetAnnotations, _modifier, _type)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new CrefSignaturePartSyntax(Me.Kind, GetDiagnostics, annotations, _modifier, _type)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitCrefSignaturePart(Me)
        End Function

    End Class

    Friend NotInheritable Class CrefOperatorReferenceSyntax
        Inherits NameSyntax

        Friend ReadOnly _operatorKeyword as KeywordSyntax
        Friend ReadOnly _operatorToken as SyntaxToken

        Friend Sub New(ByVal kind As SyntaxKind, operatorKeyword As InternalSyntax.KeywordSyntax, operatorToken As InternalSyntax.SyntaxToken)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(operatorKeyword)
            Me._operatorKeyword = operatorKeyword
            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, operatorKeyword As InternalSyntax.KeywordSyntax, operatorToken As InternalSyntax.SyntaxToken, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(operatorKeyword)
            Me._operatorKeyword = operatorKeyword
            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), operatorKeyword As InternalSyntax.KeywordSyntax, operatorToken As InternalSyntax.SyntaxToken)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(operatorKeyword)
            Me._operatorKeyword = operatorKeyword
            AdjustFlagsAndWidth(operatorToken)
            Me._operatorToken = operatorToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefOperatorReferenceSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property OperatorKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._operatorKeyword
            End Get
        End Property

        Friend ReadOnly Property OperatorToken As InternalSyntax.SyntaxToken
            Get
                Return Me._operatorToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._operatorKeyword
                Case 1
                    Return Me._operatorToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new CrefOperatorReferenceSyntax(Me.Kind, newErrors, GetAnnotations, _operatorKeyword, _operatorToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new CrefOperatorReferenceSyntax(Me.Kind, GetDiagnostics, annotations, _operatorKeyword, _operatorToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitCrefOperatorReference(Me)
        End Function

    End Class

    Friend NotInheritable Class QualifiedCrefOperatorReferenceSyntax
        Inherits NameSyntax

        Friend ReadOnly _left as NameSyntax
        Friend ReadOnly _dotToken as PunctuationSyntax
        Friend ReadOnly _right as CrefOperatorReferenceSyntax

        Friend Sub New(ByVal kind As SyntaxKind, left As NameSyntax, dotToken As InternalSyntax.PunctuationSyntax, right As CrefOperatorReferenceSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(left)
            Me._left = left
            AdjustFlagsAndWidth(dotToken)
            Me._dotToken = dotToken
            AdjustFlagsAndWidth(right)
            Me._right = right

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, left As NameSyntax, dotToken As InternalSyntax.PunctuationSyntax, right As CrefOperatorReferenceSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(left)
            Me._left = left
            AdjustFlagsAndWidth(dotToken)
            Me._dotToken = dotToken
            AdjustFlagsAndWidth(right)
            Me._right = right

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), left As NameSyntax, dotToken As InternalSyntax.PunctuationSyntax, right As CrefOperatorReferenceSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(left)
            Me._left = left
            AdjustFlagsAndWidth(dotToken)
            Me._dotToken = dotToken
            AdjustFlagsAndWidth(right)
            Me._right = right

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedCrefOperatorReferenceSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property Left As InternalSyntax.NameSyntax
            Get
                Return Me._left
            End Get
        End Property

        Friend ReadOnly Property DotToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._dotToken
            End Get
        End Property

        Friend ReadOnly Property Right As InternalSyntax.CrefOperatorReferenceSyntax
            Get
                Return Me._right
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._left
                Case 1
                    Return Me._dotToken
                Case 2
                    Return Me._right
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new QualifiedCrefOperatorReferenceSyntax(Me.Kind, newErrors, GetAnnotations, _left, _dotToken, _right)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new QualifiedCrefOperatorReferenceSyntax(Me.Kind, GetDiagnostics, annotations, _left, _dotToken, _right)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitQualifiedCrefOperatorReference(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represent a Yield statement.
    ''' </summary>
    Friend NotInheritable Class YieldStatementSyntax
        Inherits ExecutableStatementSyntax

        Friend ReadOnly _yieldKeyword as KeywordSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, yieldKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(yieldKeyword)
            Me._yieldKeyword = yieldKeyword
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, yieldKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(yieldKeyword)
            Me._yieldKeyword = yieldKeyword
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), yieldKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(yieldKeyword)
            Me._yieldKeyword = yieldKeyword
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.YieldStatementSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Yield" keyword.
        ''' </summary>
        Friend ReadOnly Property YieldKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._yieldKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression whose value is being yielded.
        ''' </summary>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._yieldKeyword
                Case 1
                    Return Me._expression
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new YieldStatementSyntax(Me.Kind, newErrors, GetAnnotations, _yieldKeyword, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new YieldStatementSyntax(Me.Kind, GetDiagnostics, annotations, _yieldKeyword, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitYieldStatement(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an Await expression.
    ''' </summary>
    Friend NotInheritable Class AwaitExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _awaitKeyword as KeywordSyntax
        Friend ReadOnly _expression as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, awaitKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(awaitKeyword)
            Me._awaitKeyword = awaitKeyword
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, awaitKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(awaitKeyword)
            Me._awaitKeyword = awaitKeyword
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), awaitKeyword As InternalSyntax.KeywordSyntax, expression As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(awaitKeyword)
            Me._awaitKeyword = awaitKeyword
            AdjustFlagsAndWidth(expression)
            Me._expression = expression

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Await" keyword.
        ''' </summary>
        Friend ReadOnly Property AwaitKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._awaitKeyword
            End Get
        End Property

        ''' <summary>
        ''' The expression being awaited.
        ''' </summary>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._awaitKeyword
                Case 1
                    Return Me._expression
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new AwaitExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _awaitKeyword, _expression)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new AwaitExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _awaitKeyword, _expression)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitAwaitExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a single syntactic token in a VB program. A token is a keyword,
    ''' punctuator, literal, identifier or XML token. The type of keyword or punctuator
    ''' can be determined from the Kind property.
    ''' </summary>
    Friend MustInherit Class SyntaxToken
        Inherits VisualBasicSyntaxNode


    End Class

    ''' <summary>
    ''' Represents a single keyword in a VB program. Which keyword can be determined
    ''' from the Kind property.
    ''' </summary>
    Friend NotInheritable Class KeywordSyntax
        Inherits SyntaxToken


        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode)
            MyBase.New(kind, errors, annotations, text, leadingTrivia, trailingTrivia)
        End Sub

        Public Overrides Function WithLeadingTrivia(ByVal trivia As GreenNode) As GreenNode
            Return new KeywordSyntax(Me.Kind, GetDiagnostics, GetAnnotations, text, trivia, GetTrailingTrivia)
        End Function

        Public Overrides Function WithTrailingTrivia(ByVal trivia As GreenNode) As GreenNode
            Return new KeywordSyntax(Me.Kind, GetDiagnostics, GetAnnotations, text, GetLeadingTrivia, trivia)
        End Function

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new KeywordSyntax(Me.Kind, newErrors, GetAnnotations, text, GetLeadingTrivia, GetTrailingTrivia)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new KeywordSyntax(Me.Kind, GetDiagnostics, annotations, text, GetLeadingTrivia, GetTrailingTrivia)
        End Function

    End Class

    ''' <summary>
    ''' Represents a single punctuation mark or operator in a VB program. Which one can
    ''' be determined from the Kind property.
    ''' </summary>
    Friend Class PunctuationSyntax
        Inherits SyntaxToken


        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode)
            MyBase.New(kind, errors, annotations, text, leadingTrivia, trailingTrivia)
        End Sub

        Public Overrides Function WithLeadingTrivia(ByVal trivia As GreenNode) As GreenNode
            Return new PunctuationSyntax(Me.Kind, GetDiagnostics, GetAnnotations, text, trivia, GetTrailingTrivia)
        End Function

        Public Overrides Function WithTrailingTrivia(ByVal trivia As GreenNode) As GreenNode
            Return new PunctuationSyntax(Me.Kind, GetDiagnostics, GetAnnotations, text, GetLeadingTrivia, trivia)
        End Function

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new PunctuationSyntax(Me.Kind, newErrors, GetAnnotations, text, GetLeadingTrivia, GetTrailingTrivia)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new PunctuationSyntax(Me.Kind, GetDiagnostics, annotations, text, GetLeadingTrivia, GetTrailingTrivia)
        End Function

    End Class

    ''' <summary>
    ''' Represents an Xml NCName per Namespaces in XML 1.0
    ''' </summary>
    Friend NotInheritable Class XmlNameTokenSyntax
        Inherits SyntaxToken

        Friend ReadOnly _possibleKeywordKind as SyntaxKind

        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode, possibleKeywordKind As SyntaxKind)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
            Me._possibleKeywordKind = possibleKeywordKind
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode, possibleKeywordKind As SyntaxKind, context As ISyntaxFactoryContext)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
            Me.SetFactoryContext(context)
            Me._possibleKeywordKind = possibleKeywordKind
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode, possibleKeywordKind As SyntaxKind)
            MyBase.New(kind, errors, annotations, text, leadingTrivia, trailingTrivia)
            Me._possibleKeywordKind = possibleKeywordKind
        End Sub

        Friend ReadOnly Property PossibleKeywordKind As SyntaxKind
            Get
                Return Me._possibleKeywordKind
            End Get
        End Property

        Public Overrides Function WithLeadingTrivia(ByVal trivia As GreenNode) As GreenNode
            Return new XmlNameTokenSyntax(Me.Kind, GetDiagnostics, GetAnnotations, text, trivia, GetTrailingTrivia, _possibleKeywordKind)
        End Function

        Public Overrides Function WithTrailingTrivia(ByVal trivia As GreenNode) As GreenNode
            Return new XmlNameTokenSyntax(Me.Kind, GetDiagnostics, GetAnnotations, text, GetLeadingTrivia, trivia, _possibleKeywordKind)
        End Function

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlNameTokenSyntax(Me.Kind, newErrors, GetAnnotations, text, GetLeadingTrivia, GetTrailingTrivia, _possibleKeywordKind)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlNameTokenSyntax(Me.Kind, GetDiagnostics, annotations, text, GetLeadingTrivia, GetTrailingTrivia, _possibleKeywordKind)
        End Function

    End Class

    ''' <summary>
    ''' Represents character data in Xml content also known as PCData or in an Xml
    ''' attribute value. All text is here for now even text that does not need
    ''' normalization such as comment, pi and cdata text.
    ''' </summary>
    Friend NotInheritable Class XmlTextTokenSyntax
        Inherits SyntaxToken

        Friend ReadOnly _value as String

        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode, value As String)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
            Me._value = value
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode, value As String, context As ISyntaxFactoryContext)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
            Me.SetFactoryContext(context)
            Me._value = value
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode, value As String)
            MyBase.New(kind, errors, annotations, text, leadingTrivia, trailingTrivia)
            Me._value = value
        End Sub

        ''' <summary>
        ''' The text of the attribute or pcdata after normalization.
        ''' </summary>
        Friend ReadOnly Property Value As String
            Get
                Return Me._value
            End Get
        End Property

        Public Overrides Function WithLeadingTrivia(ByVal trivia As GreenNode) As GreenNode
            Return new XmlTextTokenSyntax(Me.Kind, GetDiagnostics, GetAnnotations, text, trivia, GetTrailingTrivia, _value)
        End Function

        Public Overrides Function WithTrailingTrivia(ByVal trivia As GreenNode) As GreenNode
            Return new XmlTextTokenSyntax(Me.Kind, GetDiagnostics, GetAnnotations, text, GetLeadingTrivia, trivia, _value)
        End Function

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlTextTokenSyntax(Me.Kind, newErrors, GetAnnotations, text, GetLeadingTrivia, GetTrailingTrivia, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlTextTokenSyntax(Me.Kind, GetDiagnostics, annotations, text, GetLeadingTrivia, GetTrailingTrivia, _value)
        End Function

    End Class

    ''' <summary>
    ''' Represents literal character data in interpolated string expression.
    ''' </summary>
    Friend NotInheritable Class InterpolatedStringTextTokenSyntax
        Inherits SyntaxToken

        Friend ReadOnly _value as String

        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode, value As String)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
            Me._value = value
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode, value As String, context As ISyntaxFactoryContext)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
            Me.SetFactoryContext(context)
            Me._value = value
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode, value As String)
            MyBase.New(kind, errors, annotations, text, leadingTrivia, trailingTrivia)
            Me._value = value
        End Sub

        ''' <summary>
        ''' The text.
        ''' </summary>
        Friend ReadOnly Property Value As String
            Get
                Return Me._value
            End Get
        End Property

        Public Overrides Function WithLeadingTrivia(ByVal trivia As GreenNode) As GreenNode
            Return new InterpolatedStringTextTokenSyntax(Me.Kind, GetDiagnostics, GetAnnotations, text, trivia, GetTrailingTrivia, _value)
        End Function

        Public Overrides Function WithTrailingTrivia(ByVal trivia As GreenNode) As GreenNode
            Return new InterpolatedStringTextTokenSyntax(Me.Kind, GetDiagnostics, GetAnnotations, text, GetLeadingTrivia, trivia, _value)
        End Function

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new InterpolatedStringTextTokenSyntax(Me.Kind, newErrors, GetAnnotations, text, GetLeadingTrivia, GetTrailingTrivia, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new InterpolatedStringTextTokenSyntax(Me.Kind, GetDiagnostics, annotations, text, GetLeadingTrivia, GetTrailingTrivia, _value)
        End Function

    End Class

    ''' <summary>
    ''' Represents a Decimal literal token.
    ''' </summary>
    Friend NotInheritable Class DecimalLiteralTokenSyntax
        Inherits SyntaxToken

        Friend ReadOnly _typeSuffix as TypeCharacter
        Friend ReadOnly _value as System.Decimal

        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode, typeSuffix As TypeCharacter, value As System.Decimal)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
            Me._typeSuffix = typeSuffix
            Me._value = value
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode, typeSuffix As TypeCharacter, value As System.Decimal, context As ISyntaxFactoryContext)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
            Me.SetFactoryContext(context)
            Me._typeSuffix = typeSuffix
            Me._value = value
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode, typeSuffix As TypeCharacter, value As System.Decimal)
            MyBase.New(kind, errors, annotations, text, leadingTrivia, trailingTrivia)
            Me._typeSuffix = typeSuffix
            Me._value = value
        End Sub

        ''' <summary>
        ''' The type suffix or type character that was on the literal, if any. If no suffix
        ''' was present, TypeCharacter.None is returned.
        ''' </summary>
        Friend ReadOnly Property TypeSuffix As TypeCharacter
            Get
                Return Me._typeSuffix
            End Get
        End Property

        ''' <summary>
        ''' The value of the token.
        ''' </summary>
        Friend ReadOnly Property Value As System.Decimal
            Get
                Return Me._value
            End Get
        End Property

        Public Overrides Function WithLeadingTrivia(ByVal trivia As GreenNode) As GreenNode
            Return new DecimalLiteralTokenSyntax(Me.Kind, GetDiagnostics, GetAnnotations, text, trivia, GetTrailingTrivia, _typeSuffix, _value)
        End Function

        Public Overrides Function WithTrailingTrivia(ByVal trivia As GreenNode) As GreenNode
            Return new DecimalLiteralTokenSyntax(Me.Kind, GetDiagnostics, GetAnnotations, text, GetLeadingTrivia, trivia, _typeSuffix, _value)
        End Function

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new DecimalLiteralTokenSyntax(Me.Kind, newErrors, GetAnnotations, text, GetLeadingTrivia, GetTrailingTrivia, _typeSuffix, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new DecimalLiteralTokenSyntax(Me.Kind, GetDiagnostics, annotations, text, GetLeadingTrivia, GetTrailingTrivia, _typeSuffix, _value)
        End Function

    End Class

    ''' <summary>
    ''' Represents a Date literal token.
    ''' </summary>
    Friend NotInheritable Class DateLiteralTokenSyntax
        Inherits SyntaxToken

        Friend ReadOnly _value as DateTime

        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode, value As DateTime)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
            Me._value = value
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode, value As DateTime, context As ISyntaxFactoryContext)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
            Me.SetFactoryContext(context)
            Me._value = value
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode, value As DateTime)
            MyBase.New(kind, errors, annotations, text, leadingTrivia, trailingTrivia)
            Me._value = value
        End Sub

        ''' <summary>
        ''' The value of the token.
        ''' </summary>
        Friend ReadOnly Property Value As DateTime
            Get
                Return Me._value
            End Get
        End Property

        Public Overrides Function WithLeadingTrivia(ByVal trivia As GreenNode) As GreenNode
            Return new DateLiteralTokenSyntax(Me.Kind, GetDiagnostics, GetAnnotations, text, trivia, GetTrailingTrivia, _value)
        End Function

        Public Overrides Function WithTrailingTrivia(ByVal trivia As GreenNode) As GreenNode
            Return new DateLiteralTokenSyntax(Me.Kind, GetDiagnostics, GetAnnotations, text, GetLeadingTrivia, trivia, _value)
        End Function

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new DateLiteralTokenSyntax(Me.Kind, newErrors, GetAnnotations, text, GetLeadingTrivia, GetTrailingTrivia, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new DateLiteralTokenSyntax(Me.Kind, GetDiagnostics, annotations, text, GetLeadingTrivia, GetTrailingTrivia, _value)
        End Function

    End Class

    ''' <summary>
    ''' Represents a string literal token.
    ''' </summary>
    Friend NotInheritable Class StringLiteralTokenSyntax
        Inherits SyntaxToken

        Friend ReadOnly _value as String

        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode, value As String)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
            Me._value = value
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode, value As String, context As ISyntaxFactoryContext)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
            Me.SetFactoryContext(context)
            Me._value = value
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode, value As String)
            MyBase.New(kind, errors, annotations, text, leadingTrivia, trailingTrivia)
            Me._value = value
        End Sub

        ''' <summary>
        ''' The value of the string, after removing the quotation marks and combining
        ''' doubled quotation marks.
        ''' </summary>
        Friend ReadOnly Property Value As String
            Get
                Return Me._value
            End Get
        End Property

        Public Overrides Function WithLeadingTrivia(ByVal trivia As GreenNode) As GreenNode
            Return new StringLiteralTokenSyntax(Me.Kind, GetDiagnostics, GetAnnotations, text, trivia, GetTrailingTrivia, _value)
        End Function

        Public Overrides Function WithTrailingTrivia(ByVal trivia As GreenNode) As GreenNode
            Return new StringLiteralTokenSyntax(Me.Kind, GetDiagnostics, GetAnnotations, text, GetLeadingTrivia, trivia, _value)
        End Function

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new StringLiteralTokenSyntax(Me.Kind, newErrors, GetAnnotations, text, GetLeadingTrivia, GetTrailingTrivia, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new StringLiteralTokenSyntax(Me.Kind, GetDiagnostics, annotations, text, GetLeadingTrivia, GetTrailingTrivia, _value)
        End Function

    End Class

    ''' <summary>
    ''' Represents a string literal token.
    ''' </summary>
    Friend NotInheritable Class CharacterLiteralTokenSyntax
        Inherits SyntaxToken

        Friend ReadOnly _value as Char

        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode, value As Char)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
            Me._value = value
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode, value As Char, context As ISyntaxFactoryContext)
            MyBase.New(kind, text, leadingTrivia, trailingTrivia)
            Me.SetFactoryContext(context)
            Me._value = value
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), text as String, leadingTrivia As GreenNode, trailingTrivia As GreenNode, value As Char)
            MyBase.New(kind, errors, annotations, text, leadingTrivia, trailingTrivia)
            Me._value = value
        End Sub

        ''' <summary>
        ''' The value of the character, after removing the quotation marks.
        ''' </summary>
        Friend ReadOnly Property Value As Char
            Get
                Return Me._value
            End Get
        End Property

        Public Overrides Function WithLeadingTrivia(ByVal trivia As GreenNode) As GreenNode
            Return new CharacterLiteralTokenSyntax(Me.Kind, GetDiagnostics, GetAnnotations, text, trivia, GetTrailingTrivia, _value)
        End Function

        Public Overrides Function WithTrailingTrivia(ByVal trivia As GreenNode) As GreenNode
            Return new CharacterLiteralTokenSyntax(Me.Kind, GetDiagnostics, GetAnnotations, text, GetLeadingTrivia, trivia, _value)
        End Function

        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new CharacterLiteralTokenSyntax(Me.Kind, newErrors, GetAnnotations, text, GetLeadingTrivia, GetTrailingTrivia, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new CharacterLiteralTokenSyntax(Me.Kind, GetDiagnostics, annotations, text, GetLeadingTrivia, GetTrailingTrivia, _value)
        End Function

    End Class

    ''' <summary>
    ''' Abstract class that represent structured trivia.
    ''' </summary>
    Friend MustInherit Class StructuredTriviaSyntax
        Inherits VisualBasicSyntaxNode


    End Class

    ''' <summary>
    ''' Represents tokens that were skipped by the parser as part of error recovery,
    ''' and thus are not part of any syntactic structure.
    ''' </summary>
    Friend NotInheritable Class SkippedTokensTriviaSyntax
        Inherits StructuredTriviaSyntax

        Friend ReadOnly _tokens as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, tokens As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 1

            If tokens IsNot Nothing Then
                AdjustFlagsAndWidth(tokens)
                Me._tokens = tokens
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, tokens As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            If tokens IsNot Nothing Then
                AdjustFlagsAndWidth(tokens)
                Me._tokens = tokens
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), tokens As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            If tokens IsNot Nothing Then
                AdjustFlagsAndWidth(tokens)
                Me._tokens = tokens
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.SkippedTokensTriviaSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The list of tokens that were skipped by the parser.
        ''' </summary>
        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Tokens As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of SyntaxToken)
            Get
                Return New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)(Me._tokens)
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._tokens
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new SkippedTokensTriviaSyntax(Me.Kind, newErrors, GetAnnotations, _tokens)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new SkippedTokensTriviaSyntax(Me.Kind, GetDiagnostics, annotations, _tokens)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitSkippedTokensTrivia(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a documentation comment e.g. ''' &lt;Summary&gt; appearing in
    ''' source.
    ''' </summary>
    Friend NotInheritable Class DocumentationCommentTriviaSyntax
        Inherits StructuredTriviaSyntax

        Friend ReadOnly _content as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, content As GreenNode)
            MyBase.New(kind)
            Me.SlotCount = 1

            If content IsNot Nothing Then
                AdjustFlagsAndWidth(content)
                Me._content = content
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, content As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            If content IsNot Nothing Then
                AdjustFlagsAndWidth(content)
                Me._content = content
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), content As GreenNode)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            If content IsNot Nothing Then
                AdjustFlagsAndWidth(content)
                Me._content = content
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DocumentationCommentTriviaSyntax(Me, parent, startLocation)
        End Function

        ''' <remarks>
        ''' If nothing is present, an empty list is returned.
        ''' </remarks>
        Friend ReadOnly Property Content As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of XmlNodeSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of XmlNodeSyntax)(Me._content)
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._content
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new DocumentationCommentTriviaSyntax(Me.Kind, newErrors, GetAnnotations, _content)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new DocumentationCommentTriviaSyntax(Me.Kind, GetDiagnostics, annotations, _content)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitDocumentationCommentTrivia(Me)
        End Function

    End Class

    ''' <summary>
    ''' A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or
    ''' &lt;seealso&gt; documentation comment tag). For example, the M in &lt;see
    ''' cref="M" /&gt;.
    ''' </summary>
    Friend NotInheritable Class XmlCrefAttributeSyntax
        Inherits BaseXmlAttributeSyntax

        Friend ReadOnly _name as XmlNameSyntax
        Friend ReadOnly _equalsToken as PunctuationSyntax
        Friend ReadOnly _startQuoteToken as PunctuationSyntax
        Friend ReadOnly _reference as CrefReferenceSyntax
        Friend ReadOnly _endQuoteToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, name As XmlNameSyntax, equalsToken As InternalSyntax.PunctuationSyntax, startQuoteToken As InternalSyntax.PunctuationSyntax, reference As CrefReferenceSyntax, endQuoteToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken
            AdjustFlagsAndWidth(startQuoteToken)
            Me._startQuoteToken = startQuoteToken
            AdjustFlagsAndWidth(reference)
            Me._reference = reference
            AdjustFlagsAndWidth(endQuoteToken)
            Me._endQuoteToken = endQuoteToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, name As XmlNameSyntax, equalsToken As InternalSyntax.PunctuationSyntax, startQuoteToken As InternalSyntax.PunctuationSyntax, reference As CrefReferenceSyntax, endQuoteToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken
            AdjustFlagsAndWidth(startQuoteToken)
            Me._startQuoteToken = startQuoteToken
            AdjustFlagsAndWidth(reference)
            Me._reference = reference
            AdjustFlagsAndWidth(endQuoteToken)
            Me._endQuoteToken = endQuoteToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), name As XmlNameSyntax, equalsToken As InternalSyntax.PunctuationSyntax, startQuoteToken As InternalSyntax.PunctuationSyntax, reference As CrefReferenceSyntax, endQuoteToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken
            AdjustFlagsAndWidth(startQuoteToken)
            Me._startQuoteToken = startQuoteToken
            AdjustFlagsAndWidth(reference)
            Me._reference = reference
            AdjustFlagsAndWidth(endQuoteToken)
            Me._endQuoteToken = endQuoteToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCrefAttributeSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property Name As InternalSyntax.XmlNameSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend ReadOnly Property EqualsToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._equalsToken
            End Get
        End Property

        Friend ReadOnly Property StartQuoteToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._startQuoteToken
            End Get
        End Property

        Friend ReadOnly Property Reference As InternalSyntax.CrefReferenceSyntax
            Get
                Return Me._reference
            End Get
        End Property

        Friend ReadOnly Property EndQuoteToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._endQuoteToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._name
                Case 1
                    Return Me._equalsToken
                Case 2
                    Return Me._startQuoteToken
                Case 3
                    Return Me._reference
                Case 4
                    Return Me._endQuoteToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlCrefAttributeSyntax(Me.Kind, newErrors, GetAnnotations, _name, _equalsToken, _startQuoteToken, _reference, _endQuoteToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlCrefAttributeSyntax(Me.Kind, GetDiagnostics, annotations, _name, _equalsToken, _startQuoteToken, _reference, _endQuoteToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitXmlCrefAttribute(Me)
        End Function

    End Class

    ''' <summary>
    ''' A param or type param symbol referenced by a name attribute (e.g. in a
    ''' &lt;param&gt; or &lt;typeparam&gt; documentation comment tag). For example, the
    ''' M in &lt;param name="M" /&gt;.
    ''' </summary>
    Friend NotInheritable Class XmlNameAttributeSyntax
        Inherits BaseXmlAttributeSyntax

        Friend ReadOnly _name as XmlNameSyntax
        Friend ReadOnly _equalsToken as PunctuationSyntax
        Friend ReadOnly _startQuoteToken as PunctuationSyntax
        Friend ReadOnly _reference as IdentifierNameSyntax
        Friend ReadOnly _endQuoteToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, name As XmlNameSyntax, equalsToken As InternalSyntax.PunctuationSyntax, startQuoteToken As InternalSyntax.PunctuationSyntax, reference As IdentifierNameSyntax, endQuoteToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken
            AdjustFlagsAndWidth(startQuoteToken)
            Me._startQuoteToken = startQuoteToken
            AdjustFlagsAndWidth(reference)
            Me._reference = reference
            AdjustFlagsAndWidth(endQuoteToken)
            Me._endQuoteToken = endQuoteToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, name As XmlNameSyntax, equalsToken As InternalSyntax.PunctuationSyntax, startQuoteToken As InternalSyntax.PunctuationSyntax, reference As IdentifierNameSyntax, endQuoteToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken
            AdjustFlagsAndWidth(startQuoteToken)
            Me._startQuoteToken = startQuoteToken
            AdjustFlagsAndWidth(reference)
            Me._reference = reference
            AdjustFlagsAndWidth(endQuoteToken)
            Me._endQuoteToken = endQuoteToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), name As XmlNameSyntax, equalsToken As InternalSyntax.PunctuationSyntax, startQuoteToken As InternalSyntax.PunctuationSyntax, reference As IdentifierNameSyntax, endQuoteToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken
            AdjustFlagsAndWidth(startQuoteToken)
            Me._startQuoteToken = startQuoteToken
            AdjustFlagsAndWidth(reference)
            Me._reference = reference
            AdjustFlagsAndWidth(endQuoteToken)
            Me._endQuoteToken = endQuoteToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameAttributeSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property Name As InternalSyntax.XmlNameSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend ReadOnly Property EqualsToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._equalsToken
            End Get
        End Property

        Friend ReadOnly Property StartQuoteToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._startQuoteToken
            End Get
        End Property

        Friend ReadOnly Property Reference As InternalSyntax.IdentifierNameSyntax
            Get
                Return Me._reference
            End Get
        End Property

        Friend ReadOnly Property EndQuoteToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._endQuoteToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._name
                Case 1
                    Return Me._equalsToken
                Case 2
                    Return Me._startQuoteToken
                Case 3
                    Return Me._reference
                Case 4
                    Return Me._endQuoteToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new XmlNameAttributeSyntax(Me.Kind, newErrors, GetAnnotations, _name, _equalsToken, _startQuoteToken, _reference, _endQuoteToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new XmlNameAttributeSyntax(Me.Kind, GetDiagnostics, annotations, _name, _equalsToken, _startQuoteToken, _reference, _endQuoteToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitXmlNameAttribute(Me)
        End Function

    End Class

    ''' <summary>
    ''' ExpressionSyntax node representing the object conditionally accessed.
    ''' </summary>
    Friend NotInheritable Class ConditionalAccessExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _expression as ExpressionSyntax
        Friend ReadOnly _questionMarkToken as PunctuationSyntax
        Friend ReadOnly _whenNotNull as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, expression As ExpressionSyntax, questionMarkToken As InternalSyntax.PunctuationSyntax, whenNotNull As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            If expression IsNot Nothing Then
                AdjustFlagsAndWidth(expression)
                Me._expression = expression
            End If
            AdjustFlagsAndWidth(questionMarkToken)
            Me._questionMarkToken = questionMarkToken
            AdjustFlagsAndWidth(whenNotNull)
            Me._whenNotNull = whenNotNull

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, expression As ExpressionSyntax, questionMarkToken As InternalSyntax.PunctuationSyntax, whenNotNull As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            If expression IsNot Nothing Then
                AdjustFlagsAndWidth(expression)
                Me._expression = expression
            End If
            AdjustFlagsAndWidth(questionMarkToken)
            Me._questionMarkToken = questionMarkToken
            AdjustFlagsAndWidth(whenNotNull)
            Me._whenNotNull = whenNotNull

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), expression As ExpressionSyntax, questionMarkToken As InternalSyntax.PunctuationSyntax, whenNotNull As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            If expression IsNot Nothing Then
                AdjustFlagsAndWidth(expression)
                Me._expression = expression
            End If
            AdjustFlagsAndWidth(questionMarkToken)
            Me._questionMarkToken = questionMarkToken
            AdjustFlagsAndWidth(whenNotNull)
            Me._whenNotNull = whenNotNull

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The expression on the left-hand-side of the "?".
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        ''' <summary>
        ''' "?" token.
        ''' </summary>
        Friend ReadOnly Property QuestionMarkToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._questionMarkToken
            End Get
        End Property

        ''' <summary>
        ''' ExpressionSyntax node representing the access expression to be executed when
        ''' the object is not null."
        ''' </summary>
        Friend ReadOnly Property WhenNotNull As InternalSyntax.ExpressionSyntax
            Get
                Return Me._whenNotNull
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._expression
                Case 1
                    Return Me._questionMarkToken
                Case 2
                    Return Me._whenNotNull
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ConditionalAccessExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _expression, _questionMarkToken, _whenNotNull)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ConditionalAccessExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _expression, _questionMarkToken, _whenNotNull)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitConditionalAccessExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a NameOf expression.
    ''' </summary>
    Friend NotInheritable Class NameOfExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _nameOfKeyword as KeywordSyntax
        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _argument as ExpressionSyntax
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, nameOfKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, argument As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(nameOfKeyword)
            Me._nameOfKeyword = nameOfKeyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(argument)
            Me._argument = argument
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, nameOfKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, argument As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 4
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(nameOfKeyword)
            Me._nameOfKeyword = nameOfKeyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(argument)
            Me._argument = argument
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), nameOfKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, argument As ExpressionSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(nameOfKeyword)
            Me._nameOfKeyword = nameOfKeyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(argument)
            Me._argument = argument
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.NameOfExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "NameOf" keyword.
        ''' </summary>
        Friend ReadOnly Property NameOfKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._nameOfKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "(" token.
        ''' </summary>
        Friend ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        ''' <summary>
        ''' The argument.
        ''' </summary>
        Friend ReadOnly Property Argument As InternalSyntax.ExpressionSyntax
            Get
                Return Me._argument
            End Get
        End Property

        ''' <summary>
        ''' The ")" token.
        ''' </summary>
        Friend ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._nameOfKeyword
                Case 1
                    Return Me._openParenToken
                Case 2
                    Return Me._argument
                Case 3
                    Return Me._closeParenToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new NameOfExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _nameOfKeyword, _openParenToken, _argument, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new NameOfExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _nameOfKeyword, _openParenToken, _argument, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitNameOfExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an interpolated string expression.
    ''' </summary>
    Friend NotInheritable Class InterpolatedStringExpressionSyntax
        Inherits ExpressionSyntax

        Friend ReadOnly _dollarSignDoubleQuoteToken as PunctuationSyntax
        Friend ReadOnly _contents as GreenNode
        Friend ReadOnly _doubleQuoteToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, dollarSignDoubleQuoteToken As InternalSyntax.PunctuationSyntax, contents As GreenNode, doubleQuoteToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(dollarSignDoubleQuoteToken)
            Me._dollarSignDoubleQuoteToken = dollarSignDoubleQuoteToken
            If contents IsNot Nothing Then
                AdjustFlagsAndWidth(contents)
                Me._contents = contents
            End If
            AdjustFlagsAndWidth(doubleQuoteToken)
            Me._doubleQuoteToken = doubleQuoteToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, dollarSignDoubleQuoteToken As InternalSyntax.PunctuationSyntax, contents As GreenNode, doubleQuoteToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(dollarSignDoubleQuoteToken)
            Me._dollarSignDoubleQuoteToken = dollarSignDoubleQuoteToken
            If contents IsNot Nothing Then
                AdjustFlagsAndWidth(contents)
                Me._contents = contents
            End If
            AdjustFlagsAndWidth(doubleQuoteToken)
            Me._doubleQuoteToken = doubleQuoteToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), dollarSignDoubleQuoteToken As InternalSyntax.PunctuationSyntax, contents As GreenNode, doubleQuoteToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(dollarSignDoubleQuoteToken)
            Me._dollarSignDoubleQuoteToken = dollarSignDoubleQuoteToken
            If contents IsNot Nothing Then
                AdjustFlagsAndWidth(contents)
                Me._contents = contents
            End If
            AdjustFlagsAndWidth(doubleQuoteToken)
            Me._doubleQuoteToken = doubleQuoteToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringExpressionSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The opening '$"', '$“', or '$”' token.
        ''' </summary>
        Friend ReadOnly Property DollarSignDoubleQuoteToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._dollarSignDoubleQuoteToken
            End Get
        End Property

        ''' <summary>
        ''' The contents of the interpolated string.
        ''' </summary>
        Friend ReadOnly Property Contents As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of InterpolatedStringContentSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(Of InterpolatedStringContentSyntax)(Me._contents)
            End Get
        End Property

        ''' <summary>
        ''' The closing '"', '”', or '“' token.
        ''' </summary>
        Friend ReadOnly Property DoubleQuoteToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._doubleQuoteToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._dollarSignDoubleQuoteToken
                Case 1
                    Return Me._contents
                Case 2
                    Return Me._doubleQuoteToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new InterpolatedStringExpressionSyntax(Me.Kind, newErrors, GetAnnotations, _dollarSignDoubleQuoteToken, _contents, _doubleQuoteToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new InterpolatedStringExpressionSyntax(Me.Kind, GetDiagnostics, annotations, _dollarSignDoubleQuoteToken, _contents, _doubleQuoteToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitInterpolatedStringExpression(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents either text content or an interpolation.
    ''' </summary>
    Friend MustInherit Class InterpolatedStringContentSyntax
        Inherits VisualBasicSyntaxNode


        Friend Sub New(ByVal kind As SyntaxKind)
            MyBase.New(kind)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation())
            MyBase.New(kind, errors, annotations)
        End Sub

    End Class

    ''' <summary>
    ''' Represents literal text content in an interpolated string.
    ''' </summary>
    Friend NotInheritable Class InterpolatedStringTextSyntax
        Inherits InterpolatedStringContentSyntax

        Friend ReadOnly _textToken as InterpolatedStringTextTokenSyntax

        Friend Sub New(ByVal kind As SyntaxKind, textToken As InternalSyntax.InterpolatedStringTextTokenSyntax)
            MyBase.New(kind)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(textToken)
            Me._textToken = textToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, textToken As InternalSyntax.InterpolatedStringTextTokenSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(textToken)
            Me._textToken = textToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), textToken As InternalSyntax.InterpolatedStringTextTokenSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 1

            AdjustFlagsAndWidth(textToken)
            Me._textToken = textToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringTextSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The text token.
        ''' </summary>
        Friend ReadOnly Property TextToken As InternalSyntax.InterpolatedStringTextTokenSyntax
            Get
                Return Me._textToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._textToken
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new InterpolatedStringTextSyntax(Me.Kind, newErrors, GetAnnotations, _textToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new InterpolatedStringTextSyntax(Me.Kind, GetDiagnostics, annotations, _textToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitInterpolatedStringText(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an interpolation of an expression in an interpolated string
    ''' expression e.g. '{expression[,alignment][:formatString]}'.
    ''' </summary>
    Friend NotInheritable Class InterpolationSyntax
        Inherits InterpolatedStringContentSyntax

        Friend ReadOnly _openBraceToken as PunctuationSyntax
        Friend ReadOnly _expression as ExpressionSyntax
        Friend ReadOnly _alignmentClause as InterpolationAlignmentClauseSyntax
        Friend ReadOnly _formatClause as InterpolationFormatClauseSyntax
        Friend ReadOnly _closeBraceToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, openBraceToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, alignmentClause As InterpolationAlignmentClauseSyntax, formatClause As InterpolationFormatClauseSyntax, closeBraceToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(openBraceToken)
            Me._openBraceToken = openBraceToken
            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            If alignmentClause IsNot Nothing Then
                AdjustFlagsAndWidth(alignmentClause)
                Me._alignmentClause = alignmentClause
            End If
            If formatClause IsNot Nothing Then
                AdjustFlagsAndWidth(formatClause)
                Me._formatClause = formatClause
            End If
            AdjustFlagsAndWidth(closeBraceToken)
            Me._closeBraceToken = closeBraceToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, openBraceToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, alignmentClause As InterpolationAlignmentClauseSyntax, formatClause As InterpolationFormatClauseSyntax, closeBraceToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(openBraceToken)
            Me._openBraceToken = openBraceToken
            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            If alignmentClause IsNot Nothing Then
                AdjustFlagsAndWidth(alignmentClause)
                Me._alignmentClause = alignmentClause
            End If
            If formatClause IsNot Nothing Then
                AdjustFlagsAndWidth(formatClause)
                Me._formatClause = formatClause
            End If
            AdjustFlagsAndWidth(closeBraceToken)
            Me._closeBraceToken = closeBraceToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), openBraceToken As InternalSyntax.PunctuationSyntax, expression As ExpressionSyntax, alignmentClause As InterpolationAlignmentClauseSyntax, formatClause As InterpolationFormatClauseSyntax, closeBraceToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(openBraceToken)
            Me._openBraceToken = openBraceToken
            AdjustFlagsAndWidth(expression)
            Me._expression = expression
            If alignmentClause IsNot Nothing Then
                AdjustFlagsAndWidth(alignmentClause)
                Me._alignmentClause = alignmentClause
            End If
            If formatClause IsNot Nothing Then
                AdjustFlagsAndWidth(formatClause)
                Me._formatClause = formatClause
            End If
            AdjustFlagsAndWidth(closeBraceToken)
            Me._closeBraceToken = closeBraceToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The opening curly brace '{' token.
        ''' </summary>
        Friend ReadOnly Property OpenBraceToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openBraceToken
            End Get
        End Property

        ''' <summary>
        ''' The expression whose formatted value should be embedded in the resultant
        ''' string.
        ''' </summary>
        Friend ReadOnly Property Expression As InternalSyntax.ExpressionSyntax
            Get
                Return Me._expression
            End Get
        End Property

        ''' <summary>
        ''' Optional. The alignment clause ',alignment' of the embedded expression.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property AlignmentClause As InternalSyntax.InterpolationAlignmentClauseSyntax
            Get
                Return Me._alignmentClause
            End Get
        End Property

        ''' <summary>
        ''' Optional. The format string clause ':formatString' of the embedded expression.
        ''' </summary>
        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property FormatClause As InternalSyntax.InterpolationFormatClauseSyntax
            Get
                Return Me._formatClause
            End Get
        End Property

        ''' <summary>
        ''' The closing curly brace '}' token of the embedded expression.
        ''' </summary>
        Friend ReadOnly Property CloseBraceToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeBraceToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._openBraceToken
                Case 1
                    Return Me._expression
                Case 2
                    Return Me._alignmentClause
                Case 3
                    Return Me._formatClause
                Case 4
                    Return Me._closeBraceToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new InterpolationSyntax(Me.Kind, newErrors, GetAnnotations, _openBraceToken, _expression, _alignmentClause, _formatClause, _closeBraceToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new InterpolationSyntax(Me.Kind, GetDiagnostics, annotations, _openBraceToken, _expression, _alignmentClause, _formatClause, _closeBraceToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitInterpolation(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an alignment clause ',alignment' of an interpolated string embedded
    ''' expression.
    ''' </summary>
    Friend NotInheritable Class InterpolationAlignmentClauseSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _commaToken as PunctuationSyntax
        Friend ReadOnly _value as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, commaToken As InternalSyntax.PunctuationSyntax, value As ExpressionSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(commaToken)
            Me._commaToken = commaToken
            AdjustFlagsAndWidth(value)
            Me._value = value

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, commaToken As InternalSyntax.PunctuationSyntax, value As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(commaToken)
            Me._commaToken = commaToken
            AdjustFlagsAndWidth(value)
            Me._value = value

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), commaToken As InternalSyntax.PunctuationSyntax, value As ExpressionSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(commaToken)
            Me._commaToken = commaToken
            AdjustFlagsAndWidth(value)
            Me._value = value

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationAlignmentClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The comma ',' token.
        ''' </summary>
        Friend ReadOnly Property CommaToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._commaToken
            End Get
        End Property

        ''' <summary>
        ''' An expression representing the alignment of the interpolated expression.
        ''' </summary>
        Friend ReadOnly Property Value As InternalSyntax.ExpressionSyntax
            Get
                Return Me._value
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._commaToken
                Case 1
                    Return Me._value
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new InterpolationAlignmentClauseSyntax(Me.Kind, newErrors, GetAnnotations, _commaToken, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new InterpolationAlignmentClauseSyntax(Me.Kind, GetDiagnostics, annotations, _commaToken, _value)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitInterpolationAlignmentClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a format string clause ':formatString' of an interpolated string
    ''' embedded expression.
    ''' </summary>
    Friend NotInheritable Class InterpolationFormatClauseSyntax
        Inherits VisualBasicSyntaxNode

        Friend ReadOnly _colonToken as PunctuationSyntax
        Friend ReadOnly _formatStringToken as InterpolatedStringTextTokenSyntax

        Friend Sub New(ByVal kind As SyntaxKind, colonToken As InternalSyntax.PunctuationSyntax, formatStringToken As InternalSyntax.InterpolatedStringTextTokenSyntax)
            MyBase.New(kind)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(colonToken)
            Me._colonToken = colonToken
            AdjustFlagsAndWidth(formatStringToken)
            Me._formatStringToken = formatStringToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, colonToken As InternalSyntax.PunctuationSyntax, formatStringToken As InternalSyntax.InterpolatedStringTextTokenSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(colonToken)
            Me._colonToken = colonToken
            AdjustFlagsAndWidth(formatStringToken)
            Me._formatStringToken = formatStringToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), colonToken As InternalSyntax.PunctuationSyntax, formatStringToken As InternalSyntax.InterpolatedStringTextTokenSyntax)
            MyBase.New(kind, errors, annotations)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(colonToken)
            Me._colonToken = colonToken
            AdjustFlagsAndWidth(formatStringToken)
            Me._formatStringToken = formatStringToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationFormatClauseSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The ':' token.
        ''' </summary>
        Friend ReadOnly Property ColonToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._colonToken
            End Get
        End Property

        ''' <summary>
        ''' The format string.
        ''' </summary>
        Friend ReadOnly Property FormatStringToken As InternalSyntax.InterpolatedStringTextTokenSyntax
            Get
                Return Me._formatStringToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._colonToken
                Case 1
                    Return Me._formatStringToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new InterpolationFormatClauseSyntax(Me.Kind, newErrors, GetAnnotations, _colonToken, _formatStringToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new InterpolationFormatClauseSyntax(Me.Kind, GetDiagnostics, annotations, _colonToken, _formatStringToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitInterpolationFormatClause(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents a pre-processing directive (such as #If, #Const or #Region)
    ''' appearing in source.
    ''' </summary>
    Friend MustInherit Class DirectiveTriviaSyntax
        Inherits StructuredTriviaSyntax

        Friend ReadOnly _hashToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind)

            AdjustFlagsAndWidth(hashToken)
            Me._hashToken = hashToken

            SetFlags(NodeFlags.ContainsDirectives)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind)
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(hashToken)
            Me._hashToken = hashToken

            SetFlags(NodeFlags.ContainsDirectives)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations)

            AdjustFlagsAndWidth(hashToken)
            Me._hashToken = hashToken

            SetFlags(NodeFlags.ContainsDirectives)
        End Sub

        ''' <summary>
        ''' The "#" token in a preprocessor directive.
        ''' </summary>
        Friend ReadOnly Property HashToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._hashToken
            End Get
        End Property

    End Class

    ''' <summary>
    ''' Trivia nodes represents parts of the program text that are not parts of the
    ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
    ''' directives, and disabled code.
    ''' </summary>
    Friend NotInheritable Class SyntaxTrivia
        Inherits VisualBasicSyntaxNode


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new SyntaxTrivia(Me.Kind, newErrors, GetAnnotations, Me.Text)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new SyntaxTrivia(Me.Kind, GetDiagnostics, annotations, Me.Text)
        End Function

    End Class

    ''' <summary>
    ''' Represents a #Const pre-processing constant declaration appearing in source.
    ''' </summary>
    Friend NotInheritable Class ConstDirectiveTriviaSyntax
        Inherits DirectiveTriviaSyntax

        Friend ReadOnly _constKeyword as KeywordSyntax
        Friend ReadOnly _name as IdentifierTokenSyntax
        Friend ReadOnly _equalsToken as PunctuationSyntax
        Friend ReadOnly _value as ExpressionSyntax

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, constKeyword As InternalSyntax.KeywordSyntax, name As InternalSyntax.IdentifierTokenSyntax, equalsToken As InternalSyntax.PunctuationSyntax, value As ExpressionSyntax)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(constKeyword)
            Me._constKeyword = constKeyword
            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken
            AdjustFlagsAndWidth(value)
            Me._value = value

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, constKeyword As InternalSyntax.KeywordSyntax, name As InternalSyntax.IdentifierTokenSyntax, equalsToken As InternalSyntax.PunctuationSyntax, value As ExpressionSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(constKeyword)
            Me._constKeyword = constKeyword
            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken
            AdjustFlagsAndWidth(value)
            Me._value = value

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax, constKeyword As InternalSyntax.KeywordSyntax, name As InternalSyntax.IdentifierTokenSyntax, equalsToken As InternalSyntax.PunctuationSyntax, value As ExpressionSyntax)
            MyBase.New(kind, errors, annotations, hashToken)
            Me.SlotCount = 5

            AdjustFlagsAndWidth(constKeyword)
            Me._constKeyword = constKeyword
            AdjustFlagsAndWidth(name)
            Me._name = name
            AdjustFlagsAndWidth(equalsToken)
            Me._equalsToken = equalsToken
            AdjustFlagsAndWidth(value)
            Me._value = value

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstDirectiveTriviaSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Const" keyword.
        ''' </summary>
        Friend ReadOnly Property ConstKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._constKeyword
            End Get
        End Property

        ''' <summary>
        ''' The name of the pre-processing constant being defined.
        ''' </summary>
        Friend ReadOnly Property Name As InternalSyntax.IdentifierTokenSyntax
            Get
                Return Me._name
            End Get
        End Property

        ''' <summary>
        ''' The "=" token.
        ''' </summary>
        Friend ReadOnly Property EqualsToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._equalsToken
            End Get
        End Property

        ''' <summary>
        ''' An expression representing the value of the pre-processing constant being
        ''' defined.
        ''' </summary>
        Friend ReadOnly Property Value As InternalSyntax.ExpressionSyntax
            Get
                Return Me._value
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._hashToken
                Case 1
                    Return Me._constKeyword
                Case 2
                    Return Me._name
                Case 3
                    Return Me._equalsToken
                Case 4
                    Return Me._value
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ConstDirectiveTriviaSyntax(Me.Kind, newErrors, GetAnnotations, _hashToken, _constKeyword, _name, _equalsToken, _value)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ConstDirectiveTriviaSyntax(Me.Kind, GetDiagnostics, annotations, _hashToken, _constKeyword, _name, _equalsToken, _value)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitConstDirectiveTrivia(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the beginning of an #If pre-processing directive appearing in
    ''' source.
    ''' </summary>
    Friend NotInheritable Class IfDirectiveTriviaSyntax
        Inherits DirectiveTriviaSyntax

        Friend ReadOnly _elseKeyword as KeywordSyntax
        Friend ReadOnly _ifOrElseIfKeyword as KeywordSyntax
        Friend ReadOnly _condition as ExpressionSyntax
        Friend ReadOnly _thenKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, elseKeyword As InternalSyntax.KeywordSyntax, ifOrElseIfKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax, thenKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 5

            If elseKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(elseKeyword)
                Me._elseKeyword = elseKeyword
            End If
            AdjustFlagsAndWidth(ifOrElseIfKeyword)
            Me._ifOrElseIfKeyword = ifOrElseIfKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition
            If thenKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(thenKeyword)
                Me._thenKeyword = thenKeyword
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, elseKeyword As InternalSyntax.KeywordSyntax, ifOrElseIfKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax, thenKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 5
            Me.SetFactoryContext(context)

            If elseKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(elseKeyword)
                Me._elseKeyword = elseKeyword
            End If
            AdjustFlagsAndWidth(ifOrElseIfKeyword)
            Me._ifOrElseIfKeyword = ifOrElseIfKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition
            If thenKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(thenKeyword)
                Me._thenKeyword = thenKeyword
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax, elseKeyword As InternalSyntax.KeywordSyntax, ifOrElseIfKeyword As InternalSyntax.KeywordSyntax, condition As ExpressionSyntax, thenKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations, hashToken)
            Me.SlotCount = 5

            If elseKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(elseKeyword)
                Me._elseKeyword = elseKeyword
            End If
            AdjustFlagsAndWidth(ifOrElseIfKeyword)
            Me._ifOrElseIfKeyword = ifOrElseIfKeyword
            AdjustFlagsAndWidth(condition)
            Me._condition = condition
            If thenKeyword IsNot Nothing Then
                AdjustFlagsAndWidth(thenKeyword)
                Me._thenKeyword = thenKeyword
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.IfDirectiveTriviaSyntax(Me, parent, startLocation)
        End Function

        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property ElseKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._elseKeyword
            End Get
        End Property

        Friend ReadOnly Property IfOrElseIfKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._ifOrElseIfKeyword
            End Get
        End Property

        Friend ReadOnly Property Condition As InternalSyntax.ExpressionSyntax
            Get
                Return Me._condition
            End Get
        End Property

        ''' <remarks>
        ''' This child is optional. If it is not present, then Nothing is returned.
        ''' </remarks>
        Friend ReadOnly Property ThenKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._thenKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._hashToken
                Case 1
                    Return Me._elseKeyword
                Case 2
                    Return Me._ifOrElseIfKeyword
                Case 3
                    Return Me._condition
                Case 4
                    Return Me._thenKeyword
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new IfDirectiveTriviaSyntax(Me.Kind, newErrors, GetAnnotations, _hashToken, _elseKeyword, _ifOrElseIfKeyword, _condition, _thenKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new IfDirectiveTriviaSyntax(Me.Kind, GetDiagnostics, annotations, _hashToken, _elseKeyword, _ifOrElseIfKeyword, _condition, _thenKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitIfDirectiveTrivia(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an #Else pre-processing directive appearing in source.
    ''' </summary>
    Friend NotInheritable Class ElseDirectiveTriviaSyntax
        Inherits DirectiveTriviaSyntax

        Friend ReadOnly _elseKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, elseKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(elseKeyword)
            Me._elseKeyword = elseKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, elseKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 2
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(elseKeyword)
            Me._elseKeyword = elseKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax, elseKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations, hashToken)
            Me.SlotCount = 2

            AdjustFlagsAndWidth(elseKeyword)
            Me._elseKeyword = elseKeyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseDirectiveTriviaSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property ElseKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._elseKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._hashToken
                Case 1
                    Return Me._elseKeyword
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ElseDirectiveTriviaSyntax(Me.Kind, newErrors, GetAnnotations, _hashToken, _elseKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ElseDirectiveTriviaSyntax(Me.Kind, GetDiagnostics, annotations, _hashToken, _elseKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitElseDirectiveTrivia(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an #End If pre-processing directive appearing in source.
    ''' </summary>
    Friend NotInheritable Class EndIfDirectiveTriviaSyntax
        Inherits DirectiveTriviaSyntax

        Friend ReadOnly _endKeyword as KeywordSyntax
        Friend ReadOnly _ifKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, endKeyword As InternalSyntax.KeywordSyntax, ifKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(endKeyword)
            Me._endKeyword = endKeyword
            AdjustFlagsAndWidth(ifKeyword)
            Me._ifKeyword = ifKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, endKeyword As InternalSyntax.KeywordSyntax, ifKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(endKeyword)
            Me._endKeyword = endKeyword
            AdjustFlagsAndWidth(ifKeyword)
            Me._ifKeyword = ifKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax, endKeyword As InternalSyntax.KeywordSyntax, ifKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations, hashToken)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(endKeyword)
            Me._endKeyword = endKeyword
            AdjustFlagsAndWidth(ifKeyword)
            Me._ifKeyword = ifKeyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndIfDirectiveTriviaSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property EndKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._endKeyword
            End Get
        End Property

        Friend ReadOnly Property IfKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._ifKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._hashToken
                Case 1
                    Return Me._endKeyword
                Case 2
                    Return Me._ifKeyword
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new EndIfDirectiveTriviaSyntax(Me.Kind, newErrors, GetAnnotations, _hashToken, _endKeyword, _ifKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new EndIfDirectiveTriviaSyntax(Me.Kind, GetDiagnostics, annotations, _hashToken, _endKeyword, _ifKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitEndIfDirectiveTrivia(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the beginning of a #Region directive appearing in source.
    ''' </summary>
    Friend NotInheritable Class RegionDirectiveTriviaSyntax
        Inherits DirectiveTriviaSyntax

        Friend ReadOnly _regionKeyword as KeywordSyntax
        Friend ReadOnly _name as StringLiteralTokenSyntax

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, regionKeyword As InternalSyntax.KeywordSyntax, name As InternalSyntax.StringLiteralTokenSyntax)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(regionKeyword)
            Me._regionKeyword = regionKeyword
            AdjustFlagsAndWidth(name)
            Me._name = name

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, regionKeyword As InternalSyntax.KeywordSyntax, name As InternalSyntax.StringLiteralTokenSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(regionKeyword)
            Me._regionKeyword = regionKeyword
            AdjustFlagsAndWidth(name)
            Me._name = name

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax, regionKeyword As InternalSyntax.KeywordSyntax, name As InternalSyntax.StringLiteralTokenSyntax)
            MyBase.New(kind, errors, annotations, hashToken)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(regionKeyword)
            Me._regionKeyword = regionKeyword
            AdjustFlagsAndWidth(name)
            Me._name = name

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.RegionDirectiveTriviaSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "Region" keyword.
        ''' </summary>
        Friend ReadOnly Property RegionKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._regionKeyword
            End Get
        End Property

        ''' <summary>
        ''' The label of the code region being defined.
        ''' </summary>
        Friend ReadOnly Property Name As InternalSyntax.StringLiteralTokenSyntax
            Get
                Return Me._name
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._hashToken
                Case 1
                    Return Me._regionKeyword
                Case 2
                    Return Me._name
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new RegionDirectiveTriviaSyntax(Me.Kind, newErrors, GetAnnotations, _hashToken, _regionKeyword, _name)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new RegionDirectiveTriviaSyntax(Me.Kind, GetDiagnostics, annotations, _hashToken, _regionKeyword, _name)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitRegionDirectiveTrivia(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an #End Region directive appearing in source.
    ''' </summary>
    Friend NotInheritable Class EndRegionDirectiveTriviaSyntax
        Inherits DirectiveTriviaSyntax

        Friend ReadOnly _endKeyword as KeywordSyntax
        Friend ReadOnly _regionKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, endKeyword As InternalSyntax.KeywordSyntax, regionKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(endKeyword)
            Me._endKeyword = endKeyword
            AdjustFlagsAndWidth(regionKeyword)
            Me._regionKeyword = regionKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, endKeyword As InternalSyntax.KeywordSyntax, regionKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(endKeyword)
            Me._endKeyword = endKeyword
            AdjustFlagsAndWidth(regionKeyword)
            Me._regionKeyword = regionKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax, endKeyword As InternalSyntax.KeywordSyntax, regionKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations, hashToken)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(endKeyword)
            Me._endKeyword = endKeyword
            AdjustFlagsAndWidth(regionKeyword)
            Me._regionKeyword = regionKeyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndRegionDirectiveTriviaSyntax(Me, parent, startLocation)
        End Function

        ''' <summary>
        ''' The "End" keyword.
        ''' </summary>
        Friend ReadOnly Property EndKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._endKeyword
            End Get
        End Property

        ''' <summary>
        ''' The "Region" keyword.
        ''' </summary>
        Friend ReadOnly Property RegionKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._regionKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._hashToken
                Case 1
                    Return Me._endKeyword
                Case 2
                    Return Me._regionKeyword
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new EndRegionDirectiveTriviaSyntax(Me.Kind, newErrors, GetAnnotations, _hashToken, _endKeyword, _regionKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new EndRegionDirectiveTriviaSyntax(Me.Kind, GetDiagnostics, annotations, _hashToken, _endKeyword, _regionKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitEndRegionDirectiveTrivia(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents the beginning of a #ExternalSource pre-processing directive
    ''' appearing in source.
    ''' </summary>
    Friend NotInheritable Class ExternalSourceDirectiveTriviaSyntax
        Inherits DirectiveTriviaSyntax

        Friend ReadOnly _externalSourceKeyword as KeywordSyntax
        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _externalSource as StringLiteralTokenSyntax
        Friend ReadOnly _commaToken as PunctuationSyntax
        Friend ReadOnly _lineStart as IntegerLiteralTokenSyntax
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, externalSourceKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, externalSource As InternalSyntax.StringLiteralTokenSyntax, commaToken As InternalSyntax.PunctuationSyntax, lineStart As InternalSyntax.IntegerLiteralTokenSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 7

            AdjustFlagsAndWidth(externalSourceKeyword)
            Me._externalSourceKeyword = externalSourceKeyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(externalSource)
            Me._externalSource = externalSource
            AdjustFlagsAndWidth(commaToken)
            Me._commaToken = commaToken
            AdjustFlagsAndWidth(lineStart)
            Me._lineStart = lineStart
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, externalSourceKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, externalSource As InternalSyntax.StringLiteralTokenSyntax, commaToken As InternalSyntax.PunctuationSyntax, lineStart As InternalSyntax.IntegerLiteralTokenSyntax, closeParenToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 7
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(externalSourceKeyword)
            Me._externalSourceKeyword = externalSourceKeyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(externalSource)
            Me._externalSource = externalSource
            AdjustFlagsAndWidth(commaToken)
            Me._commaToken = commaToken
            AdjustFlagsAndWidth(lineStart)
            Me._lineStart = lineStart
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax, externalSourceKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, externalSource As InternalSyntax.StringLiteralTokenSyntax, commaToken As InternalSyntax.PunctuationSyntax, lineStart As InternalSyntax.IntegerLiteralTokenSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations, hashToken)
            Me.SlotCount = 7

            AdjustFlagsAndWidth(externalSourceKeyword)
            Me._externalSourceKeyword = externalSourceKeyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(externalSource)
            Me._externalSource = externalSource
            AdjustFlagsAndWidth(commaToken)
            Me._commaToken = commaToken
            AdjustFlagsAndWidth(lineStart)
            Me._lineStart = lineStart
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalSourceDirectiveTriviaSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property ExternalSourceKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._externalSourceKeyword
            End Get
        End Property

        Friend ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        Friend ReadOnly Property ExternalSource As InternalSyntax.StringLiteralTokenSyntax
            Get
                Return Me._externalSource
            End Get
        End Property

        Friend ReadOnly Property CommaToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._commaToken
            End Get
        End Property

        Friend ReadOnly Property LineStart As InternalSyntax.IntegerLiteralTokenSyntax
            Get
                Return Me._lineStart
            End Get
        End Property

        Friend ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._hashToken
                Case 1
                    Return Me._externalSourceKeyword
                Case 2
                    Return Me._openParenToken
                Case 3
                    Return Me._externalSource
                Case 4
                    Return Me._commaToken
                Case 5
                    Return Me._lineStart
                Case 6
                    Return Me._closeParenToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ExternalSourceDirectiveTriviaSyntax(Me.Kind, newErrors, GetAnnotations, _hashToken, _externalSourceKeyword, _openParenToken, _externalSource, _commaToken, _lineStart, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ExternalSourceDirectiveTriviaSyntax(Me.Kind, GetDiagnostics, annotations, _hashToken, _externalSourceKeyword, _openParenToken, _externalSource, _commaToken, _lineStart, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitExternalSourceDirectiveTrivia(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an #End ExternalSource pre-processing directive appearing in source.
    ''' </summary>
    Friend NotInheritable Class EndExternalSourceDirectiveTriviaSyntax
        Inherits DirectiveTriviaSyntax

        Friend ReadOnly _endKeyword as KeywordSyntax
        Friend ReadOnly _externalSourceKeyword as KeywordSyntax

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, endKeyword As InternalSyntax.KeywordSyntax, externalSourceKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(endKeyword)
            Me._endKeyword = endKeyword
            AdjustFlagsAndWidth(externalSourceKeyword)
            Me._externalSourceKeyword = externalSourceKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, endKeyword As InternalSyntax.KeywordSyntax, externalSourceKeyword As InternalSyntax.KeywordSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(endKeyword)
            Me._endKeyword = endKeyword
            AdjustFlagsAndWidth(externalSourceKeyword)
            Me._externalSourceKeyword = externalSourceKeyword

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax, endKeyword As InternalSyntax.KeywordSyntax, externalSourceKeyword As InternalSyntax.KeywordSyntax)
            MyBase.New(kind, errors, annotations, hashToken)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(endKeyword)
            Me._endKeyword = endKeyword
            AdjustFlagsAndWidth(externalSourceKeyword)
            Me._externalSourceKeyword = externalSourceKeyword

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EndExternalSourceDirectiveTriviaSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property EndKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._endKeyword
            End Get
        End Property

        Friend ReadOnly Property ExternalSourceKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._externalSourceKeyword
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._hashToken
                Case 1
                    Return Me._endKeyword
                Case 2
                    Return Me._externalSourceKeyword
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new EndExternalSourceDirectiveTriviaSyntax(Me.Kind, newErrors, GetAnnotations, _hashToken, _endKeyword, _externalSourceKeyword)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new EndExternalSourceDirectiveTriviaSyntax(Me.Kind, GetDiagnostics, annotations, _hashToken, _endKeyword, _externalSourceKeyword)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitEndExternalSourceDirectiveTrivia(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an #ExternalChecksum pre-processing directive appearing in source.
    ''' </summary>
    Friend NotInheritable Class ExternalChecksumDirectiveTriviaSyntax
        Inherits DirectiveTriviaSyntax

        Friend ReadOnly _externalChecksumKeyword as KeywordSyntax
        Friend ReadOnly _openParenToken as PunctuationSyntax
        Friend ReadOnly _externalSource as StringLiteralTokenSyntax
        Friend ReadOnly _firstCommaToken as PunctuationSyntax
        Friend ReadOnly _guid as StringLiteralTokenSyntax
        Friend ReadOnly _secondCommaToken as PunctuationSyntax
        Friend ReadOnly _checksum as StringLiteralTokenSyntax
        Friend ReadOnly _closeParenToken as PunctuationSyntax

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, externalChecksumKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, externalSource As InternalSyntax.StringLiteralTokenSyntax, firstCommaToken As InternalSyntax.PunctuationSyntax, guid As InternalSyntax.StringLiteralTokenSyntax, secondCommaToken As InternalSyntax.PunctuationSyntax, checksum As InternalSyntax.StringLiteralTokenSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 9

            AdjustFlagsAndWidth(externalChecksumKeyword)
            Me._externalChecksumKeyword = externalChecksumKeyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(externalSource)
            Me._externalSource = externalSource
            AdjustFlagsAndWidth(firstCommaToken)
            Me._firstCommaToken = firstCommaToken
            AdjustFlagsAndWidth(guid)
            Me._guid = guid
            AdjustFlagsAndWidth(secondCommaToken)
            Me._secondCommaToken = secondCommaToken
            AdjustFlagsAndWidth(checksum)
            Me._checksum = checksum
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, externalChecksumKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, externalSource As InternalSyntax.StringLiteralTokenSyntax, firstCommaToken As InternalSyntax.PunctuationSyntax, guid As InternalSyntax.StringLiteralTokenSyntax, secondCommaToken As InternalSyntax.PunctuationSyntax, checksum As InternalSyntax.StringLiteralTokenSyntax, closeParenToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 9
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(externalChecksumKeyword)
            Me._externalChecksumKeyword = externalChecksumKeyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(externalSource)
            Me._externalSource = externalSource
            AdjustFlagsAndWidth(firstCommaToken)
            Me._firstCommaToken = firstCommaToken
            AdjustFlagsAndWidth(guid)
            Me._guid = guid
            AdjustFlagsAndWidth(secondCommaToken)
            Me._secondCommaToken = secondCommaToken
            AdjustFlagsAndWidth(checksum)
            Me._checksum = checksum
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax, externalChecksumKeyword As InternalSyntax.KeywordSyntax, openParenToken As InternalSyntax.PunctuationSyntax, externalSource As InternalSyntax.StringLiteralTokenSyntax, firstCommaToken As InternalSyntax.PunctuationSyntax, guid As InternalSyntax.StringLiteralTokenSyntax, secondCommaToken As InternalSyntax.PunctuationSyntax, checksum As InternalSyntax.StringLiteralTokenSyntax, closeParenToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations, hashToken)
            Me.SlotCount = 9

            AdjustFlagsAndWidth(externalChecksumKeyword)
            Me._externalChecksumKeyword = externalChecksumKeyword
            AdjustFlagsAndWidth(openParenToken)
            Me._openParenToken = openParenToken
            AdjustFlagsAndWidth(externalSource)
            Me._externalSource = externalSource
            AdjustFlagsAndWidth(firstCommaToken)
            Me._firstCommaToken = firstCommaToken
            AdjustFlagsAndWidth(guid)
            Me._guid = guid
            AdjustFlagsAndWidth(secondCommaToken)
            Me._secondCommaToken = secondCommaToken
            AdjustFlagsAndWidth(checksum)
            Me._checksum = checksum
            AdjustFlagsAndWidth(closeParenToken)
            Me._closeParenToken = closeParenToken

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalChecksumDirectiveTriviaSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property ExternalChecksumKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._externalChecksumKeyword
            End Get
        End Property

        Friend ReadOnly Property OpenParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._openParenToken
            End Get
        End Property

        Friend ReadOnly Property ExternalSource As InternalSyntax.StringLiteralTokenSyntax
            Get
                Return Me._externalSource
            End Get
        End Property

        Friend ReadOnly Property FirstCommaToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._firstCommaToken
            End Get
        End Property

        Friend ReadOnly Property Guid As InternalSyntax.StringLiteralTokenSyntax
            Get
                Return Me._guid
            End Get
        End Property

        Friend ReadOnly Property SecondCommaToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._secondCommaToken
            End Get
        End Property

        Friend ReadOnly Property Checksum As InternalSyntax.StringLiteralTokenSyntax
            Get
                Return Me._checksum
            End Get
        End Property

        Friend ReadOnly Property CloseParenToken As InternalSyntax.PunctuationSyntax
            Get
                Return Me._closeParenToken
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._hashToken
                Case 1
                    Return Me._externalChecksumKeyword
                Case 2
                    Return Me._openParenToken
                Case 3
                    Return Me._externalSource
                Case 4
                    Return Me._firstCommaToken
                Case 5
                    Return Me._guid
                Case 6
                    Return Me._secondCommaToken
                Case 7
                    Return Me._checksum
                Case 8
                    Return Me._closeParenToken
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ExternalChecksumDirectiveTriviaSyntax(Me.Kind, newErrors, GetAnnotations, _hashToken, _externalChecksumKeyword, _openParenToken, _externalSource, _firstCommaToken, _guid, _secondCommaToken, _checksum, _closeParenToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ExternalChecksumDirectiveTriviaSyntax(Me.Kind, GetDiagnostics, annotations, _hashToken, _externalChecksumKeyword, _openParenToken, _externalSource, _firstCommaToken, _guid, _secondCommaToken, _checksum, _closeParenToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitExternalChecksumDirectiveTrivia(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents #Enable Warning pre-processing directive appearing in source.
    ''' </summary>
    Friend NotInheritable Class EnableWarningDirectiveTriviaSyntax
        Inherits DirectiveTriviaSyntax

        Friend ReadOnly _enableKeyword as KeywordSyntax
        Friend ReadOnly _warningKeyword as KeywordSyntax
        Friend ReadOnly _errorCodes as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, enableKeyword As InternalSyntax.KeywordSyntax, warningKeyword As InternalSyntax.KeywordSyntax, errorCodes As GreenNode)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(enableKeyword)
            Me._enableKeyword = enableKeyword
            AdjustFlagsAndWidth(warningKeyword)
            Me._warningKeyword = warningKeyword
            If errorCodes IsNot Nothing Then
                AdjustFlagsAndWidth(errorCodes)
                Me._errorCodes = errorCodes
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, enableKeyword As InternalSyntax.KeywordSyntax, warningKeyword As InternalSyntax.KeywordSyntax, errorCodes As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 4
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(enableKeyword)
            Me._enableKeyword = enableKeyword
            AdjustFlagsAndWidth(warningKeyword)
            Me._warningKeyword = warningKeyword
            If errorCodes IsNot Nothing Then
                AdjustFlagsAndWidth(errorCodes)
                Me._errorCodes = errorCodes
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax, enableKeyword As InternalSyntax.KeywordSyntax, warningKeyword As InternalSyntax.KeywordSyntax, errorCodes As GreenNode)
            MyBase.New(kind, errors, annotations, hashToken)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(enableKeyword)
            Me._enableKeyword = enableKeyword
            AdjustFlagsAndWidth(warningKeyword)
            Me._warningKeyword = warningKeyword
            If errorCodes IsNot Nothing Then
                AdjustFlagsAndWidth(errorCodes)
                Me._errorCodes = errorCodes
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.EnableWarningDirectiveTriviaSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property EnableKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._enableKeyword
            End Get
        End Property

        Friend ReadOnly Property WarningKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._warningKeyword
            End Get
        End Property

        Friend ReadOnly Property ErrorCodes As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of IdentifierNameSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of IdentifierNameSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of IdentifierNameSyntax)(Me._errorCodes))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._hashToken
                Case 1
                    Return Me._enableKeyword
                Case 2
                    Return Me._warningKeyword
                Case 3
                    Return Me._errorCodes
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new EnableWarningDirectiveTriviaSyntax(Me.Kind, newErrors, GetAnnotations, _hashToken, _enableKeyword, _warningKeyword, _errorCodes)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new EnableWarningDirectiveTriviaSyntax(Me.Kind, GetDiagnostics, annotations, _hashToken, _enableKeyword, _warningKeyword, _errorCodes)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitEnableWarningDirectiveTrivia(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents #Disable Warning pre-processing directive appearing in source.
    ''' </summary>
    Friend NotInheritable Class DisableWarningDirectiveTriviaSyntax
        Inherits DirectiveTriviaSyntax

        Friend ReadOnly _disableKeyword as KeywordSyntax
        Friend ReadOnly _warningKeyword as KeywordSyntax
        Friend ReadOnly _errorCodes as GreenNode

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, disableKeyword As InternalSyntax.KeywordSyntax, warningKeyword As InternalSyntax.KeywordSyntax, errorCodes As GreenNode)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(disableKeyword)
            Me._disableKeyword = disableKeyword
            AdjustFlagsAndWidth(warningKeyword)
            Me._warningKeyword = warningKeyword
            If errorCodes IsNot Nothing Then
                AdjustFlagsAndWidth(errorCodes)
                Me._errorCodes = errorCodes
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, disableKeyword As InternalSyntax.KeywordSyntax, warningKeyword As InternalSyntax.KeywordSyntax, errorCodes As GreenNode, context As ISyntaxFactoryContext)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 4
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(disableKeyword)
            Me._disableKeyword = disableKeyword
            AdjustFlagsAndWidth(warningKeyword)
            Me._warningKeyword = warningKeyword
            If errorCodes IsNot Nothing Then
                AdjustFlagsAndWidth(errorCodes)
                Me._errorCodes = errorCodes
            End If

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax, disableKeyword As InternalSyntax.KeywordSyntax, warningKeyword As InternalSyntax.KeywordSyntax, errorCodes As GreenNode)
            MyBase.New(kind, errors, annotations, hashToken)
            Me.SlotCount = 4

            AdjustFlagsAndWidth(disableKeyword)
            Me._disableKeyword = disableKeyword
            AdjustFlagsAndWidth(warningKeyword)
            Me._warningKeyword = warningKeyword
            If errorCodes IsNot Nothing Then
                AdjustFlagsAndWidth(errorCodes)
                Me._errorCodes = errorCodes
            End If

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.DisableWarningDirectiveTriviaSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property DisableKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._disableKeyword
            End Get
        End Property

        Friend ReadOnly Property WarningKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._warningKeyword
            End Get
        End Property

        Friend ReadOnly Property ErrorCodes As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of IdentifierNameSyntax)
            Get
                Return new Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(Of IdentifierNameSyntax)(New Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of IdentifierNameSyntax)(Me._errorCodes))
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._hashToken
                Case 1
                    Return Me._disableKeyword
                Case 2
                    Return Me._warningKeyword
                Case 3
                    Return Me._errorCodes
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new DisableWarningDirectiveTriviaSyntax(Me.Kind, newErrors, GetAnnotations, _hashToken, _disableKeyword, _warningKeyword, _errorCodes)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new DisableWarningDirectiveTriviaSyntax(Me.Kind, GetDiagnostics, annotations, _hashToken, _disableKeyword, _warningKeyword, _errorCodes)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitDisableWarningDirectiveTrivia(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an #r directive appearing in scripts.
    ''' </summary>
    Friend NotInheritable Class ReferenceDirectiveTriviaSyntax
        Inherits DirectiveTriviaSyntax

        Friend ReadOnly _referenceKeyword as KeywordSyntax
        Friend ReadOnly _file as StringLiteralTokenSyntax

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, referenceKeyword As InternalSyntax.KeywordSyntax, file As InternalSyntax.StringLiteralTokenSyntax)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(referenceKeyword)
            Me._referenceKeyword = referenceKeyword
            AdjustFlagsAndWidth(file)
            Me._file = file

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, referenceKeyword As InternalSyntax.KeywordSyntax, file As InternalSyntax.StringLiteralTokenSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 3
            Me.SetFactoryContext(context)

            AdjustFlagsAndWidth(referenceKeyword)
            Me._referenceKeyword = referenceKeyword
            AdjustFlagsAndWidth(file)
            Me._file = file

        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax, referenceKeyword As InternalSyntax.KeywordSyntax, file As InternalSyntax.StringLiteralTokenSyntax)
            MyBase.New(kind, errors, annotations, hashToken)
            Me.SlotCount = 3

            AdjustFlagsAndWidth(referenceKeyword)
            Me._referenceKeyword = referenceKeyword
            AdjustFlagsAndWidth(file)
            Me._file = file

        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.ReferenceDirectiveTriviaSyntax(Me, parent, startLocation)
        End Function

        Friend ReadOnly Property ReferenceKeyword As InternalSyntax.KeywordSyntax
            Get
                Return Me._referenceKeyword
            End Get
        End Property

        Friend ReadOnly Property File As InternalSyntax.StringLiteralTokenSyntax
            Get
                Return Me._file
            End Get
        End Property

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            Select case i
                Case 0
                    Return Me._hashToken
                Case 1
                    Return Me._referenceKeyword
                Case 2
                    Return Me._file
                Case Else
                    Debug.Assert(false, "child index out of range")
                    Return Nothing
            End Select
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new ReferenceDirectiveTriviaSyntax(Me.Kind, newErrors, GetAnnotations, _hashToken, _referenceKeyword, _file)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new ReferenceDirectiveTriviaSyntax(Me.Kind, GetDiagnostics, annotations, _hashToken, _referenceKeyword, _file)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitReferenceDirectiveTrivia(Me)
        End Function

    End Class

    ''' <summary>
    ''' Represents an unrecognized pre-processing directive. This occurs when the
    ''' parser encounters a hash '#' token at the beginning of a physical line but does
    ''' recognize the text that follows as a valid Visual Basic pre-processing
    ''' directive.
    ''' </summary>
    Friend NotInheritable Class BadDirectiveTriviaSyntax
        Inherits DirectiveTriviaSyntax


        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 1
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, hashToken As InternalSyntax.PunctuationSyntax, context As ISyntaxFactoryContext)
            MyBase.New(kind, hashToken)
            Me.SlotCount = 1
            Me.SetFactoryContext(context)
        End Sub

        Friend Sub New(ByVal kind As SyntaxKind, ByVal errors as DiagnosticInfo(), ByVal annotations as SyntaxAnnotation(), hashToken As InternalSyntax.PunctuationSyntax)
            MyBase.New(kind, errors, annotations, hashToken)
            Me.SlotCount = 1
        End Sub

        Friend Overrides Function CreateRed(ByVal parent As SyntaxNode, ByVal startLocation As Integer) As SyntaxNode
            Return new Microsoft.CodeAnalysis.VisualBasic.Syntax.BadDirectiveTriviaSyntax(Me, parent, startLocation)
        End Function

        Friend Overrides Function GetSlot(i as Integer) as GreenNode
            If i = 0 Then
                Return Me._hashToken
            Else
                Debug.Assert(false, "child index out of range")
                Return Nothing
            End If
        End Function


        Friend Overrides Function SetDiagnostics(ByVal newErrors As DiagnosticInfo()) As GreenNode
            Return new BadDirectiveTriviaSyntax(Me.Kind, newErrors, GetAnnotations, _hashToken)
        End Function

        Friend Overrides Function SetAnnotations(ByVal annotations As SyntaxAnnotation()) As GreenNode
            Return new BadDirectiveTriviaSyntax(Me.Kind, GetDiagnostics, annotations, _hashToken)
        End Function

        Public Overrides Function Accept(ByVal visitor As VisualBasicSyntaxVisitor) As VisualBasicSyntaxNode
            Return visitor.VisitBadDirectiveTrivia(Me)
        End Function

    End Class

    Friend MustInherit Class VisualBasicSyntaxVisitor
        Public Overridable Function Visit(ByVal node As VisualBasicSyntaxNode) As VisualBasicSyntaxNode
            If node IsNot Nothing
                Return node.Accept(Me)
            Else
                Return Nothing
            End If
        End Function
        Public Overridable Function VisitVisualBasicSyntaxNode(ByVal node As VisualBasicSyntaxNode) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return node
        End Function
        Public Overridable Function VisitStatement(ByVal node As StatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitExecutableStatement(ByVal node As ExecutableStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitDeclarationStatement(ByVal node As DeclarationStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitEmptyStatement(ByVal node As EmptyStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitEndBlockStatement(ByVal node As EndBlockStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitCompilationUnit(ByVal node As CompilationUnitSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitOptionStatement(ByVal node As OptionStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitImportsStatement(ByVal node As ImportsStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitImportsClause(ByVal node As ImportsClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitSimpleImportsClause(ByVal node As SimpleImportsClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitImportsClause(node)
        End Function
        Public Overridable Function VisitImportAliasClause(ByVal node As ImportAliasClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitXmlNamespaceImportsClause(ByVal node As XmlNamespaceImportsClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitImportsClause(node)
        End Function
        Public Overridable Function VisitNamespaceBlock(ByVal node As NamespaceBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitNamespaceStatement(ByVal node As NamespaceStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitTypeBlock(ByVal node As TypeBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitModuleBlock(ByVal node As ModuleBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitTypeBlock(node)
        End Function
        Public Overridable Function VisitStructureBlock(ByVal node As StructureBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitTypeBlock(node)
        End Function
        Public Overridable Function VisitInterfaceBlock(ByVal node As InterfaceBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitTypeBlock(node)
        End Function
        Public Overridable Function VisitClassBlock(ByVal node As ClassBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitTypeBlock(node)
        End Function
        Public Overridable Function VisitEnumBlock(ByVal node As EnumBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitInheritsOrImplementsStatement(ByVal node As InheritsOrImplementsStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitInheritsStatement(ByVal node As InheritsStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitInheritsOrImplementsStatement(node)
        End Function
        Public Overridable Function VisitImplementsStatement(ByVal node As ImplementsStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitInheritsOrImplementsStatement(node)
        End Function
        Public Overridable Function VisitTypeStatement(ByVal node As TypeStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitModuleStatement(ByVal node As ModuleStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitTypeStatement(node)
        End Function
        Public Overridable Function VisitStructureStatement(ByVal node As StructureStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitTypeStatement(node)
        End Function
        Public Overridable Function VisitInterfaceStatement(ByVal node As InterfaceStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitTypeStatement(node)
        End Function
        Public Overridable Function VisitClassStatement(ByVal node As ClassStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitTypeStatement(node)
        End Function
        Public Overridable Function VisitEnumStatement(ByVal node As EnumStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitTypeParameterList(ByVal node As TypeParameterListSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitTypeParameter(ByVal node As TypeParameterSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitTypeParameterConstraintClause(ByVal node As TypeParameterConstraintClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitTypeParameterSingleConstraintClause(ByVal node As TypeParameterSingleConstraintClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitTypeParameterConstraintClause(node)
        End Function
        Public Overridable Function VisitTypeParameterMultipleConstraintClause(ByVal node As TypeParameterMultipleConstraintClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitTypeParameterConstraintClause(node)
        End Function
        Public Overridable Function VisitConstraint(ByVal node As ConstraintSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitSpecialConstraint(ByVal node As SpecialConstraintSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitConstraint(node)
        End Function
        Public Overridable Function VisitTypeConstraint(ByVal node As TypeConstraintSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitConstraint(node)
        End Function
        Public Overridable Function VisitEnumMemberDeclaration(ByVal node As EnumMemberDeclarationSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitMethodBlockBase(ByVal node As MethodBlockBaseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitMethodBlock(ByVal node As MethodBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitMethodBlockBase(node)
        End Function
        Public Overridable Function VisitConstructorBlock(ByVal node As ConstructorBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitMethodBlockBase(node)
        End Function
        Public Overridable Function VisitOperatorBlock(ByVal node As OperatorBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitMethodBlockBase(node)
        End Function
        Public Overridable Function VisitAccessorBlock(ByVal node As AccessorBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitMethodBlockBase(node)
        End Function
        Public Overridable Function VisitPropertyBlock(ByVal node As PropertyBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitEventBlock(ByVal node As EventBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitMethodBase(ByVal node As MethodBaseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitParameterList(ByVal node As ParameterListSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitMethodStatement(ByVal node As MethodStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitMethodBase(node)
        End Function
        Public Overridable Function VisitSubNewStatement(ByVal node As SubNewStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitMethodBase(node)
        End Function
        Public Overridable Function VisitDeclareStatement(ByVal node As DeclareStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitMethodBase(node)
        End Function
        Public Overridable Function VisitDelegateStatement(ByVal node As DelegateStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitMethodBase(node)
        End Function
        Public Overridable Function VisitEventStatement(ByVal node As EventStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitMethodBase(node)
        End Function
        Public Overridable Function VisitOperatorStatement(ByVal node As OperatorStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitMethodBase(node)
        End Function
        Public Overridable Function VisitPropertyStatement(ByVal node As PropertyStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitMethodBase(node)
        End Function
        Public Overridable Function VisitAccessorStatement(ByVal node As AccessorStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitMethodBase(node)
        End Function
        Public Overridable Function VisitImplementsClause(ByVal node As ImplementsClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitHandlesClause(ByVal node As HandlesClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitEventContainer(ByVal node As EventContainerSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitKeywordEventContainer(ByVal node As KeywordEventContainerSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitEventContainer(node)
        End Function
        Public Overridable Function VisitWithEventsEventContainer(ByVal node As WithEventsEventContainerSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitEventContainer(node)
        End Function
        Public Overridable Function VisitWithEventsPropertyEventContainer(ByVal node As WithEventsPropertyEventContainerSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitEventContainer(node)
        End Function
        Public Overridable Function VisitHandlesClauseItem(ByVal node As HandlesClauseItemSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitIncompleteMember(ByVal node As IncompleteMemberSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitFieldDeclaration(ByVal node As FieldDeclarationSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitVariableDeclarator(ByVal node As VariableDeclaratorSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitAsClause(ByVal node As AsClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitSimpleAsClause(ByVal node As SimpleAsClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitAsClause(node)
        End Function
        Public Overridable Function VisitAsNewClause(ByVal node As AsNewClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitAsClause(node)
        End Function
        Public Overridable Function VisitObjectCreationInitializer(ByVal node As ObjectCreationInitializerSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitObjectMemberInitializer(ByVal node As ObjectMemberInitializerSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitObjectCreationInitializer(node)
        End Function
        Public Overridable Function VisitObjectCollectionInitializer(ByVal node As ObjectCollectionInitializerSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitObjectCreationInitializer(node)
        End Function
        Public Overridable Function VisitFieldInitializer(ByVal node As FieldInitializerSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitInferredFieldInitializer(ByVal node As InferredFieldInitializerSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitFieldInitializer(node)
        End Function
        Public Overridable Function VisitNamedFieldInitializer(ByVal node As NamedFieldInitializerSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitFieldInitializer(node)
        End Function
        Public Overridable Function VisitEqualsValue(ByVal node As EqualsValueSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitParameter(ByVal node As ParameterSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitModifiedIdentifier(ByVal node As ModifiedIdentifierSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitArrayRankSpecifier(ByVal node As ArrayRankSpecifierSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitAttributeList(ByVal node As AttributeListSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitAttribute(ByVal node As AttributeSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitAttributeTarget(ByVal node As AttributeTargetSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitAttributesStatement(ByVal node As AttributesStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDeclarationStatement(node)
        End Function
        Public Overridable Function VisitExpressionStatement(ByVal node As ExpressionStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitPrintStatement(ByVal node As PrintStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitWhileBlock(ByVal node As WhileBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitUsingBlock(ByVal node As UsingBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitSyncLockBlock(ByVal node As SyncLockBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitWithBlock(ByVal node As WithBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitLocalDeclarationStatement(ByVal node As LocalDeclarationStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitLabelStatement(ByVal node As LabelStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitGoToStatement(ByVal node As GoToStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitLabel(ByVal node As LabelSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitStopOrEndStatement(ByVal node As StopOrEndStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitExitStatement(ByVal node As ExitStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitContinueStatement(ByVal node As ContinueStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitReturnStatement(ByVal node As ReturnStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitSingleLineIfStatement(ByVal node As SingleLineIfStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitSingleLineElseClause(ByVal node As SingleLineElseClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitMultiLineIfBlock(ByVal node As MultiLineIfBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitIfStatement(ByVal node As IfStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitElseIfBlock(ByVal node As ElseIfBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitElseIfStatement(ByVal node As ElseIfStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitElseBlock(ByVal node As ElseBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitElseStatement(ByVal node As ElseStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitTryBlock(ByVal node As TryBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitTryStatement(ByVal node As TryStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitCatchBlock(ByVal node As CatchBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitCatchStatement(ByVal node As CatchStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitCatchFilterClause(ByVal node As CatchFilterClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitFinallyBlock(ByVal node As FinallyBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitFinallyStatement(ByVal node As FinallyStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitErrorStatement(ByVal node As ErrorStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitOnErrorGoToStatement(ByVal node As OnErrorGoToStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitOnErrorResumeNextStatement(ByVal node As OnErrorResumeNextStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitResumeStatement(ByVal node As ResumeStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitSelectBlock(ByVal node As SelectBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitSelectStatement(ByVal node As SelectStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitCaseBlock(ByVal node As CaseBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitCaseStatement(ByVal node As CaseStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitCaseClause(ByVal node As CaseClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitElseCaseClause(ByVal node As ElseCaseClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitCaseClause(node)
        End Function
        Public Overridable Function VisitSimpleCaseClause(ByVal node As SimpleCaseClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitCaseClause(node)
        End Function
        Public Overridable Function VisitRangeCaseClause(ByVal node As RangeCaseClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitCaseClause(node)
        End Function
        Public Overridable Function VisitRelationalCaseClause(ByVal node As RelationalCaseClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitCaseClause(node)
        End Function
        Public Overridable Function VisitSyncLockStatement(ByVal node As SyncLockStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitDoLoopBlock(ByVal node As DoLoopBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitDoStatement(ByVal node As DoStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitLoopStatement(ByVal node As LoopStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitWhileOrUntilClause(ByVal node As WhileOrUntilClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitWhileStatement(ByVal node As WhileStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitForOrForEachBlock(ByVal node As ForOrForEachBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitForBlock(ByVal node As ForBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitForOrForEachBlock(node)
        End Function
        Public Overridable Function VisitForEachBlock(ByVal node As ForEachBlockSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitForOrForEachBlock(node)
        End Function
        Public Overridable Function VisitForOrForEachStatement(ByVal node As ForOrForEachStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitForStatement(ByVal node As ForStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitForOrForEachStatement(node)
        End Function
        Public Overridable Function VisitForStepClause(ByVal node As ForStepClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitForEachStatement(ByVal node As ForEachStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitForOrForEachStatement(node)
        End Function
        Public Overridable Function VisitNextStatement(ByVal node As NextStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitUsingStatement(ByVal node As UsingStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitThrowStatement(ByVal node As ThrowStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitAssignmentStatement(ByVal node As AssignmentStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitMidExpression(ByVal node As MidExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitCallStatement(ByVal node As CallStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitAddRemoveHandlerStatement(ByVal node As AddRemoveHandlerStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitRaiseEventStatement(ByVal node As RaiseEventStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitWithStatement(ByVal node As WithStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStatement(node)
        End Function
        Public Overridable Function VisitReDimStatement(ByVal node As ReDimStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitRedimClause(ByVal node As RedimClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitEraseStatement(ByVal node As EraseStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitExpression(ByVal node As ExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitLiteralExpression(ByVal node As LiteralExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitParenthesizedExpression(ByVal node As ParenthesizedExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitTupleExpression(ByVal node As TupleExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitTupleType(ByVal node As TupleTypeSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitType(node)
        End Function
        Public Overridable Function VisitTupleElement(ByVal node As TupleElementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitTypedTupleElement(ByVal node As TypedTupleElementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitTupleElement(node)
        End Function
        Public Overridable Function VisitNamedTupleElement(ByVal node As NamedTupleElementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitTupleElement(node)
        End Function
        Public Overridable Function VisitInstanceExpression(ByVal node As InstanceExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitMeExpression(ByVal node As MeExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitInstanceExpression(node)
        End Function
        Public Overridable Function VisitMyBaseExpression(ByVal node As MyBaseExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitInstanceExpression(node)
        End Function
        Public Overridable Function VisitMyClassExpression(ByVal node As MyClassExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitInstanceExpression(node)
        End Function
        Public Overridable Function VisitGetTypeExpression(ByVal node As GetTypeExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitTypeOfExpression(ByVal node As TypeOfExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitGetXmlNamespaceExpression(ByVal node As GetXmlNamespaceExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitMemberAccessExpression(ByVal node As MemberAccessExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitXmlMemberAccessExpression(ByVal node As XmlMemberAccessExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitInvocationExpression(ByVal node As InvocationExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitNewExpression(ByVal node As NewExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitObjectCreationExpression(ByVal node As ObjectCreationExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitNewExpression(node)
        End Function
        Public Overridable Function VisitAnonymousObjectCreationExpression(ByVal node As AnonymousObjectCreationExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitNewExpression(node)
        End Function
        Public Overridable Function VisitArrayCreationExpression(ByVal node As ArrayCreationExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitNewExpression(node)
        End Function
        Public Overridable Function VisitCollectionInitializer(ByVal node As CollectionInitializerSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitCastExpression(ByVal node As CastExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitCTypeExpression(ByVal node As CTypeExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitCastExpression(node)
        End Function
        Public Overridable Function VisitDirectCastExpression(ByVal node As DirectCastExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitCastExpression(node)
        End Function
        Public Overridable Function VisitTryCastExpression(ByVal node As TryCastExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitCastExpression(node)
        End Function
        Public Overridable Function VisitPredefinedCastExpression(ByVal node As PredefinedCastExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitBinaryExpression(ByVal node As BinaryExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitUnaryExpression(ByVal node As UnaryExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitBinaryConditionalExpression(ByVal node As BinaryConditionalExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitTernaryConditionalExpression(ByVal node As TernaryConditionalExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitLambdaExpression(ByVal node As LambdaExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitSingleLineLambdaExpression(ByVal node As SingleLineLambdaExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitLambdaExpression(node)
        End Function
        Public Overridable Function VisitMultiLineLambdaExpression(ByVal node As MultiLineLambdaExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitLambdaExpression(node)
        End Function
        Public Overridable Function VisitLambdaHeader(ByVal node As LambdaHeaderSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitMethodBase(node)
        End Function
        Public Overridable Function VisitArgumentList(ByVal node As ArgumentListSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitArgument(ByVal node As ArgumentSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitOmittedArgument(ByVal node As OmittedArgumentSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitArgument(node)
        End Function
        Public Overridable Function VisitSimpleArgument(ByVal node As SimpleArgumentSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitArgument(node)
        End Function
        Public Overridable Function VisitNameColonEquals(ByVal node As NameColonEqualsSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitRangeArgument(ByVal node As RangeArgumentSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitArgument(node)
        End Function
        Public Overridable Function VisitQueryExpression(ByVal node As QueryExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitQueryClause(ByVal node As QueryClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitCollectionRangeVariable(ByVal node As CollectionRangeVariableSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitExpressionRangeVariable(ByVal node As ExpressionRangeVariableSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitAggregationRangeVariable(ByVal node As AggregationRangeVariableSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitVariableNameEquals(ByVal node As VariableNameEqualsSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitAggregation(ByVal node As AggregationSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitFunctionAggregation(ByVal node As FunctionAggregationSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitAggregation(node)
        End Function
        Public Overridable Function VisitGroupAggregation(ByVal node As GroupAggregationSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitAggregation(node)
        End Function
        Public Overridable Function VisitFromClause(ByVal node As FromClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitQueryClause(node)
        End Function
        Public Overridable Function VisitLetClause(ByVal node As LetClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitQueryClause(node)
        End Function
        Public Overridable Function VisitAggregateClause(ByVal node As AggregateClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitQueryClause(node)
        End Function
        Public Overridable Function VisitDistinctClause(ByVal node As DistinctClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitQueryClause(node)
        End Function
        Public Overridable Function VisitWhereClause(ByVal node As WhereClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitQueryClause(node)
        End Function
        Public Overridable Function VisitPartitionWhileClause(ByVal node As PartitionWhileClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitQueryClause(node)
        End Function
        Public Overridable Function VisitPartitionClause(ByVal node As PartitionClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitQueryClause(node)
        End Function
        Public Overridable Function VisitGroupByClause(ByVal node As GroupByClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitQueryClause(node)
        End Function
        Public Overridable Function VisitJoinClause(ByVal node As JoinClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitQueryClause(node)
        End Function
        Public Overridable Function VisitJoinCondition(ByVal node As JoinConditionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitSimpleJoinClause(ByVal node As SimpleJoinClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitJoinClause(node)
        End Function
        Public Overridable Function VisitGroupJoinClause(ByVal node As GroupJoinClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitJoinClause(node)
        End Function
        Public Overridable Function VisitOrderByClause(ByVal node As OrderByClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitQueryClause(node)
        End Function
        Public Overridable Function VisitOrdering(ByVal node As OrderingSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitSelectClause(ByVal node As SelectClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitQueryClause(node)
        End Function
        Public Overridable Function VisitXmlNode(ByVal node As XmlNodeSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitXmlDocument(ByVal node As XmlDocumentSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlDeclaration(ByVal node As XmlDeclarationSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitXmlDeclarationOption(ByVal node As XmlDeclarationOptionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitXmlElement(ByVal node As XmlElementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlText(ByVal node As XmlTextSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlElementStartTag(ByVal node As XmlElementStartTagSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlElementEndTag(ByVal node As XmlElementEndTagSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlEmptyElement(ByVal node As XmlEmptyElementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlAttribute(ByVal node As XmlAttributeSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitBaseXmlAttribute(node)
        End Function
        Public Overridable Function VisitBaseXmlAttribute(ByVal node As BaseXmlAttributeSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlString(ByVal node As XmlStringSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlPrefixName(ByVal node As XmlPrefixNameSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlName(ByVal node As XmlNameSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlBracketedName(ByVal node As XmlBracketedNameSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlPrefix(ByVal node As XmlPrefixSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitXmlComment(ByVal node As XmlCommentSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlProcessingInstruction(ByVal node As XmlProcessingInstructionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlCDataSection(ByVal node As XmlCDataSectionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitXmlEmbeddedExpression(ByVal node As XmlEmbeddedExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitXmlNode(node)
        End Function
        Public Overridable Function VisitType(ByVal node As TypeSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitArrayType(ByVal node As ArrayTypeSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitType(node)
        End Function
        Public Overridable Function VisitNullableType(ByVal node As NullableTypeSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitType(node)
        End Function
        Public Overridable Function VisitPredefinedType(ByVal node As PredefinedTypeSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitType(node)
        End Function
        Public Overridable Function VisitName(ByVal node As NameSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitType(node)
        End Function
        Public Overridable Function VisitSimpleName(ByVal node As SimpleNameSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitName(node)
        End Function
        Public Overridable Function VisitIdentifierName(ByVal node As IdentifierNameSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSimpleName(node)
        End Function
        Public Overridable Function VisitGenericName(ByVal node As GenericNameSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitSimpleName(node)
        End Function
        Public Overridable Function VisitQualifiedName(ByVal node As QualifiedNameSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitName(node)
        End Function
        Public Overridable Function VisitGlobalName(ByVal node As GlobalNameSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitName(node)
        End Function
        Public Overridable Function VisitTypeArgumentList(ByVal node As TypeArgumentListSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitCrefReference(ByVal node As CrefReferenceSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitCrefSignature(ByVal node As CrefSignatureSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitCrefSignaturePart(ByVal node As CrefSignaturePartSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitCrefOperatorReference(ByVal node As CrefOperatorReferenceSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitName(node)
        End Function
        Public Overridable Function VisitQualifiedCrefOperatorReference(ByVal node As QualifiedCrefOperatorReferenceSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitName(node)
        End Function
        Public Overridable Function VisitYieldStatement(ByVal node As YieldStatementSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExecutableStatement(node)
        End Function
        Public Overridable Function VisitAwaitExpression(ByVal node As AwaitExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitStructuredTrivia(ByVal node As StructuredTriviaSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitSkippedTokensTrivia(ByVal node As SkippedTokensTriviaSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStructuredTrivia(node)
        End Function
        Public Overridable Function VisitDocumentationCommentTrivia(ByVal node As DocumentationCommentTriviaSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStructuredTrivia(node)
        End Function
        Public Overridable Function VisitXmlCrefAttribute(ByVal node As XmlCrefAttributeSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitBaseXmlAttribute(node)
        End Function
        Public Overridable Function VisitXmlNameAttribute(ByVal node As XmlNameAttributeSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitBaseXmlAttribute(node)
        End Function
        Public Overridable Function VisitConditionalAccessExpression(ByVal node As ConditionalAccessExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitNameOfExpression(ByVal node As NameOfExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitInterpolatedStringExpression(ByVal node As InterpolatedStringExpressionSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitExpression(node)
        End Function
        Public Overridable Function VisitInterpolatedStringContent(ByVal node As InterpolatedStringContentSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitInterpolatedStringText(ByVal node As InterpolatedStringTextSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitInterpolatedStringContent(node)
        End Function
        Public Overridable Function VisitInterpolation(ByVal node As InterpolationSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitInterpolatedStringContent(node)
        End Function
        Public Overridable Function VisitInterpolationAlignmentClause(ByVal node As InterpolationAlignmentClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitInterpolationFormatClause(ByVal node As InterpolationFormatClauseSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitVisualBasicSyntaxNode(node)
        End Function
        Public Overridable Function VisitDirectiveTrivia(ByVal node As DirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitStructuredTrivia(node)
        End Function
        Public Overridable Function VisitConstDirectiveTrivia(ByVal node As ConstDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveTrivia(node)
        End Function
        Public Overridable Function VisitIfDirectiveTrivia(ByVal node As IfDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveTrivia(node)
        End Function
        Public Overridable Function VisitElseDirectiveTrivia(ByVal node As ElseDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveTrivia(node)
        End Function
        Public Overridable Function VisitEndIfDirectiveTrivia(ByVal node As EndIfDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveTrivia(node)
        End Function
        Public Overridable Function VisitRegionDirectiveTrivia(ByVal node As RegionDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveTrivia(node)
        End Function
        Public Overridable Function VisitEndRegionDirectiveTrivia(ByVal node As EndRegionDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveTrivia(node)
        End Function
        Public Overridable Function VisitExternalSourceDirectiveTrivia(ByVal node As ExternalSourceDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveTrivia(node)
        End Function
        Public Overridable Function VisitEndExternalSourceDirectiveTrivia(ByVal node As EndExternalSourceDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveTrivia(node)
        End Function
        Public Overridable Function VisitExternalChecksumDirectiveTrivia(ByVal node As ExternalChecksumDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveTrivia(node)
        End Function
        Public Overridable Function VisitEnableWarningDirectiveTrivia(ByVal node As EnableWarningDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveTrivia(node)
        End Function
        Public Overridable Function VisitDisableWarningDirectiveTrivia(ByVal node As DisableWarningDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveTrivia(node)
        End Function
        Public Overridable Function VisitReferenceDirectiveTrivia(ByVal node As ReferenceDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveTrivia(node)
        End Function
        Public Overridable Function VisitBadDirectiveTrivia(ByVal node As BadDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Debug.Assert(node IsNot Nothing)
            Return VisitDirectiveTrivia(node)
        End Function
    End Class

    Friend MustInherit Class VisualBasicSyntaxRewriter
        Inherits VisualBasicSyntaxVisitor

        Public Overrides Function VisitEmptyStatement(ByVal node As EmptyStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newEmpty = DirectCast(Visit(node.Empty), PunctuationSyntax)
            If node._empty IsNot newEmpty Then anyChanges = True

            If anyChanges Then
                Return New EmptyStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newEmpty)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitEndBlockStatement(ByVal node As EndBlockStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newEndKeyword = DirectCast(Visit(node.EndKeyword), KeywordSyntax)
            If node._endKeyword IsNot newEndKeyword Then anyChanges = True
            Dim newBlockKeyword = DirectCast(Visit(node.BlockKeyword), KeywordSyntax)
            If node._blockKeyword IsNot newBlockKeyword Then anyChanges = True

            If anyChanges Then
                Return New EndBlockStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newEndKeyword, newBlockKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCompilationUnit(ByVal node As CompilationUnitSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOptions = VisitList(node.Options)
            If node._options IsNot newOptions.Node Then anyChanges = True
            Dim newImports = VisitList(node.[Imports])
            If node._imports IsNot newImports.Node Then anyChanges = True
            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newMembers = VisitList(node.Members)
            If node._members IsNot newMembers.Node Then anyChanges = True
            Dim newEndOfFileToken = DirectCast(Visit(node.EndOfFileToken), PunctuationSyntax)
            If node._endOfFileToken IsNot newEndOfFileToken Then anyChanges = True

            If anyChanges Then
                Return New CompilationUnitSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOptions.Node, newImports.Node, newAttributes.Node, newMembers.Node, newEndOfFileToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitOptionStatement(ByVal node As OptionStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOptionKeyword = DirectCast(Visit(node.OptionKeyword), KeywordSyntax)
            If node._optionKeyword IsNot newOptionKeyword Then anyChanges = True
            Dim newNameKeyword = DirectCast(Visit(node.NameKeyword), KeywordSyntax)
            If node._nameKeyword IsNot newNameKeyword Then anyChanges = True
            Dim newValueKeyword = DirectCast(Visit(node.ValueKeyword), KeywordSyntax)
            If node._valueKeyword IsNot newValueKeyword Then anyChanges = True

            If anyChanges Then
                Return New OptionStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOptionKeyword, newNameKeyword, newValueKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitImportsStatement(ByVal node As ImportsStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newImportsKeyword = DirectCast(Visit(node.ImportsKeyword), KeywordSyntax)
            If node._importsKeyword IsNot newImportsKeyword Then anyChanges = True
            Dim newImportsClauses = VisitList(node.ImportsClauses)
            If node._importsClauses IsNot newImportsClauses.Node Then anyChanges = True

            If anyChanges Then
                Return New ImportsStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newImportsKeyword, newImportsClauses.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSimpleImportsClause(ByVal node As SimpleImportsClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAlias = DirectCast(Visit(node._alias), ImportAliasClauseSyntax)
            If node._alias IsNot newAlias Then anyChanges = True
            Dim newName = DirectCast(Visit(node._name), NameSyntax)
            If node._name IsNot newName Then anyChanges = True

            If anyChanges Then
                Return New SimpleImportsClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAlias, newName)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitImportAliasClause(ByVal node As ImportAliasClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newEqualsToken = DirectCast(Visit(node.EqualsToken), PunctuationSyntax)
            If node._equalsToken IsNot newEqualsToken Then anyChanges = True

            If anyChanges Then
                Return New ImportAliasClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIdentifier, newEqualsToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlNamespaceImportsClause(ByVal node As XmlNamespaceImportsClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLessThanToken = DirectCast(Visit(node.LessThanToken), PunctuationSyntax)
            If node._lessThanToken IsNot newLessThanToken Then anyChanges = True
            Dim newXmlNamespace = DirectCast(Visit(node._xmlNamespace), XmlAttributeSyntax)
            If node._xmlNamespace IsNot newXmlNamespace Then anyChanges = True
            Dim newGreaterThanToken = DirectCast(Visit(node.GreaterThanToken), PunctuationSyntax)
            If node._greaterThanToken IsNot newGreaterThanToken Then anyChanges = True

            If anyChanges Then
                Return New XmlNamespaceImportsClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLessThanToken, newXmlNamespace, newGreaterThanToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitNamespaceBlock(ByVal node As NamespaceBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newNamespaceStatement = DirectCast(Visit(node._namespaceStatement), NamespaceStatementSyntax)
            If node._namespaceStatement IsNot newNamespaceStatement Then anyChanges = True
            Dim newMembers = VisitList(node.Members)
            If node._members IsNot newMembers.Node Then anyChanges = True
            Dim newEndNamespaceStatement = DirectCast(Visit(node._endNamespaceStatement), EndBlockStatementSyntax)
            If node._endNamespaceStatement IsNot newEndNamespaceStatement Then anyChanges = True

            If anyChanges Then
                Return New NamespaceBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newNamespaceStatement, newMembers.Node, newEndNamespaceStatement)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitNamespaceStatement(ByVal node As NamespaceStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newNamespaceKeyword = DirectCast(Visit(node.NamespaceKeyword), KeywordSyntax)
            If node._namespaceKeyword IsNot newNamespaceKeyword Then anyChanges = True
            Dim newName = DirectCast(Visit(node._name), NameSyntax)
            If node._name IsNot newName Then anyChanges = True

            If anyChanges Then
                Return New NamespaceStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newNamespaceKeyword, newName)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitModuleBlock(ByVal node As ModuleBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newModuleStatement = DirectCast(Visit(node._moduleStatement), ModuleStatementSyntax)
            If node._moduleStatement IsNot newModuleStatement Then anyChanges = True
            Dim newInherits = VisitList(node.[Inherits])
            If node._inherits IsNot newInherits.Node Then anyChanges = True
            Dim newImplements = VisitList(node.[Implements])
            If node._implements IsNot newImplements.Node Then anyChanges = True
            Dim newMembers = VisitList(node.Members)
            If node._members IsNot newMembers.Node Then anyChanges = True
            Dim newEndModuleStatement = DirectCast(Visit(node._endModuleStatement), EndBlockStatementSyntax)
            If node._endModuleStatement IsNot newEndModuleStatement Then anyChanges = True

            If anyChanges Then
                Return New ModuleBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newModuleStatement, newInherits.Node, newImplements.Node, newMembers.Node, newEndModuleStatement)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitStructureBlock(ByVal node As StructureBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newStructureStatement = DirectCast(Visit(node._structureStatement), StructureStatementSyntax)
            If node._structureStatement IsNot newStructureStatement Then anyChanges = True
            Dim newInherits = VisitList(node.[Inherits])
            If node._inherits IsNot newInherits.Node Then anyChanges = True
            Dim newImplements = VisitList(node.[Implements])
            If node._implements IsNot newImplements.Node Then anyChanges = True
            Dim newMembers = VisitList(node.Members)
            If node._members IsNot newMembers.Node Then anyChanges = True
            Dim newEndStructureStatement = DirectCast(Visit(node._endStructureStatement), EndBlockStatementSyntax)
            If node._endStructureStatement IsNot newEndStructureStatement Then anyChanges = True

            If anyChanges Then
                Return New StructureBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newStructureStatement, newInherits.Node, newImplements.Node, newMembers.Node, newEndStructureStatement)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitInterfaceBlock(ByVal node As InterfaceBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newInterfaceStatement = DirectCast(Visit(node._interfaceStatement), InterfaceStatementSyntax)
            If node._interfaceStatement IsNot newInterfaceStatement Then anyChanges = True
            Dim newInherits = VisitList(node.[Inherits])
            If node._inherits IsNot newInherits.Node Then anyChanges = True
            Dim newImplements = VisitList(node.[Implements])
            If node._implements IsNot newImplements.Node Then anyChanges = True
            Dim newMembers = VisitList(node.Members)
            If node._members IsNot newMembers.Node Then anyChanges = True
            Dim newEndInterfaceStatement = DirectCast(Visit(node._endInterfaceStatement), EndBlockStatementSyntax)
            If node._endInterfaceStatement IsNot newEndInterfaceStatement Then anyChanges = True

            If anyChanges Then
                Return New InterfaceBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newInterfaceStatement, newInherits.Node, newImplements.Node, newMembers.Node, newEndInterfaceStatement)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitClassBlock(ByVal node As ClassBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newClassStatement = DirectCast(Visit(node._classStatement), ClassStatementSyntax)
            If node._classStatement IsNot newClassStatement Then anyChanges = True
            Dim newInherits = VisitList(node.[Inherits])
            If node._inherits IsNot newInherits.Node Then anyChanges = True
            Dim newImplements = VisitList(node.[Implements])
            If node._implements IsNot newImplements.Node Then anyChanges = True
            Dim newMembers = VisitList(node.Members)
            If node._members IsNot newMembers.Node Then anyChanges = True
            Dim newEndClassStatement = DirectCast(Visit(node._endClassStatement), EndBlockStatementSyntax)
            If node._endClassStatement IsNot newEndClassStatement Then anyChanges = True

            If anyChanges Then
                Return New ClassBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newClassStatement, newInherits.Node, newImplements.Node, newMembers.Node, newEndClassStatement)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitEnumBlock(ByVal node As EnumBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newEnumStatement = DirectCast(Visit(node._enumStatement), EnumStatementSyntax)
            If node._enumStatement IsNot newEnumStatement Then anyChanges = True
            Dim newMembers = VisitList(node.Members)
            If node._members IsNot newMembers.Node Then anyChanges = True
            Dim newEndEnumStatement = DirectCast(Visit(node._endEnumStatement), EndBlockStatementSyntax)
            If node._endEnumStatement IsNot newEndEnumStatement Then anyChanges = True

            If anyChanges Then
                Return New EnumBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newEnumStatement, newMembers.Node, newEndEnumStatement)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitInheritsStatement(ByVal node As InheritsStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newInheritsKeyword = DirectCast(Visit(node.InheritsKeyword), KeywordSyntax)
            If node._inheritsKeyword IsNot newInheritsKeyword Then anyChanges = True
            Dim newTypes = VisitList(node.Types)
            If node._types IsNot newTypes.Node Then anyChanges = True

            If anyChanges Then
                Return New InheritsStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newInheritsKeyword, newTypes.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitImplementsStatement(ByVal node As ImplementsStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newImplementsKeyword = DirectCast(Visit(node.ImplementsKeyword), KeywordSyntax)
            If node._implementsKeyword IsNot newImplementsKeyword Then anyChanges = True
            Dim newTypes = VisitList(node.Types)
            If node._types IsNot newTypes.Node Then anyChanges = True

            If anyChanges Then
                Return New ImplementsStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newImplementsKeyword, newTypes.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitModuleStatement(ByVal node As ModuleStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributeLists = VisitList(node.AttributeLists)
            If node._attributeLists IsNot newAttributeLists.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newModuleKeyword = DirectCast(Visit(node.ModuleKeyword), KeywordSyntax)
            If node._moduleKeyword IsNot newModuleKeyword Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newTypeParameterList = DirectCast(Visit(node._typeParameterList), TypeParameterListSyntax)
            If node._typeParameterList IsNot newTypeParameterList Then anyChanges = True

            If anyChanges Then
                Return New ModuleStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributeLists.Node, newModifiers.Node, newModuleKeyword, newIdentifier, newTypeParameterList)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitStructureStatement(ByVal node As StructureStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributeLists = VisitList(node.AttributeLists)
            If node._attributeLists IsNot newAttributeLists.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newStructureKeyword = DirectCast(Visit(node.StructureKeyword), KeywordSyntax)
            If node._structureKeyword IsNot newStructureKeyword Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newTypeParameterList = DirectCast(Visit(node._typeParameterList), TypeParameterListSyntax)
            If node._typeParameterList IsNot newTypeParameterList Then anyChanges = True

            If anyChanges Then
                Return New StructureStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributeLists.Node, newModifiers.Node, newStructureKeyword, newIdentifier, newTypeParameterList)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitInterfaceStatement(ByVal node As InterfaceStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributeLists = VisitList(node.AttributeLists)
            If node._attributeLists IsNot newAttributeLists.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newInterfaceKeyword = DirectCast(Visit(node.InterfaceKeyword), KeywordSyntax)
            If node._interfaceKeyword IsNot newInterfaceKeyword Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newTypeParameterList = DirectCast(Visit(node._typeParameterList), TypeParameterListSyntax)
            If node._typeParameterList IsNot newTypeParameterList Then anyChanges = True

            If anyChanges Then
                Return New InterfaceStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributeLists.Node, newModifiers.Node, newInterfaceKeyword, newIdentifier, newTypeParameterList)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitClassStatement(ByVal node As ClassStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributeLists = VisitList(node.AttributeLists)
            If node._attributeLists IsNot newAttributeLists.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newClassKeyword = DirectCast(Visit(node.ClassKeyword), KeywordSyntax)
            If node._classKeyword IsNot newClassKeyword Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newTypeParameterList = DirectCast(Visit(node._typeParameterList), TypeParameterListSyntax)
            If node._typeParameterList IsNot newTypeParameterList Then anyChanges = True

            If anyChanges Then
                Return New ClassStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributeLists.Node, newModifiers.Node, newClassKeyword, newIdentifier, newTypeParameterList)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitEnumStatement(ByVal node As EnumStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributeLists = VisitList(node.AttributeLists)
            If node._attributeLists IsNot newAttributeLists.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newEnumKeyword = DirectCast(Visit(node.EnumKeyword), KeywordSyntax)
            If node._enumKeyword IsNot newEnumKeyword Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newUnderlyingType = DirectCast(Visit(node._underlyingType), AsClauseSyntax)
            If node._underlyingType IsNot newUnderlyingType Then anyChanges = True

            If anyChanges Then
                Return New EnumStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributeLists.Node, newModifiers.Node, newEnumKeyword, newIdentifier, newUnderlyingType)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTypeParameterList(ByVal node As TypeParameterListSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newOfKeyword = DirectCast(Visit(node.OfKeyword), KeywordSyntax)
            If node._ofKeyword IsNot newOfKeyword Then anyChanges = True
            Dim newParameters = VisitList(node.Parameters)
            If node._parameters IsNot newParameters.Node Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New TypeParameterListSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOpenParenToken, newOfKeyword, newParameters.Node, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTypeParameter(ByVal node As TypeParameterSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newVarianceKeyword = DirectCast(Visit(node.VarianceKeyword), KeywordSyntax)
            If node._varianceKeyword IsNot newVarianceKeyword Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newTypeParameterConstraintClause = DirectCast(Visit(node._typeParameterConstraintClause), TypeParameterConstraintClauseSyntax)
            If node._typeParameterConstraintClause IsNot newTypeParameterConstraintClause Then anyChanges = True

            If anyChanges Then
                Return New TypeParameterSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newVarianceKeyword, newIdentifier, newTypeParameterConstraintClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTypeParameterSingleConstraintClause(ByVal node As TypeParameterSingleConstraintClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAsKeyword = DirectCast(Visit(node.AsKeyword), KeywordSyntax)
            If node._asKeyword IsNot newAsKeyword Then anyChanges = True
            Dim newConstraint = DirectCast(Visit(node._constraint), ConstraintSyntax)
            If node._constraint IsNot newConstraint Then anyChanges = True

            If anyChanges Then
                Return New TypeParameterSingleConstraintClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAsKeyword, newConstraint)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTypeParameterMultipleConstraintClause(ByVal node As TypeParameterMultipleConstraintClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAsKeyword = DirectCast(Visit(node.AsKeyword), KeywordSyntax)
            If node._asKeyword IsNot newAsKeyword Then anyChanges = True
            Dim newOpenBraceToken = DirectCast(Visit(node.OpenBraceToken), PunctuationSyntax)
            If node._openBraceToken IsNot newOpenBraceToken Then anyChanges = True
            Dim newConstraints = VisitList(node.Constraints)
            If node._constraints IsNot newConstraints.Node Then anyChanges = True
            Dim newCloseBraceToken = DirectCast(Visit(node.CloseBraceToken), PunctuationSyntax)
            If node._closeBraceToken IsNot newCloseBraceToken Then anyChanges = True

            If anyChanges Then
                Return New TypeParameterMultipleConstraintClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAsKeyword, newOpenBraceToken, newConstraints.Node, newCloseBraceToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSpecialConstraint(ByVal node As SpecialConstraintSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newConstraintKeyword = DirectCast(Visit(node.ConstraintKeyword), KeywordSyntax)
            If node._constraintKeyword IsNot newConstraintKeyword Then anyChanges = True

            If anyChanges Then
                Return New SpecialConstraintSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newConstraintKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTypeConstraint(ByVal node As TypeConstraintSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newType = DirectCast(Visit(node._type), TypeSyntax)
            If node._type IsNot newType Then anyChanges = True

            If anyChanges Then
                Return New TypeConstraintSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newType)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitEnumMemberDeclaration(ByVal node As EnumMemberDeclarationSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributeLists = VisitList(node.AttributeLists)
            If node._attributeLists IsNot newAttributeLists.Node Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newInitializer = DirectCast(Visit(node._initializer), EqualsValueSyntax)
            If node._initializer IsNot newInitializer Then anyChanges = True

            If anyChanges Then
                Return New EnumMemberDeclarationSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributeLists.Node, newIdentifier, newInitializer)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitMethodBlock(ByVal node As MethodBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newSubOrFunctionStatement = DirectCast(Visit(node._subOrFunctionStatement), MethodStatementSyntax)
            If node._subOrFunctionStatement IsNot newSubOrFunctionStatement Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True
            Dim newEndSubOrFunctionStatement = DirectCast(Visit(node._endSubOrFunctionStatement), EndBlockStatementSyntax)
            If node._endSubOrFunctionStatement IsNot newEndSubOrFunctionStatement Then anyChanges = True

            If anyChanges Then
                Return New MethodBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newSubOrFunctionStatement, newStatements.Node, newEndSubOrFunctionStatement)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitConstructorBlock(ByVal node As ConstructorBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newSubNewStatement = DirectCast(Visit(node._subNewStatement), SubNewStatementSyntax)
            If node._subNewStatement IsNot newSubNewStatement Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True
            Dim newEndSubStatement = DirectCast(Visit(node._endSubStatement), EndBlockStatementSyntax)
            If node._endSubStatement IsNot newEndSubStatement Then anyChanges = True

            If anyChanges Then
                Return New ConstructorBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newSubNewStatement, newStatements.Node, newEndSubStatement)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitOperatorBlock(ByVal node As OperatorBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOperatorStatement = DirectCast(Visit(node._operatorStatement), OperatorStatementSyntax)
            If node._operatorStatement IsNot newOperatorStatement Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True
            Dim newEndOperatorStatement = DirectCast(Visit(node._endOperatorStatement), EndBlockStatementSyntax)
            If node._endOperatorStatement IsNot newEndOperatorStatement Then anyChanges = True

            If anyChanges Then
                Return New OperatorBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOperatorStatement, newStatements.Node, newEndOperatorStatement)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAccessorBlock(ByVal node As AccessorBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAccessorStatement = DirectCast(Visit(node._accessorStatement), AccessorStatementSyntax)
            If node._accessorStatement IsNot newAccessorStatement Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True
            Dim newEndAccessorStatement = DirectCast(Visit(node._endAccessorStatement), EndBlockStatementSyntax)
            If node._endAccessorStatement IsNot newEndAccessorStatement Then anyChanges = True

            If anyChanges Then
                Return New AccessorBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAccessorStatement, newStatements.Node, newEndAccessorStatement)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitPropertyBlock(ByVal node As PropertyBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newPropertyStatement = DirectCast(Visit(node._propertyStatement), PropertyStatementSyntax)
            If node._propertyStatement IsNot newPropertyStatement Then anyChanges = True
            Dim newAccessors = VisitList(node.Accessors)
            If node._accessors IsNot newAccessors.Node Then anyChanges = True
            Dim newEndPropertyStatement = DirectCast(Visit(node._endPropertyStatement), EndBlockStatementSyntax)
            If node._endPropertyStatement IsNot newEndPropertyStatement Then anyChanges = True

            If anyChanges Then
                Return New PropertyBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newPropertyStatement, newAccessors.Node, newEndPropertyStatement)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitEventBlock(ByVal node As EventBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newEventStatement = DirectCast(Visit(node._eventStatement), EventStatementSyntax)
            If node._eventStatement IsNot newEventStatement Then anyChanges = True
            Dim newAccessors = VisitList(node.Accessors)
            If node._accessors IsNot newAccessors.Node Then anyChanges = True
            Dim newEndEventStatement = DirectCast(Visit(node._endEventStatement), EndBlockStatementSyntax)
            If node._endEventStatement IsNot newEndEventStatement Then anyChanges = True

            If anyChanges Then
                Return New EventBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newEventStatement, newAccessors.Node, newEndEventStatement)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitParameterList(ByVal node As ParameterListSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newParameters = VisitList(node.Parameters)
            If node._parameters IsNot newParameters.Node Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New ParameterListSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOpenParenToken, newParameters.Node, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitMethodStatement(ByVal node As MethodStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributeLists = VisitList(node.AttributeLists)
            If node._attributeLists IsNot newAttributeLists.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newSubOrFunctionKeyword = DirectCast(Visit(node.SubOrFunctionKeyword), KeywordSyntax)
            If node._subOrFunctionKeyword IsNot newSubOrFunctionKeyword Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newTypeParameterList = DirectCast(Visit(node._typeParameterList), TypeParameterListSyntax)
            If node._typeParameterList IsNot newTypeParameterList Then anyChanges = True
            Dim newParameterList = DirectCast(Visit(node._parameterList), ParameterListSyntax)
            If node._parameterList IsNot newParameterList Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), SimpleAsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True
            Dim newHandlesClause = DirectCast(Visit(node._handlesClause), HandlesClauseSyntax)
            If node._handlesClause IsNot newHandlesClause Then anyChanges = True
            Dim newImplementsClause = DirectCast(Visit(node._implementsClause), ImplementsClauseSyntax)
            If node._implementsClause IsNot newImplementsClause Then anyChanges = True

            If anyChanges Then
                Return New MethodStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributeLists.Node, newModifiers.Node, newSubOrFunctionKeyword, newIdentifier, newTypeParameterList, newParameterList, newAsClause, newHandlesClause, newImplementsClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSubNewStatement(ByVal node As SubNewStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributeLists = VisitList(node.AttributeLists)
            If node._attributeLists IsNot newAttributeLists.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newSubKeyword = DirectCast(Visit(node.SubKeyword), KeywordSyntax)
            If node._subKeyword IsNot newSubKeyword Then anyChanges = True
            Dim newNewKeyword = DirectCast(Visit(node.NewKeyword), KeywordSyntax)
            If node._newKeyword IsNot newNewKeyword Then anyChanges = True
            Dim newParameterList = DirectCast(Visit(node._parameterList), ParameterListSyntax)
            If node._parameterList IsNot newParameterList Then anyChanges = True

            If anyChanges Then
                Return New SubNewStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributeLists.Node, newModifiers.Node, newSubKeyword, newNewKeyword, newParameterList)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitDeclareStatement(ByVal node As DeclareStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributeLists = VisitList(node.AttributeLists)
            If node._attributeLists IsNot newAttributeLists.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newDeclareKeyword = DirectCast(Visit(node.DeclareKeyword), KeywordSyntax)
            If node._declareKeyword IsNot newDeclareKeyword Then anyChanges = True
            Dim newCharsetKeyword = DirectCast(Visit(node.CharsetKeyword), KeywordSyntax)
            If node._charsetKeyword IsNot newCharsetKeyword Then anyChanges = True
            Dim newSubOrFunctionKeyword = DirectCast(Visit(node.SubOrFunctionKeyword), KeywordSyntax)
            If node._subOrFunctionKeyword IsNot newSubOrFunctionKeyword Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newLibKeyword = DirectCast(Visit(node.LibKeyword), KeywordSyntax)
            If node._libKeyword IsNot newLibKeyword Then anyChanges = True
            Dim newLibraryName = DirectCast(Visit(node._libraryName), LiteralExpressionSyntax)
            If node._libraryName IsNot newLibraryName Then anyChanges = True
            Dim newAliasKeyword = DirectCast(Visit(node.AliasKeyword), KeywordSyntax)
            If node._aliasKeyword IsNot newAliasKeyword Then anyChanges = True
            Dim newAliasName = DirectCast(Visit(node._aliasName), LiteralExpressionSyntax)
            If node._aliasName IsNot newAliasName Then anyChanges = True
            Dim newParameterList = DirectCast(Visit(node._parameterList), ParameterListSyntax)
            If node._parameterList IsNot newParameterList Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), SimpleAsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True

            If anyChanges Then
                Return New DeclareStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributeLists.Node, newModifiers.Node, newDeclareKeyword, newCharsetKeyword, newSubOrFunctionKeyword, newIdentifier, newLibKeyword, newLibraryName, newAliasKeyword, newAliasName, newParameterList, newAsClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitDelegateStatement(ByVal node As DelegateStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributeLists = VisitList(node.AttributeLists)
            If node._attributeLists IsNot newAttributeLists.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newDelegateKeyword = DirectCast(Visit(node.DelegateKeyword), KeywordSyntax)
            If node._delegateKeyword IsNot newDelegateKeyword Then anyChanges = True
            Dim newSubOrFunctionKeyword = DirectCast(Visit(node.SubOrFunctionKeyword), KeywordSyntax)
            If node._subOrFunctionKeyword IsNot newSubOrFunctionKeyword Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newTypeParameterList = DirectCast(Visit(node._typeParameterList), TypeParameterListSyntax)
            If node._typeParameterList IsNot newTypeParameterList Then anyChanges = True
            Dim newParameterList = DirectCast(Visit(node._parameterList), ParameterListSyntax)
            If node._parameterList IsNot newParameterList Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), SimpleAsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True

            If anyChanges Then
                Return New DelegateStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributeLists.Node, newModifiers.Node, newDelegateKeyword, newSubOrFunctionKeyword, newIdentifier, newTypeParameterList, newParameterList, newAsClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitEventStatement(ByVal node As EventStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributeLists = VisitList(node.AttributeLists)
            If node._attributeLists IsNot newAttributeLists.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newCustomKeyword = DirectCast(Visit(node.CustomKeyword), KeywordSyntax)
            If node._customKeyword IsNot newCustomKeyword Then anyChanges = True
            Dim newEventKeyword = DirectCast(Visit(node.EventKeyword), KeywordSyntax)
            If node._eventKeyword IsNot newEventKeyword Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newParameterList = DirectCast(Visit(node._parameterList), ParameterListSyntax)
            If node._parameterList IsNot newParameterList Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), SimpleAsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True
            Dim newImplementsClause = DirectCast(Visit(node._implementsClause), ImplementsClauseSyntax)
            If node._implementsClause IsNot newImplementsClause Then anyChanges = True

            If anyChanges Then
                Return New EventStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributeLists.Node, newModifiers.Node, newCustomKeyword, newEventKeyword, newIdentifier, newParameterList, newAsClause, newImplementsClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitOperatorStatement(ByVal node As OperatorStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributeLists = VisitList(node.AttributeLists)
            If node._attributeLists IsNot newAttributeLists.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newOperatorKeyword = DirectCast(Visit(node.OperatorKeyword), KeywordSyntax)
            If node._operatorKeyword IsNot newOperatorKeyword Then anyChanges = True
            Dim newOperatorToken = DirectCast(Visit(node.OperatorToken), SyntaxToken)
            If node._operatorToken IsNot newOperatorToken Then anyChanges = True
            Dim newParameterList = DirectCast(Visit(node._parameterList), ParameterListSyntax)
            If node._parameterList IsNot newParameterList Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), SimpleAsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True

            If anyChanges Then
                Return New OperatorStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributeLists.Node, newModifiers.Node, newOperatorKeyword, newOperatorToken, newParameterList, newAsClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitPropertyStatement(ByVal node As PropertyStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributeLists = VisitList(node.AttributeLists)
            If node._attributeLists IsNot newAttributeLists.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newPropertyKeyword = DirectCast(Visit(node.PropertyKeyword), KeywordSyntax)
            If node._propertyKeyword IsNot newPropertyKeyword Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newParameterList = DirectCast(Visit(node._parameterList), ParameterListSyntax)
            If node._parameterList IsNot newParameterList Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), AsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True
            Dim newInitializer = DirectCast(Visit(node._initializer), EqualsValueSyntax)
            If node._initializer IsNot newInitializer Then anyChanges = True
            Dim newImplementsClause = DirectCast(Visit(node._implementsClause), ImplementsClauseSyntax)
            If node._implementsClause IsNot newImplementsClause Then anyChanges = True

            If anyChanges Then
                Return New PropertyStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributeLists.Node, newModifiers.Node, newPropertyKeyword, newIdentifier, newParameterList, newAsClause, newInitializer, newImplementsClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAccessorStatement(ByVal node As AccessorStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributeLists = VisitList(node.AttributeLists)
            If node._attributeLists IsNot newAttributeLists.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newAccessorKeyword = DirectCast(Visit(node.AccessorKeyword), KeywordSyntax)
            If node._accessorKeyword IsNot newAccessorKeyword Then anyChanges = True
            Dim newParameterList = DirectCast(Visit(node._parameterList), ParameterListSyntax)
            If node._parameterList IsNot newParameterList Then anyChanges = True

            If anyChanges Then
                Return New AccessorStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributeLists.Node, newModifiers.Node, newAccessorKeyword, newParameterList)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitImplementsClause(ByVal node As ImplementsClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newImplementsKeyword = DirectCast(Visit(node.ImplementsKeyword), KeywordSyntax)
            If node._implementsKeyword IsNot newImplementsKeyword Then anyChanges = True
            Dim newInterfaceMembers = VisitList(node.InterfaceMembers)
            If node._interfaceMembers IsNot newInterfaceMembers.Node Then anyChanges = True

            If anyChanges Then
                Return New ImplementsClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newImplementsKeyword, newInterfaceMembers.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitHandlesClause(ByVal node As HandlesClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHandlesKeyword = DirectCast(Visit(node.HandlesKeyword), KeywordSyntax)
            If node._handlesKeyword IsNot newHandlesKeyword Then anyChanges = True
            Dim newEvents = VisitList(node.Events)
            If node._events IsNot newEvents.Node Then anyChanges = True

            If anyChanges Then
                Return New HandlesClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHandlesKeyword, newEvents.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitKeywordEventContainer(ByVal node As KeywordEventContainerSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True

            If anyChanges Then
                Return New KeywordEventContainerSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitWithEventsEventContainer(ByVal node As WithEventsEventContainerSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True

            If anyChanges Then
                Return New WithEventsEventContainerSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIdentifier)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitWithEventsPropertyEventContainer(ByVal node As WithEventsPropertyEventContainerSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newWithEventsContainer = DirectCast(Visit(node._withEventsContainer), WithEventsEventContainerSyntax)
            If node._withEventsContainer IsNot newWithEventsContainer Then anyChanges = True
            Dim newDotToken = DirectCast(Visit(node.DotToken), PunctuationSyntax)
            If node._dotToken IsNot newDotToken Then anyChanges = True
            Dim newProperty = DirectCast(Visit(node._property), IdentifierNameSyntax)
            If node._property IsNot newProperty Then anyChanges = True

            If anyChanges Then
                Return New WithEventsPropertyEventContainerSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newWithEventsContainer, newDotToken, newProperty)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitHandlesClauseItem(ByVal node As HandlesClauseItemSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newEventContainer = DirectCast(Visit(node._eventContainer), EventContainerSyntax)
            If node._eventContainer IsNot newEventContainer Then anyChanges = True
            Dim newDotToken = DirectCast(Visit(node.DotToken), PunctuationSyntax)
            If node._dotToken IsNot newDotToken Then anyChanges = True
            Dim newEventMember = DirectCast(Visit(node._eventMember), IdentifierNameSyntax)
            If node._eventMember IsNot newEventMember Then anyChanges = True

            If anyChanges Then
                Return New HandlesClauseItemSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newEventContainer, newDotToken, newEventMember)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitIncompleteMember(ByVal node As IncompleteMemberSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributeLists = VisitList(node.AttributeLists)
            If node._attributeLists IsNot newAttributeLists.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newMissingIdentifier = DirectCast(Visit(node.MissingIdentifier), IdentifierTokenSyntax)
            If node._missingIdentifier IsNot newMissingIdentifier Then anyChanges = True

            If anyChanges Then
                Return New IncompleteMemberSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributeLists.Node, newModifiers.Node, newMissingIdentifier)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitFieldDeclaration(ByVal node As FieldDeclarationSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributeLists = VisitList(node.AttributeLists)
            If node._attributeLists IsNot newAttributeLists.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newDeclarators = VisitList(node.Declarators)
            If node._declarators IsNot newDeclarators.Node Then anyChanges = True

            If anyChanges Then
                Return New FieldDeclarationSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributeLists.Node, newModifiers.Node, newDeclarators.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitVariableDeclarator(ByVal node As VariableDeclaratorSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newNames = VisitList(node.Names)
            If node._names IsNot newNames.Node Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), AsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True
            Dim newInitializer = DirectCast(Visit(node._initializer), EqualsValueSyntax)
            If node._initializer IsNot newInitializer Then anyChanges = True

            If anyChanges Then
                Return New VariableDeclaratorSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newNames.Node, newAsClause, newInitializer)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSimpleAsClause(ByVal node As SimpleAsClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAsKeyword = DirectCast(Visit(node.AsKeyword), KeywordSyntax)
            If node._asKeyword IsNot newAsKeyword Then anyChanges = True
            Dim newAttributeLists = VisitList(node.AttributeLists)
            If node._attributeLists IsNot newAttributeLists.Node Then anyChanges = True
            Dim newType = DirectCast(Visit(node._type), TypeSyntax)
            If node._type IsNot newType Then anyChanges = True

            If anyChanges Then
                Return New SimpleAsClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAsKeyword, newAttributeLists.Node, newType)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAsNewClause(ByVal node As AsNewClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAsKeyword = DirectCast(Visit(node.AsKeyword), KeywordSyntax)
            If node._asKeyword IsNot newAsKeyword Then anyChanges = True
            Dim newNewExpression = DirectCast(Visit(node._newExpression), NewExpressionSyntax)
            If node._newExpression IsNot newNewExpression Then anyChanges = True

            If anyChanges Then
                Return New AsNewClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAsKeyword, newNewExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitObjectMemberInitializer(ByVal node As ObjectMemberInitializerSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newWithKeyword = DirectCast(Visit(node.WithKeyword), KeywordSyntax)
            If node._withKeyword IsNot newWithKeyword Then anyChanges = True
            Dim newOpenBraceToken = DirectCast(Visit(node.OpenBraceToken), PunctuationSyntax)
            If node._openBraceToken IsNot newOpenBraceToken Then anyChanges = True
            Dim newInitializers = VisitList(node.Initializers)
            If node._initializers IsNot newInitializers.Node Then anyChanges = True
            Dim newCloseBraceToken = DirectCast(Visit(node.CloseBraceToken), PunctuationSyntax)
            If node._closeBraceToken IsNot newCloseBraceToken Then anyChanges = True

            If anyChanges Then
                Return New ObjectMemberInitializerSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newWithKeyword, newOpenBraceToken, newInitializers.Node, newCloseBraceToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitObjectCollectionInitializer(ByVal node As ObjectCollectionInitializerSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newFromKeyword = DirectCast(Visit(node.FromKeyword), KeywordSyntax)
            If node._fromKeyword IsNot newFromKeyword Then anyChanges = True
            Dim newInitializer = DirectCast(Visit(node._initializer), CollectionInitializerSyntax)
            If node._initializer IsNot newInitializer Then anyChanges = True

            If anyChanges Then
                Return New ObjectCollectionInitializerSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newFromKeyword, newInitializer)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitInferredFieldInitializer(ByVal node As InferredFieldInitializerSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newKeyKeyword = DirectCast(Visit(node.KeyKeyword), KeywordSyntax)
            If node._keyKeyword IsNot newKeyKeyword Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New InferredFieldInitializerSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newKeyKeyword, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitNamedFieldInitializer(ByVal node As NamedFieldInitializerSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newKeyKeyword = DirectCast(Visit(node.KeyKeyword), KeywordSyntax)
            If node._keyKeyword IsNot newKeyKeyword Then anyChanges = True
            Dim newDotToken = DirectCast(Visit(node.DotToken), PunctuationSyntax)
            If node._dotToken IsNot newDotToken Then anyChanges = True
            Dim newName = DirectCast(Visit(node._name), IdentifierNameSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newEqualsToken = DirectCast(Visit(node.EqualsToken), PunctuationSyntax)
            If node._equalsToken IsNot newEqualsToken Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New NamedFieldInitializerSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newKeyKeyword, newDotToken, newName, newEqualsToken, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitEqualsValue(ByVal node As EqualsValueSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newEqualsToken = DirectCast(Visit(node.EqualsToken), PunctuationSyntax)
            If node._equalsToken IsNot newEqualsToken Then anyChanges = True
            Dim newValue = DirectCast(Visit(node._value), ExpressionSyntax)
            If node._value IsNot newValue Then anyChanges = True

            If anyChanges Then
                Return New EqualsValueSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newEqualsToken, newValue)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitParameter(ByVal node As ParameterSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributeLists = VisitList(node.AttributeLists)
            If node._attributeLists IsNot newAttributeLists.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newIdentifier = DirectCast(Visit(node._identifier), ModifiedIdentifierSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), SimpleAsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True
            Dim newDefault = DirectCast(Visit(node._default), EqualsValueSyntax)
            If node._default IsNot newDefault Then anyChanges = True

            If anyChanges Then
                Return New ParameterSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributeLists.Node, newModifiers.Node, newIdentifier, newAsClause, newDefault)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitModifiedIdentifier(ByVal node As ModifiedIdentifierSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newNullable = DirectCast(Visit(node.Nullable), PunctuationSyntax)
            If node._nullable IsNot newNullable Then anyChanges = True
            Dim newArrayBounds = DirectCast(Visit(node._arrayBounds), ArgumentListSyntax)
            If node._arrayBounds IsNot newArrayBounds Then anyChanges = True
            Dim newArrayRankSpecifiers = VisitList(node.ArrayRankSpecifiers)
            If node._arrayRankSpecifiers IsNot newArrayRankSpecifiers.Node Then anyChanges = True

            If anyChanges Then
                Return New ModifiedIdentifierSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIdentifier, newNullable, newArrayBounds, newArrayRankSpecifiers.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitArrayRankSpecifier(ByVal node As ArrayRankSpecifierSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newCommaTokens = VisitList(node.CommaTokens)
            If node._commaTokens IsNot newCommaTokens.Node Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New ArrayRankSpecifierSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOpenParenToken, newCommaTokens.Node, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAttributeList(ByVal node As AttributeListSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLessThanToken = DirectCast(Visit(node.LessThanToken), PunctuationSyntax)
            If node._lessThanToken IsNot newLessThanToken Then anyChanges = True
            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newGreaterThanToken = DirectCast(Visit(node.GreaterThanToken), PunctuationSyntax)
            If node._greaterThanToken IsNot newGreaterThanToken Then anyChanges = True

            If anyChanges Then
                Return New AttributeListSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLessThanToken, newAttributes.Node, newGreaterThanToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAttribute(ByVal node As AttributeSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newTarget = DirectCast(Visit(node._target), AttributeTargetSyntax)
            If node._target IsNot newTarget Then anyChanges = True
            Dim newName = DirectCast(Visit(node._name), TypeSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newArgumentList = DirectCast(Visit(node._argumentList), ArgumentListSyntax)
            If node._argumentList IsNot newArgumentList Then anyChanges = True

            If anyChanges Then
                Return New AttributeSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newTarget, newName, newArgumentList)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAttributeTarget(ByVal node As AttributeTargetSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributeModifier = DirectCast(Visit(node.AttributeModifier), KeywordSyntax)
            If node._attributeModifier IsNot newAttributeModifier Then anyChanges = True
            Dim newColonToken = DirectCast(Visit(node.ColonToken), PunctuationSyntax)
            If node._colonToken IsNot newColonToken Then anyChanges = True

            If anyChanges Then
                Return New AttributeTargetSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributeModifier, newColonToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAttributesStatement(ByVal node As AttributesStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributeLists = VisitList(node.AttributeLists)
            If node._attributeLists IsNot newAttributeLists.Node Then anyChanges = True

            If anyChanges Then
                Return New AttributesStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributeLists.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitExpressionStatement(ByVal node As ExpressionStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New ExpressionStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitPrintStatement(ByVal node As PrintStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newQuestionToken = DirectCast(Visit(node.QuestionToken), PunctuationSyntax)
            If node._questionToken IsNot newQuestionToken Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New PrintStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newQuestionToken, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitWhileBlock(ByVal node As WhileBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newWhileStatement = DirectCast(Visit(node._whileStatement), WhileStatementSyntax)
            If node._whileStatement IsNot newWhileStatement Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True
            Dim newEndWhileStatement = DirectCast(Visit(node._endWhileStatement), EndBlockStatementSyntax)
            If node._endWhileStatement IsNot newEndWhileStatement Then anyChanges = True

            If anyChanges Then
                Return New WhileBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newWhileStatement, newStatements.Node, newEndWhileStatement)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitUsingBlock(ByVal node As UsingBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newUsingStatement = DirectCast(Visit(node._usingStatement), UsingStatementSyntax)
            If node._usingStatement IsNot newUsingStatement Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True
            Dim newEndUsingStatement = DirectCast(Visit(node._endUsingStatement), EndBlockStatementSyntax)
            If node._endUsingStatement IsNot newEndUsingStatement Then anyChanges = True

            If anyChanges Then
                Return New UsingBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newUsingStatement, newStatements.Node, newEndUsingStatement)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSyncLockBlock(ByVal node As SyncLockBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newSyncLockStatement = DirectCast(Visit(node._syncLockStatement), SyncLockStatementSyntax)
            If node._syncLockStatement IsNot newSyncLockStatement Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True
            Dim newEndSyncLockStatement = DirectCast(Visit(node._endSyncLockStatement), EndBlockStatementSyntax)
            If node._endSyncLockStatement IsNot newEndSyncLockStatement Then anyChanges = True

            If anyChanges Then
                Return New SyncLockBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newSyncLockStatement, newStatements.Node, newEndSyncLockStatement)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitWithBlock(ByVal node As WithBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newWithStatement = DirectCast(Visit(node._withStatement), WithStatementSyntax)
            If node._withStatement IsNot newWithStatement Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True
            Dim newEndWithStatement = DirectCast(Visit(node._endWithStatement), EndBlockStatementSyntax)
            If node._endWithStatement IsNot newEndWithStatement Then anyChanges = True

            If anyChanges Then
                Return New WithBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newWithStatement, newStatements.Node, newEndWithStatement)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitLocalDeclarationStatement(ByVal node As LocalDeclarationStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newDeclarators = VisitList(node.Declarators)
            If node._declarators IsNot newDeclarators.Node Then anyChanges = True

            If anyChanges Then
                Return New LocalDeclarationStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newModifiers.Node, newDeclarators.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitLabelStatement(ByVal node As LabelStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLabelToken = DirectCast(Visit(node.LabelToken), SyntaxToken)
            If node._labelToken IsNot newLabelToken Then anyChanges = True
            Dim newColonToken = DirectCast(Visit(node.ColonToken), PunctuationSyntax)
            If node._colonToken IsNot newColonToken Then anyChanges = True

            If anyChanges Then
                Return New LabelStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLabelToken, newColonToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitGoToStatement(ByVal node As GoToStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newGoToKeyword = DirectCast(Visit(node.GoToKeyword), KeywordSyntax)
            If node._goToKeyword IsNot newGoToKeyword Then anyChanges = True
            Dim newLabel = DirectCast(Visit(node._label), LabelSyntax)
            If node._label IsNot newLabel Then anyChanges = True

            If anyChanges Then
                Return New GoToStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newGoToKeyword, newLabel)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitLabel(ByVal node As LabelSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLabelToken = DirectCast(Visit(node.LabelToken), SyntaxToken)
            If node._labelToken IsNot newLabelToken Then anyChanges = True

            If anyChanges Then
                Return New LabelSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLabelToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitStopOrEndStatement(ByVal node As StopOrEndStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newStopOrEndKeyword = DirectCast(Visit(node.StopOrEndKeyword), KeywordSyntax)
            If node._stopOrEndKeyword IsNot newStopOrEndKeyword Then anyChanges = True

            If anyChanges Then
                Return New StopOrEndStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newStopOrEndKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitExitStatement(ByVal node As ExitStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newExitKeyword = DirectCast(Visit(node.ExitKeyword), KeywordSyntax)
            If node._exitKeyword IsNot newExitKeyword Then anyChanges = True
            Dim newBlockKeyword = DirectCast(Visit(node.BlockKeyword), KeywordSyntax)
            If node._blockKeyword IsNot newBlockKeyword Then anyChanges = True

            If anyChanges Then
                Return New ExitStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newExitKeyword, newBlockKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitContinueStatement(ByVal node As ContinueStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newContinueKeyword = DirectCast(Visit(node.ContinueKeyword), KeywordSyntax)
            If node._continueKeyword IsNot newContinueKeyword Then anyChanges = True
            Dim newBlockKeyword = DirectCast(Visit(node.BlockKeyword), KeywordSyntax)
            If node._blockKeyword IsNot newBlockKeyword Then anyChanges = True

            If anyChanges Then
                Return New ContinueStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newContinueKeyword, newBlockKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitReturnStatement(ByVal node As ReturnStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newReturnKeyword = DirectCast(Visit(node.ReturnKeyword), KeywordSyntax)
            If node._returnKeyword IsNot newReturnKeyword Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New ReturnStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newReturnKeyword, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSingleLineIfStatement(ByVal node As SingleLineIfStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIfKeyword = DirectCast(Visit(node.IfKeyword), KeywordSyntax)
            If node._ifKeyword IsNot newIfKeyword Then anyChanges = True
            Dim newCondition = DirectCast(Visit(node._condition), ExpressionSyntax)
            If node._condition IsNot newCondition Then anyChanges = True
            Dim newThenKeyword = DirectCast(Visit(node.ThenKeyword), KeywordSyntax)
            If node._thenKeyword IsNot newThenKeyword Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True
            Dim newElseClause = DirectCast(Visit(node._elseClause), SingleLineElseClauseSyntax)
            If node._elseClause IsNot newElseClause Then anyChanges = True

            If anyChanges Then
                Return New SingleLineIfStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIfKeyword, newCondition, newThenKeyword, newStatements.Node, newElseClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSingleLineElseClause(ByVal node As SingleLineElseClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newElseKeyword = DirectCast(Visit(node.ElseKeyword), KeywordSyntax)
            If node._elseKeyword IsNot newElseKeyword Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True

            If anyChanges Then
                Return New SingleLineElseClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newElseKeyword, newStatements.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitMultiLineIfBlock(ByVal node As MultiLineIfBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIfStatement = DirectCast(Visit(node._ifStatement), IfStatementSyntax)
            If node._ifStatement IsNot newIfStatement Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True
            Dim newElseIfBlocks = VisitList(node.ElseIfBlocks)
            If node._elseIfBlocks IsNot newElseIfBlocks.Node Then anyChanges = True
            Dim newElseBlock = DirectCast(Visit(node._elseBlock), ElseBlockSyntax)
            If node._elseBlock IsNot newElseBlock Then anyChanges = True
            Dim newEndIfStatement = DirectCast(Visit(node._endIfStatement), EndBlockStatementSyntax)
            If node._endIfStatement IsNot newEndIfStatement Then anyChanges = True

            If anyChanges Then
                Return New MultiLineIfBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIfStatement, newStatements.Node, newElseIfBlocks.Node, newElseBlock, newEndIfStatement)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitIfStatement(ByVal node As IfStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIfKeyword = DirectCast(Visit(node.IfKeyword), KeywordSyntax)
            If node._ifKeyword IsNot newIfKeyword Then anyChanges = True
            Dim newCondition = DirectCast(Visit(node._condition), ExpressionSyntax)
            If node._condition IsNot newCondition Then anyChanges = True
            Dim newThenKeyword = DirectCast(Visit(node.ThenKeyword), KeywordSyntax)
            If node._thenKeyword IsNot newThenKeyword Then anyChanges = True

            If anyChanges Then
                Return New IfStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIfKeyword, newCondition, newThenKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitElseIfBlock(ByVal node As ElseIfBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newElseIfStatement = DirectCast(Visit(node._elseIfStatement), ElseIfStatementSyntax)
            If node._elseIfStatement IsNot newElseIfStatement Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True

            If anyChanges Then
                Return New ElseIfBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newElseIfStatement, newStatements.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitElseIfStatement(ByVal node As ElseIfStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newElseIfKeyword = DirectCast(Visit(node.ElseIfKeyword), KeywordSyntax)
            If node._elseIfKeyword IsNot newElseIfKeyword Then anyChanges = True
            Dim newCondition = DirectCast(Visit(node._condition), ExpressionSyntax)
            If node._condition IsNot newCondition Then anyChanges = True
            Dim newThenKeyword = DirectCast(Visit(node.ThenKeyword), KeywordSyntax)
            If node._thenKeyword IsNot newThenKeyword Then anyChanges = True

            If anyChanges Then
                Return New ElseIfStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newElseIfKeyword, newCondition, newThenKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitElseBlock(ByVal node As ElseBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newElseStatement = DirectCast(Visit(node._elseStatement), ElseStatementSyntax)
            If node._elseStatement IsNot newElseStatement Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True

            If anyChanges Then
                Return New ElseBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newElseStatement, newStatements.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitElseStatement(ByVal node As ElseStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newElseKeyword = DirectCast(Visit(node.ElseKeyword), KeywordSyntax)
            If node._elseKeyword IsNot newElseKeyword Then anyChanges = True

            If anyChanges Then
                Return New ElseStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newElseKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTryBlock(ByVal node As TryBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newTryStatement = DirectCast(Visit(node._tryStatement), TryStatementSyntax)
            If node._tryStatement IsNot newTryStatement Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True
            Dim newCatchBlocks = VisitList(node.CatchBlocks)
            If node._catchBlocks IsNot newCatchBlocks.Node Then anyChanges = True
            Dim newFinallyBlock = DirectCast(Visit(node._finallyBlock), FinallyBlockSyntax)
            If node._finallyBlock IsNot newFinallyBlock Then anyChanges = True
            Dim newEndTryStatement = DirectCast(Visit(node._endTryStatement), EndBlockStatementSyntax)
            If node._endTryStatement IsNot newEndTryStatement Then anyChanges = True

            If anyChanges Then
                Return New TryBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newTryStatement, newStatements.Node, newCatchBlocks.Node, newFinallyBlock, newEndTryStatement)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTryStatement(ByVal node As TryStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newTryKeyword = DirectCast(Visit(node.TryKeyword), KeywordSyntax)
            If node._tryKeyword IsNot newTryKeyword Then anyChanges = True

            If anyChanges Then
                Return New TryStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newTryKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCatchBlock(ByVal node As CatchBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newCatchStatement = DirectCast(Visit(node._catchStatement), CatchStatementSyntax)
            If node._catchStatement IsNot newCatchStatement Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True

            If anyChanges Then
                Return New CatchBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newCatchStatement, newStatements.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCatchStatement(ByVal node As CatchStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newCatchKeyword = DirectCast(Visit(node.CatchKeyword), KeywordSyntax)
            If node._catchKeyword IsNot newCatchKeyword Then anyChanges = True
            Dim newIdentifierName = DirectCast(Visit(node._identifierName), IdentifierNameSyntax)
            If node._identifierName IsNot newIdentifierName Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), SimpleAsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True
            Dim newWhenClause = DirectCast(Visit(node._whenClause), CatchFilterClauseSyntax)
            If node._whenClause IsNot newWhenClause Then anyChanges = True

            If anyChanges Then
                Return New CatchStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newCatchKeyword, newIdentifierName, newAsClause, newWhenClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCatchFilterClause(ByVal node As CatchFilterClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newWhenKeyword = DirectCast(Visit(node.WhenKeyword), KeywordSyntax)
            If node._whenKeyword IsNot newWhenKeyword Then anyChanges = True
            Dim newFilter = DirectCast(Visit(node._filter), ExpressionSyntax)
            If node._filter IsNot newFilter Then anyChanges = True

            If anyChanges Then
                Return New CatchFilterClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newWhenKeyword, newFilter)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitFinallyBlock(ByVal node As FinallyBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newFinallyStatement = DirectCast(Visit(node._finallyStatement), FinallyStatementSyntax)
            If node._finallyStatement IsNot newFinallyStatement Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True

            If anyChanges Then
                Return New FinallyBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newFinallyStatement, newStatements.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitFinallyStatement(ByVal node As FinallyStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newFinallyKeyword = DirectCast(Visit(node.FinallyKeyword), KeywordSyntax)
            If node._finallyKeyword IsNot newFinallyKeyword Then anyChanges = True

            If anyChanges Then
                Return New FinallyStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newFinallyKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitErrorStatement(ByVal node As ErrorStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newErrorKeyword = DirectCast(Visit(node.ErrorKeyword), KeywordSyntax)
            If node._errorKeyword IsNot newErrorKeyword Then anyChanges = True
            Dim newErrorNumber = DirectCast(Visit(node._errorNumber), ExpressionSyntax)
            If node._errorNumber IsNot newErrorNumber Then anyChanges = True

            If anyChanges Then
                Return New ErrorStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newErrorKeyword, newErrorNumber)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitOnErrorGoToStatement(ByVal node As OnErrorGoToStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOnKeyword = DirectCast(Visit(node.OnKeyword), KeywordSyntax)
            If node._onKeyword IsNot newOnKeyword Then anyChanges = True
            Dim newErrorKeyword = DirectCast(Visit(node.ErrorKeyword), KeywordSyntax)
            If node._errorKeyword IsNot newErrorKeyword Then anyChanges = True
            Dim newGoToKeyword = DirectCast(Visit(node.GoToKeyword), KeywordSyntax)
            If node._goToKeyword IsNot newGoToKeyword Then anyChanges = True
            Dim newMinus = DirectCast(Visit(node.Minus), PunctuationSyntax)
            If node._minus IsNot newMinus Then anyChanges = True
            Dim newLabel = DirectCast(Visit(node._label), LabelSyntax)
            If node._label IsNot newLabel Then anyChanges = True

            If anyChanges Then
                Return New OnErrorGoToStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOnKeyword, newErrorKeyword, newGoToKeyword, newMinus, newLabel)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitOnErrorResumeNextStatement(ByVal node As OnErrorResumeNextStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOnKeyword = DirectCast(Visit(node.OnKeyword), KeywordSyntax)
            If node._onKeyword IsNot newOnKeyword Then anyChanges = True
            Dim newErrorKeyword = DirectCast(Visit(node.ErrorKeyword), KeywordSyntax)
            If node._errorKeyword IsNot newErrorKeyword Then anyChanges = True
            Dim newResumeKeyword = DirectCast(Visit(node.ResumeKeyword), KeywordSyntax)
            If node._resumeKeyword IsNot newResumeKeyword Then anyChanges = True
            Dim newNextKeyword = DirectCast(Visit(node.NextKeyword), KeywordSyntax)
            If node._nextKeyword IsNot newNextKeyword Then anyChanges = True

            If anyChanges Then
                Return New OnErrorResumeNextStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOnKeyword, newErrorKeyword, newResumeKeyword, newNextKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitResumeStatement(ByVal node As ResumeStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newResumeKeyword = DirectCast(Visit(node.ResumeKeyword), KeywordSyntax)
            If node._resumeKeyword IsNot newResumeKeyword Then anyChanges = True
            Dim newLabel = DirectCast(Visit(node._label), LabelSyntax)
            If node._label IsNot newLabel Then anyChanges = True

            If anyChanges Then
                Return New ResumeStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newResumeKeyword, newLabel)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSelectBlock(ByVal node As SelectBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newSelectStatement = DirectCast(Visit(node._selectStatement), SelectStatementSyntax)
            If node._selectStatement IsNot newSelectStatement Then anyChanges = True
            Dim newCaseBlocks = VisitList(node.CaseBlocks)
            If node._caseBlocks IsNot newCaseBlocks.Node Then anyChanges = True
            Dim newEndSelectStatement = DirectCast(Visit(node._endSelectStatement), EndBlockStatementSyntax)
            If node._endSelectStatement IsNot newEndSelectStatement Then anyChanges = True

            If anyChanges Then
                Return New SelectBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newSelectStatement, newCaseBlocks.Node, newEndSelectStatement)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSelectStatement(ByVal node As SelectStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newSelectKeyword = DirectCast(Visit(node.SelectKeyword), KeywordSyntax)
            If node._selectKeyword IsNot newSelectKeyword Then anyChanges = True
            Dim newCaseKeyword = DirectCast(Visit(node.CaseKeyword), KeywordSyntax)
            If node._caseKeyword IsNot newCaseKeyword Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New SelectStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newSelectKeyword, newCaseKeyword, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCaseBlock(ByVal node As CaseBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newCaseStatement = DirectCast(Visit(node._caseStatement), CaseStatementSyntax)
            If node._caseStatement IsNot newCaseStatement Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True

            If anyChanges Then
                Return New CaseBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newCaseStatement, newStatements.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCaseStatement(ByVal node As CaseStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newCaseKeyword = DirectCast(Visit(node.CaseKeyword), KeywordSyntax)
            If node._caseKeyword IsNot newCaseKeyword Then anyChanges = True
            Dim newCases = VisitList(node.Cases)
            If node._cases IsNot newCases.Node Then anyChanges = True

            If anyChanges Then
                Return New CaseStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newCaseKeyword, newCases.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitElseCaseClause(ByVal node As ElseCaseClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newElseKeyword = DirectCast(Visit(node.ElseKeyword), KeywordSyntax)
            If node._elseKeyword IsNot newElseKeyword Then anyChanges = True

            If anyChanges Then
                Return New ElseCaseClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newElseKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSimpleCaseClause(ByVal node As SimpleCaseClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newValue = DirectCast(Visit(node._value), ExpressionSyntax)
            If node._value IsNot newValue Then anyChanges = True

            If anyChanges Then
                Return New SimpleCaseClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newValue)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitRangeCaseClause(ByVal node As RangeCaseClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLowerBound = DirectCast(Visit(node._lowerBound), ExpressionSyntax)
            If node._lowerBound IsNot newLowerBound Then anyChanges = True
            Dim newToKeyword = DirectCast(Visit(node.ToKeyword), KeywordSyntax)
            If node._toKeyword IsNot newToKeyword Then anyChanges = True
            Dim newUpperBound = DirectCast(Visit(node._upperBound), ExpressionSyntax)
            If node._upperBound IsNot newUpperBound Then anyChanges = True

            If anyChanges Then
                Return New RangeCaseClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLowerBound, newToKeyword, newUpperBound)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitRelationalCaseClause(ByVal node As RelationalCaseClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIsKeyword = DirectCast(Visit(node.IsKeyword), KeywordSyntax)
            If node._isKeyword IsNot newIsKeyword Then anyChanges = True
            Dim newOperatorToken = DirectCast(Visit(node.OperatorToken), PunctuationSyntax)
            If node._operatorToken IsNot newOperatorToken Then anyChanges = True
            Dim newValue = DirectCast(Visit(node._value), ExpressionSyntax)
            If node._value IsNot newValue Then anyChanges = True

            If anyChanges Then
                Return New RelationalCaseClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIsKeyword, newOperatorToken, newValue)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSyncLockStatement(ByVal node As SyncLockStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newSyncLockKeyword = DirectCast(Visit(node.SyncLockKeyword), KeywordSyntax)
            If node._syncLockKeyword IsNot newSyncLockKeyword Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New SyncLockStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newSyncLockKeyword, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitDoLoopBlock(ByVal node As DoLoopBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newDoStatement = DirectCast(Visit(node._doStatement), DoStatementSyntax)
            If node._doStatement IsNot newDoStatement Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True
            Dim newLoopStatement = DirectCast(Visit(node._loopStatement), LoopStatementSyntax)
            If node._loopStatement IsNot newLoopStatement Then anyChanges = True

            If anyChanges Then
                Return New DoLoopBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newDoStatement, newStatements.Node, newLoopStatement)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitDoStatement(ByVal node As DoStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newDoKeyword = DirectCast(Visit(node.DoKeyword), KeywordSyntax)
            If node._doKeyword IsNot newDoKeyword Then anyChanges = True
            Dim newWhileOrUntilClause = DirectCast(Visit(node._whileOrUntilClause), WhileOrUntilClauseSyntax)
            If node._whileOrUntilClause IsNot newWhileOrUntilClause Then anyChanges = True

            If anyChanges Then
                Return New DoStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newDoKeyword, newWhileOrUntilClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitLoopStatement(ByVal node As LoopStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLoopKeyword = DirectCast(Visit(node.LoopKeyword), KeywordSyntax)
            If node._loopKeyword IsNot newLoopKeyword Then anyChanges = True
            Dim newWhileOrUntilClause = DirectCast(Visit(node._whileOrUntilClause), WhileOrUntilClauseSyntax)
            If node._whileOrUntilClause IsNot newWhileOrUntilClause Then anyChanges = True

            If anyChanges Then
                Return New LoopStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLoopKeyword, newWhileOrUntilClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitWhileOrUntilClause(ByVal node As WhileOrUntilClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newWhileOrUntilKeyword = DirectCast(Visit(node.WhileOrUntilKeyword), KeywordSyntax)
            If node._whileOrUntilKeyword IsNot newWhileOrUntilKeyword Then anyChanges = True
            Dim newCondition = DirectCast(Visit(node._condition), ExpressionSyntax)
            If node._condition IsNot newCondition Then anyChanges = True

            If anyChanges Then
                Return New WhileOrUntilClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newWhileOrUntilKeyword, newCondition)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitWhileStatement(ByVal node As WhileStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newWhileKeyword = DirectCast(Visit(node.WhileKeyword), KeywordSyntax)
            If node._whileKeyword IsNot newWhileKeyword Then anyChanges = True
            Dim newCondition = DirectCast(Visit(node._condition), ExpressionSyntax)
            If node._condition IsNot newCondition Then anyChanges = True

            If anyChanges Then
                Return New WhileStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newWhileKeyword, newCondition)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitForBlock(ByVal node As ForBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newForStatement = DirectCast(Visit(node._forStatement), ForStatementSyntax)
            If node._forStatement IsNot newForStatement Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True
            Dim newNextStatement = DirectCast(Visit(node._nextStatement), NextStatementSyntax)
            If node._nextStatement IsNot newNextStatement Then anyChanges = True

            If anyChanges Then
                Return New ForBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newForStatement, newStatements.Node, newNextStatement)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitForEachBlock(ByVal node As ForEachBlockSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newForEachStatement = DirectCast(Visit(node._forEachStatement), ForEachStatementSyntax)
            If node._forEachStatement IsNot newForEachStatement Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True
            Dim newNextStatement = DirectCast(Visit(node._nextStatement), NextStatementSyntax)
            If node._nextStatement IsNot newNextStatement Then anyChanges = True

            If anyChanges Then
                Return New ForEachBlockSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newForEachStatement, newStatements.Node, newNextStatement)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitForStatement(ByVal node As ForStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newForKeyword = DirectCast(Visit(node.ForKeyword), KeywordSyntax)
            If node._forKeyword IsNot newForKeyword Then anyChanges = True
            Dim newControlVariable = DirectCast(Visit(node._controlVariable), VisualBasicSyntaxNode)
            If node._controlVariable IsNot newControlVariable Then anyChanges = True
            Dim newEqualsToken = DirectCast(Visit(node.EqualsToken), PunctuationSyntax)
            If node._equalsToken IsNot newEqualsToken Then anyChanges = True
            Dim newFromValue = DirectCast(Visit(node._fromValue), ExpressionSyntax)
            If node._fromValue IsNot newFromValue Then anyChanges = True
            Dim newToKeyword = DirectCast(Visit(node.ToKeyword), KeywordSyntax)
            If node._toKeyword IsNot newToKeyword Then anyChanges = True
            Dim newToValue = DirectCast(Visit(node._toValue), ExpressionSyntax)
            If node._toValue IsNot newToValue Then anyChanges = True
            Dim newStepClause = DirectCast(Visit(node._stepClause), ForStepClauseSyntax)
            If node._stepClause IsNot newStepClause Then anyChanges = True

            If anyChanges Then
                Return New ForStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newForKeyword, newControlVariable, newEqualsToken, newFromValue, newToKeyword, newToValue, newStepClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitForStepClause(ByVal node As ForStepClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newStepKeyword = DirectCast(Visit(node.StepKeyword), KeywordSyntax)
            If node._stepKeyword IsNot newStepKeyword Then anyChanges = True
            Dim newStepValue = DirectCast(Visit(node._stepValue), ExpressionSyntax)
            If node._stepValue IsNot newStepValue Then anyChanges = True

            If anyChanges Then
                Return New ForStepClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newStepKeyword, newStepValue)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitForEachStatement(ByVal node As ForEachStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newForKeyword = DirectCast(Visit(node.ForKeyword), KeywordSyntax)
            If node._forKeyword IsNot newForKeyword Then anyChanges = True
            Dim newEachKeyword = DirectCast(Visit(node.EachKeyword), KeywordSyntax)
            If node._eachKeyword IsNot newEachKeyword Then anyChanges = True
            Dim newControlVariable = DirectCast(Visit(node._controlVariable), VisualBasicSyntaxNode)
            If node._controlVariable IsNot newControlVariable Then anyChanges = True
            Dim newInKeyword = DirectCast(Visit(node.InKeyword), KeywordSyntax)
            If node._inKeyword IsNot newInKeyword Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New ForEachStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newForKeyword, newEachKeyword, newControlVariable, newInKeyword, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitNextStatement(ByVal node As NextStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newNextKeyword = DirectCast(Visit(node.NextKeyword), KeywordSyntax)
            If node._nextKeyword IsNot newNextKeyword Then anyChanges = True
            Dim newControlVariables = VisitList(node.ControlVariables)
            If node._controlVariables IsNot newControlVariables.Node Then anyChanges = True

            If anyChanges Then
                Return New NextStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newNextKeyword, newControlVariables.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitUsingStatement(ByVal node As UsingStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newUsingKeyword = DirectCast(Visit(node.UsingKeyword), KeywordSyntax)
            If node._usingKeyword IsNot newUsingKeyword Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newVariables = VisitList(node.Variables)
            If node._variables IsNot newVariables.Node Then anyChanges = True

            If anyChanges Then
                Return New UsingStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newUsingKeyword, newExpression, newVariables.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitThrowStatement(ByVal node As ThrowStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newThrowKeyword = DirectCast(Visit(node.ThrowKeyword), KeywordSyntax)
            If node._throwKeyword IsNot newThrowKeyword Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New ThrowStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newThrowKeyword, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAssignmentStatement(ByVal node As AssignmentStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLeft = DirectCast(Visit(node._left), ExpressionSyntax)
            If node._left IsNot newLeft Then anyChanges = True
            Dim newOperatorToken = DirectCast(Visit(node.OperatorToken), PunctuationSyntax)
            If node._operatorToken IsNot newOperatorToken Then anyChanges = True
            Dim newRight = DirectCast(Visit(node._right), ExpressionSyntax)
            If node._right IsNot newRight Then anyChanges = True

            If anyChanges Then
                Return New AssignmentStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLeft, newOperatorToken, newRight)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitMidExpression(ByVal node As MidExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newMid = DirectCast(Visit(node.Mid), IdentifierTokenSyntax)
            If node._mid IsNot newMid Then anyChanges = True
            Dim newArgumentList = DirectCast(Visit(node._argumentList), ArgumentListSyntax)
            If node._argumentList IsNot newArgumentList Then anyChanges = True

            If anyChanges Then
                Return New MidExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newMid, newArgumentList)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCallStatement(ByVal node As CallStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newCallKeyword = DirectCast(Visit(node.CallKeyword), KeywordSyntax)
            If node._callKeyword IsNot newCallKeyword Then anyChanges = True
            Dim newInvocation = DirectCast(Visit(node._invocation), ExpressionSyntax)
            If node._invocation IsNot newInvocation Then anyChanges = True

            If anyChanges Then
                Return New CallStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newCallKeyword, newInvocation)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAddRemoveHandlerStatement(ByVal node As AddRemoveHandlerStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAddHandlerOrRemoveHandlerKeyword = DirectCast(Visit(node.AddHandlerOrRemoveHandlerKeyword), KeywordSyntax)
            If node._addHandlerOrRemoveHandlerKeyword IsNot newAddHandlerOrRemoveHandlerKeyword Then anyChanges = True
            Dim newEventExpression = DirectCast(Visit(node._eventExpression), ExpressionSyntax)
            If node._eventExpression IsNot newEventExpression Then anyChanges = True
            Dim newCommaToken = DirectCast(Visit(node.CommaToken), PunctuationSyntax)
            If node._commaToken IsNot newCommaToken Then anyChanges = True
            Dim newDelegateExpression = DirectCast(Visit(node._delegateExpression), ExpressionSyntax)
            If node._delegateExpression IsNot newDelegateExpression Then anyChanges = True

            If anyChanges Then
                Return New AddRemoveHandlerStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAddHandlerOrRemoveHandlerKeyword, newEventExpression, newCommaToken, newDelegateExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitRaiseEventStatement(ByVal node As RaiseEventStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newRaiseEventKeyword = DirectCast(Visit(node.RaiseEventKeyword), KeywordSyntax)
            If node._raiseEventKeyword IsNot newRaiseEventKeyword Then anyChanges = True
            Dim newName = DirectCast(Visit(node._name), IdentifierNameSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newArgumentList = DirectCast(Visit(node._argumentList), ArgumentListSyntax)
            If node._argumentList IsNot newArgumentList Then anyChanges = True

            If anyChanges Then
                Return New RaiseEventStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newRaiseEventKeyword, newName, newArgumentList)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitWithStatement(ByVal node As WithStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newWithKeyword = DirectCast(Visit(node.WithKeyword), KeywordSyntax)
            If node._withKeyword IsNot newWithKeyword Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New WithStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newWithKeyword, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitReDimStatement(ByVal node As ReDimStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newReDimKeyword = DirectCast(Visit(node.ReDimKeyword), KeywordSyntax)
            If node._reDimKeyword IsNot newReDimKeyword Then anyChanges = True
            Dim newPreserveKeyword = DirectCast(Visit(node.PreserveKeyword), KeywordSyntax)
            If node._preserveKeyword IsNot newPreserveKeyword Then anyChanges = True
            Dim newClauses = VisitList(node.Clauses)
            If node._clauses IsNot newClauses.Node Then anyChanges = True

            If anyChanges Then
                Return New ReDimStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newReDimKeyword, newPreserveKeyword, newClauses.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitRedimClause(ByVal node As RedimClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newArrayBounds = DirectCast(Visit(node._arrayBounds), ArgumentListSyntax)
            If node._arrayBounds IsNot newArrayBounds Then anyChanges = True

            If anyChanges Then
                Return New RedimClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newExpression, newArrayBounds)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitEraseStatement(ByVal node As EraseStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newEraseKeyword = DirectCast(Visit(node.EraseKeyword), KeywordSyntax)
            If node._eraseKeyword IsNot newEraseKeyword Then anyChanges = True
            Dim newExpressions = VisitList(node.Expressions)
            If node._expressions IsNot newExpressions.Node Then anyChanges = True

            If anyChanges Then
                Return New EraseStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newEraseKeyword, newExpressions.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitLiteralExpression(ByVal node As LiteralExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newToken = DirectCast(Visit(node.Token), SyntaxToken)
            If node._token IsNot newToken Then anyChanges = True

            If anyChanges Then
                Return New LiteralExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitParenthesizedExpression(ByVal node As ParenthesizedExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New ParenthesizedExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOpenParenToken, newExpression, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTupleExpression(ByVal node As TupleExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newArguments = VisitList(node.Arguments)
            If node._arguments IsNot newArguments.Node Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New TupleExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOpenParenToken, newArguments.Node, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTupleType(ByVal node As TupleTypeSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newElements = VisitList(node.Elements)
            If node._elements IsNot newElements.Node Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New TupleTypeSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOpenParenToken, newElements.Node, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTypedTupleElement(ByVal node As TypedTupleElementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newType = DirectCast(Visit(node._type), TypeSyntax)
            If node._type IsNot newType Then anyChanges = True

            If anyChanges Then
                Return New TypedTupleElementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newType)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitNamedTupleElement(ByVal node As NamedTupleElementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), SimpleAsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True

            If anyChanges Then
                Return New NamedTupleElementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIdentifier, newAsClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitMeExpression(ByVal node As MeExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True

            If anyChanges Then
                Return New MeExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitMyBaseExpression(ByVal node As MyBaseExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True

            If anyChanges Then
                Return New MyBaseExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitMyClassExpression(ByVal node As MyClassExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True

            If anyChanges Then
                Return New MyClassExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitGetTypeExpression(ByVal node As GetTypeExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newGetTypeKeyword = DirectCast(Visit(node.GetTypeKeyword), KeywordSyntax)
            If node._getTypeKeyword IsNot newGetTypeKeyword Then anyChanges = True
            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newType = DirectCast(Visit(node._type), TypeSyntax)
            If node._type IsNot newType Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New GetTypeExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newGetTypeKeyword, newOpenParenToken, newType, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTypeOfExpression(ByVal node As TypeOfExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newTypeOfKeyword = DirectCast(Visit(node.TypeOfKeyword), KeywordSyntax)
            If node._typeOfKeyword IsNot newTypeOfKeyword Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newOperatorToken = DirectCast(Visit(node.OperatorToken), KeywordSyntax)
            If node._operatorToken IsNot newOperatorToken Then anyChanges = True
            Dim newType = DirectCast(Visit(node._type), TypeSyntax)
            If node._type IsNot newType Then anyChanges = True

            If anyChanges Then
                Return New TypeOfExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newTypeOfKeyword, newExpression, newOperatorToken, newType)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitGetXmlNamespaceExpression(ByVal node As GetXmlNamespaceExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newGetXmlNamespaceKeyword = DirectCast(Visit(node.GetXmlNamespaceKeyword), KeywordSyntax)
            If node._getXmlNamespaceKeyword IsNot newGetXmlNamespaceKeyword Then anyChanges = True
            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newName = DirectCast(Visit(node._name), XmlPrefixNameSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New GetXmlNamespaceExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newGetXmlNamespaceKeyword, newOpenParenToken, newName, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitMemberAccessExpression(ByVal node As MemberAccessExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newOperatorToken = DirectCast(Visit(node.OperatorToken), PunctuationSyntax)
            If node._operatorToken IsNot newOperatorToken Then anyChanges = True
            Dim newName = DirectCast(Visit(node._name), SimpleNameSyntax)
            If node._name IsNot newName Then anyChanges = True

            If anyChanges Then
                Return New MemberAccessExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newExpression, newOperatorToken, newName)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlMemberAccessExpression(ByVal node As XmlMemberAccessExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBase = DirectCast(Visit(node._base), ExpressionSyntax)
            If node._base IsNot newBase Then anyChanges = True
            Dim newToken1 = DirectCast(Visit(node.Token1), PunctuationSyntax)
            If node._token1 IsNot newToken1 Then anyChanges = True
            Dim newToken2 = DirectCast(Visit(node.Token2), PunctuationSyntax)
            If node._token2 IsNot newToken2 Then anyChanges = True
            Dim newToken3 = DirectCast(Visit(node.Token3), PunctuationSyntax)
            If node._token3 IsNot newToken3 Then anyChanges = True
            Dim newName = DirectCast(Visit(node._name), XmlNodeSyntax)
            If node._name IsNot newName Then anyChanges = True

            If anyChanges Then
                Return New XmlMemberAccessExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBase, newToken1, newToken2, newToken3, newName)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitInvocationExpression(ByVal node As InvocationExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newArgumentList = DirectCast(Visit(node._argumentList), ArgumentListSyntax)
            If node._argumentList IsNot newArgumentList Then anyChanges = True

            If anyChanges Then
                Return New InvocationExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newExpression, newArgumentList)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitObjectCreationExpression(ByVal node As ObjectCreationExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newNewKeyword = DirectCast(Visit(node.NewKeyword), KeywordSyntax)
            If node._newKeyword IsNot newNewKeyword Then anyChanges = True
            Dim newAttributeLists = VisitList(node.AttributeLists)
            If node._attributeLists IsNot newAttributeLists.Node Then anyChanges = True
            Dim newType = DirectCast(Visit(node._type), TypeSyntax)
            If node._type IsNot newType Then anyChanges = True
            Dim newArgumentList = DirectCast(Visit(node._argumentList), ArgumentListSyntax)
            If node._argumentList IsNot newArgumentList Then anyChanges = True
            Dim newInitializer = DirectCast(Visit(node._initializer), ObjectCreationInitializerSyntax)
            If node._initializer IsNot newInitializer Then anyChanges = True

            If anyChanges Then
                Return New ObjectCreationExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newNewKeyword, newAttributeLists.Node, newType, newArgumentList, newInitializer)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAnonymousObjectCreationExpression(ByVal node As AnonymousObjectCreationExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newNewKeyword = DirectCast(Visit(node.NewKeyword), KeywordSyntax)
            If node._newKeyword IsNot newNewKeyword Then anyChanges = True
            Dim newAttributeLists = VisitList(node.AttributeLists)
            If node._attributeLists IsNot newAttributeLists.Node Then anyChanges = True
            Dim newInitializer = DirectCast(Visit(node._initializer), ObjectMemberInitializerSyntax)
            If node._initializer IsNot newInitializer Then anyChanges = True

            If anyChanges Then
                Return New AnonymousObjectCreationExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newNewKeyword, newAttributeLists.Node, newInitializer)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitArrayCreationExpression(ByVal node As ArrayCreationExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newNewKeyword = DirectCast(Visit(node.NewKeyword), KeywordSyntax)
            If node._newKeyword IsNot newNewKeyword Then anyChanges = True
            Dim newAttributeLists = VisitList(node.AttributeLists)
            If node._attributeLists IsNot newAttributeLists.Node Then anyChanges = True
            Dim newType = DirectCast(Visit(node._type), TypeSyntax)
            If node._type IsNot newType Then anyChanges = True
            Dim newArrayBounds = DirectCast(Visit(node._arrayBounds), ArgumentListSyntax)
            If node._arrayBounds IsNot newArrayBounds Then anyChanges = True
            Dim newRankSpecifiers = VisitList(node.RankSpecifiers)
            If node._rankSpecifiers IsNot newRankSpecifiers.Node Then anyChanges = True
            Dim newInitializer = DirectCast(Visit(node._initializer), CollectionInitializerSyntax)
            If node._initializer IsNot newInitializer Then anyChanges = True

            If anyChanges Then
                Return New ArrayCreationExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newNewKeyword, newAttributeLists.Node, newType, newArrayBounds, newRankSpecifiers.Node, newInitializer)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCollectionInitializer(ByVal node As CollectionInitializerSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOpenBraceToken = DirectCast(Visit(node.OpenBraceToken), PunctuationSyntax)
            If node._openBraceToken IsNot newOpenBraceToken Then anyChanges = True
            Dim newInitializers = VisitList(node.Initializers)
            If node._initializers IsNot newInitializers.Node Then anyChanges = True
            Dim newCloseBraceToken = DirectCast(Visit(node.CloseBraceToken), PunctuationSyntax)
            If node._closeBraceToken IsNot newCloseBraceToken Then anyChanges = True

            If anyChanges Then
                Return New CollectionInitializerSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOpenBraceToken, newInitializers.Node, newCloseBraceToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCTypeExpression(ByVal node As CTypeExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True
            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newCommaToken = DirectCast(Visit(node.CommaToken), PunctuationSyntax)
            If node._commaToken IsNot newCommaToken Then anyChanges = True
            Dim newType = DirectCast(Visit(node._type), TypeSyntax)
            If node._type IsNot newType Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New CTypeExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newKeyword, newOpenParenToken, newExpression, newCommaToken, newType, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitDirectCastExpression(ByVal node As DirectCastExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True
            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newCommaToken = DirectCast(Visit(node.CommaToken), PunctuationSyntax)
            If node._commaToken IsNot newCommaToken Then anyChanges = True
            Dim newType = DirectCast(Visit(node._type), TypeSyntax)
            If node._type IsNot newType Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New DirectCastExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newKeyword, newOpenParenToken, newExpression, newCommaToken, newType, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTryCastExpression(ByVal node As TryCastExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True
            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newCommaToken = DirectCast(Visit(node.CommaToken), PunctuationSyntax)
            If node._commaToken IsNot newCommaToken Then anyChanges = True
            Dim newType = DirectCast(Visit(node._type), TypeSyntax)
            If node._type IsNot newType Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New TryCastExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newKeyword, newOpenParenToken, newExpression, newCommaToken, newType, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitPredefinedCastExpression(ByVal node As PredefinedCastExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True
            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New PredefinedCastExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newKeyword, newOpenParenToken, newExpression, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitBinaryExpression(ByVal node As BinaryExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLeft = DirectCast(Visit(node._left), ExpressionSyntax)
            If node._left IsNot newLeft Then anyChanges = True
            Dim newOperatorToken = DirectCast(Visit(node.OperatorToken), SyntaxToken)
            If node._operatorToken IsNot newOperatorToken Then anyChanges = True
            Dim newRight = DirectCast(Visit(node._right), ExpressionSyntax)
            If node._right IsNot newRight Then anyChanges = True

            If anyChanges Then
                Return New BinaryExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLeft, newOperatorToken, newRight)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitUnaryExpression(ByVal node As UnaryExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOperatorToken = DirectCast(Visit(node.OperatorToken), SyntaxToken)
            If node._operatorToken IsNot newOperatorToken Then anyChanges = True
            Dim newOperand = DirectCast(Visit(node._operand), ExpressionSyntax)
            If node._operand IsNot newOperand Then anyChanges = True

            If anyChanges Then
                Return New UnaryExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOperatorToken, newOperand)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitBinaryConditionalExpression(ByVal node As BinaryConditionalExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIfKeyword = DirectCast(Visit(node.IfKeyword), KeywordSyntax)
            If node._ifKeyword IsNot newIfKeyword Then anyChanges = True
            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newFirstExpression = DirectCast(Visit(node._firstExpression), ExpressionSyntax)
            If node._firstExpression IsNot newFirstExpression Then anyChanges = True
            Dim newCommaToken = DirectCast(Visit(node.CommaToken), PunctuationSyntax)
            If node._commaToken IsNot newCommaToken Then anyChanges = True
            Dim newSecondExpression = DirectCast(Visit(node._secondExpression), ExpressionSyntax)
            If node._secondExpression IsNot newSecondExpression Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New BinaryConditionalExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIfKeyword, newOpenParenToken, newFirstExpression, newCommaToken, newSecondExpression, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTernaryConditionalExpression(ByVal node As TernaryConditionalExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIfKeyword = DirectCast(Visit(node.IfKeyword), KeywordSyntax)
            If node._ifKeyword IsNot newIfKeyword Then anyChanges = True
            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newCondition = DirectCast(Visit(node._condition), ExpressionSyntax)
            If node._condition IsNot newCondition Then anyChanges = True
            Dim newFirstCommaToken = DirectCast(Visit(node.FirstCommaToken), PunctuationSyntax)
            If node._firstCommaToken IsNot newFirstCommaToken Then anyChanges = True
            Dim newWhenTrue = DirectCast(Visit(node._whenTrue), ExpressionSyntax)
            If node._whenTrue IsNot newWhenTrue Then anyChanges = True
            Dim newSecondCommaToken = DirectCast(Visit(node.SecondCommaToken), PunctuationSyntax)
            If node._secondCommaToken IsNot newSecondCommaToken Then anyChanges = True
            Dim newWhenFalse = DirectCast(Visit(node._whenFalse), ExpressionSyntax)
            If node._whenFalse IsNot newWhenFalse Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New TernaryConditionalExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIfKeyword, newOpenParenToken, newCondition, newFirstCommaToken, newWhenTrue, newSecondCommaToken, newWhenFalse, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSingleLineLambdaExpression(ByVal node As SingleLineLambdaExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newSubOrFunctionHeader = DirectCast(Visit(node._subOrFunctionHeader), LambdaHeaderSyntax)
            If node._subOrFunctionHeader IsNot newSubOrFunctionHeader Then anyChanges = True
            Dim newBody = DirectCast(Visit(node._body), VisualBasicSyntaxNode)
            If node._body IsNot newBody Then anyChanges = True

            If anyChanges Then
                Return New SingleLineLambdaExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newSubOrFunctionHeader, newBody)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitMultiLineLambdaExpression(ByVal node As MultiLineLambdaExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newSubOrFunctionHeader = DirectCast(Visit(node._subOrFunctionHeader), LambdaHeaderSyntax)
            If node._subOrFunctionHeader IsNot newSubOrFunctionHeader Then anyChanges = True
            Dim newStatements = VisitList(node.Statements)
            If node._statements IsNot newStatements.Node Then anyChanges = True
            Dim newEndSubOrFunctionStatement = DirectCast(Visit(node._endSubOrFunctionStatement), EndBlockStatementSyntax)
            If node._endSubOrFunctionStatement IsNot newEndSubOrFunctionStatement Then anyChanges = True

            If anyChanges Then
                Return New MultiLineLambdaExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newSubOrFunctionHeader, newStatements.Node, newEndSubOrFunctionStatement)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitLambdaHeader(ByVal node As LambdaHeaderSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAttributeLists = VisitList(node.AttributeLists)
            If node._attributeLists IsNot newAttributeLists.Node Then anyChanges = True
            Dim newModifiers = VisitList(node.Modifiers)
            If node._modifiers IsNot newModifiers.Node Then anyChanges = True
            Dim newSubOrFunctionKeyword = DirectCast(Visit(node.SubOrFunctionKeyword), KeywordSyntax)
            If node._subOrFunctionKeyword IsNot newSubOrFunctionKeyword Then anyChanges = True
            Dim newParameterList = DirectCast(Visit(node._parameterList), ParameterListSyntax)
            If node._parameterList IsNot newParameterList Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), SimpleAsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True

            If anyChanges Then
                Return New LambdaHeaderSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAttributeLists.Node, newModifiers.Node, newSubOrFunctionKeyword, newParameterList, newAsClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitArgumentList(ByVal node As ArgumentListSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newArguments = VisitList(node.Arguments)
            If node._arguments IsNot newArguments.Node Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New ArgumentListSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOpenParenToken, newArguments.Node, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitOmittedArgument(ByVal node As OmittedArgumentSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newEmpty = DirectCast(Visit(node.Empty), PunctuationSyntax)
            If node._empty IsNot newEmpty Then anyChanges = True

            If anyChanges Then
                Return New OmittedArgumentSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newEmpty)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSimpleArgument(ByVal node As SimpleArgumentSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newNameColonEquals = DirectCast(Visit(node._nameColonEquals), NameColonEqualsSyntax)
            If node._nameColonEquals IsNot newNameColonEquals Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New SimpleArgumentSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newNameColonEquals, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitNameColonEquals(ByVal node As NameColonEqualsSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newName = DirectCast(Visit(node._name), IdentifierNameSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newColonEqualsToken = DirectCast(Visit(node.ColonEqualsToken), PunctuationSyntax)
            If node._colonEqualsToken IsNot newColonEqualsToken Then anyChanges = True

            If anyChanges Then
                Return New NameColonEqualsSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newName, newColonEqualsToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitRangeArgument(ByVal node As RangeArgumentSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLowerBound = DirectCast(Visit(node._lowerBound), ExpressionSyntax)
            If node._lowerBound IsNot newLowerBound Then anyChanges = True
            Dim newToKeyword = DirectCast(Visit(node.ToKeyword), KeywordSyntax)
            If node._toKeyword IsNot newToKeyword Then anyChanges = True
            Dim newUpperBound = DirectCast(Visit(node._upperBound), ExpressionSyntax)
            If node._upperBound IsNot newUpperBound Then anyChanges = True

            If anyChanges Then
                Return New RangeArgumentSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLowerBound, newToKeyword, newUpperBound)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitQueryExpression(ByVal node As QueryExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newClauses = VisitList(node.Clauses)
            If node._clauses IsNot newClauses.Node Then anyChanges = True

            If anyChanges Then
                Return New QueryExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newClauses.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCollectionRangeVariable(ByVal node As CollectionRangeVariableSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIdentifier = DirectCast(Visit(node._identifier), ModifiedIdentifierSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), SimpleAsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True
            Dim newInKeyword = DirectCast(Visit(node.InKeyword), KeywordSyntax)
            If node._inKeyword IsNot newInKeyword Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New CollectionRangeVariableSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIdentifier, newAsClause, newInKeyword, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitExpressionRangeVariable(ByVal node As ExpressionRangeVariableSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newNameEquals = DirectCast(Visit(node._nameEquals), VariableNameEqualsSyntax)
            If node._nameEquals IsNot newNameEquals Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New ExpressionRangeVariableSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newNameEquals, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAggregationRangeVariable(ByVal node As AggregationRangeVariableSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newNameEquals = DirectCast(Visit(node._nameEquals), VariableNameEqualsSyntax)
            If node._nameEquals IsNot newNameEquals Then anyChanges = True
            Dim newAggregation = DirectCast(Visit(node._aggregation), AggregationSyntax)
            If node._aggregation IsNot newAggregation Then anyChanges = True

            If anyChanges Then
                Return New AggregationRangeVariableSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newNameEquals, newAggregation)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitVariableNameEquals(ByVal node As VariableNameEqualsSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIdentifier = DirectCast(Visit(node._identifier), ModifiedIdentifierSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), SimpleAsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True
            Dim newEqualsToken = DirectCast(Visit(node.EqualsToken), PunctuationSyntax)
            If node._equalsToken IsNot newEqualsToken Then anyChanges = True

            If anyChanges Then
                Return New VariableNameEqualsSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIdentifier, newAsClause, newEqualsToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitFunctionAggregation(ByVal node As FunctionAggregationSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newFunctionName = DirectCast(Visit(node.FunctionName), IdentifierTokenSyntax)
            If node._functionName IsNot newFunctionName Then anyChanges = True
            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newArgument = DirectCast(Visit(node._argument), ExpressionSyntax)
            If node._argument IsNot newArgument Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New FunctionAggregationSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newFunctionName, newOpenParenToken, newArgument, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitGroupAggregation(ByVal node As GroupAggregationSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newGroupKeyword = DirectCast(Visit(node.GroupKeyword), KeywordSyntax)
            If node._groupKeyword IsNot newGroupKeyword Then anyChanges = True

            If anyChanges Then
                Return New GroupAggregationSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newGroupKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitFromClause(ByVal node As FromClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newFromKeyword = DirectCast(Visit(node.FromKeyword), KeywordSyntax)
            If node._fromKeyword IsNot newFromKeyword Then anyChanges = True
            Dim newVariables = VisitList(node.Variables)
            If node._variables IsNot newVariables.Node Then anyChanges = True

            If anyChanges Then
                Return New FromClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newFromKeyword, newVariables.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitLetClause(ByVal node As LetClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLetKeyword = DirectCast(Visit(node.LetKeyword), KeywordSyntax)
            If node._letKeyword IsNot newLetKeyword Then anyChanges = True
            Dim newVariables = VisitList(node.Variables)
            If node._variables IsNot newVariables.Node Then anyChanges = True

            If anyChanges Then
                Return New LetClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLetKeyword, newVariables.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAggregateClause(ByVal node As AggregateClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAggregateKeyword = DirectCast(Visit(node.AggregateKeyword), KeywordSyntax)
            If node._aggregateKeyword IsNot newAggregateKeyword Then anyChanges = True
            Dim newVariables = VisitList(node.Variables)
            If node._variables IsNot newVariables.Node Then anyChanges = True
            Dim newAdditionalQueryOperators = VisitList(node.AdditionalQueryOperators)
            If node._additionalQueryOperators IsNot newAdditionalQueryOperators.Node Then anyChanges = True
            Dim newIntoKeyword = DirectCast(Visit(node.IntoKeyword), KeywordSyntax)
            If node._intoKeyword IsNot newIntoKeyword Then anyChanges = True
            Dim newAggregationVariables = VisitList(node.AggregationVariables)
            If node._aggregationVariables IsNot newAggregationVariables.Node Then anyChanges = True

            If anyChanges Then
                Return New AggregateClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAggregateKeyword, newVariables.Node, newAdditionalQueryOperators.Node, newIntoKeyword, newAggregationVariables.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitDistinctClause(ByVal node As DistinctClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newDistinctKeyword = DirectCast(Visit(node.DistinctKeyword), KeywordSyntax)
            If node._distinctKeyword IsNot newDistinctKeyword Then anyChanges = True

            If anyChanges Then
                Return New DistinctClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newDistinctKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitWhereClause(ByVal node As WhereClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newWhereKeyword = DirectCast(Visit(node.WhereKeyword), KeywordSyntax)
            If node._whereKeyword IsNot newWhereKeyword Then anyChanges = True
            Dim newCondition = DirectCast(Visit(node._condition), ExpressionSyntax)
            If node._condition IsNot newCondition Then anyChanges = True

            If anyChanges Then
                Return New WhereClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newWhereKeyword, newCondition)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitPartitionWhileClause(ByVal node As PartitionWhileClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newSkipOrTakeKeyword = DirectCast(Visit(node.SkipOrTakeKeyword), KeywordSyntax)
            If node._skipOrTakeKeyword IsNot newSkipOrTakeKeyword Then anyChanges = True
            Dim newWhileKeyword = DirectCast(Visit(node.WhileKeyword), KeywordSyntax)
            If node._whileKeyword IsNot newWhileKeyword Then anyChanges = True
            Dim newCondition = DirectCast(Visit(node._condition), ExpressionSyntax)
            If node._condition IsNot newCondition Then anyChanges = True

            If anyChanges Then
                Return New PartitionWhileClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newSkipOrTakeKeyword, newWhileKeyword, newCondition)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitPartitionClause(ByVal node As PartitionClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newSkipOrTakeKeyword = DirectCast(Visit(node.SkipOrTakeKeyword), KeywordSyntax)
            If node._skipOrTakeKeyword IsNot newSkipOrTakeKeyword Then anyChanges = True
            Dim newCount = DirectCast(Visit(node._count), ExpressionSyntax)
            If node._count IsNot newCount Then anyChanges = True

            If anyChanges Then
                Return New PartitionClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newSkipOrTakeKeyword, newCount)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitGroupByClause(ByVal node As GroupByClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newGroupKeyword = DirectCast(Visit(node.GroupKeyword), KeywordSyntax)
            If node._groupKeyword IsNot newGroupKeyword Then anyChanges = True
            Dim newItems = VisitList(node.Items)
            If node._items IsNot newItems.Node Then anyChanges = True
            Dim newByKeyword = DirectCast(Visit(node.ByKeyword), KeywordSyntax)
            If node._byKeyword IsNot newByKeyword Then anyChanges = True
            Dim newKeys = VisitList(node.Keys)
            If node._keys IsNot newKeys.Node Then anyChanges = True
            Dim newIntoKeyword = DirectCast(Visit(node.IntoKeyword), KeywordSyntax)
            If node._intoKeyword IsNot newIntoKeyword Then anyChanges = True
            Dim newAggregationVariables = VisitList(node.AggregationVariables)
            If node._aggregationVariables IsNot newAggregationVariables.Node Then anyChanges = True

            If anyChanges Then
                Return New GroupByClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newGroupKeyword, newItems.Node, newByKeyword, newKeys.Node, newIntoKeyword, newAggregationVariables.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitJoinCondition(ByVal node As JoinConditionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLeft = DirectCast(Visit(node._left), ExpressionSyntax)
            If node._left IsNot newLeft Then anyChanges = True
            Dim newEqualsKeyword = DirectCast(Visit(node.EqualsKeyword), KeywordSyntax)
            If node._equalsKeyword IsNot newEqualsKeyword Then anyChanges = True
            Dim newRight = DirectCast(Visit(node._right), ExpressionSyntax)
            If node._right IsNot newRight Then anyChanges = True

            If anyChanges Then
                Return New JoinConditionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLeft, newEqualsKeyword, newRight)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSimpleJoinClause(ByVal node As SimpleJoinClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newJoinKeyword = DirectCast(Visit(node.JoinKeyword), KeywordSyntax)
            If node._joinKeyword IsNot newJoinKeyword Then anyChanges = True
            Dim newJoinedVariables = VisitList(node.JoinedVariables)
            If node._joinedVariables IsNot newJoinedVariables.Node Then anyChanges = True
            Dim newAdditionalJoins = VisitList(node.AdditionalJoins)
            If node._additionalJoins IsNot newAdditionalJoins.Node Then anyChanges = True
            Dim newOnKeyword = DirectCast(Visit(node.OnKeyword), KeywordSyntax)
            If node._onKeyword IsNot newOnKeyword Then anyChanges = True
            Dim newJoinConditions = VisitList(node.JoinConditions)
            If node._joinConditions IsNot newJoinConditions.Node Then anyChanges = True

            If anyChanges Then
                Return New SimpleJoinClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newJoinKeyword, newJoinedVariables.Node, newAdditionalJoins.Node, newOnKeyword, newJoinConditions.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitGroupJoinClause(ByVal node As GroupJoinClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newGroupKeyword = DirectCast(Visit(node.GroupKeyword), KeywordSyntax)
            If node._groupKeyword IsNot newGroupKeyword Then anyChanges = True
            Dim newJoinKeyword = DirectCast(Visit(node.JoinKeyword), KeywordSyntax)
            If node._joinKeyword IsNot newJoinKeyword Then anyChanges = True
            Dim newJoinedVariables = VisitList(node.JoinedVariables)
            If node._joinedVariables IsNot newJoinedVariables.Node Then anyChanges = True
            Dim newAdditionalJoins = VisitList(node.AdditionalJoins)
            If node._additionalJoins IsNot newAdditionalJoins.Node Then anyChanges = True
            Dim newOnKeyword = DirectCast(Visit(node.OnKeyword), KeywordSyntax)
            If node._onKeyword IsNot newOnKeyword Then anyChanges = True
            Dim newJoinConditions = VisitList(node.JoinConditions)
            If node._joinConditions IsNot newJoinConditions.Node Then anyChanges = True
            Dim newIntoKeyword = DirectCast(Visit(node.IntoKeyword), KeywordSyntax)
            If node._intoKeyword IsNot newIntoKeyword Then anyChanges = True
            Dim newAggregationVariables = VisitList(node.AggregationVariables)
            If node._aggregationVariables IsNot newAggregationVariables.Node Then anyChanges = True

            If anyChanges Then
                Return New GroupJoinClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newGroupKeyword, newJoinKeyword, newJoinedVariables.Node, newAdditionalJoins.Node, newOnKeyword, newJoinConditions.Node, newIntoKeyword, newAggregationVariables.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitOrderByClause(ByVal node As OrderByClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOrderKeyword = DirectCast(Visit(node.OrderKeyword), KeywordSyntax)
            If node._orderKeyword IsNot newOrderKeyword Then anyChanges = True
            Dim newByKeyword = DirectCast(Visit(node.ByKeyword), KeywordSyntax)
            If node._byKeyword IsNot newByKeyword Then anyChanges = True
            Dim newOrderings = VisitList(node.Orderings)
            If node._orderings IsNot newOrderings.Node Then anyChanges = True

            If anyChanges Then
                Return New OrderByClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOrderKeyword, newByKeyword, newOrderings.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitOrdering(ByVal node As OrderingSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newAscendingOrDescendingKeyword = DirectCast(Visit(node.AscendingOrDescendingKeyword), KeywordSyntax)
            If node._ascendingOrDescendingKeyword IsNot newAscendingOrDescendingKeyword Then anyChanges = True

            If anyChanges Then
                Return New OrderingSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newExpression, newAscendingOrDescendingKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSelectClause(ByVal node As SelectClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newSelectKeyword = DirectCast(Visit(node.SelectKeyword), KeywordSyntax)
            If node._selectKeyword IsNot newSelectKeyword Then anyChanges = True
            Dim newVariables = VisitList(node.Variables)
            If node._variables IsNot newVariables.Node Then anyChanges = True

            If anyChanges Then
                Return New SelectClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newSelectKeyword, newVariables.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlDocument(ByVal node As XmlDocumentSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newDeclaration = DirectCast(Visit(node._declaration), XmlDeclarationSyntax)
            If node._declaration IsNot newDeclaration Then anyChanges = True
            Dim newPrecedingMisc = VisitList(node.PrecedingMisc)
            If node._precedingMisc IsNot newPrecedingMisc.Node Then anyChanges = True
            Dim newRoot = DirectCast(Visit(node._root), XmlNodeSyntax)
            If node._root IsNot newRoot Then anyChanges = True
            Dim newFollowingMisc = VisitList(node.FollowingMisc)
            If node._followingMisc IsNot newFollowingMisc.Node Then anyChanges = True

            If anyChanges Then
                Return New XmlDocumentSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newDeclaration, newPrecedingMisc.Node, newRoot, newFollowingMisc.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlDeclaration(ByVal node As XmlDeclarationSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLessThanQuestionToken = DirectCast(Visit(node.LessThanQuestionToken), PunctuationSyntax)
            If node._lessThanQuestionToken IsNot newLessThanQuestionToken Then anyChanges = True
            Dim newXmlKeyword = DirectCast(Visit(node.XmlKeyword), KeywordSyntax)
            If node._xmlKeyword IsNot newXmlKeyword Then anyChanges = True
            Dim newVersion = DirectCast(Visit(node._version), XmlDeclarationOptionSyntax)
            If node._version IsNot newVersion Then anyChanges = True
            Dim newEncoding = DirectCast(Visit(node._encoding), XmlDeclarationOptionSyntax)
            If node._encoding IsNot newEncoding Then anyChanges = True
            Dim newStandalone = DirectCast(Visit(node._standalone), XmlDeclarationOptionSyntax)
            If node._standalone IsNot newStandalone Then anyChanges = True
            Dim newQuestionGreaterThanToken = DirectCast(Visit(node.QuestionGreaterThanToken), PunctuationSyntax)
            If node._questionGreaterThanToken IsNot newQuestionGreaterThanToken Then anyChanges = True

            If anyChanges Then
                Return New XmlDeclarationSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLessThanQuestionToken, newXmlKeyword, newVersion, newEncoding, newStandalone, newQuestionGreaterThanToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlDeclarationOption(ByVal node As XmlDeclarationOptionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newName = DirectCast(Visit(node.Name), XmlNameTokenSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newEquals = DirectCast(Visit(node.Equals), PunctuationSyntax)
            If node._equals IsNot newEquals Then anyChanges = True
            Dim newValue = DirectCast(Visit(node._value), XmlStringSyntax)
            If node._value IsNot newValue Then anyChanges = True

            If anyChanges Then
                Return New XmlDeclarationOptionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newName, newEquals, newValue)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlElement(ByVal node As XmlElementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newStartTag = DirectCast(Visit(node._startTag), XmlElementStartTagSyntax)
            If node._startTag IsNot newStartTag Then anyChanges = True
            Dim newContent = VisitList(node.Content)
            If node._content IsNot newContent.Node Then anyChanges = True
            Dim newEndTag = DirectCast(Visit(node._endTag), XmlElementEndTagSyntax)
            If node._endTag IsNot newEndTag Then anyChanges = True

            If anyChanges Then
                Return New XmlElementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newStartTag, newContent.Node, newEndTag)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlText(ByVal node As XmlTextSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newTextTokens = VisitList(node.TextTokens)
            If node._textTokens IsNot newTextTokens.Node Then anyChanges = True

            If anyChanges Then
                Return New XmlTextSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newTextTokens.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlElementStartTag(ByVal node As XmlElementStartTagSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLessThanToken = DirectCast(Visit(node.LessThanToken), PunctuationSyntax)
            If node._lessThanToken IsNot newLessThanToken Then anyChanges = True
            Dim newName = DirectCast(Visit(node._name), XmlNodeSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newGreaterThanToken = DirectCast(Visit(node.GreaterThanToken), PunctuationSyntax)
            If node._greaterThanToken IsNot newGreaterThanToken Then anyChanges = True

            If anyChanges Then
                Return New XmlElementStartTagSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLessThanToken, newName, newAttributes.Node, newGreaterThanToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlElementEndTag(ByVal node As XmlElementEndTagSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLessThanSlashToken = DirectCast(Visit(node.LessThanSlashToken), PunctuationSyntax)
            If node._lessThanSlashToken IsNot newLessThanSlashToken Then anyChanges = True
            Dim newName = DirectCast(Visit(node._name), XmlNameSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newGreaterThanToken = DirectCast(Visit(node.GreaterThanToken), PunctuationSyntax)
            If node._greaterThanToken IsNot newGreaterThanToken Then anyChanges = True

            If anyChanges Then
                Return New XmlElementEndTagSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLessThanSlashToken, newName, newGreaterThanToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlEmptyElement(ByVal node As XmlEmptyElementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLessThanToken = DirectCast(Visit(node.LessThanToken), PunctuationSyntax)
            If node._lessThanToken IsNot newLessThanToken Then anyChanges = True
            Dim newName = DirectCast(Visit(node._name), XmlNodeSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newAttributes = VisitList(node.Attributes)
            If node._attributes IsNot newAttributes.Node Then anyChanges = True
            Dim newSlashGreaterThanToken = DirectCast(Visit(node.SlashGreaterThanToken), PunctuationSyntax)
            If node._slashGreaterThanToken IsNot newSlashGreaterThanToken Then anyChanges = True

            If anyChanges Then
                Return New XmlEmptyElementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLessThanToken, newName, newAttributes.Node, newSlashGreaterThanToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlAttribute(ByVal node As XmlAttributeSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newName = DirectCast(Visit(node._name), XmlNodeSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newEqualsToken = DirectCast(Visit(node.EqualsToken), PunctuationSyntax)
            If node._equalsToken IsNot newEqualsToken Then anyChanges = True
            Dim newValue = DirectCast(Visit(node._value), XmlNodeSyntax)
            If node._value IsNot newValue Then anyChanges = True

            If anyChanges Then
                Return New XmlAttributeSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newName, newEqualsToken, newValue)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlString(ByVal node As XmlStringSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newStartQuoteToken = DirectCast(Visit(node.StartQuoteToken), PunctuationSyntax)
            If node._startQuoteToken IsNot newStartQuoteToken Then anyChanges = True
            Dim newTextTokens = VisitList(node.TextTokens)
            If node._textTokens IsNot newTextTokens.Node Then anyChanges = True
            Dim newEndQuoteToken = DirectCast(Visit(node.EndQuoteToken), PunctuationSyntax)
            If node._endQuoteToken IsNot newEndQuoteToken Then anyChanges = True

            If anyChanges Then
                Return New XmlStringSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newStartQuoteToken, newTextTokens.Node, newEndQuoteToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlPrefixName(ByVal node As XmlPrefixNameSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newName = DirectCast(Visit(node.Name), XmlNameTokenSyntax)
            If node._name IsNot newName Then anyChanges = True

            If anyChanges Then
                Return New XmlPrefixNameSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newName)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlName(ByVal node As XmlNameSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newPrefix = DirectCast(Visit(node._prefix), XmlPrefixSyntax)
            If node._prefix IsNot newPrefix Then anyChanges = True
            Dim newLocalName = DirectCast(Visit(node.LocalName), XmlNameTokenSyntax)
            If node._localName IsNot newLocalName Then anyChanges = True

            If anyChanges Then
                Return New XmlNameSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newPrefix, newLocalName)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlBracketedName(ByVal node As XmlBracketedNameSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLessThanToken = DirectCast(Visit(node.LessThanToken), PunctuationSyntax)
            If node._lessThanToken IsNot newLessThanToken Then anyChanges = True
            Dim newName = DirectCast(Visit(node._name), XmlNameSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newGreaterThanToken = DirectCast(Visit(node.GreaterThanToken), PunctuationSyntax)
            If node._greaterThanToken IsNot newGreaterThanToken Then anyChanges = True

            If anyChanges Then
                Return New XmlBracketedNameSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLessThanToken, newName, newGreaterThanToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlPrefix(ByVal node As XmlPrefixSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newName = DirectCast(Visit(node.Name), XmlNameTokenSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newColonToken = DirectCast(Visit(node.ColonToken), PunctuationSyntax)
            If node._colonToken IsNot newColonToken Then anyChanges = True

            If anyChanges Then
                Return New XmlPrefixSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newName, newColonToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlComment(ByVal node As XmlCommentSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLessThanExclamationMinusMinusToken = DirectCast(Visit(node.LessThanExclamationMinusMinusToken), PunctuationSyntax)
            If node._lessThanExclamationMinusMinusToken IsNot newLessThanExclamationMinusMinusToken Then anyChanges = True
            Dim newTextTokens = VisitList(node.TextTokens)
            If node._textTokens IsNot newTextTokens.Node Then anyChanges = True
            Dim newMinusMinusGreaterThanToken = DirectCast(Visit(node.MinusMinusGreaterThanToken), PunctuationSyntax)
            If node._minusMinusGreaterThanToken IsNot newMinusMinusGreaterThanToken Then anyChanges = True

            If anyChanges Then
                Return New XmlCommentSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLessThanExclamationMinusMinusToken, newTextTokens.Node, newMinusMinusGreaterThanToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlProcessingInstruction(ByVal node As XmlProcessingInstructionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLessThanQuestionToken = DirectCast(Visit(node.LessThanQuestionToken), PunctuationSyntax)
            If node._lessThanQuestionToken IsNot newLessThanQuestionToken Then anyChanges = True
            Dim newName = DirectCast(Visit(node.Name), XmlNameTokenSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newTextTokens = VisitList(node.TextTokens)
            If node._textTokens IsNot newTextTokens.Node Then anyChanges = True
            Dim newQuestionGreaterThanToken = DirectCast(Visit(node.QuestionGreaterThanToken), PunctuationSyntax)
            If node._questionGreaterThanToken IsNot newQuestionGreaterThanToken Then anyChanges = True

            If anyChanges Then
                Return New XmlProcessingInstructionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLessThanQuestionToken, newName, newTextTokens.Node, newQuestionGreaterThanToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlCDataSection(ByVal node As XmlCDataSectionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newBeginCDataToken = DirectCast(Visit(node.BeginCDataToken), PunctuationSyntax)
            If node._beginCDataToken IsNot newBeginCDataToken Then anyChanges = True
            Dim newTextTokens = VisitList(node.TextTokens)
            If node._textTokens IsNot newTextTokens.Node Then anyChanges = True
            Dim newEndCDataToken = DirectCast(Visit(node.EndCDataToken), PunctuationSyntax)
            If node._endCDataToken IsNot newEndCDataToken Then anyChanges = True

            If anyChanges Then
                Return New XmlCDataSectionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newBeginCDataToken, newTextTokens.Node, newEndCDataToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlEmbeddedExpression(ByVal node As XmlEmbeddedExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLessThanPercentEqualsToken = DirectCast(Visit(node.LessThanPercentEqualsToken), PunctuationSyntax)
            If node._lessThanPercentEqualsToken IsNot newLessThanPercentEqualsToken Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newPercentGreaterThanToken = DirectCast(Visit(node.PercentGreaterThanToken), PunctuationSyntax)
            If node._percentGreaterThanToken IsNot newPercentGreaterThanToken Then anyChanges = True

            If anyChanges Then
                Return New XmlEmbeddedExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLessThanPercentEqualsToken, newExpression, newPercentGreaterThanToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitArrayType(ByVal node As ArrayTypeSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newElementType = DirectCast(Visit(node._elementType), TypeSyntax)
            If node._elementType IsNot newElementType Then anyChanges = True
            Dim newRankSpecifiers = VisitList(node.RankSpecifiers)
            If node._rankSpecifiers IsNot newRankSpecifiers.Node Then anyChanges = True

            If anyChanges Then
                Return New ArrayTypeSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newElementType, newRankSpecifiers.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitNullableType(ByVal node As NullableTypeSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newElementType = DirectCast(Visit(node._elementType), TypeSyntax)
            If node._elementType IsNot newElementType Then anyChanges = True
            Dim newQuestionMarkToken = DirectCast(Visit(node.QuestionMarkToken), PunctuationSyntax)
            If node._questionMarkToken IsNot newQuestionMarkToken Then anyChanges = True

            If anyChanges Then
                Return New NullableTypeSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newElementType, newQuestionMarkToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitPredefinedType(ByVal node As PredefinedTypeSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newKeyword = DirectCast(Visit(node.Keyword), KeywordSyntax)
            If node._keyword IsNot newKeyword Then anyChanges = True

            If anyChanges Then
                Return New PredefinedTypeSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitIdentifierName(ByVal node As IdentifierNameSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True

            If anyChanges Then
                Return New IdentifierNameSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIdentifier)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitGenericName(ByVal node As GenericNameSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newIdentifier = DirectCast(Visit(node.Identifier), IdentifierTokenSyntax)
            If node._identifier IsNot newIdentifier Then anyChanges = True
            Dim newTypeArgumentList = DirectCast(Visit(node._typeArgumentList), TypeArgumentListSyntax)
            If node._typeArgumentList IsNot newTypeArgumentList Then anyChanges = True

            If anyChanges Then
                Return New GenericNameSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newIdentifier, newTypeArgumentList)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitQualifiedName(ByVal node As QualifiedNameSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLeft = DirectCast(Visit(node._left), NameSyntax)
            If node._left IsNot newLeft Then anyChanges = True
            Dim newDotToken = DirectCast(Visit(node.DotToken), PunctuationSyntax)
            If node._dotToken IsNot newDotToken Then anyChanges = True
            Dim newRight = DirectCast(Visit(node._right), SimpleNameSyntax)
            If node._right IsNot newRight Then anyChanges = True

            If anyChanges Then
                Return New QualifiedNameSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLeft, newDotToken, newRight)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitGlobalName(ByVal node As GlobalNameSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newGlobalKeyword = DirectCast(Visit(node.GlobalKeyword), KeywordSyntax)
            If node._globalKeyword IsNot newGlobalKeyword Then anyChanges = True

            If anyChanges Then
                Return New GlobalNameSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newGlobalKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitTypeArgumentList(ByVal node As TypeArgumentListSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newOfKeyword = DirectCast(Visit(node.OfKeyword), KeywordSyntax)
            If node._ofKeyword IsNot newOfKeyword Then anyChanges = True
            Dim newArguments = VisitList(node.Arguments)
            If node._arguments IsNot newArguments.Node Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New TypeArgumentListSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOpenParenToken, newOfKeyword, newArguments.Node, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCrefReference(ByVal node As CrefReferenceSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newName = DirectCast(Visit(node._name), TypeSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newSignature = DirectCast(Visit(node._signature), CrefSignatureSyntax)
            If node._signature IsNot newSignature Then anyChanges = True
            Dim newAsClause = DirectCast(Visit(node._asClause), SimpleAsClauseSyntax)
            If node._asClause IsNot newAsClause Then anyChanges = True

            If anyChanges Then
                Return New CrefReferenceSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newName, newSignature, newAsClause)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCrefSignature(ByVal node As CrefSignatureSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newArgumentTypes = VisitList(node.ArgumentTypes)
            If node._argumentTypes IsNot newArgumentTypes.Node Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New CrefSignatureSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOpenParenToken, newArgumentTypes.Node, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCrefSignaturePart(ByVal node As CrefSignaturePartSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newModifier = DirectCast(Visit(node.Modifier), KeywordSyntax)
            If node._modifier IsNot newModifier Then anyChanges = True
            Dim newType = DirectCast(Visit(node._type), TypeSyntax)
            If node._type IsNot newType Then anyChanges = True

            If anyChanges Then
                Return New CrefSignaturePartSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newModifier, newType)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitCrefOperatorReference(ByVal node As CrefOperatorReferenceSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOperatorKeyword = DirectCast(Visit(node.OperatorKeyword), KeywordSyntax)
            If node._operatorKeyword IsNot newOperatorKeyword Then anyChanges = True
            Dim newOperatorToken = DirectCast(Visit(node.OperatorToken), SyntaxToken)
            If node._operatorToken IsNot newOperatorToken Then anyChanges = True

            If anyChanges Then
                Return New CrefOperatorReferenceSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOperatorKeyword, newOperatorToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitQualifiedCrefOperatorReference(ByVal node As QualifiedCrefOperatorReferenceSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newLeft = DirectCast(Visit(node._left), NameSyntax)
            If node._left IsNot newLeft Then anyChanges = True
            Dim newDotToken = DirectCast(Visit(node.DotToken), PunctuationSyntax)
            If node._dotToken IsNot newDotToken Then anyChanges = True
            Dim newRight = DirectCast(Visit(node._right), CrefOperatorReferenceSyntax)
            If node._right IsNot newRight Then anyChanges = True

            If anyChanges Then
                Return New QualifiedCrefOperatorReferenceSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newLeft, newDotToken, newRight)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitYieldStatement(ByVal node As YieldStatementSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newYieldKeyword = DirectCast(Visit(node.YieldKeyword), KeywordSyntax)
            If node._yieldKeyword IsNot newYieldKeyword Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New YieldStatementSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newYieldKeyword, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitAwaitExpression(ByVal node As AwaitExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newAwaitKeyword = DirectCast(Visit(node.AwaitKeyword), KeywordSyntax)
            If node._awaitKeyword IsNot newAwaitKeyword Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True

            If anyChanges Then
                Return New AwaitExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newAwaitKeyword, newExpression)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitSkippedTokensTrivia(ByVal node As SkippedTokensTriviaSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newTokens = VisitList(node.Tokens)
            If node._tokens IsNot newTokens.Node Then anyChanges = True

            If anyChanges Then
                Return New SkippedTokensTriviaSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newTokens.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitDocumentationCommentTrivia(ByVal node As DocumentationCommentTriviaSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newContent = VisitList(node.Content)
            If node._content IsNot newContent.Node Then anyChanges = True

            If anyChanges Then
                Return New DocumentationCommentTriviaSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newContent.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlCrefAttribute(ByVal node As XmlCrefAttributeSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newName = DirectCast(Visit(node._name), XmlNameSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newEqualsToken = DirectCast(Visit(node.EqualsToken), PunctuationSyntax)
            If node._equalsToken IsNot newEqualsToken Then anyChanges = True
            Dim newStartQuoteToken = DirectCast(Visit(node.StartQuoteToken), PunctuationSyntax)
            If node._startQuoteToken IsNot newStartQuoteToken Then anyChanges = True
            Dim newReference = DirectCast(Visit(node._reference), CrefReferenceSyntax)
            If node._reference IsNot newReference Then anyChanges = True
            Dim newEndQuoteToken = DirectCast(Visit(node.EndQuoteToken), PunctuationSyntax)
            If node._endQuoteToken IsNot newEndQuoteToken Then anyChanges = True

            If anyChanges Then
                Return New XmlCrefAttributeSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newName, newEqualsToken, newStartQuoteToken, newReference, newEndQuoteToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitXmlNameAttribute(ByVal node As XmlNameAttributeSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newName = DirectCast(Visit(node._name), XmlNameSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newEqualsToken = DirectCast(Visit(node.EqualsToken), PunctuationSyntax)
            If node._equalsToken IsNot newEqualsToken Then anyChanges = True
            Dim newStartQuoteToken = DirectCast(Visit(node.StartQuoteToken), PunctuationSyntax)
            If node._startQuoteToken IsNot newStartQuoteToken Then anyChanges = True
            Dim newReference = DirectCast(Visit(node._reference), IdentifierNameSyntax)
            If node._reference IsNot newReference Then anyChanges = True
            Dim newEndQuoteToken = DirectCast(Visit(node.EndQuoteToken), PunctuationSyntax)
            If node._endQuoteToken IsNot newEndQuoteToken Then anyChanges = True

            If anyChanges Then
                Return New XmlNameAttributeSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newName, newEqualsToken, newStartQuoteToken, newReference, newEndQuoteToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitConditionalAccessExpression(ByVal node As ConditionalAccessExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newQuestionMarkToken = DirectCast(Visit(node.QuestionMarkToken), PunctuationSyntax)
            If node._questionMarkToken IsNot newQuestionMarkToken Then anyChanges = True
            Dim newWhenNotNull = DirectCast(Visit(node._whenNotNull), ExpressionSyntax)
            If node._whenNotNull IsNot newWhenNotNull Then anyChanges = True

            If anyChanges Then
                Return New ConditionalAccessExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newExpression, newQuestionMarkToken, newWhenNotNull)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitNameOfExpression(ByVal node As NameOfExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newNameOfKeyword = DirectCast(Visit(node.NameOfKeyword), KeywordSyntax)
            If node._nameOfKeyword IsNot newNameOfKeyword Then anyChanges = True
            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newArgument = DirectCast(Visit(node._argument), ExpressionSyntax)
            If node._argument IsNot newArgument Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New NameOfExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newNameOfKeyword, newOpenParenToken, newArgument, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitInterpolatedStringExpression(ByVal node As InterpolatedStringExpressionSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newDollarSignDoubleQuoteToken = DirectCast(Visit(node.DollarSignDoubleQuoteToken), PunctuationSyntax)
            If node._dollarSignDoubleQuoteToken IsNot newDollarSignDoubleQuoteToken Then anyChanges = True
            Dim newContents = VisitList(node.Contents)
            If node._contents IsNot newContents.Node Then anyChanges = True
            Dim newDoubleQuoteToken = DirectCast(Visit(node.DoubleQuoteToken), PunctuationSyntax)
            If node._doubleQuoteToken IsNot newDoubleQuoteToken Then anyChanges = True

            If anyChanges Then
                Return New InterpolatedStringExpressionSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newDollarSignDoubleQuoteToken, newContents.Node, newDoubleQuoteToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitInterpolatedStringText(ByVal node As InterpolatedStringTextSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newTextToken = DirectCast(Visit(node.TextToken), InterpolatedStringTextTokenSyntax)
            If node._textToken IsNot newTextToken Then anyChanges = True

            If anyChanges Then
                Return New InterpolatedStringTextSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newTextToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitInterpolation(ByVal node As InterpolationSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newOpenBraceToken = DirectCast(Visit(node.OpenBraceToken), PunctuationSyntax)
            If node._openBraceToken IsNot newOpenBraceToken Then anyChanges = True
            Dim newExpression = DirectCast(Visit(node._expression), ExpressionSyntax)
            If node._expression IsNot newExpression Then anyChanges = True
            Dim newAlignmentClause = DirectCast(Visit(node._alignmentClause), InterpolationAlignmentClauseSyntax)
            If node._alignmentClause IsNot newAlignmentClause Then anyChanges = True
            Dim newFormatClause = DirectCast(Visit(node._formatClause), InterpolationFormatClauseSyntax)
            If node._formatClause IsNot newFormatClause Then anyChanges = True
            Dim newCloseBraceToken = DirectCast(Visit(node.CloseBraceToken), PunctuationSyntax)
            If node._closeBraceToken IsNot newCloseBraceToken Then anyChanges = True

            If anyChanges Then
                Return New InterpolationSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newOpenBraceToken, newExpression, newAlignmentClause, newFormatClause, newCloseBraceToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitInterpolationAlignmentClause(ByVal node As InterpolationAlignmentClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newCommaToken = DirectCast(Visit(node.CommaToken), PunctuationSyntax)
            If node._commaToken IsNot newCommaToken Then anyChanges = True
            Dim newValue = DirectCast(Visit(node._value), ExpressionSyntax)
            If node._value IsNot newValue Then anyChanges = True

            If anyChanges Then
                Return New InterpolationAlignmentClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newCommaToken, newValue)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitInterpolationFormatClause(ByVal node As InterpolationFormatClauseSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newColonToken = DirectCast(Visit(node.ColonToken), PunctuationSyntax)
            If node._colonToken IsNot newColonToken Then anyChanges = True
            Dim newFormatStringToken = DirectCast(Visit(node.FormatStringToken), InterpolatedStringTextTokenSyntax)
            If node._formatStringToken IsNot newFormatStringToken Then anyChanges = True

            If anyChanges Then
                Return New InterpolationFormatClauseSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newColonToken, newFormatStringToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitConstDirectiveTrivia(ByVal node As ConstDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True
            Dim newConstKeyword = DirectCast(Visit(node.ConstKeyword), KeywordSyntax)
            If node._constKeyword IsNot newConstKeyword Then anyChanges = True
            Dim newName = DirectCast(Visit(node.Name), IdentifierTokenSyntax)
            If node._name IsNot newName Then anyChanges = True
            Dim newEqualsToken = DirectCast(Visit(node.EqualsToken), PunctuationSyntax)
            If node._equalsToken IsNot newEqualsToken Then anyChanges = True
            Dim newValue = DirectCast(Visit(node._value), ExpressionSyntax)
            If node._value IsNot newValue Then anyChanges = True

            If anyChanges Then
                Return New ConstDirectiveTriviaSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken, newConstKeyword, newName, newEqualsToken, newValue)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitIfDirectiveTrivia(ByVal node As IfDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True
            Dim newElseKeyword = DirectCast(Visit(node.ElseKeyword), KeywordSyntax)
            If node._elseKeyword IsNot newElseKeyword Then anyChanges = True
            Dim newIfOrElseIfKeyword = DirectCast(Visit(node.IfOrElseIfKeyword), KeywordSyntax)
            If node._ifOrElseIfKeyword IsNot newIfOrElseIfKeyword Then anyChanges = True
            Dim newCondition = DirectCast(Visit(node._condition), ExpressionSyntax)
            If node._condition IsNot newCondition Then anyChanges = True
            Dim newThenKeyword = DirectCast(Visit(node.ThenKeyword), KeywordSyntax)
            If node._thenKeyword IsNot newThenKeyword Then anyChanges = True

            If anyChanges Then
                Return New IfDirectiveTriviaSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken, newElseKeyword, newIfOrElseIfKeyword, newCondition, newThenKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitElseDirectiveTrivia(ByVal node As ElseDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True
            Dim newElseKeyword = DirectCast(Visit(node.ElseKeyword), KeywordSyntax)
            If node._elseKeyword IsNot newElseKeyword Then anyChanges = True

            If anyChanges Then
                Return New ElseDirectiveTriviaSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken, newElseKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitEndIfDirectiveTrivia(ByVal node As EndIfDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True
            Dim newEndKeyword = DirectCast(Visit(node.EndKeyword), KeywordSyntax)
            If node._endKeyword IsNot newEndKeyword Then anyChanges = True
            Dim newIfKeyword = DirectCast(Visit(node.IfKeyword), KeywordSyntax)
            If node._ifKeyword IsNot newIfKeyword Then anyChanges = True

            If anyChanges Then
                Return New EndIfDirectiveTriviaSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken, newEndKeyword, newIfKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitRegionDirectiveTrivia(ByVal node As RegionDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True
            Dim newRegionKeyword = DirectCast(Visit(node.RegionKeyword), KeywordSyntax)
            If node._regionKeyword IsNot newRegionKeyword Then anyChanges = True
            Dim newName = DirectCast(Visit(node.Name), StringLiteralTokenSyntax)
            If node._name IsNot newName Then anyChanges = True

            If anyChanges Then
                Return New RegionDirectiveTriviaSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken, newRegionKeyword, newName)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitEndRegionDirectiveTrivia(ByVal node As EndRegionDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True
            Dim newEndKeyword = DirectCast(Visit(node.EndKeyword), KeywordSyntax)
            If node._endKeyword IsNot newEndKeyword Then anyChanges = True
            Dim newRegionKeyword = DirectCast(Visit(node.RegionKeyword), KeywordSyntax)
            If node._regionKeyword IsNot newRegionKeyword Then anyChanges = True

            If anyChanges Then
                Return New EndRegionDirectiveTriviaSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken, newEndKeyword, newRegionKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitExternalSourceDirectiveTrivia(ByVal node As ExternalSourceDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True
            Dim newExternalSourceKeyword = DirectCast(Visit(node.ExternalSourceKeyword), KeywordSyntax)
            If node._externalSourceKeyword IsNot newExternalSourceKeyword Then anyChanges = True
            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newExternalSource = DirectCast(Visit(node.ExternalSource), StringLiteralTokenSyntax)
            If node._externalSource IsNot newExternalSource Then anyChanges = True
            Dim newCommaToken = DirectCast(Visit(node.CommaToken), PunctuationSyntax)
            If node._commaToken IsNot newCommaToken Then anyChanges = True
            Dim newLineStart = DirectCast(Visit(node.LineStart), IntegerLiteralTokenSyntax)
            If node._lineStart IsNot newLineStart Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New ExternalSourceDirectiveTriviaSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken, newExternalSourceKeyword, newOpenParenToken, newExternalSource, newCommaToken, newLineStart, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitEndExternalSourceDirectiveTrivia(ByVal node As EndExternalSourceDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True
            Dim newEndKeyword = DirectCast(Visit(node.EndKeyword), KeywordSyntax)
            If node._endKeyword IsNot newEndKeyword Then anyChanges = True
            Dim newExternalSourceKeyword = DirectCast(Visit(node.ExternalSourceKeyword), KeywordSyntax)
            If node._externalSourceKeyword IsNot newExternalSourceKeyword Then anyChanges = True

            If anyChanges Then
                Return New EndExternalSourceDirectiveTriviaSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken, newEndKeyword, newExternalSourceKeyword)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitExternalChecksumDirectiveTrivia(ByVal node As ExternalChecksumDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True
            Dim newExternalChecksumKeyword = DirectCast(Visit(node.ExternalChecksumKeyword), KeywordSyntax)
            If node._externalChecksumKeyword IsNot newExternalChecksumKeyword Then anyChanges = True
            Dim newOpenParenToken = DirectCast(Visit(node.OpenParenToken), PunctuationSyntax)
            If node._openParenToken IsNot newOpenParenToken Then anyChanges = True
            Dim newExternalSource = DirectCast(Visit(node.ExternalSource), StringLiteralTokenSyntax)
            If node._externalSource IsNot newExternalSource Then anyChanges = True
            Dim newFirstCommaToken = DirectCast(Visit(node.FirstCommaToken), PunctuationSyntax)
            If node._firstCommaToken IsNot newFirstCommaToken Then anyChanges = True
            Dim newGuid = DirectCast(Visit(node.Guid), StringLiteralTokenSyntax)
            If node._guid IsNot newGuid Then anyChanges = True
            Dim newSecondCommaToken = DirectCast(Visit(node.SecondCommaToken), PunctuationSyntax)
            If node._secondCommaToken IsNot newSecondCommaToken Then anyChanges = True
            Dim newChecksum = DirectCast(Visit(node.Checksum), StringLiteralTokenSyntax)
            If node._checksum IsNot newChecksum Then anyChanges = True
            Dim newCloseParenToken = DirectCast(Visit(node.CloseParenToken), PunctuationSyntax)
            If node._closeParenToken IsNot newCloseParenToken Then anyChanges = True

            If anyChanges Then
                Return New ExternalChecksumDirectiveTriviaSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken, newExternalChecksumKeyword, newOpenParenToken, newExternalSource, newFirstCommaToken, newGuid, newSecondCommaToken, newChecksum, newCloseParenToken)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitEnableWarningDirectiveTrivia(ByVal node As EnableWarningDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True
            Dim newEnableKeyword = DirectCast(Visit(node.EnableKeyword), KeywordSyntax)
            If node._enableKeyword IsNot newEnableKeyword Then anyChanges = True
            Dim newWarningKeyword = DirectCast(Visit(node.WarningKeyword), KeywordSyntax)
            If node._warningKeyword IsNot newWarningKeyword Then anyChanges = True
            Dim newErrorCodes = VisitList(node.ErrorCodes)
            If node._errorCodes IsNot newErrorCodes.Node Then anyChanges = True

            If anyChanges Then
                Return New EnableWarningDirectiveTriviaSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken, newEnableKeyword, newWarningKeyword, newErrorCodes.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitDisableWarningDirectiveTrivia(ByVal node As DisableWarningDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True
            Dim newDisableKeyword = DirectCast(Visit(node.DisableKeyword), KeywordSyntax)
            If node._disableKeyword IsNot newDisableKeyword Then anyChanges = True
            Dim newWarningKeyword = DirectCast(Visit(node.WarningKeyword), KeywordSyntax)
            If node._warningKeyword IsNot newWarningKeyword Then anyChanges = True
            Dim newErrorCodes = VisitList(node.ErrorCodes)
            If node._errorCodes IsNot newErrorCodes.Node Then anyChanges = True

            If anyChanges Then
                Return New DisableWarningDirectiveTriviaSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken, newDisableKeyword, newWarningKeyword, newErrorCodes.Node)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitReferenceDirectiveTrivia(ByVal node As ReferenceDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True
            Dim newReferenceKeyword = DirectCast(Visit(node.ReferenceKeyword), KeywordSyntax)
            If node._referenceKeyword IsNot newReferenceKeyword Then anyChanges = True
            Dim newFile = DirectCast(Visit(node.File), StringLiteralTokenSyntax)
            If node._file IsNot newFile Then anyChanges = True

            If anyChanges Then
                Return New ReferenceDirectiveTriviaSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken, newReferenceKeyword, newFile)
            Else
                Return node
            End If
        End Function

        Public Overrides Function VisitBadDirectiveTrivia(ByVal node As BadDirectiveTriviaSyntax) As VisualBasicSyntaxNode
            Dim anyChanges As Boolean = False

            Dim newHashToken = DirectCast(Visit(node.HashToken), PunctuationSyntax)
            If node._hashToken IsNot newHashToken Then anyChanges = True

            If anyChanges Then
                Return New BadDirectiveTriviaSyntax(node.Kind, node.GetDiagnostics, node.GetAnnotations, newHashToken)
            Else
                Return node
            End If
        End Function

    End Class

End Namespace

Namespace Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax

    Friend Partial Class SyntaxFactory


        ''' <summary>
        ''' A class to represent an empty statement. This can occur when a colon is on a
        ''' line without anything else.
        ''' </summary>
        ''' <param name="empty">
        ''' An empty token because all non terminals must have a token.
        ''' </param>
        Friend Shared Function EmptyStatement(empty As PunctuationSyntax) As EmptyStatementSyntax
            Debug.Assert(empty IsNot Nothing AndAlso empty.Kind = SyntaxKind.EmptyToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EmptyStatement, empty, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EmptyStatementSyntax)
            End If

            Dim result = New EmptyStatementSyntax(SyntaxKind.EmptyStatement, empty)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndIfStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.IfKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndIfStatement, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndIfStatement, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndUsingStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.UsingKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndUsingStatement, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndUsingStatement, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndWithStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.WithKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndWithStatement, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndWithStatement, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndSelectStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.SelectKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndSelectStatement, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndSelectStatement, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndStructureStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.StructureKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndStructureStatement, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndStructureStatement, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndEnumStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.EnumKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndEnumStatement, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndEnumStatement, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndInterfaceStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.InterfaceKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndInterfaceStatement, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndInterfaceStatement, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndClassStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.ClassKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndClassStatement, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndClassStatement, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndModuleStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.ModuleKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndModuleStatement, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndModuleStatement, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndNamespaceStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.NamespaceKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndNamespaceStatement, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndNamespaceStatement, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndSubStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.SubKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndSubStatement, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndSubStatement, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndFunctionStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.FunctionKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndFunctionStatement, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndFunctionStatement, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndGetStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.GetKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndGetStatement, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndGetStatement, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndSetStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.SetKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndSetStatement, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndSetStatement, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndPropertyStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.PropertyKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndPropertyStatement, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndPropertyStatement, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndOperatorStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.OperatorKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndOperatorStatement, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndOperatorStatement, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndEventStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.EventKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndEventStatement, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndEventStatement, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndAddHandlerStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.AddHandlerKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndAddHandlerStatement, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndAddHandlerStatement, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndRemoveHandlerStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.RemoveHandlerKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndRemoveHandlerStatement, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndRemoveHandlerStatement, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndRaiseEventStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.RaiseEventKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndRaiseEventStatement, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndRaiseEventStatement, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndWhileStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.WhileKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndWhileStatement, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndWhileStatement, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndTryStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.TryKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndTryStatement, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndTryStatement, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndSyncLockStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.SyncLockKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndSyncLockStatement, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndSyncLockStatement, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' EndBlockStatementSyntax. One of EndIfStatement, EndUsingStatement,
        ''' EndWithStatement, EndSelectStatement, EndStructureStatement, EndEnumStatement,
        ''' EndInterfaceStatement, EndClassStatement, EndModuleStatement,
        ''' EndNamespaceStatement, EndSubStatement, EndFunctionStatement, EndGetStatement,
        ''' EndSetStatement, EndPropertyStatement, EndOperatorStatement, EndEventStatement,
        ''' EndAddHandlerStatement, EndRemoveHandlerStatement, EndRaiseEventStatement,
        ''' EndWhileStatement, EndTryStatement, EndSyncLockStatement.
        ''' </param>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Shared Function EndBlockStatement(kind As SyntaxKind, endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(SyntaxFacts.IsEndBlockStatement(kind))
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso SyntaxFacts.IsEndBlockStatementBlockKeyword(blockKeyword.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(kind, endKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(kind, endKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an entire source file of VB code.
        ''' </summary>
        ''' <param name="options">
        ''' Represents the list of Option statements at the beginning of a source file.
        ''' </param>
        ''' <param name="imports">
        ''' Represents the list of Imports statements at the beginning of a source file.
        ''' </param>
        ''' <param name="attributes">
        ''' Represents the list of AttributeStatements at the beginning of a source file
        ''' that contain the Assembly and Module attributes.
        ''' </param>
        ''' <param name="members">
        ''' Represents the members of the default namespace for this source file: all the
        ''' top-level type and namespace declarations in the file. May also contain
        ''' Statements that are not valid
        ''' </param>
        ''' <param name="endOfFileToken">
        ''' Represents the end of the source file. This token may have trivia (whitespace,
        ''' comments, ...) attached to it.
        ''' </param>
        Friend Shared Function CompilationUnit(options As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), [imports] As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), attributes As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), members As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endOfFileToken As PunctuationSyntax) As CompilationUnitSyntax
            Debug.Assert(endOfFileToken IsNot Nothing AndAlso endOfFileToken.Kind = SyntaxKind.EndOfFileToken)
            Return New CompilationUnitSyntax(SyntaxKind.CompilationUnit, options.Node, [imports].Node, attributes.Node, members.Node, endOfFileToken)
        End Function


        ''' <summary>
        ''' Represents an Option statement, such as "Option Strict On".
        ''' </summary>
        ''' <param name="optionKeyword">
        ''' The "Option" keyword.
        ''' </param>
        ''' <param name="nameKeyword">
        ''' The keyword that identifies the option being set: Explicit, Strict, Compare or
        ''' Infer.
        ''' </param>
        ''' <param name="valueKeyword">
        ''' The keyword that identifiers the value being set for the option: On, Off, Text
        ''' or Binary.
        ''' </param>
        Friend Shared Function OptionStatement(optionKeyword As KeywordSyntax, nameKeyword As KeywordSyntax, valueKeyword As KeywordSyntax) As OptionStatementSyntax
            Debug.Assert(optionKeyword IsNot Nothing AndAlso optionKeyword.Kind = SyntaxKind.OptionKeyword)
            Debug.Assert(nameKeyword IsNot Nothing AndAlso SyntaxFacts.IsOptionStatementNameKeyword(nameKeyword.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.OptionStatement, optionKeyword, nameKeyword, valueKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, OptionStatementSyntax)
            End If

            Dim result = New OptionStatementSyntax(SyntaxKind.OptionStatement, optionKeyword, nameKeyword, valueKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an Imports statement, which has one or more imports clauses.
        ''' </summary>
        ''' <param name="importsKeyword">
        ''' The "Imports" keyword.
        ''' </param>
        ''' <param name="importsClauses">
        ''' A list of one or more import clauses. Each clause is either an alias, namespace
        ''' or XML namespace import.
        ''' </param>
        Friend Shared Function ImportsStatement(importsKeyword As KeywordSyntax, importsClauses As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As ImportsStatementSyntax
            Debug.Assert(importsKeyword IsNot Nothing AndAlso importsKeyword.Kind = SyntaxKind.ImportsKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ImportsStatement, importsKeyword, importsClauses.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ImportsStatementSyntax)
            End If

            Dim result = New ImportsStatementSyntax(SyntaxKind.ImportsStatement, importsKeyword, importsClauses.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the clause of an Imports statement that imports all members of a
        ''' type or namespace or aliases a type or namespace.
        ''' </summary>
        ''' <param name="alias">
        ''' An optional alias for the namespace or type being imported.
        ''' </param>
        ''' <param name="name">
        ''' The namespace or type being imported.
        ''' </param>
        Friend Shared Function SimpleImportsClause([alias] As ImportAliasClauseSyntax, name As NameSyntax) As SimpleImportsClauseSyntax
            Debug.Assert(name IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.SimpleImportsClause, [alias], name, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SimpleImportsClauseSyntax)
            End If

            Dim result = New SimpleImportsClauseSyntax(SyntaxKind.SimpleImportsClause, [alias], name)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an alias identifier followed by an "=" token in an Imports clause.
        ''' </summary>
        ''' <param name="identifier">
        ''' The identifier being introduced.
        ''' </param>
        ''' <param name="equalsToken">
        ''' The "=" token.
        ''' </param>
        Friend Shared Function ImportAliasClause(identifier As IdentifierTokenSyntax, equalsToken As PunctuationSyntax) As ImportAliasClauseSyntax
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ImportAliasClause, identifier, equalsToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ImportAliasClauseSyntax)
            End If

            Dim result = New ImportAliasClauseSyntax(SyntaxKind.ImportAliasClause, identifier, equalsToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Defines a XML namespace for XML expressions.
        ''' </summary>
        ''' <param name="xmlNamespace">
        ''' Identifies the XML namespace alias and URI.
        ''' </param>
        Friend Shared Function XmlNamespaceImportsClause(lessThanToken As PunctuationSyntax, xmlNamespace As XmlAttributeSyntax, greaterThanToken As PunctuationSyntax) As XmlNamespaceImportsClauseSyntax
            Debug.Assert(lessThanToken IsNot Nothing AndAlso lessThanToken.Kind = SyntaxKind.LessThanToken)
            Debug.Assert(xmlNamespace IsNot Nothing)
            Debug.Assert(greaterThanToken IsNot Nothing AndAlso greaterThanToken.Kind = SyntaxKind.GreaterThanToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.XmlNamespaceImportsClause, lessThanToken, xmlNamespace, greaterThanToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlNamespaceImportsClauseSyntax)
            End If

            Dim result = New XmlNamespaceImportsClauseSyntax(SyntaxKind.XmlNamespaceImportsClause, lessThanToken, xmlNamespace, greaterThanToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Namespace statement, its contents and the End Namespace statement.
        ''' </summary>
        ''' <param name="namespaceStatement">
        ''' The statement that begins the NamespaceBlock.
        ''' </param>
        ''' <param name="members">
        ''' The declarations contained in the namespace statement.
        ''' </param>
        ''' <param name="endNamespaceStatement">
        ''' The End Namespace statement that ends the block.
        ''' </param>
        Friend Shared Function NamespaceBlock(namespaceStatement As NamespaceStatementSyntax, members As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endNamespaceStatement As EndBlockStatementSyntax) As NamespaceBlockSyntax
            Debug.Assert(namespaceStatement IsNot Nothing)
            Debug.Assert(endNamespaceStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.NamespaceBlock, namespaceStatement, members.Node, endNamespaceStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, NamespaceBlockSyntax)
            End If

            Dim result = New NamespaceBlockSyntax(SyntaxKind.NamespaceBlock, namespaceStatement, members.Node, endNamespaceStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the beginning statement of a namespace declaration. This node always
        ''' appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
        ''' </summary>
        ''' <param name="namespaceKeyword">
        ''' The "Namespace" keyword.
        ''' </param>
        ''' <param name="name">
        ''' A (possibly dotted) name denoting the namespace being declared.
        ''' </param>
        Friend Shared Function NamespaceStatement(namespaceKeyword As KeywordSyntax, name As NameSyntax) As NamespaceStatementSyntax
            Debug.Assert(namespaceKeyword IsNot Nothing AndAlso namespaceKeyword.Kind = SyntaxKind.NamespaceKeyword)
            Debug.Assert(name IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.NamespaceStatement, namespaceKeyword, name, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, NamespaceStatementSyntax)
            End If

            Dim result = New NamespaceStatementSyntax(SyntaxKind.NamespaceStatement, namespaceKeyword, name)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a declaration of Module, its contents and the End statement that
        ''' ends it.
        ''' </summary>
        ''' <param name="moduleStatement">
        ''' The "Module" statement that begins the block.
        ''' </param>
        ''' <param name="inherits">
        ''' A list of the Inherits declarations for the type.
        ''' </param>
        ''' <param name="implements">
        ''' A list of the Implements declarations for the type.
        ''' </param>
        ''' <param name="members">
        ''' The declarations contained in the type or module.
        ''' </param>
        ''' <param name="endModuleStatement">
        ''' The "End Module" statement that ends the block.
        ''' </param>
        Friend Shared Function ModuleBlock(moduleStatement As ModuleStatementSyntax, [inherits] As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), [implements] As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), members As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endModuleStatement As EndBlockStatementSyntax) As ModuleBlockSyntax
            Debug.Assert(moduleStatement IsNot Nothing)
            Debug.Assert(endModuleStatement IsNot Nothing)
            Return New ModuleBlockSyntax(SyntaxKind.ModuleBlock, moduleStatement, [inherits].Node, [implements].Node, members.Node, endModuleStatement)
        End Function


        ''' <summary>
        ''' Represents a declaration of a Structure, its contents and the End statement
        ''' that ends it.
        ''' </summary>
        ''' <param name="structureStatement">
        ''' The "Structure" statement that begins the block.
        ''' </param>
        ''' <param name="inherits">
        ''' A list of the Inherits declarations for the type.
        ''' </param>
        ''' <param name="implements">
        ''' A list of the Implements declarations for the type.
        ''' </param>
        ''' <param name="members">
        ''' The declarations contained in the type or module.
        ''' </param>
        ''' <param name="endStructureStatement">
        ''' The "End Structure" statement that ends the block.
        ''' </param>
        Friend Shared Function StructureBlock(structureStatement As StructureStatementSyntax, [inherits] As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), [implements] As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), members As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endStructureStatement As EndBlockStatementSyntax) As StructureBlockSyntax
            Debug.Assert(structureStatement IsNot Nothing)
            Debug.Assert(endStructureStatement IsNot Nothing)
            Return New StructureBlockSyntax(SyntaxKind.StructureBlock, structureStatement, [inherits].Node, [implements].Node, members.Node, endStructureStatement)
        End Function


        ''' <summary>
        ''' Represents a declaration of a Interface, its contents and the End statement
        ''' that ends it.
        ''' </summary>
        ''' <param name="interfaceStatement">
        ''' The "Interface" statement that begins the block.
        ''' </param>
        ''' <param name="inherits">
        ''' A list of the Inherits declarations for the type.
        ''' </param>
        ''' <param name="implements">
        ''' A list of the Implements declarations for the type.
        ''' </param>
        ''' <param name="members">
        ''' The declarations contained in the type or module.
        ''' </param>
        ''' <param name="endInterfaceStatement">
        ''' The "End Interface" statement that ends the block.
        ''' </param>
        Friend Shared Function InterfaceBlock(interfaceStatement As InterfaceStatementSyntax, [inherits] As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), [implements] As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), members As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endInterfaceStatement As EndBlockStatementSyntax) As InterfaceBlockSyntax
            Debug.Assert(interfaceStatement IsNot Nothing)
            Debug.Assert(endInterfaceStatement IsNot Nothing)
            Return New InterfaceBlockSyntax(SyntaxKind.InterfaceBlock, interfaceStatement, [inherits].Node, [implements].Node, members.Node, endInterfaceStatement)
        End Function


        ''' <summary>
        ''' Represents a declaration of a Class its contents and the End statement that
        ''' ends it.
        ''' </summary>
        ''' <param name="classStatement">
        ''' The "Class" statement that begins the block.
        ''' </param>
        ''' <param name="inherits">
        ''' A list of the Inherits declarations for the type.
        ''' </param>
        ''' <param name="implements">
        ''' A list of the Implements declarations for the type.
        ''' </param>
        ''' <param name="members">
        ''' The declarations contained in the type or module.
        ''' </param>
        ''' <param name="endClassStatement">
        ''' The "End Class" statement that ends the block.
        ''' </param>
        Friend Shared Function ClassBlock(classStatement As ClassStatementSyntax, [inherits] As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), [implements] As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), members As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endClassStatement As EndBlockStatementSyntax) As ClassBlockSyntax
            Debug.Assert(classStatement IsNot Nothing)
            Debug.Assert(endClassStatement IsNot Nothing)
            Return New ClassBlockSyntax(SyntaxKind.ClassBlock, classStatement, [inherits].Node, [implements].Node, members.Node, endClassStatement)
        End Function


        ''' <summary>
        ''' Represents a declaration of an Enum, its contents and the End Enum statement
        ''' that ends it.
        ''' </summary>
        ''' <param name="enumStatement">
        ''' The statement that begins the type or module.
        ''' </param>
        ''' <param name="members">
        ''' The declarations contained in the enumeration.
        ''' </param>
        ''' <param name="endEnumStatement">
        ''' The End XXX statement that ends the block.
        ''' </param>
        Friend Shared Function EnumBlock(enumStatement As EnumStatementSyntax, members As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endEnumStatement As EndBlockStatementSyntax) As EnumBlockSyntax
            Debug.Assert(enumStatement IsNot Nothing)
            Debug.Assert(endEnumStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EnumBlock, enumStatement, members.Node, endEnumStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EnumBlockSyntax)
            End If

            Dim result = New EnumBlockSyntax(SyntaxKind.EnumBlock, enumStatement, members.Node, endEnumStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an Inherits statement in a Class, Structure or Interface.
        ''' </summary>
        ''' <param name="inheritsKeyword">
        ''' The "Inherits" keyword.
        ''' </param>
        ''' <param name="types">
        ''' A list of the types being inherited.
        ''' </param>
        Friend Shared Function InheritsStatement(inheritsKeyword As KeywordSyntax, types As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As InheritsStatementSyntax
            Debug.Assert(inheritsKeyword IsNot Nothing AndAlso inheritsKeyword.Kind = SyntaxKind.InheritsKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.InheritsStatement, inheritsKeyword, types.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, InheritsStatementSyntax)
            End If

            Dim result = New InheritsStatementSyntax(SyntaxKind.InheritsStatement, inheritsKeyword, types.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an Implements statement in a Class or Structure.
        ''' </summary>
        ''' <param name="implementsKeyword">
        ''' The "Implements" keyword.
        ''' </param>
        ''' <param name="types">
        ''' A list of the types being implemented.
        ''' </param>
        Friend Shared Function ImplementsStatement(implementsKeyword As KeywordSyntax, types As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As ImplementsStatementSyntax
            Debug.Assert(implementsKeyword IsNot Nothing AndAlso implementsKeyword.Kind = SyntaxKind.ImplementsKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ImplementsStatement, implementsKeyword, types.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ImplementsStatementSyntax)
            End If

            Dim result = New ImplementsStatementSyntax(SyntaxKind.ImplementsStatement, implementsKeyword, types.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the beginning statement of a Module declaration. This node always
        ''' appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </param>
        ''' <param name="moduleKeyword">
        ''' The "Module" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the type being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic parameters for this type. If no
        ''' generic parameters were present, Nothing is returned.
        ''' </param>
        Friend Shared Function ModuleStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), moduleKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax) As ModuleStatementSyntax
            Debug.Assert(moduleKeyword IsNot Nothing AndAlso moduleKeyword.Kind = SyntaxKind.ModuleKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New ModuleStatementSyntax(SyntaxKind.ModuleStatement, attributeLists.Node, modifiers.Node, moduleKeyword, identifier, typeParameterList)
        End Function


        ''' <summary>
        ''' Represents the beginning statement of a Structure declaration. This node always
        ''' appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </param>
        ''' <param name="structureKeyword">
        ''' The "Structure" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the type being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic parameters for this type. If no
        ''' generic parameters were present, Nothing is returned.
        ''' </param>
        Friend Shared Function StructureStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), structureKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax) As StructureStatementSyntax
            Debug.Assert(structureKeyword IsNot Nothing AndAlso structureKeyword.Kind = SyntaxKind.StructureKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New StructureStatementSyntax(SyntaxKind.StructureStatement, attributeLists.Node, modifiers.Node, structureKeyword, identifier, typeParameterList)
        End Function


        ''' <summary>
        ''' Represents the beginning statement of a Interface declaration. This node always
        ''' appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </param>
        ''' <param name="interfaceKeyword">
        ''' The "Interface" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the type being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic parameters for this type. If no
        ''' generic parameters were present, Nothing is returned.
        ''' </param>
        Friend Shared Function InterfaceStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), interfaceKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax) As InterfaceStatementSyntax
            Debug.Assert(interfaceKeyword IsNot Nothing AndAlso interfaceKeyword.Kind = SyntaxKind.InterfaceKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New InterfaceStatementSyntax(SyntaxKind.InterfaceStatement, attributeLists.Node, modifiers.Node, interfaceKeyword, identifier, typeParameterList)
        End Function


        ''' <summary>
        ''' Represents the beginning statement of a Class declaration. This node always
        ''' appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </param>
        ''' <param name="classKeyword">
        ''' The "Class" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the type being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic parameters for this type. If no
        ''' generic parameters were present, Nothing is returned.
        ''' </param>
        Friend Shared Function ClassStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), classKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax) As ClassStatementSyntax
            Debug.Assert(classKeyword IsNot Nothing AndAlso classKeyword.Kind = SyntaxKind.ClassKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New ClassStatementSyntax(SyntaxKind.ClassStatement, attributeLists.Node, modifiers.Node, classKeyword, identifier, typeParameterList)
        End Function


        ''' <summary>
        ''' Represents the beginning statement of an Enum declaration. This node always
        ''' appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </param>
        ''' <param name="enumKeyword">
        ''' The "Enum" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the enum being declared.
        ''' </param>
        ''' <param name="underlyingType">
        ''' Optional "As XXX" clause describing the underlying type of the enumeration. If
        ''' no As clause was specified, Nothing is returned.
        ''' </param>
        Friend Shared Function EnumStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), enumKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, underlyingType As AsClauseSyntax) As EnumStatementSyntax
            Debug.Assert(enumKeyword IsNot Nothing AndAlso enumKeyword.Kind = SyntaxKind.EnumKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New EnumStatementSyntax(SyntaxKind.EnumStatement, attributeLists.Node, modifiers.Node, enumKeyword, identifier, underlyingType)
        End Function


        ''' <summary>
        ''' Represents the type parameter list in a declaration.
        ''' </summary>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="ofKeyword">
        ''' The "Of" keyword.
        ''' </param>
        ''' <param name="parameters">
        ''' A list of the type parameters. There must be at least one type parameter in the
        ''' list.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Shared Function TypeParameterList(openParenToken As PunctuationSyntax, ofKeyword As KeywordSyntax, parameters As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), closeParenToken As PunctuationSyntax) As TypeParameterListSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(ofKeyword IsNot Nothing AndAlso ofKeyword.Kind = SyntaxKind.OfKeyword)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New TypeParameterListSyntax(SyntaxKind.TypeParameterList, openParenToken, ofKeyword, parameters.Node, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents a type parameter on a generic type declaration.
        ''' </summary>
        ''' <param name="varianceKeyword">
        ''' Represents the "In" or "Out" variance keyword on a type parameter, if present.
        ''' If no variance modifier was present, Nothing is returned.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the type parameter
        ''' </param>
        ''' <param name="typeParameterConstraintClause">
        ''' The "As" keyword, if any type constraints were supplied. If no type constraints
        ''' were supplied, Nothing is returned.
        ''' </param>
        Friend Shared Function TypeParameter(varianceKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterConstraintClause As TypeParameterConstraintClauseSyntax) As TypeParameterSyntax
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.TypeParameter, varianceKeyword, identifier, typeParameterConstraintClause, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, TypeParameterSyntax)
            End If

            Dim result = New TypeParameterSyntax(SyntaxKind.TypeParameter, varianceKeyword, identifier, typeParameterConstraintClause)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' One of the type parameter constraints clauses. This represents a constraint
        ''' clause in the form of "As Constraint".
        ''' </summary>
        ''' <param name="asKeyword">
        ''' The "As" keyword, if any type constraints were supplied. If no type constraints
        ''' were supplied, Nothing is returned.
        ''' </param>
        ''' <param name="constraint">
        ''' A list of the supplied constraints. If no constraints were supplied, Nothing is
        ''' returned.
        ''' </param>
        Friend Shared Function TypeParameterSingleConstraintClause(asKeyword As KeywordSyntax, constraint As ConstraintSyntax) As TypeParameterSingleConstraintClauseSyntax
            Debug.Assert(asKeyword IsNot Nothing AndAlso asKeyword.Kind = SyntaxKind.AsKeyword)
            Debug.Assert(constraint IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.TypeParameterSingleConstraintClause, asKeyword, constraint, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, TypeParameterSingleConstraintClauseSyntax)
            End If

            Dim result = New TypeParameterSingleConstraintClauseSyntax(SyntaxKind.TypeParameterSingleConstraintClause, asKeyword, constraint)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' One of the type parameter constraints clauses. This represents a constraint
        ''' clause in the form of "As { Constraints }".
        ''' </summary>
        ''' <param name="asKeyword">
        ''' The "As" keyword.
        ''' </param>
        ''' <param name="openBraceToken">
        ''' The "{" token.
        ''' </param>
        ''' <param name="constraints">
        ''' A list of the supplied constraints. If no constraints were supplied, an empty
        ''' list is returned.
        ''' </param>
        ''' <param name="closeBraceToken">
        ''' The "}" token.
        ''' </param>
        Friend Shared Function TypeParameterMultipleConstraintClause(asKeyword As KeywordSyntax, openBraceToken As PunctuationSyntax, constraints As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), closeBraceToken As PunctuationSyntax) As TypeParameterMultipleConstraintClauseSyntax
            Debug.Assert(asKeyword IsNot Nothing AndAlso asKeyword.Kind = SyntaxKind.AsKeyword)
            Debug.Assert(openBraceToken IsNot Nothing AndAlso openBraceToken.Kind = SyntaxKind.OpenBraceToken)
            Debug.Assert(closeBraceToken IsNot Nothing AndAlso closeBraceToken.Kind = SyntaxKind.CloseBraceToken)
            Return New TypeParameterMultipleConstraintClauseSyntax(SyntaxKind.TypeParameterMultipleConstraintClause, asKeyword, openBraceToken, constraints.Node, closeBraceToken)
        End Function


        ''' <summary>
        ''' One of the special type parameter constraints: New, Class or Structure. Which
        ''' kind of special constraint it is can be obtained from the Kind property and is
        ''' one of: NewConstraint, ReferenceConstraint or ValueConstraint.
        ''' </summary>
        ''' <param name="constraintKeyword">
        ''' The "New", "Class" or "Structure" keyword that denotes the kind of special
        ''' constraint.
        ''' </param>
        Friend Shared Function NewConstraint(constraintKeyword As KeywordSyntax) As SpecialConstraintSyntax
            Debug.Assert(constraintKeyword IsNot Nothing AndAlso SyntaxFacts.IsSpecialConstraintConstraintKeyword(constraintKeyword.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.NewConstraint, constraintKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SpecialConstraintSyntax)
            End If

            Dim result = New SpecialConstraintSyntax(SyntaxKind.NewConstraint, constraintKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' One of the special type parameter constraints: New, Class or Structure. Which
        ''' kind of special constraint it is can be obtained from the Kind property and is
        ''' one of: NewConstraint, ReferenceConstraint or ValueConstraint.
        ''' </summary>
        ''' <param name="constraintKeyword">
        ''' The "New", "Class" or "Structure" keyword that denotes the kind of special
        ''' constraint.
        ''' </param>
        Friend Shared Function ClassConstraint(constraintKeyword As KeywordSyntax) As SpecialConstraintSyntax
            Debug.Assert(constraintKeyword IsNot Nothing AndAlso SyntaxFacts.IsSpecialConstraintConstraintKeyword(constraintKeyword.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ClassConstraint, constraintKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SpecialConstraintSyntax)
            End If

            Dim result = New SpecialConstraintSyntax(SyntaxKind.ClassConstraint, constraintKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' One of the special type parameter constraints: New, Class or Structure. Which
        ''' kind of special constraint it is can be obtained from the Kind property and is
        ''' one of: NewConstraint, ReferenceConstraint or ValueConstraint.
        ''' </summary>
        ''' <param name="constraintKeyword">
        ''' The "New", "Class" or "Structure" keyword that denotes the kind of special
        ''' constraint.
        ''' </param>
        Friend Shared Function StructureConstraint(constraintKeyword As KeywordSyntax) As SpecialConstraintSyntax
            Debug.Assert(constraintKeyword IsNot Nothing AndAlso SyntaxFacts.IsSpecialConstraintConstraintKeyword(constraintKeyword.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.StructureConstraint, constraintKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SpecialConstraintSyntax)
            End If

            Dim result = New SpecialConstraintSyntax(SyntaxKind.StructureConstraint, constraintKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' One of the special type parameter constraints: New, Class or Structure. Which
        ''' kind of special constraint it is can be obtained from the Kind property and is
        ''' one of: NewConstraint, ReferenceConstraint or ValueConstraint.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' SpecialConstraintSyntax. One of NewConstraint, ClassConstraint,
        ''' StructureConstraint.
        ''' </param>
        ''' <param name="constraintKeyword">
        ''' The "New", "Class" or "Structure" keyword that denotes the kind of special
        ''' constraint.
        ''' </param>
        Friend Shared Function SpecialConstraint(kind As SyntaxKind, constraintKeyword As KeywordSyntax) As SpecialConstraintSyntax
            Debug.Assert(SyntaxFacts.IsSpecialConstraint(kind))
            Debug.Assert(constraintKeyword IsNot Nothing AndAlso SyntaxFacts.IsSpecialConstraintConstraintKeyword(constraintKeyword.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(kind, constraintKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SpecialConstraintSyntax)
            End If

            Dim result = New SpecialConstraintSyntax(kind, constraintKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a type parameter constraint that is a type.
        ''' </summary>
        ''' <param name="type">
        ''' The type describing the constraint.
        ''' </param>
        Friend Shared Function TypeConstraint(type As TypeSyntax) As TypeConstraintSyntax
            Debug.Assert(type IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.TypeConstraint, type, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, TypeConstraintSyntax)
            End If

            Dim result = New TypeConstraintSyntax(SyntaxKind.TypeConstraint, type)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a name and value in an EnumDeclarationBlock.
        ''' </summary>
        ''' <param name="initializer">
        ''' An optional value for the enum member.
        ''' </param>
        Friend Shared Function EnumMemberDeclaration(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), identifier As IdentifierTokenSyntax, initializer As EqualsValueSyntax) As EnumMemberDeclarationSyntax
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EnumMemberDeclaration, attributeLists.Node, identifier, initializer, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EnumMemberDeclarationSyntax)
            End If

            Dim result = New EnumMemberDeclarationSyntax(SyntaxKind.EnumMemberDeclaration, attributeLists.Node, identifier, initializer)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Function or Sub block declaration: A declaration that has a
        ''' beginning declaration, a body of executable statements and an end statement.
        ''' </summary>
        ''' <param name="subOrFunctionStatement">
        ''' The "Sub" or "Function" statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="endSubOrFunctionStatement">
        ''' The "End Sub" or "End Function" statement that ends the block.
        ''' </param>
        Friend Shared Function SubBlock(subOrFunctionStatement As MethodStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endSubOrFunctionStatement As EndBlockStatementSyntax) As MethodBlockSyntax
            Debug.Assert(subOrFunctionStatement IsNot Nothing)
            Debug.Assert(endSubOrFunctionStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.SubBlock, subOrFunctionStatement, statements.Node, endSubOrFunctionStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MethodBlockSyntax)
            End If

            Dim result = New MethodBlockSyntax(SyntaxKind.SubBlock, subOrFunctionStatement, statements.Node, endSubOrFunctionStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Function or Sub block declaration: A declaration that has a
        ''' beginning declaration, a body of executable statements and an end statement.
        ''' </summary>
        ''' <param name="subOrFunctionStatement">
        ''' The "Sub" or "Function" statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="endSubOrFunctionStatement">
        ''' The "End Sub" or "End Function" statement that ends the block.
        ''' </param>
        Friend Shared Function FunctionBlock(subOrFunctionStatement As MethodStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endSubOrFunctionStatement As EndBlockStatementSyntax) As MethodBlockSyntax
            Debug.Assert(subOrFunctionStatement IsNot Nothing)
            Debug.Assert(endSubOrFunctionStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.FunctionBlock, subOrFunctionStatement, statements.Node, endSubOrFunctionStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MethodBlockSyntax)
            End If

            Dim result = New MethodBlockSyntax(SyntaxKind.FunctionBlock, subOrFunctionStatement, statements.Node, endSubOrFunctionStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Function or Sub block declaration: A declaration that has a
        ''' beginning declaration, a body of executable statements and an end statement.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of MethodBlockSyntax.
        ''' One of SubBlock, FunctionBlock.
        ''' </param>
        ''' <param name="subOrFunctionStatement">
        ''' The "Sub" or "Function" statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="endSubOrFunctionStatement">
        ''' The "End Sub" or "End Function" statement that ends the block.
        ''' </param>
        Friend Shared Function MethodBlock(kind As SyntaxKind, subOrFunctionStatement As MethodStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endSubOrFunctionStatement As EndBlockStatementSyntax) As MethodBlockSyntax
            Debug.Assert(SyntaxFacts.IsMethodBlock(kind))
            Debug.Assert(subOrFunctionStatement IsNot Nothing)
            Debug.Assert(endSubOrFunctionStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(kind, subOrFunctionStatement, statements.Node, endSubOrFunctionStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MethodBlockSyntax)
            End If

            Dim result = New MethodBlockSyntax(kind, subOrFunctionStatement, statements.Node, endSubOrFunctionStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a constructor block declaration: A declaration that has a beginning
        ''' declaration, a body of executable statements and an end statement.
        ''' </summary>
        ''' <param name="subNewStatement">
        ''' The "Sub New" statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="endSubStatement">
        ''' The "End Sub" statement that ends the block declaration.
        ''' </param>
        Friend Shared Function ConstructorBlock(subNewStatement As SubNewStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endSubStatement As EndBlockStatementSyntax) As ConstructorBlockSyntax
            Debug.Assert(subNewStatement IsNot Nothing)
            Debug.Assert(endSubStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ConstructorBlock, subNewStatement, statements.Node, endSubStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ConstructorBlockSyntax)
            End If

            Dim result = New ConstructorBlockSyntax(SyntaxKind.ConstructorBlock, subNewStatement, statements.Node, endSubStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an Operator block member declaration: A declaration that has a
        ''' beginning declaration, a body of executable statements and an end statement.
        ''' </summary>
        ''' <param name="operatorStatement">
        ''' The "Operator" statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="endOperatorStatement">
        ''' The "End Operator" statement that ends the block declaration.
        ''' </param>
        Friend Shared Function OperatorBlock(operatorStatement As OperatorStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endOperatorStatement As EndBlockStatementSyntax) As OperatorBlockSyntax
            Debug.Assert(operatorStatement IsNot Nothing)
            Debug.Assert(endOperatorStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.OperatorBlock, operatorStatement, statements.Node, endOperatorStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, OperatorBlockSyntax)
            End If

            Dim result = New OperatorBlockSyntax(SyntaxKind.OperatorBlock, operatorStatement, statements.Node, endOperatorStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an accessor block member declaration: A declaration that has a
        ''' beginning declaration, a body of executable statements and an end statement.
        ''' Examples include property accessors and custom event accessors.
        ''' </summary>
        ''' <param name="accessorStatement">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
        ''' begins the accessor block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="endAccessorStatement">
        ''' The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
        ''' RaiseEvent" statement that ends the accessor block.
        ''' </param>
        Friend Shared Function GetAccessorBlock(accessorStatement As AccessorStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endAccessorStatement As EndBlockStatementSyntax) As AccessorBlockSyntax
            Debug.Assert(accessorStatement IsNot Nothing)
            Debug.Assert(endAccessorStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.GetAccessorBlock, accessorStatement, statements.Node, endAccessorStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AccessorBlockSyntax)
            End If

            Dim result = New AccessorBlockSyntax(SyntaxKind.GetAccessorBlock, accessorStatement, statements.Node, endAccessorStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an accessor block member declaration: A declaration that has a
        ''' beginning declaration, a body of executable statements and an end statement.
        ''' Examples include property accessors and custom event accessors.
        ''' </summary>
        ''' <param name="accessorStatement">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
        ''' begins the accessor block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="endAccessorStatement">
        ''' The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
        ''' RaiseEvent" statement that ends the accessor block.
        ''' </param>
        Friend Shared Function SetAccessorBlock(accessorStatement As AccessorStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endAccessorStatement As EndBlockStatementSyntax) As AccessorBlockSyntax
            Debug.Assert(accessorStatement IsNot Nothing)
            Debug.Assert(endAccessorStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.SetAccessorBlock, accessorStatement, statements.Node, endAccessorStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AccessorBlockSyntax)
            End If

            Dim result = New AccessorBlockSyntax(SyntaxKind.SetAccessorBlock, accessorStatement, statements.Node, endAccessorStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an accessor block member declaration: A declaration that has a
        ''' beginning declaration, a body of executable statements and an end statement.
        ''' Examples include property accessors and custom event accessors.
        ''' </summary>
        ''' <param name="accessorStatement">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
        ''' begins the accessor block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="endAccessorStatement">
        ''' The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
        ''' RaiseEvent" statement that ends the accessor block.
        ''' </param>
        Friend Shared Function AddHandlerAccessorBlock(accessorStatement As AccessorStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endAccessorStatement As EndBlockStatementSyntax) As AccessorBlockSyntax
            Debug.Assert(accessorStatement IsNot Nothing)
            Debug.Assert(endAccessorStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.AddHandlerAccessorBlock, accessorStatement, statements.Node, endAccessorStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AccessorBlockSyntax)
            End If

            Dim result = New AccessorBlockSyntax(SyntaxKind.AddHandlerAccessorBlock, accessorStatement, statements.Node, endAccessorStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an accessor block member declaration: A declaration that has a
        ''' beginning declaration, a body of executable statements and an end statement.
        ''' Examples include property accessors and custom event accessors.
        ''' </summary>
        ''' <param name="accessorStatement">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
        ''' begins the accessor block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="endAccessorStatement">
        ''' The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
        ''' RaiseEvent" statement that ends the accessor block.
        ''' </param>
        Friend Shared Function RemoveHandlerAccessorBlock(accessorStatement As AccessorStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endAccessorStatement As EndBlockStatementSyntax) As AccessorBlockSyntax
            Debug.Assert(accessorStatement IsNot Nothing)
            Debug.Assert(endAccessorStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.RemoveHandlerAccessorBlock, accessorStatement, statements.Node, endAccessorStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AccessorBlockSyntax)
            End If

            Dim result = New AccessorBlockSyntax(SyntaxKind.RemoveHandlerAccessorBlock, accessorStatement, statements.Node, endAccessorStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an accessor block member declaration: A declaration that has a
        ''' beginning declaration, a body of executable statements and an end statement.
        ''' Examples include property accessors and custom event accessors.
        ''' </summary>
        ''' <param name="accessorStatement">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
        ''' begins the accessor block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="endAccessorStatement">
        ''' The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
        ''' RaiseEvent" statement that ends the accessor block.
        ''' </param>
        Friend Shared Function RaiseEventAccessorBlock(accessorStatement As AccessorStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endAccessorStatement As EndBlockStatementSyntax) As AccessorBlockSyntax
            Debug.Assert(accessorStatement IsNot Nothing)
            Debug.Assert(endAccessorStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.RaiseEventAccessorBlock, accessorStatement, statements.Node, endAccessorStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AccessorBlockSyntax)
            End If

            Dim result = New AccessorBlockSyntax(SyntaxKind.RaiseEventAccessorBlock, accessorStatement, statements.Node, endAccessorStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an accessor block member declaration: A declaration that has a
        ''' beginning declaration, a body of executable statements and an end statement.
        ''' Examples include property accessors and custom event accessors.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' AccessorBlockSyntax. One of GetAccessorBlock, SetAccessorBlock,
        ''' AddHandlerAccessorBlock, RemoveHandlerAccessorBlock, RaiseEventAccessorBlock.
        ''' </param>
        ''' <param name="accessorStatement">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
        ''' begins the accessor block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="endAccessorStatement">
        ''' The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
        ''' RaiseEvent" statement that ends the accessor block.
        ''' </param>
        Friend Shared Function AccessorBlock(kind As SyntaxKind, accessorStatement As AccessorStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endAccessorStatement As EndBlockStatementSyntax) As AccessorBlockSyntax
            Debug.Assert(SyntaxFacts.IsAccessorBlock(kind))
            Debug.Assert(accessorStatement IsNot Nothing)
            Debug.Assert(endAccessorStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(kind, accessorStatement, statements.Node, endAccessorStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AccessorBlockSyntax)
            End If

            Dim result = New AccessorBlockSyntax(kind, accessorStatement, statements.Node, endAccessorStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a block property declaration: A declaration that has a beginning
        ''' declaration, some get or set accessor blocks and an end statement.
        ''' </summary>
        ''' <param name="propertyStatement">
        ''' The property declaration that begins the block.
        ''' </param>
        ''' <param name="accessors">
        ''' The accessor blocks contained in the property, between the Property and the End
        ''' Property statements.
        ''' </param>
        ''' <param name="endPropertyStatement">
        ''' The End Property statement that ends the block.
        ''' </param>
        Friend Shared Function PropertyBlock(propertyStatement As PropertyStatementSyntax, accessors As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endPropertyStatement As EndBlockStatementSyntax) As PropertyBlockSyntax
            Debug.Assert(propertyStatement IsNot Nothing)
            Debug.Assert(endPropertyStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.PropertyBlock, propertyStatement, accessors.Node, endPropertyStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, PropertyBlockSyntax)
            End If

            Dim result = New PropertyBlockSyntax(SyntaxKind.PropertyBlock, propertyStatement, accessors.Node, endPropertyStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a custom event declaration: A declaration that has a beginning event
        ''' declaration, some accessor blocks and an end statement.
        ''' </summary>
        ''' <param name="eventStatement">
        ''' The event declaration that begins the block.
        ''' </param>
        ''' <param name="accessors">
        ''' The accessor blocks contained in the custom event declaration, between the
        ''' Event statement and the End Event statement.
        ''' </param>
        ''' <param name="endEventStatement">
        ''' The End Event statement that ends the block.
        ''' </param>
        Friend Shared Function EventBlock(eventStatement As EventStatementSyntax, accessors As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endEventStatement As EndBlockStatementSyntax) As EventBlockSyntax
            Debug.Assert(eventStatement IsNot Nothing)
            Debug.Assert(endEventStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EventBlock, eventStatement, accessors.Node, endEventStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EventBlockSyntax)
            End If

            Dim result = New EventBlockSyntax(SyntaxKind.EventBlock, eventStatement, accessors.Node, endEventStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the parameter list in a method declaration.
        ''' </summary>
        ''' <param name="openParenToken">
        ''' The "(" token that introduces the parameter list. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="parameters">
        ''' The list of parameters. If no parameter list was present, Nothing is returned.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token that concludes the parameter list. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        Friend Shared Function ParameterList(openParenToken As PunctuationSyntax, parameters As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), closeParenToken As PunctuationSyntax) As ParameterListSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ParameterListSyntax)
            End If

            Dim result = New ParameterListSyntax(SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The statement that declares a Sub or Function. If this method has a body, this
        ''' statement will be the Begin of a BlockStatement with
        ''' Kind=MethodDeclarationBlock, and the body of the method will be the Body of
        ''' that BlockStatement.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword that introduces this method declaration.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the method being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic type parameters for this method.
        ''' If no generic type parameters were present, Nothing is returned.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        ''' <param name="handlesClause">
        ''' If present, a Handles clause indicated the events that this method handles.
        ''' </param>
        ''' <param name="implementsClause">
        ''' If present, an Implements clause indicated the interface methods that this
        ''' method implements.
        ''' </param>
        Friend Shared Function SubStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), subOrFunctionKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax, handlesClause As HandlesClauseSyntax, implementsClause As ImplementsClauseSyntax) As MethodStatementSyntax
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso subOrFunctionKeyword.Kind = SyntaxKind.SubKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New MethodStatementSyntax(SyntaxKind.SubStatement, attributeLists.Node, modifiers.Node, subOrFunctionKeyword, identifier, typeParameterList, parameterList, asClause, handlesClause, implementsClause)
        End Function


        ''' <summary>
        ''' The statement that declares a Sub or Function. If this method has a body, this
        ''' statement will be the Begin of a BlockStatement with
        ''' Kind=MethodDeclarationBlock, and the body of the method will be the Body of
        ''' that BlockStatement.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword that introduces this method declaration.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the method being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic type parameters for this method.
        ''' If no generic type parameters were present, Nothing is returned.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        ''' <param name="handlesClause">
        ''' If present, a Handles clause indicated the events that this method handles.
        ''' </param>
        ''' <param name="implementsClause">
        ''' If present, an Implements clause indicated the interface methods that this
        ''' method implements.
        ''' </param>
        Friend Shared Function FunctionStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), subOrFunctionKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax, handlesClause As HandlesClauseSyntax, implementsClause As ImplementsClauseSyntax) As MethodStatementSyntax
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso subOrFunctionKeyword.Kind = SyntaxKind.FunctionKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New MethodStatementSyntax(SyntaxKind.FunctionStatement, attributeLists.Node, modifiers.Node, subOrFunctionKeyword, identifier, typeParameterList, parameterList, asClause, handlesClause, implementsClause)
        End Function


        ''' <summary>
        ''' The statement that declares a Sub or Function. If this method has a body, this
        ''' statement will be the Begin of a BlockStatement with
        ''' Kind=MethodDeclarationBlock, and the body of the method will be the Body of
        ''' that BlockStatement.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' MethodStatementSyntax. One of SubStatement, FunctionStatement.
        ''' </param>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword that introduces this method declaration.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the method being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic type parameters for this method.
        ''' If no generic type parameters were present, Nothing is returned.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        ''' <param name="handlesClause">
        ''' If present, a Handles clause indicated the events that this method handles.
        ''' </param>
        ''' <param name="implementsClause">
        ''' If present, an Implements clause indicated the interface methods that this
        ''' method implements.
        ''' </param>
        Friend Shared Function MethodStatement(kind As SyntaxKind, attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), subOrFunctionKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax, handlesClause As HandlesClauseSyntax, implementsClause As ImplementsClauseSyntax) As MethodStatementSyntax
            Debug.Assert(SyntaxFacts.IsMethodStatement(kind))
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso SyntaxFacts.IsMethodStatementSubOrFunctionKeyword(subOrFunctionKeyword.Kind))
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New MethodStatementSyntax(kind, attributeLists.Node, modifiers.Node, subOrFunctionKeyword, identifier, typeParameterList, parameterList, asClause, handlesClause, implementsClause)
        End Function


        ''' <summary>
        ''' A statement that declares a constructor. This statement will be the Begin of a
        ''' BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
        ''' will be the Body of that BlockStatement.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="subKeyword">
        ''' The "Sub" keyword.
        ''' </param>
        ''' <param name="newKeyword">
        ''' The "New" keyword in the constructor declaration.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        Friend Shared Function SubNewStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), subKeyword As KeywordSyntax, newKeyword As KeywordSyntax, parameterList As ParameterListSyntax) As SubNewStatementSyntax
            Debug.Assert(subKeyword IsNot Nothing AndAlso subKeyword.Kind = SyntaxKind.SubKeyword)
            Debug.Assert(newKeyword IsNot Nothing AndAlso newKeyword.Kind = SyntaxKind.NewKeyword)
            Return New SubNewStatementSyntax(SyntaxKind.SubNewStatement, attributeLists.Node, modifiers.Node, subKeyword, newKeyword, parameterList)
        End Function


        ''' <summary>
        ''' A Declare statement that declares an external DLL method.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="declareKeyword">
        ''' The "Declare" keyword.
        ''' </param>
        ''' <param name="charsetKeyword">
        ''' If present, the keyword that defines the string translation semantics of the
        ''' external method.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the method being declared.
        ''' </param>
        ''' <param name="libKeyword">
        ''' The "Lib" keyword.
        ''' </param>
        ''' <param name="libraryName">
        ''' The string literal with the library name.
        ''' </param>
        ''' <param name="aliasKeyword">
        ''' If present, the "Alias" keyword. If not present, returns Nothing.
        ''' </param>
        ''' <param name="aliasName">
        ''' The string literal with the alias. If not present, returns Nothing.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function DeclareSubStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), declareKeyword As KeywordSyntax, charsetKeyword As KeywordSyntax, subOrFunctionKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, libKeyword As KeywordSyntax, libraryName As LiteralExpressionSyntax, aliasKeyword As KeywordSyntax, aliasName As LiteralExpressionSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax) As DeclareStatementSyntax
            Debug.Assert(declareKeyword IsNot Nothing AndAlso declareKeyword.Kind = SyntaxKind.DeclareKeyword)
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso subOrFunctionKeyword.Kind = SyntaxKind.SubKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Debug.Assert(libKeyword IsNot Nothing AndAlso libKeyword.Kind = SyntaxKind.LibKeyword)
            Debug.Assert(libraryName IsNot Nothing)
            Return New DeclareStatementSyntax(SyntaxKind.DeclareSubStatement, attributeLists.Node, modifiers.Node, declareKeyword, charsetKeyword, subOrFunctionKeyword, identifier, libKeyword, libraryName, aliasKeyword, aliasName, parameterList, asClause)
        End Function


        ''' <summary>
        ''' A Declare statement that declares an external DLL method.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="declareKeyword">
        ''' The "Declare" keyword.
        ''' </param>
        ''' <param name="charsetKeyword">
        ''' If present, the keyword that defines the string translation semantics of the
        ''' external method.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the method being declared.
        ''' </param>
        ''' <param name="libKeyword">
        ''' The "Lib" keyword.
        ''' </param>
        ''' <param name="libraryName">
        ''' The string literal with the library name.
        ''' </param>
        ''' <param name="aliasKeyword">
        ''' If present, the "Alias" keyword. If not present, returns Nothing.
        ''' </param>
        ''' <param name="aliasName">
        ''' The string literal with the alias. If not present, returns Nothing.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function DeclareFunctionStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), declareKeyword As KeywordSyntax, charsetKeyword As KeywordSyntax, subOrFunctionKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, libKeyword As KeywordSyntax, libraryName As LiteralExpressionSyntax, aliasKeyword As KeywordSyntax, aliasName As LiteralExpressionSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax) As DeclareStatementSyntax
            Debug.Assert(declareKeyword IsNot Nothing AndAlso declareKeyword.Kind = SyntaxKind.DeclareKeyword)
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso subOrFunctionKeyword.Kind = SyntaxKind.FunctionKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Debug.Assert(libKeyword IsNot Nothing AndAlso libKeyword.Kind = SyntaxKind.LibKeyword)
            Debug.Assert(libraryName IsNot Nothing)
            Return New DeclareStatementSyntax(SyntaxKind.DeclareFunctionStatement, attributeLists.Node, modifiers.Node, declareKeyword, charsetKeyword, subOrFunctionKeyword, identifier, libKeyword, libraryName, aliasKeyword, aliasName, parameterList, asClause)
        End Function


        ''' <summary>
        ''' A Declare statement that declares an external DLL method.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' DeclareStatementSyntax. One of DeclareSubStatement, DeclareFunctionStatement.
        ''' </param>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="declareKeyword">
        ''' The "Declare" keyword.
        ''' </param>
        ''' <param name="charsetKeyword">
        ''' If present, the keyword that defines the string translation semantics of the
        ''' external method.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the method being declared.
        ''' </param>
        ''' <param name="libKeyword">
        ''' The "Lib" keyword.
        ''' </param>
        ''' <param name="libraryName">
        ''' The string literal with the library name.
        ''' </param>
        ''' <param name="aliasKeyword">
        ''' If present, the "Alias" keyword. If not present, returns Nothing.
        ''' </param>
        ''' <param name="aliasName">
        ''' The string literal with the alias. If not present, returns Nothing.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function DeclareStatement(kind As SyntaxKind, attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), declareKeyword As KeywordSyntax, charsetKeyword As KeywordSyntax, subOrFunctionKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, libKeyword As KeywordSyntax, libraryName As LiteralExpressionSyntax, aliasKeyword As KeywordSyntax, aliasName As LiteralExpressionSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax) As DeclareStatementSyntax
            Debug.Assert(SyntaxFacts.IsDeclareStatement(kind))
            Debug.Assert(declareKeyword IsNot Nothing AndAlso declareKeyword.Kind = SyntaxKind.DeclareKeyword)
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso SyntaxFacts.IsDeclareStatementSubOrFunctionKeyword(subOrFunctionKeyword.Kind))
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Debug.Assert(libKeyword IsNot Nothing AndAlso libKeyword.Kind = SyntaxKind.LibKeyword)
            Debug.Assert(libraryName IsNot Nothing)
            Return New DeclareStatementSyntax(kind, attributeLists.Node, modifiers.Node, declareKeyword, charsetKeyword, subOrFunctionKeyword, identifier, libKeyword, libraryName, aliasKeyword, aliasName, parameterList, asClause)
        End Function


        ''' <summary>
        ''' A statement that declares a delegate type.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="delegateKeyword">
        ''' The "Delegate" keyword.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the delegate being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic type parameters for this
        ''' delegate. If no generic type parameters were present, Nothing is returned.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function DelegateSubStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), delegateKeyword As KeywordSyntax, subOrFunctionKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax) As DelegateStatementSyntax
            Debug.Assert(delegateKeyword IsNot Nothing AndAlso delegateKeyword.Kind = SyntaxKind.DelegateKeyword)
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso subOrFunctionKeyword.Kind = SyntaxKind.SubKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New DelegateStatementSyntax(SyntaxKind.DelegateSubStatement, attributeLists.Node, modifiers.Node, delegateKeyword, subOrFunctionKeyword, identifier, typeParameterList, parameterList, asClause)
        End Function


        ''' <summary>
        ''' A statement that declares a delegate type.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="delegateKeyword">
        ''' The "Delegate" keyword.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the delegate being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic type parameters for this
        ''' delegate. If no generic type parameters were present, Nothing is returned.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function DelegateFunctionStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), delegateKeyword As KeywordSyntax, subOrFunctionKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax) As DelegateStatementSyntax
            Debug.Assert(delegateKeyword IsNot Nothing AndAlso delegateKeyword.Kind = SyntaxKind.DelegateKeyword)
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso subOrFunctionKeyword.Kind = SyntaxKind.FunctionKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New DelegateStatementSyntax(SyntaxKind.DelegateFunctionStatement, attributeLists.Node, modifiers.Node, delegateKeyword, subOrFunctionKeyword, identifier, typeParameterList, parameterList, asClause)
        End Function


        ''' <summary>
        ''' A statement that declares a delegate type.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' DelegateStatementSyntax. One of DelegateSubStatement,
        ''' DelegateFunctionStatement.
        ''' </param>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="delegateKeyword">
        ''' The "Delegate" keyword.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the delegate being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic type parameters for this
        ''' delegate. If no generic type parameters were present, Nothing is returned.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function DelegateStatement(kind As SyntaxKind, attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), delegateKeyword As KeywordSyntax, subOrFunctionKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax) As DelegateStatementSyntax
            Debug.Assert(SyntaxFacts.IsDelegateStatement(kind))
            Debug.Assert(delegateKeyword IsNot Nothing AndAlso delegateKeyword.Kind = SyntaxKind.DelegateKeyword)
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso SyntaxFacts.IsDelegateStatementSubOrFunctionKeyword(subOrFunctionKeyword.Kind))
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New DelegateStatementSyntax(kind, attributeLists.Node, modifiers.Node, delegateKeyword, subOrFunctionKeyword, identifier, typeParameterList, parameterList, asClause)
        End Function


        ''' <summary>
        ''' A statement that declares an event. If the event being declared is a custom
        ''' event, this statement will be the Begin of a PropertyOrEventBlock, and the
        ''' accessors will be part of the Accessors of that node.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="customKeyword">
        ''' The optional Custom keyword for custom event declarations.
        ''' </param>
        ''' <param name="eventKeyword">
        ''' The "Event" keyword that introduces this event declaration.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the event being declared.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        ''' <param name="implementsClause">
        ''' If present, an Implements clause indicates the interface methods that this
        ''' method implements.
        ''' </param>
        Friend Shared Function EventStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), customKeyword As KeywordSyntax, eventKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax, implementsClause As ImplementsClauseSyntax) As EventStatementSyntax
            Debug.Assert(eventKeyword IsNot Nothing AndAlso eventKeyword.Kind = SyntaxKind.EventKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New EventStatementSyntax(SyntaxKind.EventStatement, attributeLists.Node, modifiers.Node, customKeyword, eventKeyword, identifier, parameterList, asClause, implementsClause)
        End Function


        ''' <summary>
        ''' A statement that declares an operator. If this operator has a body, this
        ''' statement will be the Begin of a BlockStatement with
        ''' Kind=MethodDeclarationBlock, and the body of the method will be the Body of
        ''' that BlockStatement.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="operatorKeyword">
        ''' The "Operator" keyword that introduces this operator declaration.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator being defined.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function OperatorStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), operatorKeyword As KeywordSyntax, operatorToken As SyntaxToken, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax) As OperatorStatementSyntax
            Debug.Assert(operatorKeyword IsNot Nothing AndAlso operatorKeyword.Kind = SyntaxKind.OperatorKeyword)
            Debug.Assert(operatorToken IsNot Nothing AndAlso SyntaxFacts.IsOperatorStatementOperatorToken(operatorToken.Kind))
            Return New OperatorStatementSyntax(SyntaxKind.OperatorStatement, attributeLists.Node, modifiers.Node, operatorKeyword, operatorToken, parameterList, asClause)
        End Function


        ''' <summary>
        ''' Statement that declares a property. If this property has accessors declared,
        ''' this statement will be the Begin of a BlockNode, and the accessors will be the
        ''' Body of that node. Auto properties are property declarations without a
        ''' PropertyBlock.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="propertyKeyword">
        ''' The "Property" keyword that introduces this property declaration.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the property being declared.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        ''' <param name="initializer">
        ''' If present, an "= initial-value" clause describing the initial value of the
        ''' property.
        ''' </param>
        ''' <param name="implementsClause">
        ''' If present, an Implements clause indicated the interface methods that this
        ''' method implements.
        ''' </param>
        Friend Shared Function PropertyStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), propertyKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax, initializer As EqualsValueSyntax, implementsClause As ImplementsClauseSyntax) As PropertyStatementSyntax
            Debug.Assert(propertyKeyword IsNot Nothing AndAlso propertyKeyword.Kind = SyntaxKind.PropertyKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New PropertyStatementSyntax(SyntaxKind.PropertyStatement, attributeLists.Node, modifiers.Node, propertyKeyword, identifier, parameterList, asClause, initializer, implementsClause)
        End Function


        ''' <summary>
        ''' Represents a Get or Set accessor on a property declaration or an AddHandler,
        ''' RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
        ''' the node determines what kind of accessor this is. This statement is always the
        ''' Begin of a BlockNode, and the body of the accessor is the Body of that node.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="accessorKeyword">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
        ''' introduces this accessor declaration.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        Friend Shared Function GetAccessorStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), accessorKeyword As KeywordSyntax, parameterList As ParameterListSyntax) As AccessorStatementSyntax
            Debug.Assert(accessorKeyword IsNot Nothing AndAlso accessorKeyword.Kind = SyntaxKind.GetKeyword)
            Return New AccessorStatementSyntax(SyntaxKind.GetAccessorStatement, attributeLists.Node, modifiers.Node, accessorKeyword, parameterList)
        End Function


        ''' <summary>
        ''' Represents a Get or Set accessor on a property declaration or an AddHandler,
        ''' RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
        ''' the node determines what kind of accessor this is. This statement is always the
        ''' Begin of a BlockNode, and the body of the accessor is the Body of that node.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="accessorKeyword">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
        ''' introduces this accessor declaration.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        Friend Shared Function SetAccessorStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), accessorKeyword As KeywordSyntax, parameterList As ParameterListSyntax) As AccessorStatementSyntax
            Debug.Assert(accessorKeyword IsNot Nothing AndAlso accessorKeyword.Kind = SyntaxKind.SetKeyword)
            Return New AccessorStatementSyntax(SyntaxKind.SetAccessorStatement, attributeLists.Node, modifiers.Node, accessorKeyword, parameterList)
        End Function


        ''' <summary>
        ''' Represents a Get or Set accessor on a property declaration or an AddHandler,
        ''' RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
        ''' the node determines what kind of accessor this is. This statement is always the
        ''' Begin of a BlockNode, and the body of the accessor is the Body of that node.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="accessorKeyword">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
        ''' introduces this accessor declaration.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        Friend Shared Function AddHandlerAccessorStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), accessorKeyword As KeywordSyntax, parameterList As ParameterListSyntax) As AccessorStatementSyntax
            Debug.Assert(accessorKeyword IsNot Nothing AndAlso accessorKeyword.Kind = SyntaxKind.AddHandlerKeyword)
            Return New AccessorStatementSyntax(SyntaxKind.AddHandlerAccessorStatement, attributeLists.Node, modifiers.Node, accessorKeyword, parameterList)
        End Function


        ''' <summary>
        ''' Represents a Get or Set accessor on a property declaration or an AddHandler,
        ''' RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
        ''' the node determines what kind of accessor this is. This statement is always the
        ''' Begin of a BlockNode, and the body of the accessor is the Body of that node.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="accessorKeyword">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
        ''' introduces this accessor declaration.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        Friend Shared Function RemoveHandlerAccessorStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), accessorKeyword As KeywordSyntax, parameterList As ParameterListSyntax) As AccessorStatementSyntax
            Debug.Assert(accessorKeyword IsNot Nothing AndAlso accessorKeyword.Kind = SyntaxKind.RemoveHandlerKeyword)
            Return New AccessorStatementSyntax(SyntaxKind.RemoveHandlerAccessorStatement, attributeLists.Node, modifiers.Node, accessorKeyword, parameterList)
        End Function


        ''' <summary>
        ''' Represents a Get or Set accessor on a property declaration or an AddHandler,
        ''' RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
        ''' the node determines what kind of accessor this is. This statement is always the
        ''' Begin of a BlockNode, and the body of the accessor is the Body of that node.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="accessorKeyword">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
        ''' introduces this accessor declaration.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        Friend Shared Function RaiseEventAccessorStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), accessorKeyword As KeywordSyntax, parameterList As ParameterListSyntax) As AccessorStatementSyntax
            Debug.Assert(accessorKeyword IsNot Nothing AndAlso accessorKeyword.Kind = SyntaxKind.RaiseEventKeyword)
            Return New AccessorStatementSyntax(SyntaxKind.RaiseEventAccessorStatement, attributeLists.Node, modifiers.Node, accessorKeyword, parameterList)
        End Function


        ''' <summary>
        ''' Represents a Get or Set accessor on a property declaration or an AddHandler,
        ''' RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
        ''' the node determines what kind of accessor this is. This statement is always the
        ''' Begin of a BlockNode, and the body of the accessor is the Body of that node.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' AccessorStatementSyntax. One of GetAccessorStatement, SetAccessorStatement,
        ''' AddHandlerAccessorStatement, RemoveHandlerAccessorStatement,
        ''' RaiseEventAccessorStatement.
        ''' </param>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="accessorKeyword">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
        ''' introduces this accessor declaration.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        Friend Shared Function AccessorStatement(kind As SyntaxKind, attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), accessorKeyword As KeywordSyntax, parameterList As ParameterListSyntax) As AccessorStatementSyntax
            Debug.Assert(SyntaxFacts.IsAccessorStatement(kind))
            Debug.Assert(accessorKeyword IsNot Nothing AndAlso SyntaxFacts.IsAccessorStatementAccessorKeyword(accessorKeyword.Kind))
            Return New AccessorStatementSyntax(kind, attributeLists.Node, modifiers.Node, accessorKeyword, parameterList)
        End Function


        ''' <summary>
        ''' Represents the "Implements ..." clause on a type member, which describes which
        ''' interface members this member implements.
        ''' </summary>
        ''' <param name="implementsKeyword">
        ''' The "Implements" keyword.
        ''' </param>
        ''' <param name="interfaceMembers">
        ''' The list of interface members being implemented.
        ''' </param>
        Friend Shared Function ImplementsClause(implementsKeyword As KeywordSyntax, interfaceMembers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As ImplementsClauseSyntax
            Debug.Assert(implementsKeyword IsNot Nothing AndAlso implementsKeyword.Kind = SyntaxKind.ImplementsKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ImplementsClause, implementsKeyword, interfaceMembers.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ImplementsClauseSyntax)
            End If

            Dim result = New ImplementsClauseSyntax(SyntaxKind.ImplementsClause, implementsKeyword, interfaceMembers.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the "Handles ..." clause on a method declaration that describes
        ''' which events this method handles.
        ''' </summary>
        ''' <param name="handlesKeyword">
        ''' The "Handles" keyword.
        ''' </param>
        ''' <param name="events">
        ''' The list of event members being handled.
        ''' </param>
        Friend Shared Function HandlesClause(handlesKeyword As KeywordSyntax, events As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As HandlesClauseSyntax
            Debug.Assert(handlesKeyword IsNot Nothing AndAlso handlesKeyword.Kind = SyntaxKind.HandlesKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.HandlesClause, handlesKeyword, events.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, HandlesClauseSyntax)
            End If

            Dim result = New HandlesClauseSyntax(SyntaxKind.HandlesClause, handlesKeyword, events.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents event container specified through special keywords "Me", "MyBase" or
        ''' "MyClass"..
        ''' </summary>
        ''' <param name="keyword">
        ''' The container of the event. This can be one of the special keywords: "Me",
        ''' "MyBase" or "MyClass".
        ''' </param>
        Friend Shared Function KeywordEventContainer(keyword As KeywordSyntax) As KeywordEventContainerSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso SyntaxFacts.IsKeywordEventContainerKeyword(keyword.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.KeywordEventContainer, keyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, KeywordEventContainerSyntax)
            End If

            Dim result = New KeywordEventContainerSyntax(SyntaxKind.KeywordEventContainer, keyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents event container that refers to a WithEvents member.
        ''' </summary>
        ''' <param name="identifier">
        ''' The container of the event. It is a simple identifier that refers to a
        ''' WithEvents member of the containing type.
        ''' </param>
        Friend Shared Function WithEventsEventContainer(identifier As IdentifierTokenSyntax) As WithEventsEventContainerSyntax
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.WithEventsEventContainer, identifier, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, WithEventsEventContainerSyntax)
            End If

            Dim result = New WithEventsEventContainerSyntax(SyntaxKind.WithEventsEventContainer, identifier)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents event container that refers to a WithEvents member's property.
        ''' </summary>
        ''' <param name="withEventsContainer">
        ''' The container of the event.
        ''' </param>
        ''' <param name="dotToken">
        ''' The "." token.
        ''' </param>
        ''' <param name="property">
        ''' The provider of the event. It is a property of a WithEvents member of the
        ''' containing type.
        ''' </param>
        Friend Shared Function WithEventsPropertyEventContainer(withEventsContainer As WithEventsEventContainerSyntax, dotToken As PunctuationSyntax, [property] As IdentifierNameSyntax) As WithEventsPropertyEventContainerSyntax
            Debug.Assert(withEventsContainer IsNot Nothing)
            Debug.Assert(dotToken IsNot Nothing AndAlso dotToken.Kind = SyntaxKind.DotToken)
            Debug.Assert([property] IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.WithEventsPropertyEventContainer, withEventsContainer, dotToken, [property], hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, WithEventsPropertyEventContainerSyntax)
            End If

            Dim result = New WithEventsPropertyEventContainerSyntax(SyntaxKind.WithEventsPropertyEventContainer, withEventsContainer, dotToken, [property])
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a single handled event in a "Handles ..." clause.
        ''' </summary>
        ''' <param name="eventContainer">
        ''' The container of the event. This can either be a simple identifier (identifying
        ''' a members of the containing type) or one of the special keywords "Me", "MyBase"
        ''' or "MyClass".
        ''' </param>
        ''' <param name="dotToken">
        ''' The "." token.
        ''' </param>
        ''' <param name="eventMember">
        ''' The event being handled. This must be a simple identifier.
        ''' </param>
        Friend Shared Function HandlesClauseItem(eventContainer As EventContainerSyntax, dotToken As PunctuationSyntax, eventMember As IdentifierNameSyntax) As HandlesClauseItemSyntax
            Debug.Assert(eventContainer IsNot Nothing)
            Debug.Assert(dotToken IsNot Nothing AndAlso dotToken.Kind = SyntaxKind.DotToken)
            Debug.Assert(eventMember IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.HandlesClauseItem, eventContainer, dotToken, eventMember, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, HandlesClauseItemSyntax)
            End If

            Dim result = New HandlesClauseItemSyntax(SyntaxKind.HandlesClauseItem, eventContainer, dotToken, eventMember)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the beginning of a declaration. However, not enough syntax is
        ''' detected to classify this as a field, method, property or event. This is node
        ''' always represents a syntax error.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </param>
        ''' <param name="missingIdentifier">
        ''' The missing identifier token for this incomplete member. Should only be used to
        ''' have a location for error reporting.
        ''' </param>
        Friend Shared Function IncompleteMember(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), missingIdentifier As IdentifierTokenSyntax) As IncompleteMemberSyntax

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.IncompleteMember, attributeLists.Node, modifiers.Node, missingIdentifier, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, IncompleteMemberSyntax)
            End If

            Dim result = New IncompleteMemberSyntax(SyntaxKind.IncompleteMember, attributeLists.Node, modifiers.Node, missingIdentifier)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the declaration of one or more variables or constants, either as
        ''' local variables or as class/structure members. In the case of a constant, it is
        ''' represented by having "Const" in the Modifiers (although technically "Const" is
        ''' not a modifier, it is represented as one in the parse trees.)
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </param>
        ''' <param name="declarators">
        ''' The list of variable declarator. Each declarator specifies one or more variable
        ''' names along with a type and/or initializer.
        ''' </param>
        Friend Shared Function FieldDeclaration(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), declarators As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As FieldDeclarationSyntax

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.FieldDeclaration, attributeLists.Node, modifiers.Node, declarators.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, FieldDeclarationSyntax)
            End If

            Dim result = New FieldDeclarationSyntax(SyntaxKind.FieldDeclaration, attributeLists.Node, modifiers.Node, declarators.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the part of a variable or constant declaration statement that
        ''' associated one or more variable names with a type.
        ''' </summary>
        ''' <param name="names">
        ''' The names of the variables being declared. Each name might have a "?" or "()"
        ''' modifier(s) attached.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type, and possibly includes "New",
        ''' "With" or "From". If no As clause was present, Nothing is returned.
        ''' </param>
        ''' <param name="initializer">
        ''' If present, an "= initial-value" clause describing the initial value of the
        ''' variable or the value of the constant.
        ''' </param>
        Friend Shared Function VariableDeclarator(names As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), asClause As AsClauseSyntax, initializer As EqualsValueSyntax) As VariableDeclaratorSyntax

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.VariableDeclarator, names.Node, asClause, initializer, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, VariableDeclaratorSyntax)
            End If

            Dim result = New VariableDeclaratorSyntax(SyntaxKind.VariableDeclarator, names.Node, asClause, initializer)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "As {type-name}" clause that does not have an initializer or
        ''' "New". The type has optional attributes associated with it, although attributes
        ''' are not permitted in all possible places where this node occurs.
        ''' </summary>
        ''' <param name="asKeyword">
        ''' The "As" keyword.
        ''' </param>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on the type. If no attributes were specified, an
        ''' empty list is returned.
        ''' </param>
        ''' <param name="type">
        ''' The type-name part of the As clause.
        ''' </param>
        Friend Shared Function SimpleAsClause(asKeyword As KeywordSyntax, attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), type As TypeSyntax) As SimpleAsClauseSyntax
            Debug.Assert(asKeyword IsNot Nothing AndAlso asKeyword.Kind = SyntaxKind.AsKeyword)
            Debug.Assert(type IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.SimpleAsClause, asKeyword, attributeLists.Node, type, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SimpleAsClauseSyntax)
            End If

            Dim result = New SimpleAsClauseSyntax(SyntaxKind.SimpleAsClause, asKeyword, attributeLists.Node, type)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "As New {type-name} [arguments] [initializers]" clause in a
        ''' declaration. The type has optional attributes associated with it, although
        ''' attributes are not permitted in many places where this node occurs (they are
        ''' permitted, for example, on automatically implemented properties.)
        ''' </summary>
        ''' <param name="asKeyword">
        ''' The "As" keyword.
        ''' </param>
        ''' <param name="newExpression">
        ''' The New expression
        ''' </param>
        Friend Shared Function AsNewClause(asKeyword As KeywordSyntax, newExpression As NewExpressionSyntax) As AsNewClauseSyntax
            Debug.Assert(asKeyword IsNot Nothing AndAlso asKeyword.Kind = SyntaxKind.AsKeyword)
            Debug.Assert(newExpression IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.AsNewClause, asKeyword, newExpression, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AsNewClauseSyntax)
            End If

            Dim result = New AsNewClauseSyntax(SyntaxKind.AsNewClause, asKeyword, newExpression)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "With {...} clause used to initialize a new object's members.
        ''' </summary>
        ''' <param name="withKeyword">
        ''' The "With" keyword.
        ''' </param>
        ''' <param name="openBraceToken">
        ''' The "{" token.
        ''' </param>
        ''' <param name="initializers">
        ''' The comma-separated list of field initializers.
        ''' </param>
        ''' <param name="closeBraceToken">
        ''' The "}" token.
        ''' </param>
        Friend Shared Function ObjectMemberInitializer(withKeyword As KeywordSyntax, openBraceToken As PunctuationSyntax, initializers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), closeBraceToken As PunctuationSyntax) As ObjectMemberInitializerSyntax
            Debug.Assert(withKeyword IsNot Nothing AndAlso withKeyword.Kind = SyntaxKind.WithKeyword)
            Debug.Assert(openBraceToken IsNot Nothing AndAlso openBraceToken.Kind = SyntaxKind.OpenBraceToken)
            Debug.Assert(closeBraceToken IsNot Nothing AndAlso closeBraceToken.Kind = SyntaxKind.CloseBraceToken)
            Return New ObjectMemberInitializerSyntax(SyntaxKind.ObjectMemberInitializer, withKeyword, openBraceToken, initializers.Node, closeBraceToken)
        End Function


        ''' <summary>
        ''' Represents a "From {...} clause used to initialize a new collection object's
        ''' elements.
        ''' </summary>
        ''' <param name="fromKeyword">
        ''' The "From" keyword.
        ''' </param>
        ''' <param name="initializer">
        ''' The initializer including the braces.
        ''' </param>
        Friend Shared Function ObjectCollectionInitializer(fromKeyword As KeywordSyntax, initializer As CollectionInitializerSyntax) As ObjectCollectionInitializerSyntax
            Debug.Assert(fromKeyword IsNot Nothing AndAlso fromKeyword.Kind = SyntaxKind.FromKeyword)
            Debug.Assert(initializer IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ObjectCollectionInitializer, fromKeyword, initializer, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ObjectCollectionInitializerSyntax)
            End If

            Dim result = New ObjectCollectionInitializerSyntax(SyntaxKind.ObjectCollectionInitializer, fromKeyword, initializer)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represent a field initializer in a With {...} initializer where the field name
        ''' is inferred from the initializer expression.
        ''' </summary>
        ''' <param name="keyKeyword">
        ''' The optional "Key" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The value being assigned.
        ''' </param>
        Friend Shared Function InferredFieldInitializer(keyKeyword As KeywordSyntax, expression As ExpressionSyntax) As InferredFieldInitializerSyntax
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.InferredFieldInitializer, keyKeyword, expression, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, InferredFieldInitializerSyntax)
            End If

            Dim result = New InferredFieldInitializerSyntax(SyntaxKind.InferredFieldInitializer, keyKeyword, expression)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represent a named field initializer in a With {...} initializer, such as ".x =
        ''' expr".
        ''' </summary>
        ''' <param name="keyKeyword">
        ''' The optional "Key" keyword.
        ''' </param>
        ''' <param name="dotToken">
        ''' The "." token.
        ''' </param>
        ''' <param name="name">
        ''' The name of the field being initialized.
        ''' </param>
        ''' <param name="equalsToken">
        ''' The "=" token.
        ''' </param>
        ''' <param name="expression">
        ''' The value being assigned to the field.
        ''' </param>
        Friend Shared Function NamedFieldInitializer(keyKeyword As KeywordSyntax, dotToken As PunctuationSyntax, name As IdentifierNameSyntax, equalsToken As PunctuationSyntax, expression As ExpressionSyntax) As NamedFieldInitializerSyntax
            Debug.Assert(dotToken IsNot Nothing AndAlso dotToken.Kind = SyntaxKind.DotToken)
            Debug.Assert(name IsNot Nothing)
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(expression IsNot Nothing)
            Return New NamedFieldInitializerSyntax(SyntaxKind.NamedFieldInitializer, keyKeyword, dotToken, name, equalsToken, expression)
        End Function


        ''' <summary>
        ''' Represents an "= initializer" clause in a declaration for a variable, parameter
        ''' or automatic property.
        ''' </summary>
        ''' <param name="equalsToken">
        ''' The "=" token.
        ''' </param>
        ''' <param name="value">
        ''' The expression used as the initial value.
        ''' </param>
        Friend Shared Function EqualsValue(equalsToken As PunctuationSyntax, value As ExpressionSyntax) As EqualsValueSyntax
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EqualsValue, equalsToken, value, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EqualsValueSyntax)
            End If

            Dim result = New EqualsValueSyntax(SyntaxKind.EqualsValue, equalsToken, value)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represent a parameter to a method, property, constructor, etc.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this parameter. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of the modifier tokens "ByVal", "ByRef", "Optional" or "ParamArray" that
        ''' modify this parameter.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the parameter, including any "?" or "()" modifiers.
        ''' </param>
        ''' <param name="asClause">
        ''' If present, the "As type-name" clause describing the type of the parameter. If
        ''' no As clause is present, Nothing is returned.
        ''' </param>
        ''' <param name="default">
        ''' If present, an initializer with the default value of the parameter. If no
        ''' default value is present, Nothing is returned.
        ''' </param>
        Friend Shared Function Parameter(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, [default] As EqualsValueSyntax) As ParameterSyntax
            Debug.Assert(identifier IsNot Nothing)
            Return New ParameterSyntax(SyntaxKind.Parameter, attributeLists.Node, modifiers.Node, identifier, asClause, [default])
        End Function


        ''' <summary>
        ''' Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
        ''' used in parameter declarations and variable declarations.
        ''' </summary>
        ''' <param name="identifier">
        ''' The identifier that names the item being declared.
        ''' </param>
        ''' <param name="nullable">
        ''' The "?" token that indicates a nullable type.
        ''' </param>
        ''' <param name="arrayBounds">
        ''' The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
        ''' </param>
        ''' <param name="arrayRankSpecifiers">
        ''' A list of array modifiers for the type. If no array modifiers were present, an
        ''' empty list is returned.
        ''' </param>
        Friend Shared Function ModifiedIdentifier(identifier As IdentifierTokenSyntax, nullable As PunctuationSyntax, arrayBounds As ArgumentListSyntax, arrayRankSpecifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As ModifiedIdentifierSyntax
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New ModifiedIdentifierSyntax(SyntaxKind.ModifiedIdentifier, identifier, nullable, arrayBounds, arrayRankSpecifiers.Node)
        End Function


        ''' <summary>
        ''' Represents a modifier that describes an array type, without bounds, such as
        ''' "()" or "(,)".
        ''' </summary>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="commaTokens">
        ''' The comma tokens in the array type. There is one less comma than the rank.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Shared Function ArrayRankSpecifier(openParenToken As PunctuationSyntax, commaTokens As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), closeParenToken As PunctuationSyntax) As ArrayRankSpecifierSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ArrayRankSpecifier, openParenToken, commaTokens.Node, closeParenToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ArrayRankSpecifierSyntax)
            End If

            Dim result = New ArrayRankSpecifierSyntax(SyntaxKind.ArrayRankSpecifier, openParenToken, commaTokens.Node, closeParenToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a group of attributes within "&lt;" and "&gt;" brackets.
        ''' </summary>
        ''' <param name="lessThanToken">
        ''' The "&lt;" token.
        ''' </param>
        ''' <param name="attributes">
        ''' A comma separated list of attribute declarations in this attribute list.
        ''' </param>
        ''' <param name="greaterThanToken">
        ''' The "&gt;" token.
        ''' </param>
        Friend Shared Function AttributeList(lessThanToken As PunctuationSyntax, attributes As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), greaterThanToken As PunctuationSyntax) As AttributeListSyntax
            Debug.Assert(lessThanToken IsNot Nothing AndAlso lessThanToken.Kind = SyntaxKind.LessThanToken)
            Debug.Assert(greaterThanToken IsNot Nothing AndAlso greaterThanToken.Kind = SyntaxKind.GreaterThanToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.AttributeList, lessThanToken, attributes.Node, greaterThanToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AttributeListSyntax)
            End If

            Dim result = New AttributeListSyntax(SyntaxKind.AttributeList, lessThanToken, attributes.Node, greaterThanToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a single attribute declaration within an attribute list.
        ''' </summary>
        ''' <param name="target">
        ''' Optional attribute target. Assembly|Module :
        ''' </param>
        ''' <param name="name">
        ''' The name of the attribute.
        ''' </param>
        ''' <param name="argumentList">
        ''' The argument list, if present. If no argument list was supplied, Nothing is
        ''' returned.
        ''' </param>
        Friend Shared Function Attribute(target As AttributeTargetSyntax, name As TypeSyntax, argumentList As ArgumentListSyntax) As AttributeSyntax
            Debug.Assert(name IsNot Nothing)
            Return New AttributeSyntax(SyntaxKind.Attribute, target, name, argumentList)
        End Function


        ''' <summary>
        ''' Represents a single attribute declaration within an attribute list.
        ''' </summary>
        ''' <param name="attributeModifier">
        ''' The "Assembly" or "Module" attribute modifier, is present. If no attribute
        ''' modifier is present, Nothing is returned.
        ''' </param>
        ''' <param name="colonToken">
        ''' The ":" token, if an attribute modifier is present. If no attribute modifier is
        ''' present, Nothing is returned.
        ''' </param>
        Friend Shared Function AttributeTarget(attributeModifier As KeywordSyntax, colonToken As PunctuationSyntax) As AttributeTargetSyntax
            Debug.Assert(attributeModifier IsNot Nothing AndAlso SyntaxFacts.IsAttributeTargetAttributeModifier(attributeModifier.Kind))
            Debug.Assert(colonToken IsNot Nothing AndAlso colonToken.Kind = SyntaxKind.ColonToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.AttributeTarget, attributeModifier, colonToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AttributeTargetSyntax)
            End If

            Dim result = New AttributeTargetSyntax(SyntaxKind.AttributeTarget, attributeModifier, colonToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a file-level attribute, in which the attributes have no other
        ''' syntactic element they are attached to.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' The list of attribute lists.
        ''' </param>
        Friend Shared Function AttributesStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As AttributesStatementSyntax

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.AttributesStatement, attributeLists.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AttributesStatementSyntax)
            End If

            Dim result = New AttributesStatementSyntax(SyntaxKind.AttributesStatement, attributeLists.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represent an expression in a statement context. This may only be a invocation
        ''' or await expression in standard code but may be any expression in VB
        ''' Interactive code.
        ''' </summary>
        ''' <param name="expression">
        ''' The expression.
        ''' </param>
        Friend Shared Function ExpressionStatement(expression As ExpressionSyntax) As ExpressionStatementSyntax
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ExpressionStatement, expression, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExpressionStatementSyntax)
            End If

            Dim result = New ExpressionStatementSyntax(SyntaxKind.ExpressionStatement, expression)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represent a "? expression" "Print" statement in VB Interactive code.
        ''' </summary>
        ''' <param name="questionToken">
        ''' "?" token.
        ''' </param>
        ''' <param name="expression">
        ''' The expression whose value is being output.
        ''' </param>
        Friend Shared Function PrintStatement(questionToken As PunctuationSyntax, expression As ExpressionSyntax) As PrintStatementSyntax
            Debug.Assert(questionToken IsNot Nothing AndAlso questionToken.Kind = SyntaxKind.QuestionToken)
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.PrintStatement, questionToken, expression, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, PrintStatementSyntax)
            End If

            Dim result = New PrintStatementSyntax(SyntaxKind.PrintStatement, questionToken, expression)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a While...End While statement, including the While, body and End
        ''' While.
        ''' </summary>
        ''' <param name="whileStatement">
        ''' The While statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the While...End While. This might be an empty list.
        ''' </param>
        ''' <param name="endWhileStatement">
        ''' The End While statement that ends the block.
        ''' </param>
        Friend Shared Function WhileBlock(whileStatement As WhileStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endWhileStatement As EndBlockStatementSyntax) As WhileBlockSyntax
            Debug.Assert(whileStatement IsNot Nothing)
            Debug.Assert(endWhileStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.WhileBlock, whileStatement, statements.Node, endWhileStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, WhileBlockSyntax)
            End If

            Dim result = New WhileBlockSyntax(SyntaxKind.WhileBlock, whileStatement, statements.Node, endWhileStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an entire Using...End Using statement, including the Using, body and
        ''' End Using statements.
        ''' </summary>
        ''' <param name="usingStatement">
        ''' The UsingStatement that begins the Using...End Using block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the Using...End Using block. This might be an empty
        ''' list.
        ''' </param>
        ''' <param name="endUsingStatement">
        ''' The End Using statement that ends the block.
        ''' </param>
        Friend Shared Function UsingBlock(usingStatement As UsingStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endUsingStatement As EndBlockStatementSyntax) As UsingBlockSyntax
            Debug.Assert(usingStatement IsNot Nothing)
            Debug.Assert(endUsingStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.UsingBlock, usingStatement, statements.Node, endUsingStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, UsingBlockSyntax)
            End If

            Dim result = New UsingBlockSyntax(SyntaxKind.UsingBlock, usingStatement, statements.Node, endUsingStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a entire SyncLock...End SyncLock block, including the SyncLock
        ''' statement, the enclosed statements, and the End SyncLock statement.
        ''' </summary>
        ''' <param name="syncLockStatement">
        ''' The SyncLock statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the SyncLock...End SyncLock statement. This might
        ''' be an empty list.
        ''' </param>
        ''' <param name="endSyncLockStatement">
        ''' The End SyncLock statement that ends the block.
        ''' </param>
        Friend Shared Function SyncLockBlock(syncLockStatement As SyncLockStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endSyncLockStatement As EndBlockStatementSyntax) As SyncLockBlockSyntax
            Debug.Assert(syncLockStatement IsNot Nothing)
            Debug.Assert(endSyncLockStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.SyncLockBlock, syncLockStatement, statements.Node, endSyncLockStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SyncLockBlockSyntax)
            End If

            Dim result = New SyncLockBlockSyntax(SyntaxKind.SyncLockBlock, syncLockStatement, statements.Node, endSyncLockStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a With...End With block, include the With statement, the body of the
        ''' block and the End With statement.
        ''' </summary>
        ''' <param name="withStatement">
        ''' The WithStatement that begins the With...End With block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the With...End With block. This might be an empty
        ''' list.
        ''' </param>
        ''' <param name="endWithStatement">
        ''' The End With statement that ends the block.
        ''' </param>
        Friend Shared Function WithBlock(withStatement As WithStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endWithStatement As EndBlockStatementSyntax) As WithBlockSyntax
            Debug.Assert(withStatement IsNot Nothing)
            Debug.Assert(endWithStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.WithBlock, withStatement, statements.Node, endWithStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, WithBlockSyntax)
            End If

            Dim result = New WithBlockSyntax(SyntaxKind.WithBlock, withStatement, statements.Node, endWithStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the declaration of one or more local variables or constants.
        ''' </summary>
        ''' <param name="modifiers">
        ''' The modifier token (Static, Dim or Const) that introduces this local variable
        ''' declaration.
        ''' </param>
        ''' <param name="declarators">
        ''' The list of variable declarator. Each declarator specifies one or more variable
        ''' names along with a type and/or initializer.
        ''' </param>
        Friend Shared Function LocalDeclarationStatement(modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), declarators As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As LocalDeclarationStatementSyntax

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.LocalDeclarationStatement, modifiers.Node, declarators.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LocalDeclarationStatementSyntax)
            End If

            Dim result = New LocalDeclarationStatementSyntax(SyntaxKind.LocalDeclarationStatement, modifiers.Node, declarators.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a label statement.
        ''' </summary>
        ''' <param name="labelToken">
        ''' The name of the label. If the label is a line number, returns an IntegerLiteral
        ''' that is the line number, otherwise, returns an Identifier.
        ''' </param>
        ''' <param name="colonToken">
        ''' The ":" token of the label statement.
        ''' </param>
        Friend Shared Function LabelStatement(labelToken As SyntaxToken, colonToken As PunctuationSyntax) As LabelStatementSyntax
            Debug.Assert(labelToken IsNot Nothing AndAlso SyntaxFacts.IsLabelStatementLabelToken(labelToken.Kind))
            Debug.Assert(colonToken IsNot Nothing AndAlso colonToken.Kind = SyntaxKind.ColonToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.LabelStatement, labelToken, colonToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LabelStatementSyntax)
            End If

            Dim result = New LabelStatementSyntax(SyntaxKind.LabelStatement, labelToken, colonToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "GoTo" statement.
        ''' </summary>
        ''' <param name="goToKeyword">
        ''' The "GoTo" keyword.
        ''' </param>
        ''' <param name="label">
        ''' The name of the label. If the label is a line number, wraps an IntegerLiteral
        ''' that is the line number, otherwise, wraps an Identifier.
        ''' </param>
        Friend Shared Function GoToStatement(goToKeyword As KeywordSyntax, label As LabelSyntax) As GoToStatementSyntax
            Debug.Assert(goToKeyword IsNot Nothing AndAlso goToKeyword.Kind = SyntaxKind.GoToKeyword)
            Debug.Assert(label IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.GoToStatement, goToKeyword, label, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, GoToStatementSyntax)
            End If

            Dim result = New GoToStatementSyntax(SyntaxKind.GoToStatement, goToKeyword, label)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' A label for a GoTo, Resume, or On Error statement. An identifier, line number,
        ''' or next keyword.
        ''' </summary>
        ''' <param name="labelToken">
        ''' The label name (identifier), line number (integer literal), or next keyword
        ''' token.
        ''' </param>
        Friend Shared Function IdentifierLabel(labelToken As SyntaxToken) As LabelSyntax
            Debug.Assert(labelToken IsNot Nothing AndAlso labelToken.Kind = SyntaxKind.IdentifierToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.IdentifierLabel, labelToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LabelSyntax)
            End If

            Dim result = New LabelSyntax(SyntaxKind.IdentifierLabel, labelToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' A label for a GoTo, Resume, or On Error statement. An identifier, line number,
        ''' or next keyword.
        ''' </summary>
        ''' <param name="labelToken">
        ''' The label name (identifier), line number (integer literal), or next keyword
        ''' token.
        ''' </param>
        Friend Shared Function NumericLabel(labelToken As SyntaxToken) As LabelSyntax
            Debug.Assert(labelToken IsNot Nothing AndAlso labelToken.Kind = SyntaxKind.IntegerLiteralToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.NumericLabel, labelToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LabelSyntax)
            End If

            Dim result = New LabelSyntax(SyntaxKind.NumericLabel, labelToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' A label for a GoTo, Resume, or On Error statement. An identifier, line number,
        ''' or next keyword.
        ''' </summary>
        ''' <param name="labelToken">
        ''' The label name (identifier), line number (integer literal), or next keyword
        ''' token.
        ''' </param>
        Friend Shared Function NextLabel(labelToken As SyntaxToken) As LabelSyntax
            Debug.Assert(labelToken IsNot Nothing AndAlso labelToken.Kind = SyntaxKind.NextKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.NextLabel, labelToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LabelSyntax)
            End If

            Dim result = New LabelSyntax(SyntaxKind.NextLabel, labelToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' A label for a GoTo, Resume, or On Error statement. An identifier, line number,
        ''' or next keyword.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of LabelSyntax. One
        ''' of IdentifierLabel, NumericLabel, NextLabel.
        ''' </param>
        ''' <param name="labelToken">
        ''' The label name (identifier), line number (integer literal), or next keyword
        ''' token.
        ''' </param>
        Friend Shared Function Label(kind As SyntaxKind, labelToken As SyntaxToken) As LabelSyntax
            Debug.Assert(SyntaxFacts.IsLabel(kind))
            Debug.Assert(labelToken IsNot Nothing AndAlso SyntaxFacts.IsLabelLabelToken(labelToken.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(kind, labelToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LabelSyntax)
            End If

            Dim result = New LabelSyntax(kind, labelToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Stop" or "End" statement. The Kind can be used to determine which
        ''' kind of statement this is.
        ''' </summary>
        ''' <param name="stopOrEndKeyword">
        ''' The "Stop" or "End" keyword.
        ''' </param>
        Friend Shared Function StopStatement(stopOrEndKeyword As KeywordSyntax) As StopOrEndStatementSyntax
            Debug.Assert(stopOrEndKeyword IsNot Nothing AndAlso SyntaxFacts.IsStopOrEndStatementStopOrEndKeyword(stopOrEndKeyword.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.StopStatement, stopOrEndKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, StopOrEndStatementSyntax)
            End If

            Dim result = New StopOrEndStatementSyntax(SyntaxKind.StopStatement, stopOrEndKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Stop" or "End" statement. The Kind can be used to determine which
        ''' kind of statement this is.
        ''' </summary>
        ''' <param name="stopOrEndKeyword">
        ''' The "Stop" or "End" keyword.
        ''' </param>
        Friend Shared Function EndStatement(stopOrEndKeyword As KeywordSyntax) As StopOrEndStatementSyntax
            Debug.Assert(stopOrEndKeyword IsNot Nothing AndAlso SyntaxFacts.IsStopOrEndStatementStopOrEndKeyword(stopOrEndKeyword.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EndStatement, stopOrEndKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, StopOrEndStatementSyntax)
            End If

            Dim result = New StopOrEndStatementSyntax(SyntaxKind.EndStatement, stopOrEndKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Stop" or "End" statement. The Kind can be used to determine which
        ''' kind of statement this is.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' StopOrEndStatementSyntax. One of StopStatement, EndStatement.
        ''' </param>
        ''' <param name="stopOrEndKeyword">
        ''' The "Stop" or "End" keyword.
        ''' </param>
        Friend Shared Function StopOrEndStatement(kind As SyntaxKind, stopOrEndKeyword As KeywordSyntax) As StopOrEndStatementSyntax
            Debug.Assert(SyntaxFacts.IsStopOrEndStatement(kind))
            Debug.Assert(stopOrEndKeyword IsNot Nothing AndAlso SyntaxFacts.IsStopOrEndStatementStopOrEndKeyword(stopOrEndKeyword.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(kind, stopOrEndKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, StopOrEndStatementSyntax)
            End If

            Dim result = New StopOrEndStatementSyntax(kind, stopOrEndKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Shared Function ExitDoStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.DoKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ExitDoStatement, exitKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExitStatementSyntax)
            End If

            Dim result = New ExitStatementSyntax(SyntaxKind.ExitDoStatement, exitKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Shared Function ExitForStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.ForKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ExitForStatement, exitKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExitStatementSyntax)
            End If

            Dim result = New ExitStatementSyntax(SyntaxKind.ExitForStatement, exitKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Shared Function ExitSubStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.SubKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ExitSubStatement, exitKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExitStatementSyntax)
            End If

            Dim result = New ExitStatementSyntax(SyntaxKind.ExitSubStatement, exitKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Shared Function ExitFunctionStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.FunctionKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ExitFunctionStatement, exitKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExitStatementSyntax)
            End If

            Dim result = New ExitStatementSyntax(SyntaxKind.ExitFunctionStatement, exitKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Shared Function ExitOperatorStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.OperatorKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ExitOperatorStatement, exitKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExitStatementSyntax)
            End If

            Dim result = New ExitStatementSyntax(SyntaxKind.ExitOperatorStatement, exitKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Shared Function ExitPropertyStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.PropertyKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ExitPropertyStatement, exitKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExitStatementSyntax)
            End If

            Dim result = New ExitStatementSyntax(SyntaxKind.ExitPropertyStatement, exitKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Shared Function ExitTryStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.TryKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ExitTryStatement, exitKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExitStatementSyntax)
            End If

            Dim result = New ExitStatementSyntax(SyntaxKind.ExitTryStatement, exitKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Shared Function ExitSelectStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.SelectKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ExitSelectStatement, exitKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExitStatementSyntax)
            End If

            Dim result = New ExitStatementSyntax(SyntaxKind.ExitSelectStatement, exitKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Shared Function ExitWhileStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.WhileKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ExitWhileStatement, exitKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExitStatementSyntax)
            End If

            Dim result = New ExitStatementSyntax(SyntaxKind.ExitWhileStatement, exitKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' ExitStatementSyntax. One of ExitDoStatement, ExitForStatement,
        ''' ExitSubStatement, ExitFunctionStatement, ExitOperatorStatement,
        ''' ExitPropertyStatement, ExitTryStatement, ExitSelectStatement,
        ''' ExitWhileStatement.
        ''' </param>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Shared Function ExitStatement(kind As SyntaxKind, exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(SyntaxFacts.IsExitStatement(kind))
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso SyntaxFacts.IsExitStatementBlockKeyword(blockKeyword.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(kind, exitKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExitStatementSyntax)
            End If

            Dim result = New ExitStatementSyntax(kind, exitKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Continue (block)" statement. THe kind of block referenced can be
        ''' determined by examining the Kind.
        ''' </summary>
        ''' <param name="continueKeyword">
        ''' The "Continue" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The "Do", "For" or "While" keyword that identifies the kind of loop being
        ''' continued.
        ''' </param>
        Friend Shared Function ContinueWhileStatement(continueKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ContinueStatementSyntax
            Debug.Assert(continueKeyword IsNot Nothing AndAlso continueKeyword.Kind = SyntaxKind.ContinueKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.WhileKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ContinueWhileStatement, continueKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ContinueStatementSyntax)
            End If

            Dim result = New ContinueStatementSyntax(SyntaxKind.ContinueWhileStatement, continueKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Continue (block)" statement. THe kind of block referenced can be
        ''' determined by examining the Kind.
        ''' </summary>
        ''' <param name="continueKeyword">
        ''' The "Continue" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The "Do", "For" or "While" keyword that identifies the kind of loop being
        ''' continued.
        ''' </param>
        Friend Shared Function ContinueDoStatement(continueKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ContinueStatementSyntax
            Debug.Assert(continueKeyword IsNot Nothing AndAlso continueKeyword.Kind = SyntaxKind.ContinueKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.DoKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ContinueDoStatement, continueKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ContinueStatementSyntax)
            End If

            Dim result = New ContinueStatementSyntax(SyntaxKind.ContinueDoStatement, continueKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Continue (block)" statement. THe kind of block referenced can be
        ''' determined by examining the Kind.
        ''' </summary>
        ''' <param name="continueKeyword">
        ''' The "Continue" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The "Do", "For" or "While" keyword that identifies the kind of loop being
        ''' continued.
        ''' </param>
        Friend Shared Function ContinueForStatement(continueKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ContinueStatementSyntax
            Debug.Assert(continueKeyword IsNot Nothing AndAlso continueKeyword.Kind = SyntaxKind.ContinueKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.ForKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ContinueForStatement, continueKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ContinueStatementSyntax)
            End If

            Dim result = New ContinueStatementSyntax(SyntaxKind.ContinueForStatement, continueKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Continue (block)" statement. THe kind of block referenced can be
        ''' determined by examining the Kind.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' ContinueStatementSyntax. One of ContinueWhileStatement, ContinueDoStatement,
        ''' ContinueForStatement.
        ''' </param>
        ''' <param name="continueKeyword">
        ''' The "Continue" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The "Do", "For" or "While" keyword that identifies the kind of loop being
        ''' continued.
        ''' </param>
        Friend Shared Function ContinueStatement(kind As SyntaxKind, continueKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ContinueStatementSyntax
            Debug.Assert(SyntaxFacts.IsContinueStatement(kind))
            Debug.Assert(continueKeyword IsNot Nothing AndAlso continueKeyword.Kind = SyntaxKind.ContinueKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso SyntaxFacts.IsContinueStatementBlockKeyword(blockKeyword.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(kind, continueKeyword, blockKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ContinueStatementSyntax)
            End If

            Dim result = New ContinueStatementSyntax(kind, continueKeyword, blockKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Return" statement.
        ''' </summary>
        ''' <param name="returnKeyword">
        ''' The "Return" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being returned, if present.
        ''' </param>
        Friend Shared Function ReturnStatement(returnKeyword As KeywordSyntax, expression As ExpressionSyntax) As ReturnStatementSyntax
            Debug.Assert(returnKeyword IsNot Nothing AndAlso returnKeyword.Kind = SyntaxKind.ReturnKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ReturnStatement, returnKeyword, expression, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ReturnStatementSyntax)
            End If

            Dim result = New ReturnStatementSyntax(SyntaxKind.ReturnStatement, returnKeyword, expression)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a single-line "If ... Then ... Else ..." statement.
        ''' </summary>
        ''' <param name="ifKeyword">
        ''' The "If" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The condition expression to be evaluated.
        ''' </param>
        ''' <param name="thenKeyword">
        ''' The "Then" keyword.
        ''' </param>
        ''' <param name="statements">
        ''' A list of statements to be executed if the condition expression evaluates as
        ''' true. Multiple statements must be separated by colons.
        ''' </param>
        ''' <param name="elseClause">
        ''' An "Else" clause to be executed if the condition expression evaluates as false.
        ''' </param>
        Friend Shared Function SingleLineIfStatement(ifKeyword As KeywordSyntax, condition As ExpressionSyntax, thenKeyword As KeywordSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), elseClause As SingleLineElseClauseSyntax) As SingleLineIfStatementSyntax
            Debug.Assert(ifKeyword IsNot Nothing AndAlso ifKeyword.Kind = SyntaxKind.IfKeyword)
            Debug.Assert(condition IsNot Nothing)
            Debug.Assert(thenKeyword IsNot Nothing AndAlso thenKeyword.Kind = SyntaxKind.ThenKeyword)
            Return New SingleLineIfStatementSyntax(SyntaxKind.SingleLineIfStatement, ifKeyword, condition, thenKeyword, statements.Node, elseClause)
        End Function


        ''' <summary>
        ''' Represents the "Else ..." clause of a single-line "If" statement.
        ''' </summary>
        ''' <param name="elseKeyword">
        ''' The "Else" keyword.
        ''' </param>
        ''' <param name="statements">
        ''' A list of statements to be executed. Multiple statements must be separated by
        ''' colons.
        ''' </param>
        Friend Shared Function SingleLineElseClause(elseKeyword As KeywordSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As SingleLineElseClauseSyntax
            Debug.Assert(elseKeyword IsNot Nothing AndAlso elseKeyword.Kind = SyntaxKind.ElseKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.SingleLineElseClause, elseKeyword, statements.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SingleLineElseClauseSyntax)
            End If

            Dim result = New SingleLineElseClauseSyntax(SyntaxKind.SingleLineElseClause, elseKeyword, statements.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a multi-line "If ... Then ... ElseIf ... Then ... Else ... End If"
        ''' block.
        ''' </summary>
        ''' <param name="ifStatement">
        ''' The "If" statement that begins the "If" block.
        ''' </param>
        ''' <param name="statements">
        ''' A list of statements to be executed if the condition expression evaluates as
        ''' true.
        ''' </param>
        ''' <param name="elseIfBlocks">
        ''' A list of "ElseIf" blocks to be evaluated, in order, if the condition
        ''' expression of the "If" statement evaluates as false.
        ''' </param>
        ''' <param name="elseBlock">
        ''' An "Else" block to be executed if the condition expression of the "If"
        ''' statement and all "ElseIf" blocks evaluate as false.
        ''' </param>
        ''' <param name="endIfStatement">
        ''' Then "End If" statement.
        ''' </param>
        Friend Shared Function MultiLineIfBlock(ifStatement As IfStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), elseIfBlocks As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), elseBlock As ElseBlockSyntax, endIfStatement As EndBlockStatementSyntax) As MultiLineIfBlockSyntax
            Debug.Assert(ifStatement IsNot Nothing)
            Debug.Assert(endIfStatement IsNot Nothing)
            Return New MultiLineIfBlockSyntax(SyntaxKind.MultiLineIfBlock, ifStatement, statements.Node, elseIfBlocks.Node, elseBlock, endIfStatement)
        End Function


        ''' <summary>
        ''' Represents the "If ... Then" statement that begins a multi-line "If" block.
        ''' </summary>
        ''' <param name="ifKeyword">
        ''' The "If" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The condition expression to be evaluated.
        ''' </param>
        ''' <param name="thenKeyword">
        ''' The "Then" keyword.
        ''' </param>
        Friend Shared Function IfStatement(ifKeyword As KeywordSyntax, condition As ExpressionSyntax, thenKeyword As KeywordSyntax) As IfStatementSyntax
            Debug.Assert(ifKeyword IsNot Nothing AndAlso ifKeyword.Kind = SyntaxKind.IfKeyword)
            Debug.Assert(condition IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.IfStatement, ifKeyword, condition, thenKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, IfStatementSyntax)
            End If

            Dim result = New IfStatementSyntax(SyntaxKind.IfStatement, ifKeyword, condition, thenKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "ElseIf ... Then ..." block.
        ''' </summary>
        ''' <param name="elseIfStatement">
        ''' The "ElseIf ... Then" statement the begins the "ElseIf" block.
        ''' </param>
        ''' <param name="statements">
        ''' A list of statements to be executed if the condition expression of the "ElseIf"
        ''' statement evaluates as true.
        ''' </param>
        Friend Shared Function ElseIfBlock(elseIfStatement As ElseIfStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As ElseIfBlockSyntax
            Debug.Assert(elseIfStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ElseIfBlock, elseIfStatement, statements.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ElseIfBlockSyntax)
            End If

            Dim result = New ElseIfBlockSyntax(SyntaxKind.ElseIfBlock, elseIfStatement, statements.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the "ElseIf ... Then" statement that begins an "ElseIf" block.
        ''' </summary>
        ''' <param name="elseIfKeyword">
        ''' The "ElseIf" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The condition expression to be evaluated.
        ''' </param>
        ''' <param name="thenKeyword">
        ''' The "Then" keyword.
        ''' </param>
        Friend Shared Function ElseIfStatement(elseIfKeyword As KeywordSyntax, condition As ExpressionSyntax, thenKeyword As KeywordSyntax) As ElseIfStatementSyntax
            Debug.Assert(elseIfKeyword IsNot Nothing AndAlso elseIfKeyword.Kind = SyntaxKind.ElseIfKeyword)
            Debug.Assert(condition IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ElseIfStatement, elseIfKeyword, condition, thenKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ElseIfStatementSyntax)
            End If

            Dim result = New ElseIfStatementSyntax(SyntaxKind.ElseIfStatement, elseIfKeyword, condition, thenKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "Else ..." block.
        ''' </summary>
        ''' <param name="elseStatement">
        ''' The "Else" statement that begins the "Else" block.
        ''' </param>
        ''' <param name="statements">
        ''' A list of statements to be executed.
        ''' </param>
        Friend Shared Function ElseBlock(elseStatement As ElseStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As ElseBlockSyntax
            Debug.Assert(elseStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ElseBlock, elseStatement, statements.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ElseBlockSyntax)
            End If

            Dim result = New ElseBlockSyntax(SyntaxKind.ElseBlock, elseStatement, statements.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the "Else" statement that begins an "Else" block.
        ''' </summary>
        ''' <param name="elseKeyword">
        ''' The "Else" keyword.
        ''' </param>
        Friend Shared Function ElseStatement(elseKeyword As KeywordSyntax) As ElseStatementSyntax
            Debug.Assert(elseKeyword IsNot Nothing AndAlso elseKeyword.Kind = SyntaxKind.ElseKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ElseStatement, elseKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ElseStatementSyntax)
            End If

            Dim result = New ElseStatementSyntax(SyntaxKind.ElseStatement, elseKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Try ... Catch ... Finally ... End Try" block.
        ''' </summary>
        ''' <param name="tryStatement">
        ''' The "Try" statement that begins the "Try" block.
        ''' </param>
        ''' <param name="statements">
        ''' A list of statements to be executed.
        ''' </param>
        ''' <param name="catchBlocks">
        ''' A list of "Catch" blocks which may be executed if an exception is thrown while
        ''' executing the statements in the "Try" block.
        ''' </param>
        ''' <param name="finallyBlock">
        ''' A "Finally" block to be executed before execution leaves the "Try" block.
        ''' </param>
        ''' <param name="endTryStatement">
        ''' The "End Try" statement.
        ''' </param>
        Friend Shared Function TryBlock(tryStatement As TryStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), catchBlocks As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), finallyBlock As FinallyBlockSyntax, endTryStatement As EndBlockStatementSyntax) As TryBlockSyntax
            Debug.Assert(tryStatement IsNot Nothing)
            Debug.Assert(endTryStatement IsNot Nothing)
            Return New TryBlockSyntax(SyntaxKind.TryBlock, tryStatement, statements.Node, catchBlocks.Node, finallyBlock, endTryStatement)
        End Function


        ''' <summary>
        ''' Represents the "Try" statement that begins a "Try" block.
        ''' </summary>
        ''' <param name="tryKeyword">
        ''' The "Try" keyword.
        ''' </param>
        Friend Shared Function TryStatement(tryKeyword As KeywordSyntax) As TryStatementSyntax
            Debug.Assert(tryKeyword IsNot Nothing AndAlso tryKeyword.Kind = SyntaxKind.TryKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.TryStatement, tryKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, TryStatementSyntax)
            End If

            Dim result = New TryStatementSyntax(SyntaxKind.TryStatement, tryKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Catch ..." block.
        ''' </summary>
        ''' <param name="catchStatement">
        ''' The "Catch" statement that begins the "Catch" block.
        ''' </param>
        ''' <param name="statements">
        ''' A list of statements to be executed if an exception is caught by the "Catch"
        ''' block.
        ''' </param>
        Friend Shared Function CatchBlock(catchStatement As CatchStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As CatchBlockSyntax
            Debug.Assert(catchStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.CatchBlock, catchStatement, statements.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CatchBlockSyntax)
            End If

            Dim result = New CatchBlockSyntax(SyntaxKind.CatchBlock, catchStatement, statements.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the "Catch ... When ..." statement that begins a "Catch" block.
        ''' </summary>
        ''' <param name="catchKeyword">
        ''' The "Catch" keyword.
        ''' </param>
        ''' <param name="identifierName">
        ''' An identifier declaring a new variable or naming an existing variable to store
        ''' the exception caught by the "Catch" statement.
        ''' </param>
        ''' <param name="asClause">
        ''' A simple "As" clause specifying the type of exception to catch.
        ''' </param>
        ''' <param name="whenClause">
        ''' A "When" clause to filter exceptions before catching.
        ''' </param>
        Friend Shared Function CatchStatement(catchKeyword As KeywordSyntax, identifierName As IdentifierNameSyntax, asClause As SimpleAsClauseSyntax, whenClause As CatchFilterClauseSyntax) As CatchStatementSyntax
            Debug.Assert(catchKeyword IsNot Nothing AndAlso catchKeyword.Kind = SyntaxKind.CatchKeyword)
            Return New CatchStatementSyntax(SyntaxKind.CatchStatement, catchKeyword, identifierName, asClause, whenClause)
        End Function


        ''' <summary>
        ''' Represents the "When ..." clause of a "Catch" statement.
        ''' </summary>
        ''' <param name="whenKeyword">
        ''' The "When" keyword.
        ''' </param>
        ''' <param name="filter">
        ''' The filter expression to be evaluated.
        ''' </param>
        Friend Shared Function CatchFilterClause(whenKeyword As KeywordSyntax, filter As ExpressionSyntax) As CatchFilterClauseSyntax
            Debug.Assert(whenKeyword IsNot Nothing AndAlso whenKeyword.Kind = SyntaxKind.WhenKeyword)
            Debug.Assert(filter IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.CatchFilterClause, whenKeyword, filter, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CatchFilterClauseSyntax)
            End If

            Dim result = New CatchFilterClauseSyntax(SyntaxKind.CatchFilterClause, whenKeyword, filter)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Finally ..." block of a "Try" block.
        ''' </summary>
        ''' <param name="finallyStatement">
        ''' The "Finally" statement that begins the "Finally" block.
        ''' </param>
        ''' <param name="statements">
        ''' A list of statements to be executed.
        ''' </param>
        Friend Shared Function FinallyBlock(finallyStatement As FinallyStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As FinallyBlockSyntax
            Debug.Assert(finallyStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.FinallyBlock, finallyStatement, statements.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, FinallyBlockSyntax)
            End If

            Dim result = New FinallyBlockSyntax(SyntaxKind.FinallyBlock, finallyStatement, statements.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the "Finally" statement that begins a "Finally" block.
        ''' </summary>
        ''' <param name="finallyKeyword">
        ''' The "Finally" keyword.
        ''' </param>
        Friend Shared Function FinallyStatement(finallyKeyword As KeywordSyntax) As FinallyStatementSyntax
            Debug.Assert(finallyKeyword IsNot Nothing AndAlso finallyKeyword.Kind = SyntaxKind.FinallyKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.FinallyStatement, finallyKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, FinallyStatementSyntax)
            End If

            Dim result = New FinallyStatementSyntax(SyntaxKind.FinallyStatement, finallyKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the "Error" statement.
        ''' </summary>
        ''' <param name="errorKeyword">
        ''' The "Error" keyword.
        ''' </param>
        ''' <param name="errorNumber">
        ''' The expression that represents the error number.
        ''' </param>
        Friend Shared Function ErrorStatement(errorKeyword As KeywordSyntax, errorNumber As ExpressionSyntax) As ErrorStatementSyntax
            Debug.Assert(errorKeyword IsNot Nothing AndAlso errorKeyword.Kind = SyntaxKind.ErrorKeyword)
            Debug.Assert(errorNumber IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ErrorStatement, errorKeyword, errorNumber, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ErrorStatementSyntax)
            End If

            Dim result = New ErrorStatementSyntax(SyntaxKind.ErrorStatement, errorKeyword, errorNumber)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an OnError Goto statement.
        ''' </summary>
        ''' <param name="onKeyword">
        ''' The "On" keyword
        ''' </param>
        ''' <param name="errorKeyword">
        ''' The "Error" keyword.
        ''' </param>
        ''' <param name="goToKeyword">
        ''' The "GoTo" keyword
        ''' </param>
        ''' <param name="minus">
        ''' An optional minus for On Error Goto -1
        ''' </param>
        ''' <param name="label">
        ''' The name of the label. If the label is a line number, 0 or -1, wraps an
        ''' IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
        ''' </param>
        Friend Shared Function OnErrorGoToZeroStatement(onKeyword As KeywordSyntax, errorKeyword As KeywordSyntax, goToKeyword As KeywordSyntax, minus As PunctuationSyntax, label As LabelSyntax) As OnErrorGoToStatementSyntax
            Debug.Assert(onKeyword IsNot Nothing AndAlso onKeyword.Kind = SyntaxKind.OnKeyword)
            Debug.Assert(errorKeyword IsNot Nothing AndAlso errorKeyword.Kind = SyntaxKind.ErrorKeyword)
            Debug.Assert(goToKeyword IsNot Nothing AndAlso goToKeyword.Kind = SyntaxKind.GoToKeyword)
            Debug.Assert(label IsNot Nothing)
            Return New OnErrorGoToStatementSyntax(SyntaxKind.OnErrorGoToZeroStatement, onKeyword, errorKeyword, goToKeyword, minus, label)
        End Function


        ''' <summary>
        ''' Represents an OnError Goto statement.
        ''' </summary>
        ''' <param name="onKeyword">
        ''' The "On" keyword
        ''' </param>
        ''' <param name="errorKeyword">
        ''' The "Error" keyword.
        ''' </param>
        ''' <param name="goToKeyword">
        ''' The "GoTo" keyword
        ''' </param>
        ''' <param name="minus">
        ''' An optional minus for On Error Goto -1
        ''' </param>
        ''' <param name="label">
        ''' The name of the label. If the label is a line number, 0 or -1, wraps an
        ''' IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
        ''' </param>
        Friend Shared Function OnErrorGoToMinusOneStatement(onKeyword As KeywordSyntax, errorKeyword As KeywordSyntax, goToKeyword As KeywordSyntax, minus As PunctuationSyntax, label As LabelSyntax) As OnErrorGoToStatementSyntax
            Debug.Assert(onKeyword IsNot Nothing AndAlso onKeyword.Kind = SyntaxKind.OnKeyword)
            Debug.Assert(errorKeyword IsNot Nothing AndAlso errorKeyword.Kind = SyntaxKind.ErrorKeyword)
            Debug.Assert(goToKeyword IsNot Nothing AndAlso goToKeyword.Kind = SyntaxKind.GoToKeyword)
            Debug.Assert(label IsNot Nothing)
            Return New OnErrorGoToStatementSyntax(SyntaxKind.OnErrorGoToMinusOneStatement, onKeyword, errorKeyword, goToKeyword, minus, label)
        End Function


        ''' <summary>
        ''' Represents an OnError Goto statement.
        ''' </summary>
        ''' <param name="onKeyword">
        ''' The "On" keyword
        ''' </param>
        ''' <param name="errorKeyword">
        ''' The "Error" keyword.
        ''' </param>
        ''' <param name="goToKeyword">
        ''' The "GoTo" keyword
        ''' </param>
        ''' <param name="minus">
        ''' An optional minus for On Error Goto -1
        ''' </param>
        ''' <param name="label">
        ''' The name of the label. If the label is a line number, 0 or -1, wraps an
        ''' IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
        ''' </param>
        Friend Shared Function OnErrorGoToLabelStatement(onKeyword As KeywordSyntax, errorKeyword As KeywordSyntax, goToKeyword As KeywordSyntax, minus As PunctuationSyntax, label As LabelSyntax) As OnErrorGoToStatementSyntax
            Debug.Assert(onKeyword IsNot Nothing AndAlso onKeyword.Kind = SyntaxKind.OnKeyword)
            Debug.Assert(errorKeyword IsNot Nothing AndAlso errorKeyword.Kind = SyntaxKind.ErrorKeyword)
            Debug.Assert(goToKeyword IsNot Nothing AndAlso goToKeyword.Kind = SyntaxKind.GoToKeyword)
            Debug.Assert(label IsNot Nothing)
            Return New OnErrorGoToStatementSyntax(SyntaxKind.OnErrorGoToLabelStatement, onKeyword, errorKeyword, goToKeyword, minus, label)
        End Function


        ''' <summary>
        ''' Represents an OnError Goto statement.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' OnErrorGoToStatementSyntax. One of OnErrorGoToZeroStatement,
        ''' OnErrorGoToMinusOneStatement, OnErrorGoToLabelStatement.
        ''' </param>
        ''' <param name="onKeyword">
        ''' The "On" keyword
        ''' </param>
        ''' <param name="errorKeyword">
        ''' The "Error" keyword.
        ''' </param>
        ''' <param name="goToKeyword">
        ''' The "GoTo" keyword
        ''' </param>
        ''' <param name="minus">
        ''' An optional minus for On Error Goto -1
        ''' </param>
        ''' <param name="label">
        ''' The name of the label. If the label is a line number, 0 or -1, wraps an
        ''' IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
        ''' </param>
        Friend Shared Function OnErrorGoToStatement(kind As SyntaxKind, onKeyword As KeywordSyntax, errorKeyword As KeywordSyntax, goToKeyword As KeywordSyntax, minus As PunctuationSyntax, label As LabelSyntax) As OnErrorGoToStatementSyntax
            Debug.Assert(SyntaxFacts.IsOnErrorGoToStatement(kind))
            Debug.Assert(onKeyword IsNot Nothing AndAlso onKeyword.Kind = SyntaxKind.OnKeyword)
            Debug.Assert(errorKeyword IsNot Nothing AndAlso errorKeyword.Kind = SyntaxKind.ErrorKeyword)
            Debug.Assert(goToKeyword IsNot Nothing AndAlso goToKeyword.Kind = SyntaxKind.GoToKeyword)
            Debug.Assert(label IsNot Nothing)
            Return New OnErrorGoToStatementSyntax(kind, onKeyword, errorKeyword, goToKeyword, minus, label)
        End Function


        ''' <summary>
        ''' Represents an OnError Resume Next statement.
        ''' </summary>
        ''' <param name="onKeyword">
        ''' The "On" keyword
        ''' </param>
        ''' <param name="errorKeyword">
        ''' The "Error" keyword.
        ''' </param>
        ''' <param name="resumeKeyword">
        ''' The "Resume" keyword.
        ''' </param>
        ''' <param name="nextKeyword">
        ''' The "Next"
        ''' </param>
        Friend Shared Function OnErrorResumeNextStatement(onKeyword As KeywordSyntax, errorKeyword As KeywordSyntax, resumeKeyword As KeywordSyntax, nextKeyword As KeywordSyntax) As OnErrorResumeNextStatementSyntax
            Debug.Assert(onKeyword IsNot Nothing AndAlso onKeyword.Kind = SyntaxKind.OnKeyword)
            Debug.Assert(errorKeyword IsNot Nothing AndAlso errorKeyword.Kind = SyntaxKind.ErrorKeyword)
            Debug.Assert(resumeKeyword IsNot Nothing AndAlso resumeKeyword.Kind = SyntaxKind.ResumeKeyword)
            Debug.Assert(nextKeyword IsNot Nothing AndAlso nextKeyword.Kind = SyntaxKind.NextKeyword)
            Return New OnErrorResumeNextStatementSyntax(SyntaxKind.OnErrorResumeNextStatement, onKeyword, errorKeyword, resumeKeyword, nextKeyword)
        End Function


        ''' <summary>
        ''' Represents a "Resume" statement. The Kind property can be used to determine if
        ''' this is a "Resume", "Resume Next" or "Resume label" statement.
        ''' </summary>
        ''' <param name="resumeKeyword">
        ''' The "Resume" keyword.
        ''' </param>
        ''' <param name="label">
        ''' The label. The value of this depends on the Kind. If Kind=Resume, returns
        ''' Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
        ''' wraps an Identifier or IntegerLiteralToken with the label or line number.
        ''' </param>
        Friend Shared Function ResumeStatement(resumeKeyword As KeywordSyntax, label As LabelSyntax) As ResumeStatementSyntax
            Debug.Assert(resumeKeyword IsNot Nothing AndAlso resumeKeyword.Kind = SyntaxKind.ResumeKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ResumeStatement, resumeKeyword, label, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ResumeStatementSyntax)
            End If

            Dim result = New ResumeStatementSyntax(SyntaxKind.ResumeStatement, resumeKeyword, label)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Resume" statement. The Kind property can be used to determine if
        ''' this is a "Resume", "Resume Next" or "Resume label" statement.
        ''' </summary>
        ''' <param name="resumeKeyword">
        ''' The "Resume" keyword.
        ''' </param>
        ''' <param name="label">
        ''' The label. The value of this depends on the Kind. If Kind=Resume, returns
        ''' Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
        ''' wraps an Identifier or IntegerLiteralToken with the label or line number.
        ''' </param>
        Friend Shared Function ResumeLabelStatement(resumeKeyword As KeywordSyntax, label As LabelSyntax) As ResumeStatementSyntax
            Debug.Assert(resumeKeyword IsNot Nothing AndAlso resumeKeyword.Kind = SyntaxKind.ResumeKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ResumeLabelStatement, resumeKeyword, label, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ResumeStatementSyntax)
            End If

            Dim result = New ResumeStatementSyntax(SyntaxKind.ResumeLabelStatement, resumeKeyword, label)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Resume" statement. The Kind property can be used to determine if
        ''' this is a "Resume", "Resume Next" or "Resume label" statement.
        ''' </summary>
        ''' <param name="resumeKeyword">
        ''' The "Resume" keyword.
        ''' </param>
        ''' <param name="label">
        ''' The label. The value of this depends on the Kind. If Kind=Resume, returns
        ''' Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
        ''' wraps an Identifier or IntegerLiteralToken with the label or line number.
        ''' </param>
        Friend Shared Function ResumeNextStatement(resumeKeyword As KeywordSyntax, label As LabelSyntax) As ResumeStatementSyntax
            Debug.Assert(resumeKeyword IsNot Nothing AndAlso resumeKeyword.Kind = SyntaxKind.ResumeKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ResumeNextStatement, resumeKeyword, label, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ResumeStatementSyntax)
            End If

            Dim result = New ResumeStatementSyntax(SyntaxKind.ResumeNextStatement, resumeKeyword, label)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Select Case block, including the Select Case that begins it, the
        ''' contains Case blocks and the End Select.
        ''' </summary>
        ''' <param name="selectStatement">
        ''' The Select Case statement that begins the block.
        ''' </param>
        ''' <param name="caseBlocks">
        ''' A list of the contained Case blocks.
        ''' </param>
        ''' <param name="endSelectStatement">
        ''' The End Select statement that ends the block.
        ''' </param>
        Friend Shared Function SelectBlock(selectStatement As SelectStatementSyntax, caseBlocks As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endSelectStatement As EndBlockStatementSyntax) As SelectBlockSyntax
            Debug.Assert(selectStatement IsNot Nothing)
            Debug.Assert(endSelectStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.SelectBlock, selectStatement, caseBlocks.Node, endSelectStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SelectBlockSyntax)
            End If

            Dim result = New SelectBlockSyntax(SyntaxKind.SelectBlock, selectStatement, caseBlocks.Node, endSelectStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Select Case statement. This statement always occurs as the Begin
        ''' of a SelectBlock.
        ''' </summary>
        ''' <param name="selectKeyword">
        ''' The "Select" keyword.
        ''' </param>
        ''' <param name="caseKeyword">
        ''' The "Case" keyword, if present.
        ''' </param>
        ''' <param name="expression">
        ''' The value that branching is based on.
        ''' </param>
        Friend Shared Function SelectStatement(selectKeyword As KeywordSyntax, caseKeyword As KeywordSyntax, expression As ExpressionSyntax) As SelectStatementSyntax
            Debug.Assert(selectKeyword IsNot Nothing AndAlso selectKeyword.Kind = SyntaxKind.SelectKeyword)
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.SelectStatement, selectKeyword, caseKeyword, expression, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SelectStatementSyntax)
            End If

            Dim result = New SelectStatementSyntax(SyntaxKind.SelectStatement, selectKeyword, caseKeyword, expression)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a case statement and its subsequent block.
        ''' </summary>
        ''' <param name="caseStatement">
        ''' The statement that begins the case block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the case block. This might be an empty list.
        ''' </param>
        Friend Shared Function CaseBlock(caseStatement As CaseStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As CaseBlockSyntax
            Debug.Assert(caseStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.CaseBlock, caseStatement, statements.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CaseBlockSyntax)
            End If

            Dim result = New CaseBlockSyntax(SyntaxKind.CaseBlock, caseStatement, statements.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a case statement and its subsequent block.
        ''' </summary>
        ''' <param name="caseStatement">
        ''' The statement that begins the case block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the case block. This might be an empty list.
        ''' </param>
        Friend Shared Function CaseElseBlock(caseStatement As CaseStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As CaseBlockSyntax
            Debug.Assert(caseStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.CaseElseBlock, caseStatement, statements.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CaseBlockSyntax)
            End If

            Dim result = New CaseBlockSyntax(SyntaxKind.CaseElseBlock, caseStatement, statements.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Case or Case Else statement. This statement is always the Begin of
        ''' a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
        ''' Kind=Case.
        ''' </summary>
        ''' <param name="caseKeyword">
        ''' The "Case" keyword
        ''' </param>
        ''' <param name="cases">
        ''' A list of clauses associated with this Case. If Kind=CaseElse, then this list
        ''' has exactly one child, which is a ElseCaseClause.
        ''' </param>
        Friend Shared Function CaseStatement(caseKeyword As KeywordSyntax, cases As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As CaseStatementSyntax
            Debug.Assert(caseKeyword IsNot Nothing AndAlso caseKeyword.Kind = SyntaxKind.CaseKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.CaseStatement, caseKeyword, cases.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CaseStatementSyntax)
            End If

            Dim result = New CaseStatementSyntax(SyntaxKind.CaseStatement, caseKeyword, cases.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Case or Case Else statement. This statement is always the Begin of
        ''' a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
        ''' Kind=Case.
        ''' </summary>
        ''' <param name="caseKeyword">
        ''' The "Case" keyword
        ''' </param>
        ''' <param name="cases">
        ''' A list of clauses associated with this Case. If Kind=CaseElse, then this list
        ''' has exactly one child, which is a ElseCaseClause.
        ''' </param>
        Friend Shared Function CaseElseStatement(caseKeyword As KeywordSyntax, cases As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As CaseStatementSyntax
            Debug.Assert(caseKeyword IsNot Nothing AndAlso caseKeyword.Kind = SyntaxKind.CaseKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.CaseElseStatement, caseKeyword, cases.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CaseStatementSyntax)
            End If

            Dim result = New CaseStatementSyntax(SyntaxKind.CaseElseStatement, caseKeyword, cases.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The "Else" part in a Case Else statement.
        ''' </summary>
        ''' <param name="elseKeyword">
        ''' The "Else" keyword.
        ''' </param>
        Friend Shared Function ElseCaseClause(elseKeyword As KeywordSyntax) As ElseCaseClauseSyntax
            Debug.Assert(elseKeyword IsNot Nothing AndAlso elseKeyword.Kind = SyntaxKind.ElseKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ElseCaseClause, elseKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ElseCaseClauseSyntax)
            End If

            Dim result = New ElseCaseClauseSyntax(SyntaxKind.ElseCaseClause, elseKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a single value in a Case.
        ''' </summary>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Shared Function SimpleCaseClause(value As ExpressionSyntax) As SimpleCaseClauseSyntax
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.SimpleCaseClause, value, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SimpleCaseClauseSyntax)
            End If

            Dim result = New SimpleCaseClauseSyntax(SyntaxKind.SimpleCaseClause, value)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a range "expression To expression" in a Case.
        ''' </summary>
        ''' <param name="lowerBound">
        ''' The lower bound of the range.
        ''' </param>
        ''' <param name="toKeyword">
        ''' The "To" keyword
        ''' </param>
        ''' <param name="upperBound">
        ''' The upper bound of the range.
        ''' </param>
        Friend Shared Function RangeCaseClause(lowerBound As ExpressionSyntax, toKeyword As KeywordSyntax, upperBound As ExpressionSyntax) As RangeCaseClauseSyntax
            Debug.Assert(lowerBound IsNot Nothing)
            Debug.Assert(toKeyword IsNot Nothing AndAlso toKeyword.Kind = SyntaxKind.ToKeyword)
            Debug.Assert(upperBound IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.RangeCaseClause, lowerBound, toKeyword, upperBound, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, RangeCaseClauseSyntax)
            End If

            Dim result = New RangeCaseClauseSyntax(SyntaxKind.RangeCaseClause, lowerBound, toKeyword, upperBound)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a relation clause in a Case statement, such as "Is &gt; expression".
        ''' </summary>
        ''' <param name="isKeyword">
        ''' The "Is" keyword, if present.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
        ''' "&gt;=".
        ''' </param>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Shared Function CaseEqualsClause(isKeyword As KeywordSyntax, operatorToken As PunctuationSyntax, value As ExpressionSyntax) As RelationalCaseClauseSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.CaseEqualsClause, isKeyword, operatorToken, value, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, RelationalCaseClauseSyntax)
            End If

            Dim result = New RelationalCaseClauseSyntax(SyntaxKind.CaseEqualsClause, isKeyword, operatorToken, value)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a relation clause in a Case statement, such as "Is &gt; expression".
        ''' </summary>
        ''' <param name="isKeyword">
        ''' The "Is" keyword, if present.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
        ''' "&gt;=".
        ''' </param>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Shared Function CaseNotEqualsClause(isKeyword As KeywordSyntax, operatorToken As PunctuationSyntax, value As ExpressionSyntax) As RelationalCaseClauseSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LessThanGreaterThanToken)
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.CaseNotEqualsClause, isKeyword, operatorToken, value, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, RelationalCaseClauseSyntax)
            End If

            Dim result = New RelationalCaseClauseSyntax(SyntaxKind.CaseNotEqualsClause, isKeyword, operatorToken, value)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a relation clause in a Case statement, such as "Is &gt; expression".
        ''' </summary>
        ''' <param name="isKeyword">
        ''' The "Is" keyword, if present.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
        ''' "&gt;=".
        ''' </param>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Shared Function CaseLessThanClause(isKeyword As KeywordSyntax, operatorToken As PunctuationSyntax, value As ExpressionSyntax) As RelationalCaseClauseSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LessThanToken)
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.CaseLessThanClause, isKeyword, operatorToken, value, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, RelationalCaseClauseSyntax)
            End If

            Dim result = New RelationalCaseClauseSyntax(SyntaxKind.CaseLessThanClause, isKeyword, operatorToken, value)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a relation clause in a Case statement, such as "Is &gt; expression".
        ''' </summary>
        ''' <param name="isKeyword">
        ''' The "Is" keyword, if present.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
        ''' "&gt;=".
        ''' </param>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Shared Function CaseLessThanOrEqualClause(isKeyword As KeywordSyntax, operatorToken As PunctuationSyntax, value As ExpressionSyntax) As RelationalCaseClauseSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LessThanEqualsToken)
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.CaseLessThanOrEqualClause, isKeyword, operatorToken, value, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, RelationalCaseClauseSyntax)
            End If

            Dim result = New RelationalCaseClauseSyntax(SyntaxKind.CaseLessThanOrEqualClause, isKeyword, operatorToken, value)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a relation clause in a Case statement, such as "Is &gt; expression".
        ''' </summary>
        ''' <param name="isKeyword">
        ''' The "Is" keyword, if present.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
        ''' "&gt;=".
        ''' </param>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Shared Function CaseGreaterThanOrEqualClause(isKeyword As KeywordSyntax, operatorToken As PunctuationSyntax, value As ExpressionSyntax) As RelationalCaseClauseSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.GreaterThanEqualsToken)
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.CaseGreaterThanOrEqualClause, isKeyword, operatorToken, value, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, RelationalCaseClauseSyntax)
            End If

            Dim result = New RelationalCaseClauseSyntax(SyntaxKind.CaseGreaterThanOrEqualClause, isKeyword, operatorToken, value)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a relation clause in a Case statement, such as "Is &gt; expression".
        ''' </summary>
        ''' <param name="isKeyword">
        ''' The "Is" keyword, if present.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
        ''' "&gt;=".
        ''' </param>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Shared Function CaseGreaterThanClause(isKeyword As KeywordSyntax, operatorToken As PunctuationSyntax, value As ExpressionSyntax) As RelationalCaseClauseSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.GreaterThanToken)
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.CaseGreaterThanClause, isKeyword, operatorToken, value, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, RelationalCaseClauseSyntax)
            End If

            Dim result = New RelationalCaseClauseSyntax(SyntaxKind.CaseGreaterThanClause, isKeyword, operatorToken, value)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a relation clause in a Case statement, such as "Is &gt; expression".
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' RelationalCaseClauseSyntax. One of CaseEqualsClause, CaseNotEqualsClause,
        ''' CaseLessThanClause, CaseLessThanOrEqualClause, CaseGreaterThanOrEqualClause,
        ''' CaseGreaterThanClause.
        ''' </param>
        ''' <param name="isKeyword">
        ''' The "Is" keyword, if present.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
        ''' "&gt;=".
        ''' </param>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Shared Function RelationalCaseClause(kind As SyntaxKind, isKeyword As KeywordSyntax, operatorToken As PunctuationSyntax, value As ExpressionSyntax) As RelationalCaseClauseSyntax
            Debug.Assert(SyntaxFacts.IsRelationalCaseClause(kind))
            Debug.Assert(operatorToken IsNot Nothing AndAlso SyntaxFacts.IsRelationalCaseClauseOperatorToken(operatorToken.Kind))
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(kind, isKeyword, operatorToken, value, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, RelationalCaseClauseSyntax)
            End If

            Dim result = New RelationalCaseClauseSyntax(kind, isKeyword, operatorToken, value)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the "SyncLock" statement. This statement always occurs as the Begin
        ''' of a SyncLockBlock.
        ''' </summary>
        ''' <param name="syncLockKeyword">
        ''' The "SyncLock" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being synchronized on.
        ''' </param>
        Friend Shared Function SyncLockStatement(syncLockKeyword As KeywordSyntax, expression As ExpressionSyntax) As SyncLockStatementSyntax
            Debug.Assert(syncLockKeyword IsNot Nothing AndAlso syncLockKeyword.Kind = SyntaxKind.SyncLockKeyword)
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.SyncLockStatement, syncLockKeyword, expression, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SyncLockStatementSyntax)
            End If

            Dim result = New SyncLockStatementSyntax(SyntaxKind.SyncLockStatement, syncLockKeyword, expression)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Do-Loop block. The Kind property can be used to determine if this
        ''' is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
        ''' </summary>
        ''' <param name="doStatement">
        ''' The Do statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="loopStatement">
        ''' The Loop statement that ends the block.
        ''' </param>
        Friend Shared Function SimpleDoLoopBlock(doStatement As DoStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), loopStatement As LoopStatementSyntax) As DoLoopBlockSyntax
            Debug.Assert(doStatement IsNot Nothing)
            Debug.Assert(loopStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.SimpleDoLoopBlock, doStatement, statements.Node, loopStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, DoLoopBlockSyntax)
            End If

            Dim result = New DoLoopBlockSyntax(SyntaxKind.SimpleDoLoopBlock, doStatement, statements.Node, loopStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Do-Loop block. The Kind property can be used to determine if this
        ''' is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
        ''' </summary>
        ''' <param name="doStatement">
        ''' The Do statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="loopStatement">
        ''' The Loop statement that ends the block.
        ''' </param>
        Friend Shared Function DoWhileLoopBlock(doStatement As DoStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), loopStatement As LoopStatementSyntax) As DoLoopBlockSyntax
            Debug.Assert(doStatement IsNot Nothing)
            Debug.Assert(loopStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.DoWhileLoopBlock, doStatement, statements.Node, loopStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, DoLoopBlockSyntax)
            End If

            Dim result = New DoLoopBlockSyntax(SyntaxKind.DoWhileLoopBlock, doStatement, statements.Node, loopStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Do-Loop block. The Kind property can be used to determine if this
        ''' is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
        ''' </summary>
        ''' <param name="doStatement">
        ''' The Do statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="loopStatement">
        ''' The Loop statement that ends the block.
        ''' </param>
        Friend Shared Function DoUntilLoopBlock(doStatement As DoStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), loopStatement As LoopStatementSyntax) As DoLoopBlockSyntax
            Debug.Assert(doStatement IsNot Nothing)
            Debug.Assert(loopStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.DoUntilLoopBlock, doStatement, statements.Node, loopStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, DoLoopBlockSyntax)
            End If

            Dim result = New DoLoopBlockSyntax(SyntaxKind.DoUntilLoopBlock, doStatement, statements.Node, loopStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Do-Loop block. The Kind property can be used to determine if this
        ''' is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
        ''' </summary>
        ''' <param name="doStatement">
        ''' The Do statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="loopStatement">
        ''' The Loop statement that ends the block.
        ''' </param>
        Friend Shared Function DoLoopWhileBlock(doStatement As DoStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), loopStatement As LoopStatementSyntax) As DoLoopBlockSyntax
            Debug.Assert(doStatement IsNot Nothing)
            Debug.Assert(loopStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.DoLoopWhileBlock, doStatement, statements.Node, loopStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, DoLoopBlockSyntax)
            End If

            Dim result = New DoLoopBlockSyntax(SyntaxKind.DoLoopWhileBlock, doStatement, statements.Node, loopStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Do-Loop block. The Kind property can be used to determine if this
        ''' is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
        ''' </summary>
        ''' <param name="doStatement">
        ''' The Do statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="loopStatement">
        ''' The Loop statement that ends the block.
        ''' </param>
        Friend Shared Function DoLoopUntilBlock(doStatement As DoStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), loopStatement As LoopStatementSyntax) As DoLoopBlockSyntax
            Debug.Assert(doStatement IsNot Nothing)
            Debug.Assert(loopStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.DoLoopUntilBlock, doStatement, statements.Node, loopStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, DoLoopBlockSyntax)
            End If

            Dim result = New DoLoopBlockSyntax(SyntaxKind.DoLoopUntilBlock, doStatement, statements.Node, loopStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Do-Loop block. The Kind property can be used to determine if this
        ''' is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of DoLoopBlockSyntax.
        ''' One of SimpleDoLoopBlock, DoWhileLoopBlock, DoUntilLoopBlock, DoLoopWhileBlock,
        ''' DoLoopUntilBlock.
        ''' </param>
        ''' <param name="doStatement">
        ''' The Do statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="loopStatement">
        ''' The Loop statement that ends the block.
        ''' </param>
        Friend Shared Function DoLoopBlock(kind As SyntaxKind, doStatement As DoStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), loopStatement As LoopStatementSyntax) As DoLoopBlockSyntax
            Debug.Assert(SyntaxFacts.IsDoLoopBlock(kind))
            Debug.Assert(doStatement IsNot Nothing)
            Debug.Assert(loopStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(kind, doStatement, statements.Node, loopStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, DoLoopBlockSyntax)
            End If

            Dim result = New DoLoopBlockSyntax(kind, doStatement, statements.Node, loopStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The Do statement that begins a Do-Loop block.
        ''' </summary>
        ''' <param name="doKeyword">
        ''' The "Do" keyword.
        ''' </param>
        ''' <param name="whileOrUntilClause">
        ''' The "While expression" or "Until expression" clause of the Do statement, if
        ''' present.
        ''' </param>
        Friend Shared Function SimpleDoStatement(doKeyword As KeywordSyntax, whileOrUntilClause As WhileOrUntilClauseSyntax) As DoStatementSyntax
            Debug.Assert(doKeyword IsNot Nothing AndAlso doKeyword.Kind = SyntaxKind.DoKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.SimpleDoStatement, doKeyword, whileOrUntilClause, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, DoStatementSyntax)
            End If

            Dim result = New DoStatementSyntax(SyntaxKind.SimpleDoStatement, doKeyword, whileOrUntilClause)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The Do statement that begins a Do-Loop block.
        ''' </summary>
        ''' <param name="doKeyword">
        ''' The "Do" keyword.
        ''' </param>
        ''' <param name="whileOrUntilClause">
        ''' The "While expression" or "Until expression" clause of the Do statement, if
        ''' present.
        ''' </param>
        Friend Shared Function DoWhileStatement(doKeyword As KeywordSyntax, whileOrUntilClause As WhileOrUntilClauseSyntax) As DoStatementSyntax
            Debug.Assert(doKeyword IsNot Nothing AndAlso doKeyword.Kind = SyntaxKind.DoKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.DoWhileStatement, doKeyword, whileOrUntilClause, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, DoStatementSyntax)
            End If

            Dim result = New DoStatementSyntax(SyntaxKind.DoWhileStatement, doKeyword, whileOrUntilClause)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The Do statement that begins a Do-Loop block.
        ''' </summary>
        ''' <param name="doKeyword">
        ''' The "Do" keyword.
        ''' </param>
        ''' <param name="whileOrUntilClause">
        ''' The "While expression" or "Until expression" clause of the Do statement, if
        ''' present.
        ''' </param>
        Friend Shared Function DoUntilStatement(doKeyword As KeywordSyntax, whileOrUntilClause As WhileOrUntilClauseSyntax) As DoStatementSyntax
            Debug.Assert(doKeyword IsNot Nothing AndAlso doKeyword.Kind = SyntaxKind.DoKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.DoUntilStatement, doKeyword, whileOrUntilClause, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, DoStatementSyntax)
            End If

            Dim result = New DoStatementSyntax(SyntaxKind.DoUntilStatement, doKeyword, whileOrUntilClause)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The Do statement that begins a Do-Loop block.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of DoStatementSyntax.
        ''' One of SimpleDoStatement, DoWhileStatement, DoUntilStatement.
        ''' </param>
        ''' <param name="doKeyword">
        ''' The "Do" keyword.
        ''' </param>
        ''' <param name="whileOrUntilClause">
        ''' The "While expression" or "Until expression" clause of the Do statement, if
        ''' present.
        ''' </param>
        Friend Shared Function DoStatement(kind As SyntaxKind, doKeyword As KeywordSyntax, whileOrUntilClause As WhileOrUntilClauseSyntax) As DoStatementSyntax
            Debug.Assert(SyntaxFacts.IsDoStatement(kind))
            Debug.Assert(doKeyword IsNot Nothing AndAlso doKeyword.Kind = SyntaxKind.DoKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(kind, doKeyword, whileOrUntilClause, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, DoStatementSyntax)
            End If

            Dim result = New DoStatementSyntax(kind, doKeyword, whileOrUntilClause)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The Loop statement that begins a Do-Loop block.
        ''' </summary>
        ''' <param name="loopKeyword">
        ''' The "Loop" keyword.
        ''' </param>
        ''' <param name="whileOrUntilClause">
        ''' The "While expression" or "Until expression" clause of the Loop statement, if
        ''' present.
        ''' </param>
        Friend Shared Function SimpleLoopStatement(loopKeyword As KeywordSyntax, whileOrUntilClause As WhileOrUntilClauseSyntax) As LoopStatementSyntax
            Debug.Assert(loopKeyword IsNot Nothing AndAlso loopKeyword.Kind = SyntaxKind.LoopKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.SimpleLoopStatement, loopKeyword, whileOrUntilClause, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LoopStatementSyntax)
            End If

            Dim result = New LoopStatementSyntax(SyntaxKind.SimpleLoopStatement, loopKeyword, whileOrUntilClause)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The Loop statement that begins a Do-Loop block.
        ''' </summary>
        ''' <param name="loopKeyword">
        ''' The "Loop" keyword.
        ''' </param>
        ''' <param name="whileOrUntilClause">
        ''' The "While expression" or "Until expression" clause of the Loop statement, if
        ''' present.
        ''' </param>
        Friend Shared Function LoopWhileStatement(loopKeyword As KeywordSyntax, whileOrUntilClause As WhileOrUntilClauseSyntax) As LoopStatementSyntax
            Debug.Assert(loopKeyword IsNot Nothing AndAlso loopKeyword.Kind = SyntaxKind.LoopKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.LoopWhileStatement, loopKeyword, whileOrUntilClause, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LoopStatementSyntax)
            End If

            Dim result = New LoopStatementSyntax(SyntaxKind.LoopWhileStatement, loopKeyword, whileOrUntilClause)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The Loop statement that begins a Do-Loop block.
        ''' </summary>
        ''' <param name="loopKeyword">
        ''' The "Loop" keyword.
        ''' </param>
        ''' <param name="whileOrUntilClause">
        ''' The "While expression" or "Until expression" clause of the Loop statement, if
        ''' present.
        ''' </param>
        Friend Shared Function LoopUntilStatement(loopKeyword As KeywordSyntax, whileOrUntilClause As WhileOrUntilClauseSyntax) As LoopStatementSyntax
            Debug.Assert(loopKeyword IsNot Nothing AndAlso loopKeyword.Kind = SyntaxKind.LoopKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.LoopUntilStatement, loopKeyword, whileOrUntilClause, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LoopStatementSyntax)
            End If

            Dim result = New LoopStatementSyntax(SyntaxKind.LoopUntilStatement, loopKeyword, whileOrUntilClause)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The Loop statement that begins a Do-Loop block.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' LoopStatementSyntax. One of SimpleLoopStatement, LoopWhileStatement,
        ''' LoopUntilStatement.
        ''' </param>
        ''' <param name="loopKeyword">
        ''' The "Loop" keyword.
        ''' </param>
        ''' <param name="whileOrUntilClause">
        ''' The "While expression" or "Until expression" clause of the Loop statement, if
        ''' present.
        ''' </param>
        Friend Shared Function LoopStatement(kind As SyntaxKind, loopKeyword As KeywordSyntax, whileOrUntilClause As WhileOrUntilClauseSyntax) As LoopStatementSyntax
            Debug.Assert(SyntaxFacts.IsLoopStatement(kind))
            Debug.Assert(loopKeyword IsNot Nothing AndAlso loopKeyword.Kind = SyntaxKind.LoopKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(kind, loopKeyword, whileOrUntilClause, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LoopStatementSyntax)
            End If

            Dim result = New LoopStatementSyntax(kind, loopKeyword, whileOrUntilClause)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "While expression" or "Until expression" in a Do or Loop
        ''' statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
        ''' indicate which kind of clause.
        ''' </summary>
        ''' <param name="whileOrUntilKeyword">
        ''' The "While" or "Until" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression after the While or Until.
        ''' </param>
        Friend Shared Function WhileClause(whileOrUntilKeyword As KeywordSyntax, condition As ExpressionSyntax) As WhileOrUntilClauseSyntax
            Debug.Assert(whileOrUntilKeyword IsNot Nothing AndAlso whileOrUntilKeyword.Kind = SyntaxKind.WhileKeyword)
            Debug.Assert(condition IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.WhileClause, whileOrUntilKeyword, condition, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, WhileOrUntilClauseSyntax)
            End If

            Dim result = New WhileOrUntilClauseSyntax(SyntaxKind.WhileClause, whileOrUntilKeyword, condition)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "While expression" or "Until expression" in a Do or Loop
        ''' statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
        ''' indicate which kind of clause.
        ''' </summary>
        ''' <param name="whileOrUntilKeyword">
        ''' The "While" or "Until" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression after the While or Until.
        ''' </param>
        Friend Shared Function UntilClause(whileOrUntilKeyword As KeywordSyntax, condition As ExpressionSyntax) As WhileOrUntilClauseSyntax
            Debug.Assert(whileOrUntilKeyword IsNot Nothing AndAlso whileOrUntilKeyword.Kind = SyntaxKind.UntilKeyword)
            Debug.Assert(condition IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.UntilClause, whileOrUntilKeyword, condition, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, WhileOrUntilClauseSyntax)
            End If

            Dim result = New WhileOrUntilClauseSyntax(SyntaxKind.UntilClause, whileOrUntilKeyword, condition)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "While expression" or "Until expression" in a Do or Loop
        ''' statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
        ''' indicate which kind of clause.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' WhileOrUntilClauseSyntax. One of WhileClause, UntilClause.
        ''' </param>
        ''' <param name="whileOrUntilKeyword">
        ''' The "While" or "Until" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression after the While or Until.
        ''' </param>
        Friend Shared Function WhileOrUntilClause(kind As SyntaxKind, whileOrUntilKeyword As KeywordSyntax, condition As ExpressionSyntax) As WhileOrUntilClauseSyntax
            Debug.Assert(SyntaxFacts.IsWhileOrUntilClause(kind))
            Debug.Assert(whileOrUntilKeyword IsNot Nothing AndAlso SyntaxFacts.IsWhileOrUntilClauseWhileOrUntilKeyword(whileOrUntilKeyword.Kind))
            Debug.Assert(condition IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(kind, whileOrUntilKeyword, condition, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, WhileOrUntilClauseSyntax)
            End If

            Dim result = New WhileOrUntilClauseSyntax(kind, whileOrUntilKeyword, condition)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The While statement that begins a While...End While block. This statement
        ''' always occurs as the Begin of a WhileBlock.
        ''' </summary>
        ''' <param name="whileKeyword">
        ''' The "While" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression that controls the While loop.
        ''' </param>
        Friend Shared Function WhileStatement(whileKeyword As KeywordSyntax, condition As ExpressionSyntax) As WhileStatementSyntax
            Debug.Assert(whileKeyword IsNot Nothing AndAlso whileKeyword.Kind = SyntaxKind.WhileKeyword)
            Debug.Assert(condition IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.WhileStatement, whileKeyword, condition, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, WhileStatementSyntax)
            End If

            Dim result = New WhileStatementSyntax(SyntaxKind.WhileStatement, whileKeyword, condition)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a For block, including the introducing statement, the body and the
        ''' "Next" (which can be omitted if a containing For has a Next with multiple
        ''' variables).
        ''' </summary>
        ''' <param name="forStatement">
        ''' The For statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the For or For Each loop. This might be an empty
        ''' list.
        ''' </param>
        ''' <param name="nextStatement">
        ''' The Next statement that ends the block. If two For or For Each statements are
        ''' ended by a single Next statement, the inner For will not have a Next statement.
        ''' </param>
        Friend Shared Function ForBlock(forStatement As ForStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), nextStatement As NextStatementSyntax) As ForBlockSyntax
            Debug.Assert(forStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ForBlock, forStatement, statements.Node, nextStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ForBlockSyntax)
            End If

            Dim result = New ForBlockSyntax(SyntaxKind.ForBlock, forStatement, statements.Node, nextStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a For Each block, including the introducing statement, the body and
        ''' the "Next" (which can be omitted if a containing For has a Next with multiple
        ''' variables).
        ''' </summary>
        ''' <param name="forEachStatement">
        ''' The For Each statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the For or For Each loop. This might be an empty
        ''' list.
        ''' </param>
        ''' <param name="nextStatement">
        ''' The Next statement that ends the block. If two For or For Each statements are
        ''' ended by a single Next statement, the inner For will not have a Next statement.
        ''' </param>
        Friend Shared Function ForEachBlock(forEachStatement As ForEachStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), nextStatement As NextStatementSyntax) As ForEachBlockSyntax
            Debug.Assert(forEachStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ForEachBlock, forEachStatement, statements.Node, nextStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ForEachBlockSyntax)
            End If

            Dim result = New ForEachBlockSyntax(SyntaxKind.ForEachBlock, forEachStatement, statements.Node, nextStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The For statement that begins a For-Next block. This statement always occurs as
        ''' the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
        ''' corresponding Next statement. However, multiple nested For statements are ended
        ''' by a single Next statement with multiple variables, then the inner For
        ''' statements will have End set to Nothing, and the Next statement is the End of
        ''' the outermost For statement that is being ended.
        ''' </summary>
        ''' <param name="forKeyword">
        ''' The "For" keyword.
        ''' </param>
        ''' <param name="controlVariable">
        ''' If the For or For Each statement is of a form that does not declare a new loop
        ''' control variable, this is the expression that denotes the loop control
        ''' variable. If this loop is of a form that does declare a new control variable,
        ''' this is a VariableDeclarator that has the variable being declared.
        ''' </param>
        ''' <param name="equalsToken">
        ''' The "=" token.
        ''' </param>
        ''' <param name="fromValue">
        ''' The expression denoting the initial value of the iteration.
        ''' </param>
        ''' <param name="toKeyword">
        ''' The "To" keyword.
        ''' </param>
        ''' <param name="toValue">
        ''' The expression denoting the final value of the iteration.
        ''' </param>
        ''' <param name="stepClause">
        ''' The optional Step clause.
        ''' </param>
        Friend Shared Function ForStatement(forKeyword As KeywordSyntax, controlVariable As VisualBasicSyntaxNode, equalsToken As PunctuationSyntax, fromValue As ExpressionSyntax, toKeyword As KeywordSyntax, toValue As ExpressionSyntax, stepClause As ForStepClauseSyntax) As ForStatementSyntax
            Debug.Assert(forKeyword IsNot Nothing AndAlso forKeyword.Kind = SyntaxKind.ForKeyword)
            Debug.Assert(controlVariable IsNot Nothing)
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(fromValue IsNot Nothing)
            Debug.Assert(toKeyword IsNot Nothing AndAlso toKeyword.Kind = SyntaxKind.ToKeyword)
            Debug.Assert(toValue IsNot Nothing)
            Return New ForStatementSyntax(SyntaxKind.ForStatement, forKeyword, controlVariable, equalsToken, fromValue, toKeyword, toValue, stepClause)
        End Function


        ''' <summary>
        ''' The Step clause in a For Statement.
        ''' </summary>
        ''' <param name="stepKeyword">
        ''' The "Step" keyword.
        ''' </param>
        ''' <param name="stepValue">
        ''' The expression denoting the step increment.
        ''' </param>
        Friend Shared Function ForStepClause(stepKeyword As KeywordSyntax, stepValue As ExpressionSyntax) As ForStepClauseSyntax
            Debug.Assert(stepKeyword IsNot Nothing AndAlso stepKeyword.Kind = SyntaxKind.StepKeyword)
            Debug.Assert(stepValue IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ForStepClause, stepKeyword, stepValue, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ForStepClauseSyntax)
            End If

            Dim result = New ForStepClauseSyntax(SyntaxKind.ForStepClause, stepKeyword, stepValue)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The For Each statement that begins a For Each-Next block. This statement always
        ''' occurs as the Begin of a ForBlock, and the body of the For Each-Next is the
        ''' Body of that ForBlock. Most of the time, the End of that ForBlock is the
        ''' corresponding Next statement. However, multiple nested For statements are ended
        ''' by a single Next statement with multiple variables, then the inner For
        ''' statements will have End set to Nothing, and the Next statement is the End of
        ''' the outermost For statement that is being ended.
        ''' </summary>
        ''' <param name="forKeyword">
        ''' The "For" keyword.
        ''' </param>
        ''' <param name="eachKeyword">
        ''' The "Each" keyword.
        ''' </param>
        ''' <param name="controlVariable">
        ''' If the For or For Each statement is of a form that does not declare a new loop
        ''' control variable, this is the expression that denotes the loop control
        ''' variable. If this loop is of a form that does declare a new control variable,
        ''' this is a VariableDeclarator that has the variable being declared.
        ''' </param>
        ''' <param name="inKeyword">
        ''' The "In" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression denoting the collection to iterate over.
        ''' </param>
        Friend Shared Function ForEachStatement(forKeyword As KeywordSyntax, eachKeyword As KeywordSyntax, controlVariable As VisualBasicSyntaxNode, inKeyword As KeywordSyntax, expression As ExpressionSyntax) As ForEachStatementSyntax
            Debug.Assert(forKeyword IsNot Nothing AndAlso forKeyword.Kind = SyntaxKind.ForKeyword)
            Debug.Assert(eachKeyword IsNot Nothing AndAlso eachKeyword.Kind = SyntaxKind.EachKeyword)
            Debug.Assert(controlVariable IsNot Nothing)
            Debug.Assert(inKeyword IsNot Nothing AndAlso inKeyword.Kind = SyntaxKind.InKeyword)
            Debug.Assert(expression IsNot Nothing)
            Return New ForEachStatementSyntax(SyntaxKind.ForEachStatement, forKeyword, eachKeyword, controlVariable, inKeyword, expression)
        End Function


        ''' <summary>
        ''' The Next statement that ends a For-Next or For Each-Next block. This statement
        ''' always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
        ''' and the body of the For-Next is the Body of that ForBlock. The Begin of that
        ''' ForBlock has the corresponding For or For Each statement.
        ''' </summary>
        ''' <param name="nextKeyword">
        ''' The "Next" keyword.
        ''' </param>
        ''' <param name="controlVariables">
        ''' The variables in the Next statement, if present
        ''' </param>
        Friend Shared Function NextStatement(nextKeyword As KeywordSyntax, controlVariables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As NextStatementSyntax
            Debug.Assert(nextKeyword IsNot Nothing AndAlso nextKeyword.Kind = SyntaxKind.NextKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.NextStatement, nextKeyword, controlVariables.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, NextStatementSyntax)
            End If

            Dim result = New NextStatementSyntax(SyntaxKind.NextStatement, nextKeyword, controlVariables.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The Using statement that begins a Using block. This statement always occurs as
        ''' the Begin of a UsingBlock, and the body of the Using is the Body of that
        ''' UsingBlock.
        ''' </summary>
        ''' <param name="usingKeyword">
        ''' The "Using" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' If the Using statement is of a form that does not declare a new variable, this
        ''' is the expression used in the using. Otherwise, Nothing is returned.
        ''' </param>
        ''' <param name="variables">
        ''' If the Using statement is of a form that declares one or more new variables,
        ''' this is the list of variable declarations. Otherwise, Nothing is returned.
        ''' </param>
        Friend Shared Function UsingStatement(usingKeyword As KeywordSyntax, expression As ExpressionSyntax, variables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As UsingStatementSyntax
            Debug.Assert(usingKeyword IsNot Nothing AndAlso usingKeyword.Kind = SyntaxKind.UsingKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.UsingStatement, usingKeyword, expression, variables.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, UsingStatementSyntax)
            End If

            Dim result = New UsingStatementSyntax(SyntaxKind.UsingStatement, usingKeyword, expression, variables.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Throw statement.
        ''' </summary>
        ''' <param name="throwKeyword">
        ''' The "Throw" keyword
        ''' </param>
        ''' <param name="expression">
        ''' The expression denoting the value being thrown.
        ''' </param>
        Friend Shared Function ThrowStatement(throwKeyword As KeywordSyntax, expression As ExpressionSyntax) As ThrowStatementSyntax
            Debug.Assert(throwKeyword IsNot Nothing AndAlso throwKeyword.Kind = SyntaxKind.ThrowKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ThrowStatement, throwKeyword, expression, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ThrowStatementSyntax)
            End If

            Dim result = New ThrowStatementSyntax(SyntaxKind.ThrowStatement, throwKeyword, expression)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Shared Function SimpleAssignmentStatement(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.SimpleAssignmentStatement, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(SyntaxKind.SimpleAssignmentStatement, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Shared Function MidAssignmentStatement(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.MidAssignmentStatement, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(SyntaxKind.MidAssignmentStatement, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Shared Function AddAssignmentStatement(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.PlusEqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.AddAssignmentStatement, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(SyntaxKind.AddAssignmentStatement, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Shared Function SubtractAssignmentStatement(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.MinusEqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.SubtractAssignmentStatement, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(SyntaxKind.SubtractAssignmentStatement, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Shared Function MultiplyAssignmentStatement(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.AsteriskEqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.MultiplyAssignmentStatement, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(SyntaxKind.MultiplyAssignmentStatement, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Shared Function DivideAssignmentStatement(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.SlashEqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.DivideAssignmentStatement, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(SyntaxKind.DivideAssignmentStatement, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Shared Function IntegerDivideAssignmentStatement(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.BackslashEqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.IntegerDivideAssignmentStatement, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(SyntaxKind.IntegerDivideAssignmentStatement, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Shared Function ExponentiateAssignmentStatement(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.CaretEqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ExponentiateAssignmentStatement, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(SyntaxKind.ExponentiateAssignmentStatement, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Shared Function LeftShiftAssignmentStatement(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LessThanLessThanEqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.LeftShiftAssignmentStatement, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(SyntaxKind.LeftShiftAssignmentStatement, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Shared Function RightShiftAssignmentStatement(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.GreaterThanGreaterThanEqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.RightShiftAssignmentStatement, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(SyntaxKind.RightShiftAssignmentStatement, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Shared Function ConcatenateAssignmentStatement(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.AmpersandEqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ConcatenateAssignmentStatement, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(SyntaxKind.ConcatenateAssignmentStatement, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' AssignmentStatementSyntax. One of SimpleAssignmentStatement,
        ''' MidAssignmentStatement, AddAssignmentStatement, SubtractAssignmentStatement,
        ''' MultiplyAssignmentStatement, DivideAssignmentStatement,
        ''' IntegerDivideAssignmentStatement, ExponentiateAssignmentStatement,
        ''' LeftShiftAssignmentStatement, RightShiftAssignmentStatement,
        ''' ConcatenateAssignmentStatement.
        ''' </param>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Shared Function AssignmentStatement(kind As SyntaxKind, left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(SyntaxFacts.IsAssignmentStatement(kind))
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso SyntaxFacts.IsAssignmentStatementOperatorToken(operatorToken.Kind))
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(kind, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(kind, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a left-hand side of a MidAssignment statement.
        ''' </summary>
        ''' <param name="mid">
        ''' The "Mid" possibly followed by a type character.
        ''' </param>
        ''' <param name="argumentList">
        ''' The argument list.
        ''' </param>
        Friend Shared Function MidExpression(mid As IdentifierTokenSyntax, argumentList As ArgumentListSyntax) As MidExpressionSyntax
            Debug.Assert(mid IsNot Nothing AndAlso mid.Kind = SyntaxKind.IdentifierToken)
            Debug.Assert(argumentList IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.MidExpression, mid, argumentList, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MidExpressionSyntax)
            End If

            Dim result = New MidExpressionSyntax(SyntaxKind.MidExpression, mid, argumentList)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represent a call statement (also known as a invocation statement).
        ''' </summary>
        ''' <param name="callKeyword">
        ''' The "Call" keyword.
        ''' </param>
        ''' <param name="invocation">
        ''' The expression denoting the call. This could be an Invocation or a MemberAccess
        ''' (in the case where no parentheses were supplied.)
        ''' </param>
        Friend Shared Function CallStatement(callKeyword As KeywordSyntax, invocation As ExpressionSyntax) As CallStatementSyntax
            Debug.Assert(callKeyword IsNot Nothing AndAlso callKeyword.Kind = SyntaxKind.CallKeyword)
            Debug.Assert(invocation IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.CallStatement, callKeyword, invocation, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CallStatementSyntax)
            End If

            Dim result = New CallStatementSyntax(SyntaxKind.CallStatement, callKeyword, invocation)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an AddHandler or RemoveHandler statement. The Kind property
        ''' determines which one.
        ''' </summary>
        ''' <param name="addHandlerOrRemoveHandlerKeyword">
        ''' The "AddHandler" or "RemoveHandler" keyword.
        ''' </param>
        ''' <param name="eventExpression">
        ''' The event being accessed.
        ''' </param>
        ''' <param name="commaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="delegateExpression">
        ''' The delegate being added or removed.
        ''' </param>
        Friend Shared Function AddHandlerStatement(addHandlerOrRemoveHandlerKeyword As KeywordSyntax, eventExpression As ExpressionSyntax, commaToken As PunctuationSyntax, delegateExpression As ExpressionSyntax) As AddRemoveHandlerStatementSyntax
            Debug.Assert(addHandlerOrRemoveHandlerKeyword IsNot Nothing AndAlso addHandlerOrRemoveHandlerKeyword.Kind = SyntaxKind.AddHandlerKeyword)
            Debug.Assert(eventExpression IsNot Nothing)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(delegateExpression IsNot Nothing)
            Return New AddRemoveHandlerStatementSyntax(SyntaxKind.AddHandlerStatement, addHandlerOrRemoveHandlerKeyword, eventExpression, commaToken, delegateExpression)
        End Function


        ''' <summary>
        ''' Represents an AddHandler or RemoveHandler statement. The Kind property
        ''' determines which one.
        ''' </summary>
        ''' <param name="addHandlerOrRemoveHandlerKeyword">
        ''' The "AddHandler" or "RemoveHandler" keyword.
        ''' </param>
        ''' <param name="eventExpression">
        ''' The event being accessed.
        ''' </param>
        ''' <param name="commaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="delegateExpression">
        ''' The delegate being added or removed.
        ''' </param>
        Friend Shared Function RemoveHandlerStatement(addHandlerOrRemoveHandlerKeyword As KeywordSyntax, eventExpression As ExpressionSyntax, commaToken As PunctuationSyntax, delegateExpression As ExpressionSyntax) As AddRemoveHandlerStatementSyntax
            Debug.Assert(addHandlerOrRemoveHandlerKeyword IsNot Nothing AndAlso addHandlerOrRemoveHandlerKeyword.Kind = SyntaxKind.RemoveHandlerKeyword)
            Debug.Assert(eventExpression IsNot Nothing)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(delegateExpression IsNot Nothing)
            Return New AddRemoveHandlerStatementSyntax(SyntaxKind.RemoveHandlerStatement, addHandlerOrRemoveHandlerKeyword, eventExpression, commaToken, delegateExpression)
        End Function


        ''' <summary>
        ''' Represents an AddHandler or RemoveHandler statement. The Kind property
        ''' determines which one.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' AddRemoveHandlerStatementSyntax. One of AddHandlerStatement,
        ''' RemoveHandlerStatement.
        ''' </param>
        ''' <param name="addHandlerOrRemoveHandlerKeyword">
        ''' The "AddHandler" or "RemoveHandler" keyword.
        ''' </param>
        ''' <param name="eventExpression">
        ''' The event being accessed.
        ''' </param>
        ''' <param name="commaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="delegateExpression">
        ''' The delegate being added or removed.
        ''' </param>
        Friend Shared Function AddRemoveHandlerStatement(kind As SyntaxKind, addHandlerOrRemoveHandlerKeyword As KeywordSyntax, eventExpression As ExpressionSyntax, commaToken As PunctuationSyntax, delegateExpression As ExpressionSyntax) As AddRemoveHandlerStatementSyntax
            Debug.Assert(SyntaxFacts.IsAddRemoveHandlerStatement(kind))
            Debug.Assert(addHandlerOrRemoveHandlerKeyword IsNot Nothing AndAlso SyntaxFacts.IsAddRemoveHandlerStatementAddHandlerOrRemoveHandlerKeyword(addHandlerOrRemoveHandlerKeyword.Kind))
            Debug.Assert(eventExpression IsNot Nothing)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(delegateExpression IsNot Nothing)
            Return New AddRemoveHandlerStatementSyntax(kind, addHandlerOrRemoveHandlerKeyword, eventExpression, commaToken, delegateExpression)
        End Function


        ''' <summary>
        ''' Represent a RaiseEvent statement.
        ''' </summary>
        ''' <param name="raiseEventKeyword">
        ''' The "RaiseEvent" keyword
        ''' </param>
        ''' <param name="name">
        ''' The name of the event being raised.
        ''' </param>
        ''' <param name="argumentList">
        ''' The argument list, if present.
        ''' </param>
        Friend Shared Function RaiseEventStatement(raiseEventKeyword As KeywordSyntax, name As IdentifierNameSyntax, argumentList As ArgumentListSyntax) As RaiseEventStatementSyntax
            Debug.Assert(raiseEventKeyword IsNot Nothing AndAlso raiseEventKeyword.Kind = SyntaxKind.RaiseEventKeyword)
            Debug.Assert(name IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.RaiseEventStatement, raiseEventKeyword, name, argumentList, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, RaiseEventStatementSyntax)
            End If

            Dim result = New RaiseEventStatementSyntax(SyntaxKind.RaiseEventStatement, raiseEventKeyword, name, argumentList)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "With" statement. This statement always occurs as the
        ''' BeginStatement of a WithBlock, and the body of the With is the Body of that
        ''' WithBlock.
        ''' </summary>
        ''' <param name="withKeyword">
        ''' The "With" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression that is the operand of the With statement.
        ''' </param>
        Friend Shared Function WithStatement(withKeyword As KeywordSyntax, expression As ExpressionSyntax) As WithStatementSyntax
            Debug.Assert(withKeyword IsNot Nothing AndAlso withKeyword.Kind = SyntaxKind.WithKeyword)
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.WithStatement, withKeyword, expression, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, WithStatementSyntax)
            End If

            Dim result = New WithStatementSyntax(SyntaxKind.WithStatement, withKeyword, expression)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a ReDim statement.
        ''' </summary>
        ''' <param name="reDimKeyword">
        ''' The "ReDim" keyword.
        ''' </param>
        ''' <param name="preserveKeyword">
        ''' Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
        ''' Kind=RedimPreserve.
        ''' </param>
        ''' <param name="clauses">
        ''' The list of ReDim clauses.
        ''' </param>
        Friend Shared Function ReDimStatement(reDimKeyword As KeywordSyntax, preserveKeyword As KeywordSyntax, clauses As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As ReDimStatementSyntax
            Debug.Assert(reDimKeyword IsNot Nothing AndAlso reDimKeyword.Kind = SyntaxKind.ReDimKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ReDimStatement, reDimKeyword, preserveKeyword, clauses.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ReDimStatementSyntax)
            End If

            Dim result = New ReDimStatementSyntax(SyntaxKind.ReDimStatement, reDimKeyword, preserveKeyword, clauses.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a ReDim statement.
        ''' </summary>
        ''' <param name="reDimKeyword">
        ''' The "ReDim" keyword.
        ''' </param>
        ''' <param name="preserveKeyword">
        ''' Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
        ''' Kind=RedimPreserve.
        ''' </param>
        ''' <param name="clauses">
        ''' The list of ReDim clauses.
        ''' </param>
        Friend Shared Function ReDimPreserveStatement(reDimKeyword As KeywordSyntax, preserveKeyword As KeywordSyntax, clauses As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As ReDimStatementSyntax
            Debug.Assert(reDimKeyword IsNot Nothing AndAlso reDimKeyword.Kind = SyntaxKind.ReDimKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ReDimPreserveStatement, reDimKeyword, preserveKeyword, clauses.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ReDimStatementSyntax)
            End If

            Dim result = New ReDimStatementSyntax(SyntaxKind.ReDimPreserveStatement, reDimKeyword, preserveKeyword, clauses.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a ReDim statement clause.
        ''' </summary>
        ''' <param name="expression">
        ''' The target of the ReDim statement.
        ''' </param>
        ''' <param name="arrayBounds">
        ''' The ArraySizeInitializationModifier.
        ''' </param>
        Friend Shared Function RedimClause(expression As ExpressionSyntax, arrayBounds As ArgumentListSyntax) As RedimClauseSyntax
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(arrayBounds IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.RedimClause, expression, arrayBounds, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, RedimClauseSyntax)
            End If

            Dim result = New RedimClauseSyntax(SyntaxKind.RedimClause, expression, arrayBounds)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "Erase" statement.
        ''' </summary>
        ''' <param name="eraseKeyword">
        ''' The "Erase" keyword.
        ''' </param>
        ''' <param name="expressions">
        ''' A list of expressions denoting the arrays to erase.
        ''' </param>
        Friend Shared Function EraseStatement(eraseKeyword As KeywordSyntax, expressions As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As EraseStatementSyntax
            Debug.Assert(eraseKeyword IsNot Nothing AndAlso eraseKeyword.Kind = SyntaxKind.EraseKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EraseStatement, eraseKeyword, expressions.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EraseStatementSyntax)
            End If

            Dim result = New EraseStatementSyntax(SyntaxKind.EraseStatement, eraseKeyword, expressions.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Shared Function CharacterLiteralExpression(token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(token IsNot Nothing AndAlso SyntaxFacts.IsLiteralExpressionToken(token.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.CharacterLiteralExpression, token, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LiteralExpressionSyntax)
            End If

            Dim result = New LiteralExpressionSyntax(SyntaxKind.CharacterLiteralExpression, token)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Shared Function TrueLiteralExpression(token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(token IsNot Nothing AndAlso SyntaxFacts.IsLiteralExpressionToken(token.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.TrueLiteralExpression, token, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LiteralExpressionSyntax)
            End If

            Dim result = New LiteralExpressionSyntax(SyntaxKind.TrueLiteralExpression, token)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Shared Function FalseLiteralExpression(token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(token IsNot Nothing AndAlso SyntaxFacts.IsLiteralExpressionToken(token.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.FalseLiteralExpression, token, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LiteralExpressionSyntax)
            End If

            Dim result = New LiteralExpressionSyntax(SyntaxKind.FalseLiteralExpression, token)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Shared Function NumericLiteralExpression(token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(token IsNot Nothing AndAlso SyntaxFacts.IsLiteralExpressionToken(token.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.NumericLiteralExpression, token, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LiteralExpressionSyntax)
            End If

            Dim result = New LiteralExpressionSyntax(SyntaxKind.NumericLiteralExpression, token)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Shared Function DateLiteralExpression(token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(token IsNot Nothing AndAlso SyntaxFacts.IsLiteralExpressionToken(token.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.DateLiteralExpression, token, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LiteralExpressionSyntax)
            End If

            Dim result = New LiteralExpressionSyntax(SyntaxKind.DateLiteralExpression, token)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Shared Function StringLiteralExpression(token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(token IsNot Nothing AndAlso SyntaxFacts.IsLiteralExpressionToken(token.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.StringLiteralExpression, token, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LiteralExpressionSyntax)
            End If

            Dim result = New LiteralExpressionSyntax(SyntaxKind.StringLiteralExpression, token)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Shared Function NothingLiteralExpression(token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(token IsNot Nothing AndAlso SyntaxFacts.IsLiteralExpressionToken(token.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.NothingLiteralExpression, token, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LiteralExpressionSyntax)
            End If

            Dim result = New LiteralExpressionSyntax(SyntaxKind.NothingLiteralExpression, token)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' LiteralExpressionSyntax. One of CharacterLiteralExpression,
        ''' TrueLiteralExpression, FalseLiteralExpression, NumericLiteralExpression,
        ''' DateLiteralExpression, StringLiteralExpression, NothingLiteralExpression.
        ''' </param>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Shared Function LiteralExpression(kind As SyntaxKind, token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(SyntaxFacts.IsLiteralExpression(kind))
            Debug.Assert(token IsNot Nothing AndAlso SyntaxFacts.IsLiteralExpressionToken(token.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(kind, token, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LiteralExpressionSyntax)
            End If

            Dim result = New LiteralExpressionSyntax(kind, token)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a parenthesized expression.
        ''' </summary>
        ''' <param name="openParenToken">
        ''' The "(" token
        ''' </param>
        ''' <param name="expression">
        ''' The expression inside the parentheses.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token
        ''' </param>
        Friend Shared Function ParenthesizedExpression(openParenToken As PunctuationSyntax, expression As ExpressionSyntax, closeParenToken As PunctuationSyntax) As ParenthesizedExpressionSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ParenthesizedExpressionSyntax)
            End If

            Dim result = New ParenthesizedExpressionSyntax(SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a tuple literal expression.
        ''' </summary>
        ''' <param name="openParenToken">
        ''' The "(" token
        ''' </param>
        ''' <param name="arguments">
        ''' The list of tuple arguments.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token
        ''' </param>
        Friend Shared Function TupleExpression(openParenToken As PunctuationSyntax, arguments As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), closeParenToken As PunctuationSyntax) As TupleExpressionSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.TupleExpression, openParenToken, arguments.Node, closeParenToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, TupleExpressionSyntax)
            End If

            Dim result = New TupleExpressionSyntax(SyntaxKind.TupleExpression, openParenToken, arguments.Node, closeParenToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a tuple type expression.
        ''' </summary>
        ''' <param name="openParenToken">
        ''' The "(" token
        ''' </param>
        ''' <param name="elements">
        ''' The list of tuple elements.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token
        ''' </param>
        Friend Shared Function TupleType(openParenToken As PunctuationSyntax, elements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), closeParenToken As PunctuationSyntax) As TupleTypeSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.TupleType, openParenToken, elements.Node, closeParenToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, TupleTypeSyntax)
            End If

            Dim result = New TupleTypeSyntax(SyntaxKind.TupleType, openParenToken, elements.Node, closeParenToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a single declaration of a tuple element supplying only the type.
        ''' </summary>
        ''' <param name="type">
        ''' The type-name part of the tuple element syntax.
        ''' </param>
        Friend Shared Function TypedTupleElement(type As TypeSyntax) As TypedTupleElementSyntax
            Debug.Assert(type IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.TypedTupleElement, type, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, TypedTupleElementSyntax)
            End If

            Dim result = New TypedTupleElementSyntax(SyntaxKind.TypedTupleElement, type)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a single declaration of a tuple element supplying element name and
        ''' optionally a type.
        ''' </summary>
        ''' <param name="identifier">
        ''' The name of the element.
        ''' </param>
        ''' <param name="asClause">
        ''' A simple "As" clause specifying the type of the tuple element.
        ''' </param>
        Friend Shared Function NamedTupleElement(identifier As IdentifierTokenSyntax, asClause As SimpleAsClauseSyntax) As NamedTupleElementSyntax
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.NamedTupleElement, identifier, asClause, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, NamedTupleElementSyntax)
            End If

            Dim result = New NamedTupleElementSyntax(SyntaxKind.NamedTupleElement, identifier, asClause)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Identifies the special instance "Me"
        ''' </summary>
        ''' <param name="keyword">
        ''' The "Me", "MyClass" or "MyBase" keyword.
        ''' </param>
        Friend Shared Function MeExpression(keyword As KeywordSyntax) As MeExpressionSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.MeKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.MeExpression, keyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MeExpressionSyntax)
            End If

            Dim result = New MeExpressionSyntax(SyntaxKind.MeExpression, keyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Identifies the special instance "MyBase"
        ''' </summary>
        ''' <param name="keyword">
        ''' The "Me", "MyClass" or "MyBase" keyword.
        ''' </param>
        Friend Shared Function MyBaseExpression(keyword As KeywordSyntax) As MyBaseExpressionSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.MyBaseKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.MyBaseExpression, keyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MyBaseExpressionSyntax)
            End If

            Dim result = New MyBaseExpressionSyntax(SyntaxKind.MyBaseExpression, keyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Identifies the special instance "MyClass"
        ''' </summary>
        ''' <param name="keyword">
        ''' The "Me", "MyClass" or "MyBase" keyword.
        ''' </param>
        Friend Shared Function MyClassExpression(keyword As KeywordSyntax) As MyClassExpressionSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.MyClassKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.MyClassExpression, keyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MyClassExpressionSyntax)
            End If

            Dim result = New MyClassExpressionSyntax(SyntaxKind.MyClassExpression, keyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a GetType expression.
        ''' </summary>
        ''' <param name="getTypeKeyword">
        ''' The "GetType" keyword.
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="type">
        ''' The type to get the Type object for. This can be an open generic type.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Shared Function GetTypeExpression(getTypeKeyword As KeywordSyntax, openParenToken As PunctuationSyntax, type As TypeSyntax, closeParenToken As PunctuationSyntax) As GetTypeExpressionSyntax
            Debug.Assert(getTypeKeyword IsNot Nothing AndAlso getTypeKeyword.Kind = SyntaxKind.GetTypeKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(type IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New GetTypeExpressionSyntax(SyntaxKind.GetTypeExpression, getTypeKeyword, openParenToken, type, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents a TypeOf...Is or IsNot expression.
        ''' </summary>
        ''' <param name="typeOfKeyword">
        ''' The "TypeOf" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being tested.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The "Is" or "IsNot" keyword.
        ''' </param>
        ''' <param name="type">
        ''' The name of the type being tested against.
        ''' </param>
        Friend Shared Function TypeOfIsExpression(typeOfKeyword As KeywordSyntax, expression As ExpressionSyntax, operatorToken As KeywordSyntax, type As TypeSyntax) As TypeOfExpressionSyntax
            Debug.Assert(typeOfKeyword IsNot Nothing AndAlso typeOfKeyword.Kind = SyntaxKind.TypeOfKeyword)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.IsKeyword)
            Debug.Assert(type IsNot Nothing)
            Return New TypeOfExpressionSyntax(SyntaxKind.TypeOfIsExpression, typeOfKeyword, expression, operatorToken, type)
        End Function


        ''' <summary>
        ''' Represents a TypeOf...Is or IsNot expression.
        ''' </summary>
        ''' <param name="typeOfKeyword">
        ''' The "TypeOf" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being tested.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The "Is" or "IsNot" keyword.
        ''' </param>
        ''' <param name="type">
        ''' The name of the type being tested against.
        ''' </param>
        Friend Shared Function TypeOfIsNotExpression(typeOfKeyword As KeywordSyntax, expression As ExpressionSyntax, operatorToken As KeywordSyntax, type As TypeSyntax) As TypeOfExpressionSyntax
            Debug.Assert(typeOfKeyword IsNot Nothing AndAlso typeOfKeyword.Kind = SyntaxKind.TypeOfKeyword)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.IsNotKeyword)
            Debug.Assert(type IsNot Nothing)
            Return New TypeOfExpressionSyntax(SyntaxKind.TypeOfIsNotExpression, typeOfKeyword, expression, operatorToken, type)
        End Function


        ''' <summary>
        ''' Represents a TypeOf...Is or IsNot expression.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' TypeOfExpressionSyntax. One of TypeOfIsExpression, TypeOfIsNotExpression.
        ''' </param>
        ''' <param name="typeOfKeyword">
        ''' The "TypeOf" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being tested.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The "Is" or "IsNot" keyword.
        ''' </param>
        ''' <param name="type">
        ''' The name of the type being tested against.
        ''' </param>
        Friend Shared Function TypeOfExpression(kind As SyntaxKind, typeOfKeyword As KeywordSyntax, expression As ExpressionSyntax, operatorToken As KeywordSyntax, type As TypeSyntax) As TypeOfExpressionSyntax
            Debug.Assert(SyntaxFacts.IsTypeOfExpression(kind))
            Debug.Assert(typeOfKeyword IsNot Nothing AndAlso typeOfKeyword.Kind = SyntaxKind.TypeOfKeyword)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso SyntaxFacts.IsTypeOfExpressionOperatorToken(operatorToken.Kind))
            Debug.Assert(type IsNot Nothing)
            Return New TypeOfExpressionSyntax(kind, typeOfKeyword, expression, operatorToken, type)
        End Function


        ''' <summary>
        ''' Represents a GetXmlNamespace expression.
        ''' </summary>
        ''' <param name="getXmlNamespaceKeyword">
        ''' The "GetXmlNamespace" keyword.
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="name">
        ''' The Xml namespace name being referenced.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Shared Function GetXmlNamespaceExpression(getXmlNamespaceKeyword As KeywordSyntax, openParenToken As PunctuationSyntax, name As XmlPrefixNameSyntax, closeParenToken As PunctuationSyntax) As GetXmlNamespaceExpressionSyntax
            Debug.Assert(getXmlNamespaceKeyword IsNot Nothing AndAlso getXmlNamespaceKeyword.Kind = SyntaxKind.GetXmlNamespaceKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New GetXmlNamespaceExpressionSyntax(SyntaxKind.GetXmlNamespaceExpression, getXmlNamespaceKeyword, openParenToken, name, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents member access (.name) or dictionary access (!name). The Kind
        ''' property determines which kind of access.
        ''' </summary>
        ''' <param name="expression">
        ''' The expression on the left-hand-side of the "." or "!" token.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The "." or "!" token.
        ''' </param>
        ''' <param name="name">
        ''' The identifier after the "." or "!" token.
        ''' </param>
        Friend Shared Function SimpleMemberAccessExpression(expression As ExpressionSyntax, operatorToken As PunctuationSyntax, name As SimpleNameSyntax) As MemberAccessExpressionSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.DotToken)
            Debug.Assert(name IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.SimpleMemberAccessExpression, expression, operatorToken, name, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MemberAccessExpressionSyntax)
            End If

            Dim result = New MemberAccessExpressionSyntax(SyntaxKind.SimpleMemberAccessExpression, expression, operatorToken, name)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents member access (.name) or dictionary access (!name). The Kind
        ''' property determines which kind of access.
        ''' </summary>
        ''' <param name="expression">
        ''' The expression on the left-hand-side of the "." or "!" token.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The "." or "!" token.
        ''' </param>
        ''' <param name="name">
        ''' The identifier after the "." or "!" token.
        ''' </param>
        Friend Shared Function DictionaryAccessExpression(expression As ExpressionSyntax, operatorToken As PunctuationSyntax, name As SimpleNameSyntax) As MemberAccessExpressionSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.ExclamationToken)
            Debug.Assert(name IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.DictionaryAccessExpression, expression, operatorToken, name, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MemberAccessExpressionSyntax)
            End If

            Dim result = New MemberAccessExpressionSyntax(SyntaxKind.DictionaryAccessExpression, expression, operatorToken, name)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents member access (.name) or dictionary access (!name). The Kind
        ''' property determines which kind of access.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' MemberAccessExpressionSyntax. One of SimpleMemberAccessExpression,
        ''' DictionaryAccessExpression.
        ''' </param>
        ''' <param name="expression">
        ''' The expression on the left-hand-side of the "." or "!" token.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The "." or "!" token.
        ''' </param>
        ''' <param name="name">
        ''' The identifier after the "." or "!" token.
        ''' </param>
        Friend Shared Function MemberAccessExpression(kind As SyntaxKind, expression As ExpressionSyntax, operatorToken As PunctuationSyntax, name As SimpleNameSyntax) As MemberAccessExpressionSyntax
            Debug.Assert(SyntaxFacts.IsMemberAccessExpression(kind))
            Debug.Assert(operatorToken IsNot Nothing AndAlso SyntaxFacts.IsMemberAccessExpressionOperatorToken(operatorToken.Kind))
            Debug.Assert(name IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(kind, expression, operatorToken, name, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MemberAccessExpressionSyntax)
            End If

            Dim result = New MemberAccessExpressionSyntax(kind, expression, operatorToken, name)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an XML member element access (node.&lt;Element&gt;), attribute
        ''' access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
        ''' Kind property determines which kind of access.
        ''' </summary>
        ''' <param name="base">
        ''' The expression on the left-hand-side of the ".", ".@" or "..." .
        ''' </param>
        ''' <param name="token1">
        ''' The initial dot "." part of the separator.
        ''' </param>
        ''' <param name="token2">
        ''' The "@" part of .@ or the second "." of "...".
        ''' </param>
        ''' <param name="token3">
        ''' The third "." in a "..." separator.
        ''' </param>
        ''' <param name="name">
        ''' The identifier after the ".", ".@" or "..."
        ''' </param>
        Friend Shared Function XmlElementAccessExpression(base As ExpressionSyntax, token1 As PunctuationSyntax, token2 As PunctuationSyntax, token3 As PunctuationSyntax, name As XmlNodeSyntax) As XmlMemberAccessExpressionSyntax
            Debug.Assert(token1 IsNot Nothing AndAlso token1.Kind = SyntaxKind.DotToken)
            Debug.Assert(name IsNot Nothing)
            Return New XmlMemberAccessExpressionSyntax(SyntaxKind.XmlElementAccessExpression, base, token1, token2, token3, name)
        End Function


        ''' <summary>
        ''' Represents an XML member element access (node.&lt;Element&gt;), attribute
        ''' access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
        ''' Kind property determines which kind of access.
        ''' </summary>
        ''' <param name="base">
        ''' The expression on the left-hand-side of the ".", ".@" or "..." .
        ''' </param>
        ''' <param name="token1">
        ''' The initial dot "." part of the separator.
        ''' </param>
        ''' <param name="token2">
        ''' The "@" part of .@ or the second "." of "...".
        ''' </param>
        ''' <param name="token3">
        ''' The third "." in a "..." separator.
        ''' </param>
        ''' <param name="name">
        ''' The identifier after the ".", ".@" or "..."
        ''' </param>
        Friend Shared Function XmlDescendantAccessExpression(base As ExpressionSyntax, token1 As PunctuationSyntax, token2 As PunctuationSyntax, token3 As PunctuationSyntax, name As XmlNodeSyntax) As XmlMemberAccessExpressionSyntax
            Debug.Assert(token1 IsNot Nothing AndAlso token1.Kind = SyntaxKind.DotToken)
            Debug.Assert(name IsNot Nothing)
            Return New XmlMemberAccessExpressionSyntax(SyntaxKind.XmlDescendantAccessExpression, base, token1, token2, token3, name)
        End Function


        ''' <summary>
        ''' Represents an XML member element access (node.&lt;Element&gt;), attribute
        ''' access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
        ''' Kind property determines which kind of access.
        ''' </summary>
        ''' <param name="base">
        ''' The expression on the left-hand-side of the ".", ".@" or "..." .
        ''' </param>
        ''' <param name="token1">
        ''' The initial dot "." part of the separator.
        ''' </param>
        ''' <param name="token2">
        ''' The "@" part of .@ or the second "." of "...".
        ''' </param>
        ''' <param name="token3">
        ''' The third "." in a "..." separator.
        ''' </param>
        ''' <param name="name">
        ''' The identifier after the ".", ".@" or "..."
        ''' </param>
        Friend Shared Function XmlAttributeAccessExpression(base As ExpressionSyntax, token1 As PunctuationSyntax, token2 As PunctuationSyntax, token3 As PunctuationSyntax, name As XmlNodeSyntax) As XmlMemberAccessExpressionSyntax
            Debug.Assert(token1 IsNot Nothing AndAlso token1.Kind = SyntaxKind.DotToken)
            Debug.Assert(name IsNot Nothing)
            Return New XmlMemberAccessExpressionSyntax(SyntaxKind.XmlAttributeAccessExpression, base, token1, token2, token3, name)
        End Function


        ''' <summary>
        ''' Represents an XML member element access (node.&lt;Element&gt;), attribute
        ''' access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
        ''' Kind property determines which kind of access.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' XmlMemberAccessExpressionSyntax. One of XmlElementAccessExpression,
        ''' XmlDescendantAccessExpression, XmlAttributeAccessExpression.
        ''' </param>
        ''' <param name="base">
        ''' The expression on the left-hand-side of the ".", ".@" or "..." .
        ''' </param>
        ''' <param name="token1">
        ''' The initial dot "." part of the separator.
        ''' </param>
        ''' <param name="token2">
        ''' The "@" part of .@ or the second "." of "...".
        ''' </param>
        ''' <param name="token3">
        ''' The third "." in a "..." separator.
        ''' </param>
        ''' <param name="name">
        ''' The identifier after the ".", ".@" or "..."
        ''' </param>
        Friend Shared Function XmlMemberAccessExpression(kind As SyntaxKind, base As ExpressionSyntax, token1 As PunctuationSyntax, token2 As PunctuationSyntax, token3 As PunctuationSyntax, name As XmlNodeSyntax) As XmlMemberAccessExpressionSyntax
            Debug.Assert(SyntaxFacts.IsXmlMemberAccessExpression(kind))
            Debug.Assert(token1 IsNot Nothing AndAlso token1.Kind = SyntaxKind.DotToken)
            Debug.Assert(name IsNot Nothing)
            Return New XmlMemberAccessExpressionSyntax(kind, base, token1, token2, token3, name)
        End Function


        ''' <summary>
        ''' Represents an invocation expression consisting of an invocation target and an
        ''' optional argument list or an array, parameterized property or object default
        ''' property index.
        ''' </summary>
        ''' <param name="expression">
        ''' The target of the call or index expression.
        ''' </param>
        ''' <param name="argumentList">
        ''' The argument list.
        ''' </param>
        Friend Shared Function InvocationExpression(expression As ExpressionSyntax, argumentList As ArgumentListSyntax) As InvocationExpressionSyntax

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.InvocationExpression, expression, argumentList, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, InvocationExpressionSyntax)
            End If

            Dim result = New InvocationExpressionSyntax(SyntaxKind.InvocationExpression, expression, argumentList)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a New expression that creates a new non-array object, possibly with
        ''' a "With" or "From" clause.
        ''' </summary>
        ''' <param name="newKeyword">
        ''' The "New" keyword.
        ''' </param>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on the type. If no attributes were specified, an
        ''' empty list is returned.
        ''' </param>
        ''' <param name="type">
        ''' The type of the object being initialized.
        ''' </param>
        ''' <param name="argumentList">
        ''' The argument list, if present. If no argument list was supplied, Nothing is
        ''' returned.
        ''' </param>
        ''' <param name="initializer">
        ''' An optional From or With clause to initialize the new object.
        ''' </param>
        Friend Shared Function ObjectCreationExpression(newKeyword As KeywordSyntax, attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), type As TypeSyntax, argumentList As ArgumentListSyntax, initializer As ObjectCreationInitializerSyntax) As ObjectCreationExpressionSyntax
            Debug.Assert(newKeyword IsNot Nothing AndAlso newKeyword.Kind = SyntaxKind.NewKeyword)
            Debug.Assert(type IsNot Nothing)
            Return New ObjectCreationExpressionSyntax(SyntaxKind.ObjectCreationExpression, newKeyword, attributeLists.Node, type, argumentList, initializer)
        End Function


        ''' <summary>
        ''' Represents a New expression that create an object of anonymous type.
        ''' </summary>
        ''' <param name="newKeyword">
        ''' The "New" keyword.
        ''' </param>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on the type. If no attributes were specified, an
        ''' empty list is returned.
        ''' </param>
        ''' <param name="initializer">
        ''' The With clause to initialize the new object.
        ''' </param>
        Friend Shared Function AnonymousObjectCreationExpression(newKeyword As KeywordSyntax, attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), initializer As ObjectMemberInitializerSyntax) As AnonymousObjectCreationExpressionSyntax
            Debug.Assert(newKeyword IsNot Nothing AndAlso newKeyword.Kind = SyntaxKind.NewKeyword)
            Debug.Assert(initializer IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.AnonymousObjectCreationExpression, newKeyword, attributeLists.Node, initializer, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AnonymousObjectCreationExpressionSyntax)
            End If

            Dim result = New AnonymousObjectCreationExpressionSyntax(SyntaxKind.AnonymousObjectCreationExpression, newKeyword, attributeLists.Node, initializer)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an expression that creates a new array.
        ''' </summary>
        ''' <param name="newKeyword">
        ''' The "New" keyword.
        ''' </param>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on the type. If no attributes were specified, an
        ''' empty list is returned.
        ''' </param>
        ''' <param name="type">
        ''' The element type of the array being created.
        ''' </param>
        ''' <param name="arrayBounds">
        ''' The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
        ''' </param>
        ''' <param name="rankSpecifiers">
        ''' A list of array modifiers such as "()" or "(,)". If no array modifiers were
        ''' present, an empty list is returned.
        ''' </param>
        ''' <param name="initializer">
        ''' The initializer including the braces.
        ''' </param>
        Friend Shared Function ArrayCreationExpression(newKeyword As KeywordSyntax, attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), type As TypeSyntax, arrayBounds As ArgumentListSyntax, rankSpecifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), initializer As CollectionInitializerSyntax) As ArrayCreationExpressionSyntax
            Debug.Assert(newKeyword IsNot Nothing AndAlso newKeyword.Kind = SyntaxKind.NewKeyword)
            Debug.Assert(type IsNot Nothing)
            Debug.Assert(initializer IsNot Nothing)
            Return New ArrayCreationExpressionSyntax(SyntaxKind.ArrayCreationExpression, newKeyword, attributeLists.Node, type, arrayBounds, rankSpecifiers.Node, initializer)
        End Function


        ''' <summary>
        ''' Represents an expression that creates a new array without naming the element
        ''' type.
        ''' </summary>
        ''' <param name="openBraceToken">
        ''' The "{" token.
        ''' </param>
        ''' <param name="initializers">
        ''' The list of initializers between the braces.
        ''' </param>
        ''' <param name="closeBraceToken">
        ''' The "}" token.
        ''' </param>
        Friend Shared Function CollectionInitializer(openBraceToken As PunctuationSyntax, initializers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), closeBraceToken As PunctuationSyntax) As CollectionInitializerSyntax
            Debug.Assert(openBraceToken IsNot Nothing AndAlso openBraceToken.Kind = SyntaxKind.OpenBraceToken)
            Debug.Assert(closeBraceToken IsNot Nothing AndAlso closeBraceToken.Kind = SyntaxKind.CloseBraceToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.CollectionInitializer, openBraceToken, initializers.Node, closeBraceToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CollectionInitializerSyntax)
            End If

            Dim result = New CollectionInitializerSyntax(SyntaxKind.CollectionInitializer, openBraceToken, initializers.Node, closeBraceToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <param name="keyword">
        ''' The "CType", "DirectCast" or "TryCast" keyword.
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being cast.
        ''' </param>
        ''' <param name="commaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="type">
        ''' The type the expression is being cast to.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Shared Function CTypeExpression(keyword As KeywordSyntax, openParenToken As PunctuationSyntax, expression As ExpressionSyntax, commaToken As PunctuationSyntax, type As TypeSyntax, closeParenToken As PunctuationSyntax) As CTypeExpressionSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.CTypeKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(type IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New CTypeExpressionSyntax(SyntaxKind.CTypeExpression, keyword, openParenToken, expression, commaToken, type, closeParenToken)
        End Function


        ''' <param name="keyword">
        ''' The "CType", "DirectCast" or "TryCast" keyword.
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being cast.
        ''' </param>
        ''' <param name="commaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="type">
        ''' The type the expression is being cast to.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Shared Function DirectCastExpression(keyword As KeywordSyntax, openParenToken As PunctuationSyntax, expression As ExpressionSyntax, commaToken As PunctuationSyntax, type As TypeSyntax, closeParenToken As PunctuationSyntax) As DirectCastExpressionSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.DirectCastKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(type IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New DirectCastExpressionSyntax(SyntaxKind.DirectCastExpression, keyword, openParenToken, expression, commaToken, type, closeParenToken)
        End Function


        ''' <param name="keyword">
        ''' The "CType", "DirectCast" or "TryCast" keyword.
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being cast.
        ''' </param>
        ''' <param name="commaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="type">
        ''' The type the expression is being cast to.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Shared Function TryCastExpression(keyword As KeywordSyntax, openParenToken As PunctuationSyntax, expression As ExpressionSyntax, commaToken As PunctuationSyntax, type As TypeSyntax, closeParenToken As PunctuationSyntax) As TryCastExpressionSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.TryCastKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(type IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New TryCastExpressionSyntax(SyntaxKind.TryCastExpression, keyword, openParenToken, expression, commaToken, type, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents a cast to a pre-defined type using a pre-defined cast expression,
        ''' such as CInt or CLng.
        ''' </summary>
        ''' <param name="keyword">
        ''' The keyword that was used in the cast operation.
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being cast.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Shared Function PredefinedCastExpression(keyword As KeywordSyntax, openParenToken As PunctuationSyntax, expression As ExpressionSyntax, closeParenToken As PunctuationSyntax) As PredefinedCastExpressionSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso SyntaxFacts.IsPredefinedCastExpressionKeyword(keyword.Kind))
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New PredefinedCastExpressionSyntax(SyntaxKind.PredefinedCastExpression, keyword, openParenToken, expression, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function AddExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.PlusToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.AddExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.AddExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function SubtractExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.MinusToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.SubtractExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.SubtractExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function MultiplyExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.AsteriskToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.MultiplyExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.MultiplyExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function DivideExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.SlashToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.DivideExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.DivideExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function IntegerDivideExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.BackslashToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.IntegerDivideExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.IntegerDivideExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function ExponentiateExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.CaretToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ExponentiateExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.ExponentiateExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function LeftShiftExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LessThanLessThanToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.LeftShiftExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.LeftShiftExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function RightShiftExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.GreaterThanGreaterThanToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.RightShiftExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.RightShiftExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function ConcatenateExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.AmpersandToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ConcatenateExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.ConcatenateExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function ModuloExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.ModKeyword)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ModuloExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.ModuloExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function EqualsExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.EqualsExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.EqualsExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function NotEqualsExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LessThanGreaterThanToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.NotEqualsExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.NotEqualsExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function LessThanExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LessThanToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.LessThanExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.LessThanExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function LessThanOrEqualExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LessThanEqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.LessThanOrEqualExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.LessThanOrEqualExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function GreaterThanOrEqualExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.GreaterThanEqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.GreaterThanOrEqualExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.GreaterThanOrEqualExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function GreaterThanExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.GreaterThanToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.GreaterThanExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.GreaterThanExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function IsExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.IsKeyword)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.IsExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.IsExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function IsNotExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.IsNotKeyword)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.IsNotExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.IsNotExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function LikeExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LikeKeyword)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.LikeExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.LikeExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function OrExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.OrKeyword)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.OrExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.OrExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function ExclusiveOrExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.XorKeyword)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ExclusiveOrExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.ExclusiveOrExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function AndExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.AndKeyword)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.AndExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.AndExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function OrElseExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.OrElseKeyword)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.OrElseExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.OrElseExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function AndAlsoExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.AndAlsoKeyword)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.AndAlsoExpression, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.AndAlsoExpression, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' BinaryExpressionSyntax. One of AddExpression, SubtractExpression,
        ''' MultiplyExpression, DivideExpression, IntegerDivideExpression,
        ''' ExponentiateExpression, LeftShiftExpression, RightShiftExpression,
        ''' ConcatenateExpression, ModuloExpression, EqualsExpression, NotEqualsExpression,
        ''' LessThanExpression, LessThanOrEqualExpression, GreaterThanOrEqualExpression,
        ''' GreaterThanExpression, IsExpression, IsNotExpression, LikeExpression,
        ''' OrExpression, ExclusiveOrExpression, AndExpression, OrElseExpression,
        ''' AndAlsoExpression.
        ''' </param>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Shared Function BinaryExpression(kind As SyntaxKind, left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(SyntaxFacts.IsBinaryExpression(kind))
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso SyntaxFacts.IsBinaryExpressionOperatorToken(operatorToken.Kind))
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(kind, left, operatorToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(kind, left, operatorToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Describes a unary operator: Plus, Negate, Not or AddressOf.
        ''' </summary>
        ''' <param name="operatorToken">
        ''' The token that is the operator.
        ''' </param>
        ''' <param name="operand">
        ''' The expression being operated on.
        ''' </param>
        Friend Shared Function UnaryPlusExpression(operatorToken As SyntaxToken, operand As ExpressionSyntax) As UnaryExpressionSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.PlusToken)
            Debug.Assert(operand IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.UnaryPlusExpression, operatorToken, operand, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, UnaryExpressionSyntax)
            End If

            Dim result = New UnaryExpressionSyntax(SyntaxKind.UnaryPlusExpression, operatorToken, operand)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Describes a unary operator: Plus, Negate, Not or AddressOf.
        ''' </summary>
        ''' <param name="operatorToken">
        ''' The token that is the operator.
        ''' </param>
        ''' <param name="operand">
        ''' The expression being operated on.
        ''' </param>
        Friend Shared Function UnaryMinusExpression(operatorToken As SyntaxToken, operand As ExpressionSyntax) As UnaryExpressionSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.MinusToken)
            Debug.Assert(operand IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.UnaryMinusExpression, operatorToken, operand, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, UnaryExpressionSyntax)
            End If

            Dim result = New UnaryExpressionSyntax(SyntaxKind.UnaryMinusExpression, operatorToken, operand)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Describes a unary operator: Plus, Negate, Not or AddressOf.
        ''' </summary>
        ''' <param name="operatorToken">
        ''' The token that is the operator.
        ''' </param>
        ''' <param name="operand">
        ''' The expression being operated on.
        ''' </param>
        Friend Shared Function NotExpression(operatorToken As SyntaxToken, operand As ExpressionSyntax) As UnaryExpressionSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.NotKeyword)
            Debug.Assert(operand IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.NotExpression, operatorToken, operand, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, UnaryExpressionSyntax)
            End If

            Dim result = New UnaryExpressionSyntax(SyntaxKind.NotExpression, operatorToken, operand)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Describes a unary operator: Plus, Negate, Not or AddressOf.
        ''' </summary>
        ''' <param name="operatorToken">
        ''' The token that is the operator.
        ''' </param>
        ''' <param name="operand">
        ''' The expression being operated on.
        ''' </param>
        Friend Shared Function AddressOfExpression(operatorToken As SyntaxToken, operand As ExpressionSyntax) As UnaryExpressionSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.AddressOfKeyword)
            Debug.Assert(operand IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.AddressOfExpression, operatorToken, operand, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, UnaryExpressionSyntax)
            End If

            Dim result = New UnaryExpressionSyntax(SyntaxKind.AddressOfExpression, operatorToken, operand)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Describes a unary operator: Plus, Negate, Not or AddressOf.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' UnaryExpressionSyntax. One of UnaryPlusExpression, UnaryMinusExpression,
        ''' NotExpression, AddressOfExpression.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The token that is the operator.
        ''' </param>
        ''' <param name="operand">
        ''' The expression being operated on.
        ''' </param>
        Friend Shared Function UnaryExpression(kind As SyntaxKind, operatorToken As SyntaxToken, operand As ExpressionSyntax) As UnaryExpressionSyntax
            Debug.Assert(SyntaxFacts.IsUnaryExpression(kind))
            Debug.Assert(operatorToken IsNot Nothing AndAlso SyntaxFacts.IsUnaryExpressionOperatorToken(operatorToken.Kind))
            Debug.Assert(operand IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(kind, operatorToken, operand, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, UnaryExpressionSyntax)
            End If

            Dim result = New UnaryExpressionSyntax(kind, operatorToken, operand)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a conditional expression, If(condition, true-expr, false-expr) or
        ''' If(expr, nothing-expr).
        ''' </summary>
        ''' <param name="ifKeyword">
        ''' The "If" keyword
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token
        ''' </param>
        ''' <param name="firstExpression">
        ''' The first expression inside the parentheses.
        ''' </param>
        ''' <param name="commaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="secondExpression">
        ''' The second expression inside the parentheses.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token
        ''' </param>
        Friend Shared Function BinaryConditionalExpression(ifKeyword As KeywordSyntax, openParenToken As PunctuationSyntax, firstExpression As ExpressionSyntax, commaToken As PunctuationSyntax, secondExpression As ExpressionSyntax, closeParenToken As PunctuationSyntax) As BinaryConditionalExpressionSyntax
            Debug.Assert(ifKeyword IsNot Nothing AndAlso ifKeyword.Kind = SyntaxKind.IfKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(firstExpression IsNot Nothing)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(secondExpression IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New BinaryConditionalExpressionSyntax(SyntaxKind.BinaryConditionalExpression, ifKeyword, openParenToken, firstExpression, commaToken, secondExpression, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents a conditional expression, If(condition, true-expr, false-expr) or
        ''' If(expr, nothing-expr).
        ''' </summary>
        ''' <param name="ifKeyword">
        ''' The "If" keyword
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token
        ''' </param>
        ''' <param name="condition">
        ''' The first expression inside the parentheses.
        ''' </param>
        ''' <param name="firstCommaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="whenTrue">
        ''' The second expression inside the parentheses.
        ''' </param>
        ''' <param name="secondCommaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="whenFalse">
        ''' The second expression inside the parentheses.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token
        ''' </param>
        Friend Shared Function TernaryConditionalExpression(ifKeyword As KeywordSyntax, openParenToken As PunctuationSyntax, condition As ExpressionSyntax, firstCommaToken As PunctuationSyntax, whenTrue As ExpressionSyntax, secondCommaToken As PunctuationSyntax, whenFalse As ExpressionSyntax, closeParenToken As PunctuationSyntax) As TernaryConditionalExpressionSyntax
            Debug.Assert(ifKeyword IsNot Nothing AndAlso ifKeyword.Kind = SyntaxKind.IfKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(condition IsNot Nothing)
            Debug.Assert(firstCommaToken IsNot Nothing AndAlso firstCommaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(whenTrue IsNot Nothing)
            Debug.Assert(secondCommaToken IsNot Nothing AndAlso secondCommaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(whenFalse IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New TernaryConditionalExpressionSyntax(SyntaxKind.TernaryConditionalExpression, ifKeyword, openParenToken, condition, firstCommaToken, whenTrue, secondCommaToken, whenFalse, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents a single line lambda expression.
        ''' </summary>
        ''' <param name="subOrFunctionHeader">
        ''' The header part of the lambda that includes the "Sub" or "Function" keyword,
        ''' the argument list and return type.
        ''' </param>
        ''' <param name="body">
        ''' The body of the lambda. Depending on the kind of lambda, this is either a
        ''' Statement (single-line Sub lambda) or Expression (single-line Function).
        ''' </param>
        Friend Shared Function SingleLineFunctionLambdaExpression(subOrFunctionHeader As LambdaHeaderSyntax, body As VisualBasicSyntaxNode) As SingleLineLambdaExpressionSyntax
            Debug.Assert(subOrFunctionHeader IsNot Nothing)
            Debug.Assert(body IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.SingleLineFunctionLambdaExpression, subOrFunctionHeader, body, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SingleLineLambdaExpressionSyntax)
            End If

            Dim result = New SingleLineLambdaExpressionSyntax(SyntaxKind.SingleLineFunctionLambdaExpression, subOrFunctionHeader, body)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a single line lambda expression.
        ''' </summary>
        ''' <param name="subOrFunctionHeader">
        ''' The header part of the lambda that includes the "Sub" or "Function" keyword,
        ''' the argument list and return type.
        ''' </param>
        ''' <param name="body">
        ''' The body of the lambda. Depending on the kind of lambda, this is either a
        ''' Statement (single-line Sub lambda) or Expression (single-line Function).
        ''' </param>
        Friend Shared Function SingleLineSubLambdaExpression(subOrFunctionHeader As LambdaHeaderSyntax, body As VisualBasicSyntaxNode) As SingleLineLambdaExpressionSyntax
            Debug.Assert(subOrFunctionHeader IsNot Nothing)
            Debug.Assert(body IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.SingleLineSubLambdaExpression, subOrFunctionHeader, body, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SingleLineLambdaExpressionSyntax)
            End If

            Dim result = New SingleLineLambdaExpressionSyntax(SyntaxKind.SingleLineSubLambdaExpression, subOrFunctionHeader, body)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a single line lambda expression.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' SingleLineLambdaExpressionSyntax. One of SingleLineFunctionLambdaExpression,
        ''' SingleLineSubLambdaExpression.
        ''' </param>
        ''' <param name="subOrFunctionHeader">
        ''' The header part of the lambda that includes the "Sub" or "Function" keyword,
        ''' the argument list and return type.
        ''' </param>
        ''' <param name="body">
        ''' The body of the lambda. Depending on the kind of lambda, this is either a
        ''' Statement (single-line Sub lambda) or Expression (single-line Function).
        ''' </param>
        Friend Shared Function SingleLineLambdaExpression(kind As SyntaxKind, subOrFunctionHeader As LambdaHeaderSyntax, body As VisualBasicSyntaxNode) As SingleLineLambdaExpressionSyntax
            Debug.Assert(SyntaxFacts.IsSingleLineLambdaExpression(kind))
            Debug.Assert(subOrFunctionHeader IsNot Nothing)
            Debug.Assert(body IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(kind, subOrFunctionHeader, body, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SingleLineLambdaExpressionSyntax)
            End If

            Dim result = New SingleLineLambdaExpressionSyntax(kind, subOrFunctionHeader, body)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a multi-line lambda expression.
        ''' </summary>
        ''' <param name="subOrFunctionHeader">
        ''' The header part of the lambda that includes the "Sub" or "Function" keyword,
        ''' the argument list and return type.
        ''' </param>
        ''' <param name="statements">
        ''' The body of the lambda. Depending on the kind of lambda, this is either a
        ''' StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
        ''' Expression (single-line Function). This might be an empty list.
        ''' </param>
        ''' <param name="endSubOrFunctionStatement">
        ''' Returns the "End Sub" or "End Function" statement if this is a multi-line
        ''' lambda.
        ''' </param>
        Friend Shared Function MultiLineFunctionLambdaExpression(subOrFunctionHeader As LambdaHeaderSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endSubOrFunctionStatement As EndBlockStatementSyntax) As MultiLineLambdaExpressionSyntax
            Debug.Assert(subOrFunctionHeader IsNot Nothing)
            Debug.Assert(endSubOrFunctionStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.MultiLineFunctionLambdaExpression, subOrFunctionHeader, statements.Node, endSubOrFunctionStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MultiLineLambdaExpressionSyntax)
            End If

            Dim result = New MultiLineLambdaExpressionSyntax(SyntaxKind.MultiLineFunctionLambdaExpression, subOrFunctionHeader, statements.Node, endSubOrFunctionStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a multi-line lambda expression.
        ''' </summary>
        ''' <param name="subOrFunctionHeader">
        ''' The header part of the lambda that includes the "Sub" or "Function" keyword,
        ''' the argument list and return type.
        ''' </param>
        ''' <param name="statements">
        ''' The body of the lambda. Depending on the kind of lambda, this is either a
        ''' StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
        ''' Expression (single-line Function). This might be an empty list.
        ''' </param>
        ''' <param name="endSubOrFunctionStatement">
        ''' Returns the "End Sub" or "End Function" statement if this is a multi-line
        ''' lambda.
        ''' </param>
        Friend Shared Function MultiLineSubLambdaExpression(subOrFunctionHeader As LambdaHeaderSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endSubOrFunctionStatement As EndBlockStatementSyntax) As MultiLineLambdaExpressionSyntax
            Debug.Assert(subOrFunctionHeader IsNot Nothing)
            Debug.Assert(endSubOrFunctionStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.MultiLineSubLambdaExpression, subOrFunctionHeader, statements.Node, endSubOrFunctionStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MultiLineLambdaExpressionSyntax)
            End If

            Dim result = New MultiLineLambdaExpressionSyntax(SyntaxKind.MultiLineSubLambdaExpression, subOrFunctionHeader, statements.Node, endSubOrFunctionStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a multi-line lambda expression.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' MultiLineLambdaExpressionSyntax. One of MultiLineFunctionLambdaExpression,
        ''' MultiLineSubLambdaExpression.
        ''' </param>
        ''' <param name="subOrFunctionHeader">
        ''' The header part of the lambda that includes the "Sub" or "Function" keyword,
        ''' the argument list and return type.
        ''' </param>
        ''' <param name="statements">
        ''' The body of the lambda. Depending on the kind of lambda, this is either a
        ''' StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
        ''' Expression (single-line Function). This might be an empty list.
        ''' </param>
        ''' <param name="endSubOrFunctionStatement">
        ''' Returns the "End Sub" or "End Function" statement if this is a multi-line
        ''' lambda.
        ''' </param>
        Friend Shared Function MultiLineLambdaExpression(kind As SyntaxKind, subOrFunctionHeader As LambdaHeaderSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endSubOrFunctionStatement As EndBlockStatementSyntax) As MultiLineLambdaExpressionSyntax
            Debug.Assert(SyntaxFacts.IsMultiLineLambdaExpression(kind))
            Debug.Assert(subOrFunctionHeader IsNot Nothing)
            Debug.Assert(endSubOrFunctionStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(kind, subOrFunctionHeader, statements.Node, endSubOrFunctionStatement, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MultiLineLambdaExpressionSyntax)
            End If

            Dim result = New MultiLineLambdaExpressionSyntax(kind, subOrFunctionHeader, statements.Node, endSubOrFunctionStatement)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the header part of a lambda expression
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword that introduces this lambda expression.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function SubLambdaHeader(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), subOrFunctionKeyword As KeywordSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax) As LambdaHeaderSyntax
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso subOrFunctionKeyword.Kind = SyntaxKind.SubKeyword)
            Return New LambdaHeaderSyntax(SyntaxKind.SubLambdaHeader, attributeLists.Node, modifiers.Node, subOrFunctionKeyword, parameterList, asClause)
        End Function


        ''' <summary>
        ''' Represents the header part of a lambda expression
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword that introduces this lambda expression.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function FunctionLambdaHeader(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), subOrFunctionKeyword As KeywordSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax) As LambdaHeaderSyntax
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso subOrFunctionKeyword.Kind = SyntaxKind.FunctionKeyword)
            Return New LambdaHeaderSyntax(SyntaxKind.FunctionLambdaHeader, attributeLists.Node, modifiers.Node, subOrFunctionKeyword, parameterList, asClause)
        End Function


        ''' <summary>
        ''' Represents the header part of a lambda expression
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' LambdaHeaderSyntax. One of SubLambdaHeader, FunctionLambdaHeader.
        ''' </param>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword that introduces this lambda expression.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Shared Function LambdaHeader(kind As SyntaxKind, attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), subOrFunctionKeyword As KeywordSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax) As LambdaHeaderSyntax
            Debug.Assert(SyntaxFacts.IsLambdaHeader(kind))
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso SyntaxFacts.IsLambdaHeaderSubOrFunctionKeyword(subOrFunctionKeyword.Kind))
            Return New LambdaHeaderSyntax(kind, attributeLists.Node, modifiers.Node, subOrFunctionKeyword, parameterList, asClause)
        End Function


        ''' <summary>
        ''' Represents a parenthesized argument list.
        ''' </summary>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="arguments">
        ''' The list of arguments. This may be empty. Omitted argument are represented by
        ''' an OmittedArgumentSyntax node.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Shared Function ArgumentList(openParenToken As PunctuationSyntax, arguments As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), closeParenToken As PunctuationSyntax) As ArgumentListSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ArgumentListSyntax)
            End If

            Dim result = New ArgumentListSyntax(SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an omitted argument in an argument list. An omitted argument is not
        ''' considered a syntax error but a valid case when no argument is required.
        ''' </summary>
        ''' <param name="empty">
        ''' An empty token because all non terminals must have a token.
        ''' </param>
        Friend Shared Function OmittedArgument(empty As PunctuationSyntax) As OmittedArgumentSyntax
            Debug.Assert(empty IsNot Nothing AndAlso empty.Kind = SyntaxKind.EmptyToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.OmittedArgument, empty, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, OmittedArgumentSyntax)
            End If

            Dim result = New OmittedArgumentSyntax(SyntaxKind.OmittedArgument, empty)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an argument that is just an optional argument name and an
        ''' expression.
        ''' </summary>
        ''' <param name="nameColonEquals">
        ''' The optional name and ":=" prefix of a named argument.
        ''' </param>
        ''' <param name="expression">
        ''' The expression that is the argument.
        ''' </param>
        Friend Shared Function SimpleArgument(nameColonEquals As NameColonEqualsSyntax, expression As ExpressionSyntax) As SimpleArgumentSyntax
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.SimpleArgument, nameColonEquals, expression, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SimpleArgumentSyntax)
            End If

            Dim result = New SimpleArgumentSyntax(SyntaxKind.SimpleArgument, nameColonEquals, expression)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an identifier name followed by a ":=" token in a named argument.
        ''' </summary>
        ''' <param name="name">
        ''' The name used to identify the named argument.
        ''' </param>
        ''' <param name="colonEqualsToken">
        ''' The ":=" token.
        ''' </param>
        Friend Shared Function NameColonEquals(name As IdentifierNameSyntax, colonEqualsToken As PunctuationSyntax) As NameColonEqualsSyntax
            Debug.Assert(name IsNot Nothing)
            Debug.Assert(colonEqualsToken IsNot Nothing AndAlso colonEqualsToken.Kind = SyntaxKind.ColonEqualsToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.NameColonEquals, name, colonEqualsToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, NameColonEqualsSyntax)
            End If

            Dim result = New NameColonEqualsSyntax(SyntaxKind.NameColonEquals, name, colonEqualsToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a range argument, such as "0 to 5", used in array bounds. The
        ''' "Value" property represents the upper bound of the range.
        ''' </summary>
        ''' <param name="lowerBound">
        ''' The lower bound of the range. This is typically the integer constant zero.
        ''' </param>
        ''' <param name="toKeyword">
        ''' The "To" keyword.
        ''' </param>
        ''' <param name="upperBound">
        ''' The upper bound of the range.
        ''' </param>
        Friend Shared Function RangeArgument(lowerBound As ExpressionSyntax, toKeyword As KeywordSyntax, upperBound As ExpressionSyntax) As RangeArgumentSyntax
            Debug.Assert(lowerBound IsNot Nothing)
            Debug.Assert(toKeyword IsNot Nothing AndAlso toKeyword.Kind = SyntaxKind.ToKeyword)
            Debug.Assert(upperBound IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.RangeArgument, lowerBound, toKeyword, upperBound, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, RangeArgumentSyntax)
            End If

            Dim result = New RangeArgumentSyntax(SyntaxKind.RangeArgument, lowerBound, toKeyword, upperBound)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' This class represents a query expression. A query expression is composed of one
        ''' or more query operators in a row. The first query operator must be a From or
        ''' Aggregate.
        ''' </summary>
        ''' <param name="clauses">
        ''' A list of all the query operators in this query expression. This list always
        ''' contains at least one operator.
        ''' </param>
        Friend Shared Function QueryExpression(clauses As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As QueryExpressionSyntax

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.QueryExpression, clauses.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, QueryExpressionSyntax)
            End If

            Dim result = New QueryExpressionSyntax(SyntaxKind.QueryExpression, clauses.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Describes a single variable of the form "x [As Type] In expression" for use in
        ''' query expressions.
        ''' </summary>
        ''' <param name="identifier">
        ''' The name of the range variable being defined.
        ''' </param>
        ''' <param name="asClause">
        ''' Describes the type of the variable being defined.
        ''' </param>
        ''' <param name="inKeyword">
        ''' The "In" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression that serves as the source of items for the range variable.
        ''' </param>
        Friend Shared Function CollectionRangeVariable(identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, inKeyword As KeywordSyntax, expression As ExpressionSyntax) As CollectionRangeVariableSyntax
            Debug.Assert(identifier IsNot Nothing)
            Debug.Assert(inKeyword IsNot Nothing AndAlso inKeyword.Kind = SyntaxKind.InKeyword)
            Debug.Assert(expression IsNot Nothing)
            Return New CollectionRangeVariableSyntax(SyntaxKind.CollectionRangeVariable, identifier, asClause, inKeyword, expression)
        End Function


        ''' <summary>
        ''' Describes a single variable of the form "[x [As Type] =] expression" for use in
        ''' query expressions.
        ''' </summary>
        ''' <param name="nameEquals">
        ''' The optional name and type of the expression range variable. If omitted, the
        ''' name of the expression range variable is inferred from the expression.
        ''' </param>
        ''' <param name="expression">
        ''' The expression used to initialize the expression variable.
        ''' </param>
        Friend Shared Function ExpressionRangeVariable(nameEquals As VariableNameEqualsSyntax, expression As ExpressionSyntax) As ExpressionRangeVariableSyntax
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ExpressionRangeVariable, nameEquals, expression, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExpressionRangeVariableSyntax)
            End If

            Dim result = New ExpressionRangeVariableSyntax(SyntaxKind.ExpressionRangeVariable, nameEquals, expression)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Describes a single variable of the form "[x [As Type] =] aggregation-function"
        ''' for use in the Into clause of Aggregate or Group By or Group Join query
        ''' operators.
        ''' </summary>
        ''' <param name="nameEquals">
        ''' The optional name and type of the expression range variable. If omitted, the
        ''' name of the expression range variable is inferred from the aggregation
        ''' expression.
        ''' </param>
        ''' <param name="aggregation">
        ''' The name of the aggregation function. The "Group" aggregation function is
        ''' represented by the identifier "Group".
        ''' </param>
        Friend Shared Function AggregationRangeVariable(nameEquals As VariableNameEqualsSyntax, aggregation As AggregationSyntax) As AggregationRangeVariableSyntax
            Debug.Assert(aggregation IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.AggregationRangeVariable, nameEquals, aggregation, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AggregationRangeVariableSyntax)
            End If

            Dim result = New AggregationRangeVariableSyntax(SyntaxKind.AggregationRangeVariable, nameEquals, aggregation)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the name and optional type of an expression range variable.
        ''' </summary>
        ''' <param name="identifier">
        ''' The name of the variable being defined.
        ''' </param>
        ''' <param name="asClause">
        ''' Describes the type of the variable being defined.
        ''' </param>
        ''' <param name="equalsToken">
        ''' The "=" token.
        ''' </param>
        Friend Shared Function VariableNameEquals(identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, equalsToken As PunctuationSyntax) As VariableNameEqualsSyntax
            Debug.Assert(identifier IsNot Nothing)
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.VariableNameEquals, identifier, asClause, equalsToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, VariableNameEqualsSyntax)
            End If

            Dim result = New VariableNameEqualsSyntax(SyntaxKind.VariableNameEquals, identifier, asClause, equalsToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an invocation of an Aggregation function in the aggregation range
        ''' variable declaration of a Group By, Group Join or Aggregate query operator.
        ''' </summary>
        ''' <param name="functionName">
        ''' The name of the aggregation function.
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token if present.
        ''' </param>
        ''' <param name="argument">
        ''' The argument to the aggregation function.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token, if present.
        ''' </param>
        Friend Shared Function FunctionAggregation(functionName As IdentifierTokenSyntax, openParenToken As PunctuationSyntax, argument As ExpressionSyntax, closeParenToken As PunctuationSyntax) As FunctionAggregationSyntax
            Debug.Assert(functionName IsNot Nothing AndAlso functionName.Kind = SyntaxKind.IdentifierToken)
            Return New FunctionAggregationSyntax(SyntaxKind.FunctionAggregation, functionName, openParenToken, argument, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents the use of "Group" as the aggregation function in the in the
        ''' aggregation range variable declaration of a Group By or Group Join query
        ''' operator.
        ''' </summary>
        ''' <param name="groupKeyword">
        ''' The "Group" keyword.
        ''' </param>
        Friend Shared Function GroupAggregation(groupKeyword As KeywordSyntax) As GroupAggregationSyntax
            Debug.Assert(groupKeyword IsNot Nothing AndAlso groupKeyword.Kind = SyntaxKind.GroupKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.GroupAggregation, groupKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, GroupAggregationSyntax)
            End If

            Dim result = New GroupAggregationSyntax(SyntaxKind.GroupAggregation, groupKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "From" query operator. If this is the beginning of a query, the
        ''' Source will be Nothing. Otherwise, the Source will be the part of the query to
        ''' the left of the From.
        ''' </summary>
        ''' <param name="fromKeyword">
        ''' The "From" keyword.
        ''' </param>
        ''' <param name="variables">
        ''' The list of collection variables declared by this From operator.
        ''' </param>
        Friend Shared Function FromClause(fromKeyword As KeywordSyntax, variables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As FromClauseSyntax
            Debug.Assert(fromKeyword IsNot Nothing AndAlso fromKeyword.Kind = SyntaxKind.FromKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.FromClause, fromKeyword, variables.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, FromClauseSyntax)
            End If

            Dim result = New FromClauseSyntax(SyntaxKind.FromClause, fromKeyword, variables.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Let" query operator.
        ''' </summary>
        ''' <param name="letKeyword">
        ''' The "Let" keyword.
        ''' </param>
        ''' <param name="variables">
        ''' The list of expression range variable being defined by the Let operator.
        ''' </param>
        Friend Shared Function LetClause(letKeyword As KeywordSyntax, variables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As LetClauseSyntax
            Debug.Assert(letKeyword IsNot Nothing AndAlso letKeyword.Kind = SyntaxKind.LetKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.LetClause, letKeyword, variables.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LetClauseSyntax)
            End If

            Dim result = New LetClauseSyntax(SyntaxKind.LetClause, letKeyword, variables.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an Aggregate query operator.
        ''' </summary>
        ''' <param name="aggregateKeyword">
        ''' The "Aggregate" keyword.
        ''' </param>
        ''' <param name="variables">
        ''' The list of collection range variables declared by this Aggregate operator.
        ''' </param>
        ''' <param name="additionalQueryOperators">
        ''' A list of additional query operators. It may be empty.
        ''' </param>
        ''' <param name="intoKeyword">
        ''' The "Into" keyword.
        ''' </param>
        ''' <param name="aggregationVariables">
        ''' The list of new variables being defined by the aggregation.
        ''' </param>
        Friend Shared Function AggregateClause(aggregateKeyword As KeywordSyntax, variables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), additionalQueryOperators As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), intoKeyword As KeywordSyntax, aggregationVariables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As AggregateClauseSyntax
            Debug.Assert(aggregateKeyword IsNot Nothing AndAlso aggregateKeyword.Kind = SyntaxKind.AggregateKeyword)
            Debug.Assert(intoKeyword IsNot Nothing AndAlso intoKeyword.Kind = SyntaxKind.IntoKeyword)
            Return New AggregateClauseSyntax(SyntaxKind.AggregateClause, aggregateKeyword, variables.Node, additionalQueryOperators.Node, intoKeyword, aggregationVariables.Node)
        End Function


        ''' <summary>
        ''' Represents the "Distinct" query operator.
        ''' </summary>
        ''' <param name="distinctKeyword">
        ''' The "Distinct" keyword.
        ''' </param>
        Friend Shared Function DistinctClause(distinctKeyword As KeywordSyntax) As DistinctClauseSyntax
            Debug.Assert(distinctKeyword IsNot Nothing AndAlso distinctKeyword.Kind = SyntaxKind.DistinctKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.DistinctClause, distinctKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, DistinctClauseSyntax)
            End If

            Dim result = New DistinctClauseSyntax(SyntaxKind.DistinctClause, distinctKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Where" query operator.
        ''' </summary>
        ''' <param name="whereKeyword">
        ''' The "Where" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression used for filtering.
        ''' </param>
        Friend Shared Function WhereClause(whereKeyword As KeywordSyntax, condition As ExpressionSyntax) As WhereClauseSyntax
            Debug.Assert(whereKeyword IsNot Nothing AndAlso whereKeyword.Kind = SyntaxKind.WhereKeyword)
            Debug.Assert(condition IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.WhereClause, whereKeyword, condition, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, WhereClauseSyntax)
            End If

            Dim result = New WhereClauseSyntax(SyntaxKind.WhereClause, whereKeyword, condition)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Skip While" or "Take While" query operator. The Kind property
        ''' tells which.
        ''' </summary>
        ''' <param name="skipOrTakeKeyword">
        ''' The "Skip" or "Take" keyword.
        ''' </param>
        ''' <param name="whileKeyword">
        ''' The "While" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression used for partitioning.
        ''' </param>
        Friend Shared Function SkipWhileClause(skipOrTakeKeyword As KeywordSyntax, whileKeyword As KeywordSyntax, condition As ExpressionSyntax) As PartitionWhileClauseSyntax
            Debug.Assert(skipOrTakeKeyword IsNot Nothing AndAlso skipOrTakeKeyword.Kind = SyntaxKind.SkipKeyword)
            Debug.Assert(whileKeyword IsNot Nothing AndAlso whileKeyword.Kind = SyntaxKind.WhileKeyword)
            Debug.Assert(condition IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.SkipWhileClause, skipOrTakeKeyword, whileKeyword, condition, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, PartitionWhileClauseSyntax)
            End If

            Dim result = New PartitionWhileClauseSyntax(SyntaxKind.SkipWhileClause, skipOrTakeKeyword, whileKeyword, condition)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Skip While" or "Take While" query operator. The Kind property
        ''' tells which.
        ''' </summary>
        ''' <param name="skipOrTakeKeyword">
        ''' The "Skip" or "Take" keyword.
        ''' </param>
        ''' <param name="whileKeyword">
        ''' The "While" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression used for partitioning.
        ''' </param>
        Friend Shared Function TakeWhileClause(skipOrTakeKeyword As KeywordSyntax, whileKeyword As KeywordSyntax, condition As ExpressionSyntax) As PartitionWhileClauseSyntax
            Debug.Assert(skipOrTakeKeyword IsNot Nothing AndAlso skipOrTakeKeyword.Kind = SyntaxKind.TakeKeyword)
            Debug.Assert(whileKeyword IsNot Nothing AndAlso whileKeyword.Kind = SyntaxKind.WhileKeyword)
            Debug.Assert(condition IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.TakeWhileClause, skipOrTakeKeyword, whileKeyword, condition, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, PartitionWhileClauseSyntax)
            End If

            Dim result = New PartitionWhileClauseSyntax(SyntaxKind.TakeWhileClause, skipOrTakeKeyword, whileKeyword, condition)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Skip While" or "Take While" query operator. The Kind property
        ''' tells which.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' PartitionWhileClauseSyntax. One of SkipWhileClause, TakeWhileClause.
        ''' </param>
        ''' <param name="skipOrTakeKeyword">
        ''' The "Skip" or "Take" keyword.
        ''' </param>
        ''' <param name="whileKeyword">
        ''' The "While" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression used for partitioning.
        ''' </param>
        Friend Shared Function PartitionWhileClause(kind As SyntaxKind, skipOrTakeKeyword As KeywordSyntax, whileKeyword As KeywordSyntax, condition As ExpressionSyntax) As PartitionWhileClauseSyntax
            Debug.Assert(SyntaxFacts.IsPartitionWhileClause(kind))
            Debug.Assert(skipOrTakeKeyword IsNot Nothing AndAlso SyntaxFacts.IsPartitionWhileClauseSkipOrTakeKeyword(skipOrTakeKeyword.Kind))
            Debug.Assert(whileKeyword IsNot Nothing AndAlso whileKeyword.Kind = SyntaxKind.WhileKeyword)
            Debug.Assert(condition IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(kind, skipOrTakeKeyword, whileKeyword, condition, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, PartitionWhileClauseSyntax)
            End If

            Dim result = New PartitionWhileClauseSyntax(kind, skipOrTakeKeyword, whileKeyword, condition)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Skip" or "Take" query operator. The Kind property tells which.
        ''' </summary>
        ''' <param name="skipOrTakeKeyword">
        ''' The "Skip" or "Take" keyword.
        ''' </param>
        ''' <param name="count">
        ''' Represents the expression with the number of items to take or skip.
        ''' </param>
        Friend Shared Function SkipClause(skipOrTakeKeyword As KeywordSyntax, count As ExpressionSyntax) As PartitionClauseSyntax
            Debug.Assert(skipOrTakeKeyword IsNot Nothing AndAlso skipOrTakeKeyword.Kind = SyntaxKind.SkipKeyword)
            Debug.Assert(count IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.SkipClause, skipOrTakeKeyword, count, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, PartitionClauseSyntax)
            End If

            Dim result = New PartitionClauseSyntax(SyntaxKind.SkipClause, skipOrTakeKeyword, count)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Skip" or "Take" query operator. The Kind property tells which.
        ''' </summary>
        ''' <param name="skipOrTakeKeyword">
        ''' The "Skip" or "Take" keyword.
        ''' </param>
        ''' <param name="count">
        ''' Represents the expression with the number of items to take or skip.
        ''' </param>
        Friend Shared Function TakeClause(skipOrTakeKeyword As KeywordSyntax, count As ExpressionSyntax) As PartitionClauseSyntax
            Debug.Assert(skipOrTakeKeyword IsNot Nothing AndAlso skipOrTakeKeyword.Kind = SyntaxKind.TakeKeyword)
            Debug.Assert(count IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.TakeClause, skipOrTakeKeyword, count, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, PartitionClauseSyntax)
            End If

            Dim result = New PartitionClauseSyntax(SyntaxKind.TakeClause, skipOrTakeKeyword, count)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Skip" or "Take" query operator. The Kind property tells which.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' PartitionClauseSyntax. One of SkipClause, TakeClause.
        ''' </param>
        ''' <param name="skipOrTakeKeyword">
        ''' The "Skip" or "Take" keyword.
        ''' </param>
        ''' <param name="count">
        ''' Represents the expression with the number of items to take or skip.
        ''' </param>
        Friend Shared Function PartitionClause(kind As SyntaxKind, skipOrTakeKeyword As KeywordSyntax, count As ExpressionSyntax) As PartitionClauseSyntax
            Debug.Assert(SyntaxFacts.IsPartitionClause(kind))
            Debug.Assert(skipOrTakeKeyword IsNot Nothing AndAlso SyntaxFacts.IsPartitionClauseSkipOrTakeKeyword(skipOrTakeKeyword.Kind))
            Debug.Assert(count IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(kind, skipOrTakeKeyword, count, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, PartitionClauseSyntax)
            End If

            Dim result = New PartitionClauseSyntax(kind, skipOrTakeKeyword, count)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the "Group By" query operator.
        ''' </summary>
        ''' <param name="groupKeyword">
        ''' The "Group" keyword.
        ''' </param>
        ''' <param name="items">
        ''' The optional list of variables being grouped; the contents of the Group clause.
        ''' If none were specified, an empty list is returned.
        ''' </param>
        ''' <param name="byKeyword">
        ''' The "By" keyword.
        ''' </param>
        ''' <param name="keys">
        ''' The key values being used for grouping.
        ''' </param>
        ''' <param name="aggregationVariables">
        ''' The list of new variables that calculate aggregations.
        ''' </param>
        Friend Shared Function GroupByClause(groupKeyword As KeywordSyntax, items As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), byKeyword As KeywordSyntax, keys As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), intoKeyword As KeywordSyntax, aggregationVariables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As GroupByClauseSyntax
            Debug.Assert(groupKeyword IsNot Nothing AndAlso groupKeyword.Kind = SyntaxKind.GroupKeyword)
            Debug.Assert(byKeyword IsNot Nothing AndAlso byKeyword.Kind = SyntaxKind.ByKeyword)
            Debug.Assert(intoKeyword IsNot Nothing AndAlso intoKeyword.Kind = SyntaxKind.IntoKeyword)
            Return New GroupByClauseSyntax(SyntaxKind.GroupByClause, groupKeyword, items.Node, byKeyword, keys.Node, intoKeyword, aggregationVariables.Node)
        End Function


        ''' <summary>
        ''' Represents the "expression Equals expression" condition in a Join.
        ''' </summary>
        ''' <param name="left">
        ''' The left expression in the Join condition.
        ''' </param>
        ''' <param name="equalsKeyword">
        ''' The "Equals" keyword.
        ''' </param>
        ''' <param name="right">
        ''' The right expression in the Join condition.
        ''' </param>
        Friend Shared Function JoinCondition(left As ExpressionSyntax, equalsKeyword As KeywordSyntax, right As ExpressionSyntax) As JoinConditionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(equalsKeyword IsNot Nothing AndAlso equalsKeyword.Kind = SyntaxKind.EqualsKeyword)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.JoinCondition, left, equalsKeyword, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, JoinConditionSyntax)
            End If

            Dim result = New JoinConditionSyntax(SyntaxKind.JoinCondition, left, equalsKeyword, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Join query operator.
        ''' </summary>
        ''' <param name="joinKeyword">
        ''' The "Join" keyword.
        ''' </param>
        ''' <param name="joinedVariables">
        ''' Defines the collection range variables being joined to.
        ''' </param>
        ''' <param name="additionalJoins">
        ''' An additional Join or Group Join query operator.
        ''' </param>
        ''' <param name="onKeyword">
        ''' The "On" keyword.
        ''' </param>
        ''' <param name="joinConditions">
        ''' The conditions indicating what expressions to compare during the join. Each
        ''' condition is a JoinCondition, and the separators are "And" keywords.
        ''' </param>
        Friend Shared Function SimpleJoinClause(joinKeyword As KeywordSyntax, joinedVariables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), additionalJoins As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), onKeyword As KeywordSyntax, joinConditions As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As SimpleJoinClauseSyntax
            Debug.Assert(joinKeyword IsNot Nothing AndAlso joinKeyword.Kind = SyntaxKind.JoinKeyword)
            Debug.Assert(onKeyword IsNot Nothing AndAlso onKeyword.Kind = SyntaxKind.OnKeyword)
            Return New SimpleJoinClauseSyntax(SyntaxKind.SimpleJoinClause, joinKeyword, joinedVariables.Node, additionalJoins.Node, onKeyword, joinConditions.Node)
        End Function


        ''' <summary>
        ''' Represents the "Group Join" query operator.
        ''' </summary>
        ''' <param name="groupKeyword">
        ''' The "Group" keyword.
        ''' </param>
        ''' <param name="joinKeyword">
        ''' The "Join" keyword.
        ''' </param>
        ''' <param name="joinedVariables">
        ''' Defines the collection range variables being joined to.
        ''' </param>
        ''' <param name="additionalJoins">
        ''' An additional Join or Group Join query operator.
        ''' </param>
        ''' <param name="onKeyword">
        ''' The "On" keyword.
        ''' </param>
        ''' <param name="joinConditions">
        ''' The conditions indicating what expressions to compare during the join. Each
        ''' condition is a JoinCondition, and the separators are "And" keywords.
        ''' </param>
        ''' <param name="intoKeyword">
        ''' The "Into" keyword.
        ''' </param>
        ''' <param name="aggregationVariables">
        ''' The list of new variables that calculate aggregations.
        ''' </param>
        Friend Shared Function GroupJoinClause(groupKeyword As KeywordSyntax, joinKeyword As KeywordSyntax, joinedVariables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), additionalJoins As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), onKeyword As KeywordSyntax, joinConditions As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), intoKeyword As KeywordSyntax, aggregationVariables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As GroupJoinClauseSyntax
            Debug.Assert(groupKeyword IsNot Nothing AndAlso groupKeyword.Kind = SyntaxKind.GroupKeyword)
            Debug.Assert(joinKeyword IsNot Nothing AndAlso joinKeyword.Kind = SyntaxKind.JoinKeyword)
            Debug.Assert(onKeyword IsNot Nothing AndAlso onKeyword.Kind = SyntaxKind.OnKeyword)
            Debug.Assert(intoKeyword IsNot Nothing AndAlso intoKeyword.Kind = SyntaxKind.IntoKeyword)
            Return New GroupJoinClauseSyntax(SyntaxKind.GroupJoinClause, groupKeyword, joinKeyword, joinedVariables.Node, additionalJoins.Node, onKeyword, joinConditions.Node, intoKeyword, aggregationVariables.Node)
        End Function


        ''' <summary>
        ''' Represents the "Order By" query operator.
        ''' </summary>
        ''' <param name="orderKeyword">
        ''' The "Order" keyword
        ''' </param>
        ''' <param name="byKeyword">
        ''' The "By" keyword.
        ''' </param>
        ''' <param name="orderings">
        ''' The list of OrderExpression's to sort by.
        ''' </param>
        Friend Shared Function OrderByClause(orderKeyword As KeywordSyntax, byKeyword As KeywordSyntax, orderings As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As OrderByClauseSyntax
            Debug.Assert(orderKeyword IsNot Nothing AndAlso orderKeyword.Kind = SyntaxKind.OrderKeyword)
            Debug.Assert(byKeyword IsNot Nothing AndAlso byKeyword.Kind = SyntaxKind.ByKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.OrderByClause, orderKeyword, byKeyword, orderings.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, OrderByClauseSyntax)
            End If

            Dim result = New OrderByClauseSyntax(SyntaxKind.OrderByClause, orderKeyword, byKeyword, orderings.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An expression to order by, plus an optional ordering. The Kind indicates
        ''' whether to order in ascending or descending order.
        ''' </summary>
        ''' <param name="expression">
        ''' The expression to sort by.
        ''' </param>
        ''' <param name="ascendingOrDescendingKeyword">
        ''' The "Ascending" or "Descending" keyword, if present. To determine whether to
        ''' sort in ascending or descending order, checking the Kind property is easier.
        ''' </param>
        Friend Shared Function AscendingOrdering(expression As ExpressionSyntax, ascendingOrDescendingKeyword As KeywordSyntax) As OrderingSyntax
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.AscendingOrdering, expression, ascendingOrDescendingKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, OrderingSyntax)
            End If

            Dim result = New OrderingSyntax(SyntaxKind.AscendingOrdering, expression, ascendingOrDescendingKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An expression to order by, plus an optional ordering. The Kind indicates
        ''' whether to order in ascending or descending order.
        ''' </summary>
        ''' <param name="expression">
        ''' The expression to sort by.
        ''' </param>
        ''' <param name="ascendingOrDescendingKeyword">
        ''' The "Ascending" or "Descending" keyword, if present. To determine whether to
        ''' sort in ascending or descending order, checking the Kind property is easier.
        ''' </param>
        Friend Shared Function DescendingOrdering(expression As ExpressionSyntax, ascendingOrDescendingKeyword As KeywordSyntax) As OrderingSyntax
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.DescendingOrdering, expression, ascendingOrDescendingKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, OrderingSyntax)
            End If

            Dim result = New OrderingSyntax(SyntaxKind.DescendingOrdering, expression, ascendingOrDescendingKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An expression to order by, plus an optional ordering. The Kind indicates
        ''' whether to order in ascending or descending order.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of OrderingSyntax.
        ''' One of AscendingOrdering, DescendingOrdering.
        ''' </param>
        ''' <param name="expression">
        ''' The expression to sort by.
        ''' </param>
        ''' <param name="ascendingOrDescendingKeyword">
        ''' The "Ascending" or "Descending" keyword, if present. To determine whether to
        ''' sort in ascending or descending order, checking the Kind property is easier.
        ''' </param>
        Friend Shared Function Ordering(kind As SyntaxKind, expression As ExpressionSyntax, ascendingOrDescendingKeyword As KeywordSyntax) As OrderingSyntax
            Debug.Assert(SyntaxFacts.IsOrdering(kind))
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(kind, expression, ascendingOrDescendingKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, OrderingSyntax)
            End If

            Dim result = New OrderingSyntax(kind, expression, ascendingOrDescendingKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the "Select" query operator.
        ''' </summary>
        ''' <param name="selectKeyword">
        ''' The "Select" keyword.
        ''' </param>
        ''' <param name="variables">
        ''' The list of expression range variables being defined by the Select query
        ''' operator.
        ''' </param>
        Friend Shared Function SelectClause(selectKeyword As KeywordSyntax, variables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As SelectClauseSyntax
            Debug.Assert(selectKeyword IsNot Nothing AndAlso selectKeyword.Kind = SyntaxKind.SelectKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.SelectClause, selectKeyword, variables.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SelectClauseSyntax)
            End If

            Dim result = New SelectClauseSyntax(SyntaxKind.SelectClause, selectKeyword, variables.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an XML Document literal expression.
        ''' </summary>
        Friend Shared Function XmlDocument(declaration As XmlDeclarationSyntax, precedingMisc As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), root As XmlNodeSyntax, followingMisc As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As XmlDocumentSyntax
            Debug.Assert(declaration IsNot Nothing)
            Debug.Assert(root IsNot Nothing)
            Return New XmlDocumentSyntax(SyntaxKind.XmlDocument, declaration, precedingMisc.Node, root, followingMisc.Node)
        End Function


        ''' <summary>
        ''' Represents the XML declaration prologue in an XML literal expression.
        ''' </summary>
        Friend Shared Function XmlDeclaration(lessThanQuestionToken As PunctuationSyntax, xmlKeyword As KeywordSyntax, version As XmlDeclarationOptionSyntax, encoding As XmlDeclarationOptionSyntax, standalone As XmlDeclarationOptionSyntax, questionGreaterThanToken As PunctuationSyntax) As XmlDeclarationSyntax
            Debug.Assert(lessThanQuestionToken IsNot Nothing AndAlso lessThanQuestionToken.Kind = SyntaxKind.LessThanQuestionToken)
            Debug.Assert(xmlKeyword IsNot Nothing AndAlso xmlKeyword.Kind = SyntaxKind.XmlKeyword)
            Debug.Assert(version IsNot Nothing)
            Debug.Assert(questionGreaterThanToken IsNot Nothing AndAlso questionGreaterThanToken.Kind = SyntaxKind.QuestionGreaterThanToken)
            Return New XmlDeclarationSyntax(SyntaxKind.XmlDeclaration, lessThanQuestionToken, xmlKeyword, version, encoding, standalone, questionGreaterThanToken)
        End Function


        ''' <summary>
        ''' Represents an XML document prologue option - version, encoding, standalone or
        ''' whitespace in an XML literal expression.
        ''' </summary>
        Friend Shared Function XmlDeclarationOption(name As XmlNameTokenSyntax, equals As PunctuationSyntax, value As XmlStringSyntax) As XmlDeclarationOptionSyntax
            Debug.Assert(name IsNot Nothing AndAlso name.Kind = SyntaxKind.XmlNameToken)
            Debug.Assert(equals IsNot Nothing AndAlso equals.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.XmlDeclarationOption, name, equals, value, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlDeclarationOptionSyntax)
            End If

            Dim result = New XmlDeclarationOptionSyntax(SyntaxKind.XmlDeclarationOption, name, equals, value)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an XML element with content in an XML literal expression.
        ''' </summary>
        Friend Shared Function XmlElement(startTag As XmlElementStartTagSyntax, content As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endTag As XmlElementEndTagSyntax) As XmlElementSyntax
            Debug.Assert(startTag IsNot Nothing)
            Debug.Assert(endTag IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.XmlElement, startTag, content.Node, endTag, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlElementSyntax)
            End If

            Dim result = New XmlElementSyntax(SyntaxKind.XmlElement, startTag, content.Node, endTag)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents Xml text.
        ''' </summary>
        ''' <param name="textTokens">
        ''' A list of all the text tokens in the Xml text. This list always contains at
        ''' least one token.
        ''' </param>
        Friend Shared Function XmlText(textTokens As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As XmlTextSyntax

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.XmlText, textTokens.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlTextSyntax)
            End If

            Dim result = New XmlTextSyntax(SyntaxKind.XmlText, textTokens.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the start tag of an XML element of the form &lt;element&gt;.
        ''' </summary>
        Friend Shared Function XmlElementStartTag(lessThanToken As PunctuationSyntax, name As XmlNodeSyntax, attributes As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), greaterThanToken As PunctuationSyntax) As XmlElementStartTagSyntax
            Debug.Assert(lessThanToken IsNot Nothing AndAlso lessThanToken.Kind = SyntaxKind.LessThanToken)
            Debug.Assert(name IsNot Nothing)
            Debug.Assert(greaterThanToken IsNot Nothing AndAlso greaterThanToken.Kind = SyntaxKind.GreaterThanToken)
            Return New XmlElementStartTagSyntax(SyntaxKind.XmlElementStartTag, lessThanToken, name, attributes.Node, greaterThanToken)
        End Function


        ''' <summary>
        ''' Represents the end tag of an XML element of the form &lt;/element&gt;.
        ''' </summary>
        Friend Shared Function XmlElementEndTag(lessThanSlashToken As PunctuationSyntax, name As XmlNameSyntax, greaterThanToken As PunctuationSyntax) As XmlElementEndTagSyntax
            Debug.Assert(lessThanSlashToken IsNot Nothing AndAlso lessThanSlashToken.Kind = SyntaxKind.LessThanSlashToken)
            Debug.Assert(greaterThanToken IsNot Nothing AndAlso greaterThanToken.Kind = SyntaxKind.GreaterThanToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlElementEndTagSyntax)
            End If

            Dim result = New XmlElementEndTagSyntax(SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an empty XML element of the form &lt;element /&gt;
        ''' </summary>
        Friend Shared Function XmlEmptyElement(lessThanToken As PunctuationSyntax, name As XmlNodeSyntax, attributes As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), slashGreaterThanToken As PunctuationSyntax) As XmlEmptyElementSyntax
            Debug.Assert(lessThanToken IsNot Nothing AndAlso lessThanToken.Kind = SyntaxKind.LessThanToken)
            Debug.Assert(name IsNot Nothing)
            Debug.Assert(slashGreaterThanToken IsNot Nothing AndAlso slashGreaterThanToken.Kind = SyntaxKind.SlashGreaterThanToken)
            Return New XmlEmptyElementSyntax(SyntaxKind.XmlEmptyElement, lessThanToken, name, attributes.Node, slashGreaterThanToken)
        End Function


        ''' <summary>
        ''' Represents an XML attribute in an XML literal expression.
        ''' </summary>
        Friend Shared Function XmlAttribute(name As XmlNodeSyntax, equalsToken As PunctuationSyntax, value As XmlNodeSyntax) As XmlAttributeSyntax
            Debug.Assert(name IsNot Nothing)
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.XmlAttribute, name, equalsToken, value, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlAttributeSyntax)
            End If

            Dim result = New XmlAttributeSyntax(SyntaxKind.XmlAttribute, name, equalsToken, value)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a string of XML characters embedded as the content of an XML
        ''' element.
        ''' </summary>
        Friend Shared Function XmlString(startQuoteToken As PunctuationSyntax, textTokens As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endQuoteToken As PunctuationSyntax) As XmlStringSyntax
            Debug.Assert(startQuoteToken IsNot Nothing AndAlso SyntaxFacts.IsXmlStringStartQuoteToken(startQuoteToken.Kind))
            Debug.Assert(endQuoteToken IsNot Nothing AndAlso SyntaxFacts.IsXmlStringEndQuoteToken(endQuoteToken.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.XmlString, startQuoteToken, textTokens.Node, endQuoteToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlStringSyntax)
            End If

            Dim result = New XmlStringSyntax(SyntaxKind.XmlString, startQuoteToken, textTokens.Node, endQuoteToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an XML name of the form 'name' appearing in GetXmlNamespace().
        ''' </summary>
        Friend Shared Function XmlPrefixName(name As XmlNameTokenSyntax) As XmlPrefixNameSyntax
            Debug.Assert(name IsNot Nothing AndAlso name.Kind = SyntaxKind.XmlNameToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.XmlPrefixName, name, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlPrefixNameSyntax)
            End If

            Dim result = New XmlPrefixNameSyntax(SyntaxKind.XmlPrefixName, name)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an XML name of the form 'name' or 'namespace:name' appearing in
        ''' source as part of an XML literal or member access expression or an XML
        ''' namespace import clause.
        ''' </summary>
        Friend Shared Function XmlName(prefix As XmlPrefixSyntax, localName As XmlNameTokenSyntax) As XmlNameSyntax
            Debug.Assert(localName IsNot Nothing AndAlso localName.Kind = SyntaxKind.XmlNameToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.XmlName, prefix, localName, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlNameSyntax)
            End If

            Dim result = New XmlNameSyntax(SyntaxKind.XmlName, prefix, localName)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an XML name of the form &lt;xml-name&gt; appearing in source as part
        ''' of an XML literal or member access expression or an XML namespace import
        ''' clause.
        ''' </summary>
        Friend Shared Function XmlBracketedName(lessThanToken As PunctuationSyntax, name As XmlNameSyntax, greaterThanToken As PunctuationSyntax) As XmlBracketedNameSyntax
            Debug.Assert(lessThanToken IsNot Nothing AndAlso lessThanToken.Kind = SyntaxKind.LessThanToken)
            Debug.Assert(name IsNot Nothing)
            Debug.Assert(greaterThanToken IsNot Nothing AndAlso greaterThanToken.Kind = SyntaxKind.GreaterThanToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.XmlBracketedName, lessThanToken, name, greaterThanToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlBracketedNameSyntax)
            End If

            Dim result = New XmlBracketedNameSyntax(SyntaxKind.XmlBracketedName, lessThanToken, name, greaterThanToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an XML namespace prefix of the form 'prefix:' as in xml:ns="".
        ''' </summary>
        Friend Shared Function XmlPrefix(name As XmlNameTokenSyntax, colonToken As PunctuationSyntax) As XmlPrefixSyntax
            Debug.Assert(name IsNot Nothing AndAlso name.Kind = SyntaxKind.XmlNameToken)
            Debug.Assert(colonToken IsNot Nothing AndAlso colonToken.Kind = SyntaxKind.ColonToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.XmlPrefix, name, colonToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlPrefixSyntax)
            End If

            Dim result = New XmlPrefixSyntax(SyntaxKind.XmlPrefix, name, colonToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an XML comment of the form &lt;!-- Comment --&gt; appearing in an
        ''' XML literal expression.
        ''' </summary>
        Friend Shared Function XmlComment(lessThanExclamationMinusMinusToken As PunctuationSyntax, textTokens As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), minusMinusGreaterThanToken As PunctuationSyntax) As XmlCommentSyntax
            Debug.Assert(lessThanExclamationMinusMinusToken IsNot Nothing AndAlso lessThanExclamationMinusMinusToken.Kind = SyntaxKind.LessThanExclamationMinusMinusToken)
            Debug.Assert(minusMinusGreaterThanToken IsNot Nothing AndAlso minusMinusGreaterThanToken.Kind = SyntaxKind.MinusMinusGreaterThanToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlCommentSyntax)
            End If

            Dim result = New XmlCommentSyntax(SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an XML processing instruction of the form '&lt;? XMLProcessingTarget
        ''' XMLProcessingValue ?&gt;'.
        ''' </summary>
        Friend Shared Function XmlProcessingInstruction(lessThanQuestionToken As PunctuationSyntax, name As XmlNameTokenSyntax, textTokens As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), questionGreaterThanToken As PunctuationSyntax) As XmlProcessingInstructionSyntax
            Debug.Assert(lessThanQuestionToken IsNot Nothing AndAlso lessThanQuestionToken.Kind = SyntaxKind.LessThanQuestionToken)
            Debug.Assert(name IsNot Nothing AndAlso name.Kind = SyntaxKind.XmlNameToken)
            Debug.Assert(questionGreaterThanToken IsNot Nothing AndAlso questionGreaterThanToken.Kind = SyntaxKind.QuestionGreaterThanToken)
            Return New XmlProcessingInstructionSyntax(SyntaxKind.XmlProcessingInstruction, lessThanQuestionToken, name, textTokens.Node, questionGreaterThanToken)
        End Function


        ''' <summary>
        ''' Represents an XML CDATA section in an XML literal expression.
        ''' </summary>
        Friend Shared Function XmlCDataSection(beginCDataToken As PunctuationSyntax, textTokens As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endCDataToken As PunctuationSyntax) As XmlCDataSectionSyntax
            Debug.Assert(beginCDataToken IsNot Nothing AndAlso beginCDataToken.Kind = SyntaxKind.BeginCDataToken)
            Debug.Assert(endCDataToken IsNot Nothing AndAlso endCDataToken.Kind = SyntaxKind.EndCDataToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.XmlCDataSection, beginCDataToken, textTokens.Node, endCDataToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlCDataSectionSyntax)
            End If

            Dim result = New XmlCDataSectionSyntax(SyntaxKind.XmlCDataSection, beginCDataToken, textTokens.Node, endCDataToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an embedded expression in an XML literal e.g. '&lt;name&gt;&lt;%=
        ''' obj.Name =%&gt;&lt;/name&gt;'.
        ''' </summary>
        Friend Shared Function XmlEmbeddedExpression(lessThanPercentEqualsToken As PunctuationSyntax, expression As ExpressionSyntax, percentGreaterThanToken As PunctuationSyntax) As XmlEmbeddedExpressionSyntax
            Debug.Assert(lessThanPercentEqualsToken IsNot Nothing AndAlso lessThanPercentEqualsToken.Kind = SyntaxKind.LessThanPercentEqualsToken)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(percentGreaterThanToken IsNot Nothing AndAlso percentGreaterThanToken.Kind = SyntaxKind.PercentGreaterThanToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.XmlEmbeddedExpression, lessThanPercentEqualsToken, expression, percentGreaterThanToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlEmbeddedExpressionSyntax)
            End If

            Dim result = New XmlEmbeddedExpressionSyntax(SyntaxKind.XmlEmbeddedExpression, lessThanPercentEqualsToken, expression, percentGreaterThanToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an array type, such as "A() or "A(,)", without bounds specified for
        ''' the array.
        ''' </summary>
        ''' <param name="elementType">
        ''' The type of the elements of the array.
        ''' </param>
        ''' <param name="rankSpecifiers">
        ''' Represents the list of "()" or "(,,)" modifiers on the array type.
        ''' </param>
        Friend Shared Function ArrayType(elementType As TypeSyntax, rankSpecifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As ArrayTypeSyntax
            Debug.Assert(elementType IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ArrayType, elementType, rankSpecifiers.Node, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ArrayTypeSyntax)
            End If

            Dim result = New ArrayTypeSyntax(SyntaxKind.ArrayType, elementType, rankSpecifiers.Node)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' A type name that represents a nullable type, such as "Integer?".
        ''' </summary>
        ''' <param name="elementType">
        ''' The kind of type that is this type is a nullable of. Cannot be an array type or
        ''' a nullable type.
        ''' </param>
        ''' <param name="questionMarkToken">
        ''' The "?" token.
        ''' </param>
        Friend Shared Function NullableType(elementType As TypeSyntax, questionMarkToken As PunctuationSyntax) As NullableTypeSyntax
            Debug.Assert(elementType IsNot Nothing)
            Debug.Assert(questionMarkToken IsNot Nothing AndAlso questionMarkToken.Kind = SyntaxKind.QuestionToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.NullableType, elementType, questionMarkToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, NullableTypeSyntax)
            End If

            Dim result = New NullableTypeSyntax(SyntaxKind.NullableType, elementType, questionMarkToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an occurrence of a Visual Basic built-in type such as Integer or
        ''' String in source code.
        ''' </summary>
        ''' <param name="keyword">
        ''' The keyword that was used to describe the built-in type.
        ''' </param>
        Friend Shared Function PredefinedType(keyword As KeywordSyntax) As PredefinedTypeSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso SyntaxFacts.IsPredefinedTypeKeyword(keyword.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.PredefinedType, keyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, PredefinedTypeSyntax)
            End If

            Dim result = New PredefinedTypeSyntax(SyntaxKind.PredefinedType, keyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a type name consisting of a single identifier (which might include
        ''' brackets or a type character).
        ''' </summary>
        ''' <param name="identifier">
        ''' The identifier in the name.
        ''' </param>
        Friend Shared Function IdentifierName(identifier As IdentifierTokenSyntax) As IdentifierNameSyntax
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.IdentifierName, identifier, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, IdentifierNameSyntax)
            End If

            Dim result = New IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple type name with one or more generic arguments, such as "X(Of
        ''' Y, Z).
        ''' </summary>
        ''' <param name="identifier">
        ''' The identifier in the name.
        ''' </param>
        ''' <param name="typeArgumentList">
        ''' The generic argument list.
        ''' </param>
        Friend Shared Function GenericName(identifier As IdentifierTokenSyntax, typeArgumentList As TypeArgumentListSyntax) As GenericNameSyntax
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Debug.Assert(typeArgumentList IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.GenericName, identifier, typeArgumentList, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, GenericNameSyntax)
            End If

            Dim result = New GenericNameSyntax(SyntaxKind.GenericName, identifier, typeArgumentList)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a qualified type name, for example X.Y or X(Of Z).Y.
        ''' </summary>
        ''' <param name="left">
        ''' The part of the name that appears to the left of the dot. This can itself be
        ''' any name.
        ''' </param>
        ''' <param name="dotToken">
        ''' The "." token that separates the names.
        ''' </param>
        ''' <param name="right">
        ''' The part of the name that appears to the right of the dot. This must be a
        ''' simple identifier.
        ''' </param>
        Friend Shared Function QualifiedName(left As NameSyntax, dotToken As PunctuationSyntax, right As SimpleNameSyntax) As QualifiedNameSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(dotToken IsNot Nothing AndAlso dotToken.Kind = SyntaxKind.DotToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.QualifiedName, left, dotToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, QualifiedNameSyntax)
            End If

            Dim result = New QualifiedNameSyntax(SyntaxKind.QualifiedName, left, dotToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a name in the global namespace.
        ''' </summary>
        ''' <param name="globalKeyword">
        ''' The "Global" keyword.
        ''' </param>
        Friend Shared Function GlobalName(globalKeyword As KeywordSyntax) As GlobalNameSyntax
            Debug.Assert(globalKeyword IsNot Nothing AndAlso globalKeyword.Kind = SyntaxKind.GlobalKeyword)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.GlobalName, globalKeyword, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, GlobalNameSyntax)
            End If

            Dim result = New GlobalNameSyntax(SyntaxKind.GlobalName, globalKeyword)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a parenthesized list of generic type arguments.
        ''' </summary>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="ofKeyword">
        ''' The "Of" keyword.
        ''' </param>
        ''' <param name="arguments">
        ''' A list of all the type arguments.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Shared Function TypeArgumentList(openParenToken As PunctuationSyntax, ofKeyword As KeywordSyntax, arguments As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), closeParenToken As PunctuationSyntax) As TypeArgumentListSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(ofKeyword IsNot Nothing AndAlso ofKeyword.Kind = SyntaxKind.OfKeyword)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New TypeArgumentListSyntax(SyntaxKind.TypeArgumentList, openParenToken, ofKeyword, arguments.Node, closeParenToken)
        End Function


        ''' <summary>
        ''' Syntax node class that represents a value of 'cref' attribute inside
        ''' documentation comment trivia.
        ''' </summary>
        Friend Shared Function CrefReference(name As TypeSyntax, signature As CrefSignatureSyntax, asClause As SimpleAsClauseSyntax) As CrefReferenceSyntax
            Debug.Assert(name IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.CrefReference, name, signature, asClause, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CrefReferenceSyntax)
            End If

            Dim result = New CrefReferenceSyntax(SyntaxKind.CrefReference, name, signature, asClause)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a parenthesized list of argument types for a signature inside
        ''' CrefReferenceSyntax syntax.
        ''' </summary>
        Friend Shared Function CrefSignature(openParenToken As PunctuationSyntax, argumentTypes As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), closeParenToken As PunctuationSyntax) As CrefSignatureSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.CrefSignature, openParenToken, argumentTypes.Node, closeParenToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CrefSignatureSyntax)
            End If

            Dim result = New CrefSignatureSyntax(SyntaxKind.CrefSignature, openParenToken, argumentTypes.Node, closeParenToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        Friend Shared Function CrefSignaturePart(modifier As KeywordSyntax, type As TypeSyntax) As CrefSignaturePartSyntax

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.CrefSignaturePart, modifier, type, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CrefSignaturePartSyntax)
            End If

            Dim result = New CrefSignaturePartSyntax(SyntaxKind.CrefSignaturePart, modifier, type)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        Friend Shared Function CrefOperatorReference(operatorKeyword As KeywordSyntax, operatorToken As SyntaxToken) As CrefOperatorReferenceSyntax
            Debug.Assert(operatorKeyword IsNot Nothing AndAlso operatorKeyword.Kind = SyntaxKind.OperatorKeyword)
            Debug.Assert(operatorToken IsNot Nothing AndAlso SyntaxFacts.IsCrefOperatorReferenceOperatorToken(operatorToken.Kind))

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.CrefOperatorReference, operatorKeyword, operatorToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CrefOperatorReferenceSyntax)
            End If

            Dim result = New CrefOperatorReferenceSyntax(SyntaxKind.CrefOperatorReference, operatorKeyword, operatorToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        Friend Shared Function QualifiedCrefOperatorReference(left As NameSyntax, dotToken As PunctuationSyntax, right As CrefOperatorReferenceSyntax) As QualifiedCrefOperatorReferenceSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(dotToken IsNot Nothing AndAlso dotToken.Kind = SyntaxKind.DotToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.QualifiedCrefOperatorReference, left, dotToken, right, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, QualifiedCrefOperatorReferenceSyntax)
            End If

            Dim result = New QualifiedCrefOperatorReferenceSyntax(SyntaxKind.QualifiedCrefOperatorReference, left, dotToken, right)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represent a Yield statement.
        ''' </summary>
        ''' <param name="yieldKeyword">
        ''' The "Yield" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression whose value is being yielded.
        ''' </param>
        Friend Shared Function YieldStatement(yieldKeyword As KeywordSyntax, expression As ExpressionSyntax) As YieldStatementSyntax
            Debug.Assert(yieldKeyword IsNot Nothing AndAlso yieldKeyword.Kind = SyntaxKind.YieldKeyword)
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.YieldStatement, yieldKeyword, expression, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, YieldStatementSyntax)
            End If

            Dim result = New YieldStatementSyntax(SyntaxKind.YieldStatement, yieldKeyword, expression)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an Await expression.
        ''' </summary>
        ''' <param name="awaitKeyword">
        ''' The "Await" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being awaited.
        ''' </param>
        Friend Shared Function AwaitExpression(awaitKeyword As KeywordSyntax, expression As ExpressionSyntax) As AwaitExpressionSyntax
            Debug.Assert(awaitKeyword IsNot Nothing AndAlso awaitKeyword.Kind = SyntaxKind.AwaitKeyword)
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.AwaitExpression, awaitKeyword, expression, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AwaitExpressionSyntax)
            End If

            Dim result = New AwaitExpressionSyntax(SyntaxKind.AwaitExpression, awaitKeyword, expression)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an Xml NCName per Namespaces in XML 1.0
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function XmlNameToken(text as String, possibleKeywordKind As SyntaxKind, leadingTrivia As GreenNode, trailingTrivia As GreenNode) As XmlNameTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New XmlNameTokenSyntax(SyntaxKind.XmlNameToken, text, leadingTrivia, trailingTrivia, possibleKeywordKind)
        End Function


        ''' <summary>
        ''' Represents character data in Xml content also known as PCData or in an Xml
        ''' attribute value. All text is here for now even text that does not need
        ''' normalization such as comment, pi and cdata text.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function XmlTextLiteralToken(text as String, value As String, leadingTrivia As GreenNode, trailingTrivia As GreenNode) As XmlTextTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New XmlTextTokenSyntax(SyntaxKind.XmlTextLiteralToken, text, leadingTrivia, trailingTrivia, value)
        End Function


        ''' <summary>
        ''' Represents character data in Xml content also known as PCData or in an Xml
        ''' attribute value. All text is here for now even text that does not need
        ''' normalization such as comment, pi and cdata text.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function XmlEntityLiteralToken(text as String, value As String, leadingTrivia As GreenNode, trailingTrivia As GreenNode) As XmlTextTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New XmlTextTokenSyntax(SyntaxKind.XmlEntityLiteralToken, text, leadingTrivia, trailingTrivia, value)
        End Function


        ''' <summary>
        ''' Represents character data in Xml content also known as PCData or in an Xml
        ''' attribute value. All text is here for now even text that does not need
        ''' normalization such as comment, pi and cdata text.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function DocumentationCommentLineBreakToken(text as String, value As String, leadingTrivia As GreenNode, trailingTrivia As GreenNode) As XmlTextTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New XmlTextTokenSyntax(SyntaxKind.DocumentationCommentLineBreakToken, text, leadingTrivia, trailingTrivia, value)
        End Function


        ''' <summary>
        ''' Represents character data in Xml content also known as PCData or in an Xml
        ''' attribute value. All text is here for now even text that does not need
        ''' normalization such as comment, pi and cdata text.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' XmlTextTokenSyntax. One of XmlTextLiteralToken, XmlEntityLiteralToken,
        ''' DocumentationCommentLineBreakToken.
        ''' </param>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function XmlTextToken(kind As SyntaxKind, text as String, value As String, leadingTrivia As GreenNode, trailingTrivia As GreenNode) As XmlTextTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Debug.Assert(SyntaxFacts.IsXmlTextToken(kind))
            Return New XmlTextTokenSyntax(kind, text, leadingTrivia, trailingTrivia, value)
        End Function


        ''' <summary>
        ''' Represents literal character data in interpolated string expression.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function InterpolatedStringTextToken(text as String, value As String, leadingTrivia As GreenNode, trailingTrivia As GreenNode) As InterpolatedStringTextTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New InterpolatedStringTextTokenSyntax(SyntaxKind.InterpolatedStringTextToken, text, leadingTrivia, trailingTrivia, value)
        End Function


        ''' <summary>
        ''' Represents a Decimal literal token.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function DecimalLiteralToken(text as String, typeSuffix As TypeCharacter, value As System.Decimal, leadingTrivia As GreenNode, trailingTrivia As GreenNode) As DecimalLiteralTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New DecimalLiteralTokenSyntax(SyntaxKind.DecimalLiteralToken, text, leadingTrivia, trailingTrivia, typeSuffix, value)
        End Function


        ''' <summary>
        ''' Represents a Date literal token.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function DateLiteralToken(text as String, value As DateTime, leadingTrivia As GreenNode, trailingTrivia As GreenNode) As DateLiteralTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New DateLiteralTokenSyntax(SyntaxKind.DateLiteralToken, text, leadingTrivia, trailingTrivia, value)
        End Function


        ''' <summary>
        ''' Represents a string literal token.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function StringLiteralToken(text as String, value As String, leadingTrivia As GreenNode, trailingTrivia As GreenNode) As StringLiteralTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New StringLiteralTokenSyntax(SyntaxKind.StringLiteralToken, text, leadingTrivia, trailingTrivia, value)
        End Function


        ''' <summary>
        ''' Represents a string literal token.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function CharacterLiteralToken(text as String, value As Char, leadingTrivia As GreenNode, trailingTrivia As GreenNode) As CharacterLiteralTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New CharacterLiteralTokenSyntax(SyntaxKind.CharacterLiteralToken, text, leadingTrivia, trailingTrivia, value)
        End Function


        ''' <summary>
        ''' Represents tokens that were skipped by the parser as part of error recovery,
        ''' and thus are not part of any syntactic structure.
        ''' </summary>
        ''' <param name="tokens">
        ''' The list of tokens that were skipped by the parser.
        ''' </param>
        Friend Shared Function SkippedTokensTrivia(tokens As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As SkippedTokensTriviaSyntax
            Return New SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, tokens.Node)
        End Function


        ''' <summary>
        ''' Represents a documentation comment e.g. ''' &lt;Summary&gt; appearing in
        ''' source.
        ''' </summary>
        Friend Shared Function DocumentationCommentTrivia(content As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As DocumentationCommentTriviaSyntax
            Return New DocumentationCommentTriviaSyntax(SyntaxKind.DocumentationCommentTrivia, content.Node)
        End Function


        ''' <summary>
        ''' A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or
        ''' &lt;seealso&gt; documentation comment tag). For example, the M in &lt;see
        ''' cref="M" /&gt;.
        ''' </summary>
        Friend Shared Function XmlCrefAttribute(name As XmlNameSyntax, equalsToken As PunctuationSyntax, startQuoteToken As PunctuationSyntax, reference As CrefReferenceSyntax, endQuoteToken As PunctuationSyntax) As XmlCrefAttributeSyntax
            Debug.Assert(name IsNot Nothing)
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(startQuoteToken IsNot Nothing AndAlso SyntaxFacts.IsXmlCrefAttributeStartQuoteToken(startQuoteToken.Kind))
            Debug.Assert(reference IsNot Nothing)
            Debug.Assert(endQuoteToken IsNot Nothing AndAlso SyntaxFacts.IsXmlCrefAttributeEndQuoteToken(endQuoteToken.Kind))
            Return New XmlCrefAttributeSyntax(SyntaxKind.XmlCrefAttribute, name, equalsToken, startQuoteToken, reference, endQuoteToken)
        End Function


        ''' <summary>
        ''' A param or type param symbol referenced by a name attribute (e.g. in a
        ''' &lt;param&gt; or &lt;typeparam&gt; documentation comment tag). For example, the
        ''' M in &lt;param name="M" /&gt;.
        ''' </summary>
        Friend Shared Function XmlNameAttribute(name As XmlNameSyntax, equalsToken As PunctuationSyntax, startQuoteToken As PunctuationSyntax, reference As IdentifierNameSyntax, endQuoteToken As PunctuationSyntax) As XmlNameAttributeSyntax
            Debug.Assert(name IsNot Nothing)
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(startQuoteToken IsNot Nothing AndAlso SyntaxFacts.IsXmlNameAttributeStartQuoteToken(startQuoteToken.Kind))
            Debug.Assert(reference IsNot Nothing)
            Debug.Assert(endQuoteToken IsNot Nothing AndAlso SyntaxFacts.IsXmlNameAttributeEndQuoteToken(endQuoteToken.Kind))
            Return New XmlNameAttributeSyntax(SyntaxKind.XmlNameAttribute, name, equalsToken, startQuoteToken, reference, endQuoteToken)
        End Function


        ''' <summary>
        ''' ExpressionSyntax node representing the object conditionally accessed.
        ''' </summary>
        ''' <param name="expression">
        ''' The expression on the left-hand-side of the "?".
        ''' </param>
        ''' <param name="questionMarkToken">
        ''' "?" token.
        ''' </param>
        ''' <param name="whenNotNull">
        ''' ExpressionSyntax node representing the access expression to be executed when
        ''' the object is not null."
        ''' </param>
        Friend Shared Function ConditionalAccessExpression(expression As ExpressionSyntax, questionMarkToken As PunctuationSyntax, whenNotNull As ExpressionSyntax) As ConditionalAccessExpressionSyntax
            Debug.Assert(questionMarkToken IsNot Nothing AndAlso questionMarkToken.Kind = SyntaxKind.QuestionToken)
            Debug.Assert(whenNotNull IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.ConditionalAccessExpression, expression, questionMarkToken, whenNotNull, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ConditionalAccessExpressionSyntax)
            End If

            Dim result = New ConditionalAccessExpressionSyntax(SyntaxKind.ConditionalAccessExpression, expression, questionMarkToken, whenNotNull)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a NameOf expression.
        ''' </summary>
        ''' <param name="nameOfKeyword">
        ''' The "NameOf" keyword.
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="argument">
        ''' The argument.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Shared Function NameOfExpression(nameOfKeyword As KeywordSyntax, openParenToken As PunctuationSyntax, argument As ExpressionSyntax, closeParenToken As PunctuationSyntax) As NameOfExpressionSyntax
            Debug.Assert(nameOfKeyword IsNot Nothing AndAlso nameOfKeyword.Kind = SyntaxKind.NameOfKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(argument IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New NameOfExpressionSyntax(SyntaxKind.NameOfExpression, nameOfKeyword, openParenToken, argument, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents an interpolated string expression.
        ''' </summary>
        ''' <param name="dollarSignDoubleQuoteToken">
        ''' The opening '$"', '$“', or '$”' token.
        ''' </param>
        ''' <param name="contents">
        ''' The contents of the interpolated string.
        ''' </param>
        ''' <param name="doubleQuoteToken">
        ''' The closing '"', '”', or '“' token.
        ''' </param>
        Friend Shared Function InterpolatedStringExpression(dollarSignDoubleQuoteToken As PunctuationSyntax, contents As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), doubleQuoteToken As PunctuationSyntax) As InterpolatedStringExpressionSyntax
            Debug.Assert(dollarSignDoubleQuoteToken IsNot Nothing AndAlso dollarSignDoubleQuoteToken.Kind = SyntaxKind.DollarSignDoubleQuoteToken)
            Debug.Assert(doubleQuoteToken IsNot Nothing AndAlso doubleQuoteToken.Kind = SyntaxKind.DoubleQuoteToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.InterpolatedStringExpression, dollarSignDoubleQuoteToken, contents.Node, doubleQuoteToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, InterpolatedStringExpressionSyntax)
            End If

            Dim result = New InterpolatedStringExpressionSyntax(SyntaxKind.InterpolatedStringExpression, dollarSignDoubleQuoteToken, contents.Node, doubleQuoteToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents literal text content in an interpolated string.
        ''' </summary>
        ''' <param name="textToken">
        ''' The text token.
        ''' </param>
        Friend Shared Function InterpolatedStringText(textToken As InterpolatedStringTextTokenSyntax) As InterpolatedStringTextSyntax
            Debug.Assert(textToken IsNot Nothing AndAlso textToken.Kind = SyntaxKind.InterpolatedStringTextToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.InterpolatedStringText, textToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, InterpolatedStringTextSyntax)
            End If

            Dim result = New InterpolatedStringTextSyntax(SyntaxKind.InterpolatedStringText, textToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an interpolation of an expression in an interpolated string
        ''' expression e.g. '{expression[,alignment][:formatString]}'.
        ''' </summary>
        ''' <param name="openBraceToken">
        ''' The opening curly brace '{' token.
        ''' </param>
        ''' <param name="expression">
        ''' The expression whose formatted value should be embedded in the resultant
        ''' string.
        ''' </param>
        ''' <param name="alignmentClause">
        ''' Optional. The alignment clause ',alignment' of the embedded expression.
        ''' </param>
        ''' <param name="formatClause">
        ''' Optional. The format string clause ':formatString' of the embedded expression.
        ''' </param>
        ''' <param name="closeBraceToken">
        ''' The closing curly brace '}' token of the embedded expression.
        ''' </param>
        Friend Shared Function Interpolation(openBraceToken As PunctuationSyntax, expression As ExpressionSyntax, alignmentClause As InterpolationAlignmentClauseSyntax, formatClause As InterpolationFormatClauseSyntax, closeBraceToken As PunctuationSyntax) As InterpolationSyntax
            Debug.Assert(openBraceToken IsNot Nothing AndAlso openBraceToken.Kind = SyntaxKind.OpenBraceToken)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(closeBraceToken IsNot Nothing AndAlso closeBraceToken.Kind = SyntaxKind.CloseBraceToken)
            Return New InterpolationSyntax(SyntaxKind.Interpolation, openBraceToken, expression, alignmentClause, formatClause, closeBraceToken)
        End Function


        ''' <summary>
        ''' Represents an alignment clause ',alignment' of an interpolated string embedded
        ''' expression.
        ''' </summary>
        ''' <param name="commaToken">
        ''' The comma ',' token.
        ''' </param>
        ''' <param name="value">
        ''' An expression representing the alignment of the interpolated expression.
        ''' </param>
        Friend Shared Function InterpolationAlignmentClause(commaToken As PunctuationSyntax, value As ExpressionSyntax) As InterpolationAlignmentClauseSyntax
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.InterpolationAlignmentClause, commaToken, value, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, InterpolationAlignmentClauseSyntax)
            End If

            Dim result = New InterpolationAlignmentClauseSyntax(SyntaxKind.InterpolationAlignmentClause, commaToken, value)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a format string clause ':formatString' of an interpolated string
        ''' embedded expression.
        ''' </summary>
        ''' <param name="colonToken">
        ''' The ':' token.
        ''' </param>
        ''' <param name="formatStringToken">
        ''' The format string.
        ''' </param>
        Friend Shared Function InterpolationFormatClause(colonToken As PunctuationSyntax, formatStringToken As InterpolatedStringTextTokenSyntax) As InterpolationFormatClauseSyntax
            Debug.Assert(colonToken IsNot Nothing AndAlso colonToken.Kind = SyntaxKind.ColonToken)
            Debug.Assert(formatStringToken IsNot Nothing AndAlso formatStringToken.Kind = SyntaxKind.InterpolatedStringTextToken)

            Dim hash As Integer
            Dim cached = SyntaxNodeCache.TryGetNode(SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, InterpolationFormatClauseSyntax)
            End If

            Dim result = New InterpolationFormatClauseSyntax(SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function WhitespaceTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.WhitespaceTrivia, text)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function EndOfLineTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.EndOfLineTrivia, text)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function ColonTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.ColonTrivia, text)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function CommentTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.CommentTrivia, text)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function ConflictMarkerTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.ConflictMarkerTrivia, text)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function LineContinuationTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.LineContinuationTrivia, text)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function DocumentationCommentExteriorTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.DocumentationCommentExteriorTrivia, text)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function DisabledTextTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.DisabledTextTrivia, text)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of SyntaxTrivia. One
        ''' of WhitespaceTrivia, EndOfLineTrivia, ColonTrivia, CommentTrivia,
        ''' ConflictMarkerTrivia, LineContinuationTrivia,
        ''' DocumentationCommentExteriorTrivia, DisabledTextTrivia.
        ''' </param>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Shared Function SyntaxTrivia(kind As SyntaxKind, text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Debug.Assert(SyntaxFacts.IsSyntaxTrivia(kind))
            Return New SyntaxTrivia(kind, text)
        End Function


        ''' <summary>
        ''' Represents a #Const pre-processing constant declaration appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        ''' <param name="constKeyword">
        ''' The "Const" keyword.
        ''' </param>
        ''' <param name="name">
        ''' The name of the pre-processing constant being defined.
        ''' </param>
        ''' <param name="equalsToken">
        ''' The "=" token.
        ''' </param>
        ''' <param name="value">
        ''' An expression representing the value of the pre-processing constant being
        ''' defined.
        ''' </param>
        Friend Shared Function ConstDirectiveTrivia(hashToken As PunctuationSyntax, constKeyword As KeywordSyntax, name As IdentifierTokenSyntax, equalsToken As PunctuationSyntax, value As ExpressionSyntax) As ConstDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(constKeyword IsNot Nothing AndAlso constKeyword.Kind = SyntaxKind.ConstKeyword)
            Debug.Assert(name IsNot Nothing AndAlso name.Kind = SyntaxKind.IdentifierToken)
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(value IsNot Nothing)
            Return New ConstDirectiveTriviaSyntax(SyntaxKind.ConstDirectiveTrivia, hashToken, constKeyword, name, equalsToken, value)
        End Function


        ''' <summary>
        ''' Represents the beginning of an #If pre-processing directive appearing in
        ''' source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Shared Function IfDirectiveTrivia(hashToken As PunctuationSyntax, elseKeyword As KeywordSyntax, ifOrElseIfKeyword As KeywordSyntax, condition As ExpressionSyntax, thenKeyword As KeywordSyntax) As IfDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(ifOrElseIfKeyword IsNot Nothing AndAlso SyntaxFacts.IsIfDirectiveTriviaIfOrElseIfKeyword(ifOrElseIfKeyword.Kind))
            Debug.Assert(condition IsNot Nothing)
            Return New IfDirectiveTriviaSyntax(SyntaxKind.IfDirectiveTrivia, hashToken, elseKeyword, ifOrElseIfKeyword, condition, thenKeyword)
        End Function


        ''' <summary>
        ''' Represents the beginning of an #If pre-processing directive appearing in
        ''' source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Shared Function ElseIfDirectiveTrivia(hashToken As PunctuationSyntax, elseKeyword As KeywordSyntax, ifOrElseIfKeyword As KeywordSyntax, condition As ExpressionSyntax, thenKeyword As KeywordSyntax) As IfDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(ifOrElseIfKeyword IsNot Nothing AndAlso SyntaxFacts.IsIfDirectiveTriviaIfOrElseIfKeyword(ifOrElseIfKeyword.Kind))
            Debug.Assert(condition IsNot Nothing)
            Return New IfDirectiveTriviaSyntax(SyntaxKind.ElseIfDirectiveTrivia, hashToken, elseKeyword, ifOrElseIfKeyword, condition, thenKeyword)
        End Function


        ''' <summary>
        ''' Represents an #Else pre-processing directive appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Shared Function ElseDirectiveTrivia(hashToken As PunctuationSyntax, elseKeyword As KeywordSyntax) As ElseDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(elseKeyword IsNot Nothing AndAlso elseKeyword.Kind = SyntaxKind.ElseKeyword)
            Return New ElseDirectiveTriviaSyntax(SyntaxKind.ElseDirectiveTrivia, hashToken, elseKeyword)
        End Function


        ''' <summary>
        ''' Represents an #End If pre-processing directive appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Shared Function EndIfDirectiveTrivia(hashToken As PunctuationSyntax, endKeyword As KeywordSyntax, ifKeyword As KeywordSyntax) As EndIfDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(ifKeyword IsNot Nothing AndAlso ifKeyword.Kind = SyntaxKind.IfKeyword)
            Return New EndIfDirectiveTriviaSyntax(SyntaxKind.EndIfDirectiveTrivia, hashToken, endKeyword, ifKeyword)
        End Function


        ''' <summary>
        ''' Represents the beginning of a #Region directive appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        ''' <param name="regionKeyword">
        ''' The "Region" keyword.
        ''' </param>
        ''' <param name="name">
        ''' The label of the code region being defined.
        ''' </param>
        Friend Shared Function RegionDirectiveTrivia(hashToken As PunctuationSyntax, regionKeyword As KeywordSyntax, name As StringLiteralTokenSyntax) As RegionDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(regionKeyword IsNot Nothing AndAlso regionKeyword.Kind = SyntaxKind.RegionKeyword)
            Debug.Assert(name IsNot Nothing AndAlso name.Kind = SyntaxKind.StringLiteralToken)
            Return New RegionDirectiveTriviaSyntax(SyntaxKind.RegionDirectiveTrivia, hashToken, regionKeyword, name)
        End Function


        ''' <summary>
        ''' Represents an #End Region directive appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        ''' <param name="endKeyword">
        ''' The "End" keyword.
        ''' </param>
        ''' <param name="regionKeyword">
        ''' The "Region" keyword.
        ''' </param>
        Friend Shared Function EndRegionDirectiveTrivia(hashToken As PunctuationSyntax, endKeyword As KeywordSyntax, regionKeyword As KeywordSyntax) As EndRegionDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(regionKeyword IsNot Nothing AndAlso regionKeyword.Kind = SyntaxKind.RegionKeyword)
            Return New EndRegionDirectiveTriviaSyntax(SyntaxKind.EndRegionDirectiveTrivia, hashToken, endKeyword, regionKeyword)
        End Function


        ''' <summary>
        ''' Represents the beginning of a #ExternalSource pre-processing directive
        ''' appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Shared Function ExternalSourceDirectiveTrivia(hashToken As PunctuationSyntax, externalSourceKeyword As KeywordSyntax, openParenToken As PunctuationSyntax, externalSource As StringLiteralTokenSyntax, commaToken As PunctuationSyntax, lineStart As IntegerLiteralTokenSyntax, closeParenToken As PunctuationSyntax) As ExternalSourceDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(externalSourceKeyword IsNot Nothing AndAlso externalSourceKeyword.Kind = SyntaxKind.ExternalSourceKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(externalSource IsNot Nothing AndAlso externalSource.Kind = SyntaxKind.StringLiteralToken)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(lineStart IsNot Nothing AndAlso lineStart.Kind = SyntaxKind.IntegerLiteralToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New ExternalSourceDirectiveTriviaSyntax(SyntaxKind.ExternalSourceDirectiveTrivia, hashToken, externalSourceKeyword, openParenToken, externalSource, commaToken, lineStart, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents an #End ExternalSource pre-processing directive appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Shared Function EndExternalSourceDirectiveTrivia(hashToken As PunctuationSyntax, endKeyword As KeywordSyntax, externalSourceKeyword As KeywordSyntax) As EndExternalSourceDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(externalSourceKeyword IsNot Nothing AndAlso externalSourceKeyword.Kind = SyntaxKind.ExternalSourceKeyword)
            Return New EndExternalSourceDirectiveTriviaSyntax(SyntaxKind.EndExternalSourceDirectiveTrivia, hashToken, endKeyword, externalSourceKeyword)
        End Function


        ''' <summary>
        ''' Represents an #ExternalChecksum pre-processing directive appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Shared Function ExternalChecksumDirectiveTrivia(hashToken As PunctuationSyntax, externalChecksumKeyword As KeywordSyntax, openParenToken As PunctuationSyntax, externalSource As StringLiteralTokenSyntax, firstCommaToken As PunctuationSyntax, guid As StringLiteralTokenSyntax, secondCommaToken As PunctuationSyntax, checksum As StringLiteralTokenSyntax, closeParenToken As PunctuationSyntax) As ExternalChecksumDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(externalChecksumKeyword IsNot Nothing AndAlso externalChecksumKeyword.Kind = SyntaxKind.ExternalChecksumKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(externalSource IsNot Nothing AndAlso externalSource.Kind = SyntaxKind.StringLiteralToken)
            Debug.Assert(firstCommaToken IsNot Nothing AndAlso firstCommaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(guid IsNot Nothing AndAlso guid.Kind = SyntaxKind.StringLiteralToken)
            Debug.Assert(secondCommaToken IsNot Nothing AndAlso secondCommaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(checksum IsNot Nothing AndAlso checksum.Kind = SyntaxKind.StringLiteralToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New ExternalChecksumDirectiveTriviaSyntax(SyntaxKind.ExternalChecksumDirectiveTrivia, hashToken, externalChecksumKeyword, openParenToken, externalSource, firstCommaToken, guid, secondCommaToken, checksum, closeParenToken)
        End Function


        ''' <summary>
        ''' Represents #Enable Warning pre-processing directive appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Shared Function EnableWarningDirectiveTrivia(hashToken As PunctuationSyntax, enableKeyword As KeywordSyntax, warningKeyword As KeywordSyntax, errorCodes As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As EnableWarningDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(enableKeyword IsNot Nothing AndAlso enableKeyword.Kind = SyntaxKind.EnableKeyword)
            Debug.Assert(warningKeyword IsNot Nothing AndAlso warningKeyword.Kind = SyntaxKind.WarningKeyword)
            Return New EnableWarningDirectiveTriviaSyntax(SyntaxKind.EnableWarningDirectiveTrivia, hashToken, enableKeyword, warningKeyword, errorCodes.Node)
        End Function


        ''' <summary>
        ''' Represents #Disable Warning pre-processing directive appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Shared Function DisableWarningDirectiveTrivia(hashToken As PunctuationSyntax, disableKeyword As KeywordSyntax, warningKeyword As KeywordSyntax, errorCodes As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As DisableWarningDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(disableKeyword IsNot Nothing AndAlso disableKeyword.Kind = SyntaxKind.DisableKeyword)
            Debug.Assert(warningKeyword IsNot Nothing AndAlso warningKeyword.Kind = SyntaxKind.WarningKeyword)
            Return New DisableWarningDirectiveTriviaSyntax(SyntaxKind.DisableWarningDirectiveTrivia, hashToken, disableKeyword, warningKeyword, errorCodes.Node)
        End Function


        ''' <summary>
        ''' Represents an #r directive appearing in scripts.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Shared Function ReferenceDirectiveTrivia(hashToken As PunctuationSyntax, referenceKeyword As KeywordSyntax, file As StringLiteralTokenSyntax) As ReferenceDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(referenceKeyword IsNot Nothing AndAlso referenceKeyword.Kind = SyntaxKind.ReferenceKeyword)
            Debug.Assert(file IsNot Nothing AndAlso file.Kind = SyntaxKind.StringLiteralToken)
            Return New ReferenceDirectiveTriviaSyntax(SyntaxKind.ReferenceDirectiveTrivia, hashToken, referenceKeyword, file)
        End Function


        ''' <summary>
        ''' Represents an unrecognized pre-processing directive. This occurs when the
        ''' parser encounters a hash '#' token at the beginning of a physical line but does
        ''' recognize the text that follows as a valid Visual Basic pre-processing
        ''' directive.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Shared Function BadDirectiveTrivia(hashToken As PunctuationSyntax) As BadDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Return New BadDirectiveTriviaSyntax(SyntaxKind.BadDirectiveTrivia, hashToken)
        End Function

    End Class
End Namespace

Namespace Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax

    Friend Class ContextAwareSyntaxFactory

        Private ReadOnly _factoryContext As ISyntaxFactoryContext

        Sub New(factoryContext As ISyntaxFactoryContext)
            _factoryContext = factoryContext
        End Sub


        ''' <summary>
        ''' A class to represent an empty statement. This can occur when a colon is on a
        ''' line without anything else.
        ''' </summary>
        ''' <param name="empty">
        ''' An empty token because all non terminals must have a token.
        ''' </param>
        Friend Function EmptyStatement(empty As PunctuationSyntax) As EmptyStatementSyntax
            Debug.Assert(empty IsNot Nothing AndAlso empty.Kind = SyntaxKind.EmptyToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EmptyStatement, empty, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EmptyStatementSyntax)
            End If

            Dim result = New EmptyStatementSyntax(SyntaxKind.EmptyStatement, empty, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndIfStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.IfKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndIfStatement, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndIfStatement, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndUsingStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.UsingKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndUsingStatement, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndUsingStatement, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndWithStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.WithKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndWithStatement, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndWithStatement, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndSelectStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.SelectKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndSelectStatement, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndSelectStatement, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndStructureStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.StructureKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndStructureStatement, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndStructureStatement, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndEnumStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.EnumKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndEnumStatement, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndEnumStatement, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndInterfaceStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.InterfaceKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndInterfaceStatement, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndInterfaceStatement, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndClassStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.ClassKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndClassStatement, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndClassStatement, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndModuleStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.ModuleKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndModuleStatement, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndModuleStatement, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndNamespaceStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.NamespaceKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndNamespaceStatement, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndNamespaceStatement, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndSubStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.SubKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndSubStatement, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndSubStatement, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndFunctionStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.FunctionKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndFunctionStatement, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndFunctionStatement, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndGetStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.GetKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndGetStatement, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndGetStatement, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndSetStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.SetKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndSetStatement, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndSetStatement, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndPropertyStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.PropertyKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndPropertyStatement, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndPropertyStatement, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndOperatorStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.OperatorKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndOperatorStatement, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndOperatorStatement, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndEventStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.EventKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndEventStatement, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndEventStatement, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndAddHandlerStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.AddHandlerKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndAddHandlerStatement, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndAddHandlerStatement, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndRemoveHandlerStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.RemoveHandlerKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndRemoveHandlerStatement, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndRemoveHandlerStatement, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndRaiseEventStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.RaiseEventKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndRaiseEventStatement, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndRaiseEventStatement, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndWhileStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.WhileKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndWhileStatement, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndWhileStatement, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndTryStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.TryKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndTryStatement, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndTryStatement, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndSyncLockStatement(endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.SyncLockKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndSyncLockStatement, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(SyntaxKind.EndSyncLockStatement, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "End XXX" statement, where XXX is a single keyword.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' EndBlockStatementSyntax. One of EndIfStatement, EndUsingStatement,
        ''' EndWithStatement, EndSelectStatement, EndStructureStatement, EndEnumStatement,
        ''' EndInterfaceStatement, EndClassStatement, EndModuleStatement,
        ''' EndNamespaceStatement, EndSubStatement, EndFunctionStatement, EndGetStatement,
        ''' EndSetStatement, EndPropertyStatement, EndOperatorStatement, EndEventStatement,
        ''' EndAddHandlerStatement, EndRemoveHandlerStatement, EndRaiseEventStatement,
        ''' EndWhileStatement, EndTryStatement, EndSyncLockStatement.
        ''' </param>
        ''' <param name="endKeyword">
        ''' The "End" keyword
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword that ends the block. Must be one of: "If", "Using", "With",
        ''' "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace",
        ''' "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler",
        ''' "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        ''' </param>
        Friend Function EndBlockStatement(kind As SyntaxKind, endKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As EndBlockStatementSyntax
            Debug.Assert(SyntaxFacts.IsEndBlockStatement(kind))
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso SyntaxFacts.IsEndBlockStatementBlockKeyword(blockKeyword.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(kind, endKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EndBlockStatementSyntax)
            End If

            Dim result = New EndBlockStatementSyntax(kind, endKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an entire source file of VB code.
        ''' </summary>
        ''' <param name="options">
        ''' Represents the list of Option statements at the beginning of a source file.
        ''' </param>
        ''' <param name="imports">
        ''' Represents the list of Imports statements at the beginning of a source file.
        ''' </param>
        ''' <param name="attributes">
        ''' Represents the list of AttributeStatements at the beginning of a source file
        ''' that contain the Assembly and Module attributes.
        ''' </param>
        ''' <param name="members">
        ''' Represents the members of the default namespace for this source file: all the
        ''' top-level type and namespace declarations in the file. May also contain
        ''' Statements that are not valid
        ''' </param>
        ''' <param name="endOfFileToken">
        ''' Represents the end of the source file. This token may have trivia (whitespace,
        ''' comments, ...) attached to it.
        ''' </param>
        Friend Function CompilationUnit(options As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), [imports] As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), attributes As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), members As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endOfFileToken As PunctuationSyntax) As CompilationUnitSyntax
            Debug.Assert(endOfFileToken IsNot Nothing AndAlso endOfFileToken.Kind = SyntaxKind.EndOfFileToken)
            Return New CompilationUnitSyntax(SyntaxKind.CompilationUnit, options.Node, [imports].Node, attributes.Node, members.Node, endOfFileToken, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an Option statement, such as "Option Strict On".
        ''' </summary>
        ''' <param name="optionKeyword">
        ''' The "Option" keyword.
        ''' </param>
        ''' <param name="nameKeyword">
        ''' The keyword that identifies the option being set: Explicit, Strict, Compare or
        ''' Infer.
        ''' </param>
        ''' <param name="valueKeyword">
        ''' The keyword that identifiers the value being set for the option: On, Off, Text
        ''' or Binary.
        ''' </param>
        Friend Function OptionStatement(optionKeyword As KeywordSyntax, nameKeyword As KeywordSyntax, valueKeyword As KeywordSyntax) As OptionStatementSyntax
            Debug.Assert(optionKeyword IsNot Nothing AndAlso optionKeyword.Kind = SyntaxKind.OptionKeyword)
            Debug.Assert(nameKeyword IsNot Nothing AndAlso SyntaxFacts.IsOptionStatementNameKeyword(nameKeyword.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.OptionStatement, optionKeyword, nameKeyword, valueKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, OptionStatementSyntax)
            End If

            Dim result = New OptionStatementSyntax(SyntaxKind.OptionStatement, optionKeyword, nameKeyword, valueKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an Imports statement, which has one or more imports clauses.
        ''' </summary>
        ''' <param name="importsKeyword">
        ''' The "Imports" keyword.
        ''' </param>
        ''' <param name="importsClauses">
        ''' A list of one or more import clauses. Each clause is either an alias, namespace
        ''' or XML namespace import.
        ''' </param>
        Friend Function ImportsStatement(importsKeyword As KeywordSyntax, importsClauses As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As ImportsStatementSyntax
            Debug.Assert(importsKeyword IsNot Nothing AndAlso importsKeyword.Kind = SyntaxKind.ImportsKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ImportsStatement, importsKeyword, importsClauses.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ImportsStatementSyntax)
            End If

            Dim result = New ImportsStatementSyntax(SyntaxKind.ImportsStatement, importsKeyword, importsClauses.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the clause of an Imports statement that imports all members of a
        ''' type or namespace or aliases a type or namespace.
        ''' </summary>
        ''' <param name="alias">
        ''' An optional alias for the namespace or type being imported.
        ''' </param>
        ''' <param name="name">
        ''' The namespace or type being imported.
        ''' </param>
        Friend Function SimpleImportsClause([alias] As ImportAliasClauseSyntax, name As NameSyntax) As SimpleImportsClauseSyntax
            Debug.Assert(name IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.SimpleImportsClause, [alias], name, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SimpleImportsClauseSyntax)
            End If

            Dim result = New SimpleImportsClauseSyntax(SyntaxKind.SimpleImportsClause, [alias], name, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an alias identifier followed by an "=" token in an Imports clause.
        ''' </summary>
        ''' <param name="identifier">
        ''' The identifier being introduced.
        ''' </param>
        ''' <param name="equalsToken">
        ''' The "=" token.
        ''' </param>
        Friend Function ImportAliasClause(identifier As IdentifierTokenSyntax, equalsToken As PunctuationSyntax) As ImportAliasClauseSyntax
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ImportAliasClause, identifier, equalsToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ImportAliasClauseSyntax)
            End If

            Dim result = New ImportAliasClauseSyntax(SyntaxKind.ImportAliasClause, identifier, equalsToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Defines a XML namespace for XML expressions.
        ''' </summary>
        ''' <param name="xmlNamespace">
        ''' Identifies the XML namespace alias and URI.
        ''' </param>
        Friend Function XmlNamespaceImportsClause(lessThanToken As PunctuationSyntax, xmlNamespace As XmlAttributeSyntax, greaterThanToken As PunctuationSyntax) As XmlNamespaceImportsClauseSyntax
            Debug.Assert(lessThanToken IsNot Nothing AndAlso lessThanToken.Kind = SyntaxKind.LessThanToken)
            Debug.Assert(xmlNamespace IsNot Nothing)
            Debug.Assert(greaterThanToken IsNot Nothing AndAlso greaterThanToken.Kind = SyntaxKind.GreaterThanToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.XmlNamespaceImportsClause, lessThanToken, xmlNamespace, greaterThanToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlNamespaceImportsClauseSyntax)
            End If

            Dim result = New XmlNamespaceImportsClauseSyntax(SyntaxKind.XmlNamespaceImportsClause, lessThanToken, xmlNamespace, greaterThanToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Namespace statement, its contents and the End Namespace statement.
        ''' </summary>
        ''' <param name="namespaceStatement">
        ''' The statement that begins the NamespaceBlock.
        ''' </param>
        ''' <param name="members">
        ''' The declarations contained in the namespace statement.
        ''' </param>
        ''' <param name="endNamespaceStatement">
        ''' The End Namespace statement that ends the block.
        ''' </param>
        Friend Function NamespaceBlock(namespaceStatement As NamespaceStatementSyntax, members As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endNamespaceStatement As EndBlockStatementSyntax) As NamespaceBlockSyntax
            Debug.Assert(namespaceStatement IsNot Nothing)
            Debug.Assert(endNamespaceStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.NamespaceBlock, namespaceStatement, members.Node, endNamespaceStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, NamespaceBlockSyntax)
            End If

            Dim result = New NamespaceBlockSyntax(SyntaxKind.NamespaceBlock, namespaceStatement, members.Node, endNamespaceStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the beginning statement of a namespace declaration. This node always
        ''' appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
        ''' </summary>
        ''' <param name="namespaceKeyword">
        ''' The "Namespace" keyword.
        ''' </param>
        ''' <param name="name">
        ''' A (possibly dotted) name denoting the namespace being declared.
        ''' </param>
        Friend Function NamespaceStatement(namespaceKeyword As KeywordSyntax, name As NameSyntax) As NamespaceStatementSyntax
            Debug.Assert(namespaceKeyword IsNot Nothing AndAlso namespaceKeyword.Kind = SyntaxKind.NamespaceKeyword)
            Debug.Assert(name IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.NamespaceStatement, namespaceKeyword, name, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, NamespaceStatementSyntax)
            End If

            Dim result = New NamespaceStatementSyntax(SyntaxKind.NamespaceStatement, namespaceKeyword, name, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a declaration of Module, its contents and the End statement that
        ''' ends it.
        ''' </summary>
        ''' <param name="moduleStatement">
        ''' The "Module" statement that begins the block.
        ''' </param>
        ''' <param name="inherits">
        ''' A list of the Inherits declarations for the type.
        ''' </param>
        ''' <param name="implements">
        ''' A list of the Implements declarations for the type.
        ''' </param>
        ''' <param name="members">
        ''' The declarations contained in the type or module.
        ''' </param>
        ''' <param name="endModuleStatement">
        ''' The "End Module" statement that ends the block.
        ''' </param>
        Friend Function ModuleBlock(moduleStatement As ModuleStatementSyntax, [inherits] As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), [implements] As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), members As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endModuleStatement As EndBlockStatementSyntax) As ModuleBlockSyntax
            Debug.Assert(moduleStatement IsNot Nothing)
            Debug.Assert(endModuleStatement IsNot Nothing)
            Return New ModuleBlockSyntax(SyntaxKind.ModuleBlock, moduleStatement, [inherits].Node, [implements].Node, members.Node, endModuleStatement, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a declaration of a Structure, its contents and the End statement
        ''' that ends it.
        ''' </summary>
        ''' <param name="structureStatement">
        ''' The "Structure" statement that begins the block.
        ''' </param>
        ''' <param name="inherits">
        ''' A list of the Inherits declarations for the type.
        ''' </param>
        ''' <param name="implements">
        ''' A list of the Implements declarations for the type.
        ''' </param>
        ''' <param name="members">
        ''' The declarations contained in the type or module.
        ''' </param>
        ''' <param name="endStructureStatement">
        ''' The "End Structure" statement that ends the block.
        ''' </param>
        Friend Function StructureBlock(structureStatement As StructureStatementSyntax, [inherits] As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), [implements] As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), members As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endStructureStatement As EndBlockStatementSyntax) As StructureBlockSyntax
            Debug.Assert(structureStatement IsNot Nothing)
            Debug.Assert(endStructureStatement IsNot Nothing)
            Return New StructureBlockSyntax(SyntaxKind.StructureBlock, structureStatement, [inherits].Node, [implements].Node, members.Node, endStructureStatement, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a declaration of a Interface, its contents and the End statement
        ''' that ends it.
        ''' </summary>
        ''' <param name="interfaceStatement">
        ''' The "Interface" statement that begins the block.
        ''' </param>
        ''' <param name="inherits">
        ''' A list of the Inherits declarations for the type.
        ''' </param>
        ''' <param name="implements">
        ''' A list of the Implements declarations for the type.
        ''' </param>
        ''' <param name="members">
        ''' The declarations contained in the type or module.
        ''' </param>
        ''' <param name="endInterfaceStatement">
        ''' The "End Interface" statement that ends the block.
        ''' </param>
        Friend Function InterfaceBlock(interfaceStatement As InterfaceStatementSyntax, [inherits] As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), [implements] As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), members As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endInterfaceStatement As EndBlockStatementSyntax) As InterfaceBlockSyntax
            Debug.Assert(interfaceStatement IsNot Nothing)
            Debug.Assert(endInterfaceStatement IsNot Nothing)
            Return New InterfaceBlockSyntax(SyntaxKind.InterfaceBlock, interfaceStatement, [inherits].Node, [implements].Node, members.Node, endInterfaceStatement, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a declaration of a Class its contents and the End statement that
        ''' ends it.
        ''' </summary>
        ''' <param name="classStatement">
        ''' The "Class" statement that begins the block.
        ''' </param>
        ''' <param name="inherits">
        ''' A list of the Inherits declarations for the type.
        ''' </param>
        ''' <param name="implements">
        ''' A list of the Implements declarations for the type.
        ''' </param>
        ''' <param name="members">
        ''' The declarations contained in the type or module.
        ''' </param>
        ''' <param name="endClassStatement">
        ''' The "End Class" statement that ends the block.
        ''' </param>
        Friend Function ClassBlock(classStatement As ClassStatementSyntax, [inherits] As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), [implements] As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), members As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endClassStatement As EndBlockStatementSyntax) As ClassBlockSyntax
            Debug.Assert(classStatement IsNot Nothing)
            Debug.Assert(endClassStatement IsNot Nothing)
            Return New ClassBlockSyntax(SyntaxKind.ClassBlock, classStatement, [inherits].Node, [implements].Node, members.Node, endClassStatement, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a declaration of an Enum, its contents and the End Enum statement
        ''' that ends it.
        ''' </summary>
        ''' <param name="enumStatement">
        ''' The statement that begins the type or module.
        ''' </param>
        ''' <param name="members">
        ''' The declarations contained in the enumeration.
        ''' </param>
        ''' <param name="endEnumStatement">
        ''' The End XXX statement that ends the block.
        ''' </param>
        Friend Function EnumBlock(enumStatement As EnumStatementSyntax, members As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endEnumStatement As EndBlockStatementSyntax) As EnumBlockSyntax
            Debug.Assert(enumStatement IsNot Nothing)
            Debug.Assert(endEnumStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EnumBlock, enumStatement, members.Node, endEnumStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EnumBlockSyntax)
            End If

            Dim result = New EnumBlockSyntax(SyntaxKind.EnumBlock, enumStatement, members.Node, endEnumStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an Inherits statement in a Class, Structure or Interface.
        ''' </summary>
        ''' <param name="inheritsKeyword">
        ''' The "Inherits" keyword.
        ''' </param>
        ''' <param name="types">
        ''' A list of the types being inherited.
        ''' </param>
        Friend Function InheritsStatement(inheritsKeyword As KeywordSyntax, types As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As InheritsStatementSyntax
            Debug.Assert(inheritsKeyword IsNot Nothing AndAlso inheritsKeyword.Kind = SyntaxKind.InheritsKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.InheritsStatement, inheritsKeyword, types.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, InheritsStatementSyntax)
            End If

            Dim result = New InheritsStatementSyntax(SyntaxKind.InheritsStatement, inheritsKeyword, types.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an Implements statement in a Class or Structure.
        ''' </summary>
        ''' <param name="implementsKeyword">
        ''' The "Implements" keyword.
        ''' </param>
        ''' <param name="types">
        ''' A list of the types being implemented.
        ''' </param>
        Friend Function ImplementsStatement(implementsKeyword As KeywordSyntax, types As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As ImplementsStatementSyntax
            Debug.Assert(implementsKeyword IsNot Nothing AndAlso implementsKeyword.Kind = SyntaxKind.ImplementsKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ImplementsStatement, implementsKeyword, types.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ImplementsStatementSyntax)
            End If

            Dim result = New ImplementsStatementSyntax(SyntaxKind.ImplementsStatement, implementsKeyword, types.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the beginning statement of a Module declaration. This node always
        ''' appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </param>
        ''' <param name="moduleKeyword">
        ''' The "Module" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the type being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic parameters for this type. If no
        ''' generic parameters were present, Nothing is returned.
        ''' </param>
        Friend Function ModuleStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), moduleKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax) As ModuleStatementSyntax
            Debug.Assert(moduleKeyword IsNot Nothing AndAlso moduleKeyword.Kind = SyntaxKind.ModuleKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New ModuleStatementSyntax(SyntaxKind.ModuleStatement, attributeLists.Node, modifiers.Node, moduleKeyword, identifier, typeParameterList, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents the beginning statement of a Structure declaration. This node always
        ''' appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </param>
        ''' <param name="structureKeyword">
        ''' The "Structure" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the type being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic parameters for this type. If no
        ''' generic parameters were present, Nothing is returned.
        ''' </param>
        Friend Function StructureStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), structureKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax) As StructureStatementSyntax
            Debug.Assert(structureKeyword IsNot Nothing AndAlso structureKeyword.Kind = SyntaxKind.StructureKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New StructureStatementSyntax(SyntaxKind.StructureStatement, attributeLists.Node, modifiers.Node, structureKeyword, identifier, typeParameterList, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents the beginning statement of a Interface declaration. This node always
        ''' appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </param>
        ''' <param name="interfaceKeyword">
        ''' The "Interface" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the type being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic parameters for this type. If no
        ''' generic parameters were present, Nothing is returned.
        ''' </param>
        Friend Function InterfaceStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), interfaceKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax) As InterfaceStatementSyntax
            Debug.Assert(interfaceKeyword IsNot Nothing AndAlso interfaceKeyword.Kind = SyntaxKind.InterfaceKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New InterfaceStatementSyntax(SyntaxKind.InterfaceStatement, attributeLists.Node, modifiers.Node, interfaceKeyword, identifier, typeParameterList, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents the beginning statement of a Class declaration. This node always
        ''' appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </param>
        ''' <param name="classKeyword">
        ''' The "Class" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the type being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic parameters for this type. If no
        ''' generic parameters were present, Nothing is returned.
        ''' </param>
        Friend Function ClassStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), classKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax) As ClassStatementSyntax
            Debug.Assert(classKeyword IsNot Nothing AndAlso classKeyword.Kind = SyntaxKind.ClassKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New ClassStatementSyntax(SyntaxKind.ClassStatement, attributeLists.Node, modifiers.Node, classKeyword, identifier, typeParameterList, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents the beginning statement of an Enum declaration. This node always
        ''' appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </param>
        ''' <param name="enumKeyword">
        ''' The "Enum" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the enum being declared.
        ''' </param>
        ''' <param name="underlyingType">
        ''' Optional "As XXX" clause describing the underlying type of the enumeration. If
        ''' no As clause was specified, Nothing is returned.
        ''' </param>
        Friend Function EnumStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), enumKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, underlyingType As AsClauseSyntax) As EnumStatementSyntax
            Debug.Assert(enumKeyword IsNot Nothing AndAlso enumKeyword.Kind = SyntaxKind.EnumKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New EnumStatementSyntax(SyntaxKind.EnumStatement, attributeLists.Node, modifiers.Node, enumKeyword, identifier, underlyingType, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents the type parameter list in a declaration.
        ''' </summary>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="ofKeyword">
        ''' The "Of" keyword.
        ''' </param>
        ''' <param name="parameters">
        ''' A list of the type parameters. There must be at least one type parameter in the
        ''' list.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Function TypeParameterList(openParenToken As PunctuationSyntax, ofKeyword As KeywordSyntax, parameters As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), closeParenToken As PunctuationSyntax) As TypeParameterListSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(ofKeyword IsNot Nothing AndAlso ofKeyword.Kind = SyntaxKind.OfKeyword)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New TypeParameterListSyntax(SyntaxKind.TypeParameterList, openParenToken, ofKeyword, parameters.Node, closeParenToken, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a type parameter on a generic type declaration.
        ''' </summary>
        ''' <param name="varianceKeyword">
        ''' Represents the "In" or "Out" variance keyword on a type parameter, if present.
        ''' If no variance modifier was present, Nothing is returned.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the type parameter
        ''' </param>
        ''' <param name="typeParameterConstraintClause">
        ''' The "As" keyword, if any type constraints were supplied. If no type constraints
        ''' were supplied, Nothing is returned.
        ''' </param>
        Friend Function TypeParameter(varianceKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterConstraintClause As TypeParameterConstraintClauseSyntax) As TypeParameterSyntax
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.TypeParameter, varianceKeyword, identifier, typeParameterConstraintClause, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, TypeParameterSyntax)
            End If

            Dim result = New TypeParameterSyntax(SyntaxKind.TypeParameter, varianceKeyword, identifier, typeParameterConstraintClause, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' One of the type parameter constraints clauses. This represents a constraint
        ''' clause in the form of "As Constraint".
        ''' </summary>
        ''' <param name="asKeyword">
        ''' The "As" keyword, if any type constraints were supplied. If no type constraints
        ''' were supplied, Nothing is returned.
        ''' </param>
        ''' <param name="constraint">
        ''' A list of the supplied constraints. If no constraints were supplied, Nothing is
        ''' returned.
        ''' </param>
        Friend Function TypeParameterSingleConstraintClause(asKeyword As KeywordSyntax, constraint As ConstraintSyntax) As TypeParameterSingleConstraintClauseSyntax
            Debug.Assert(asKeyword IsNot Nothing AndAlso asKeyword.Kind = SyntaxKind.AsKeyword)
            Debug.Assert(constraint IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.TypeParameterSingleConstraintClause, asKeyword, constraint, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, TypeParameterSingleConstraintClauseSyntax)
            End If

            Dim result = New TypeParameterSingleConstraintClauseSyntax(SyntaxKind.TypeParameterSingleConstraintClause, asKeyword, constraint, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' One of the type parameter constraints clauses. This represents a constraint
        ''' clause in the form of "As { Constraints }".
        ''' </summary>
        ''' <param name="asKeyword">
        ''' The "As" keyword.
        ''' </param>
        ''' <param name="openBraceToken">
        ''' The "{" token.
        ''' </param>
        ''' <param name="constraints">
        ''' A list of the supplied constraints. If no constraints were supplied, an empty
        ''' list is returned.
        ''' </param>
        ''' <param name="closeBraceToken">
        ''' The "}" token.
        ''' </param>
        Friend Function TypeParameterMultipleConstraintClause(asKeyword As KeywordSyntax, openBraceToken As PunctuationSyntax, constraints As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), closeBraceToken As PunctuationSyntax) As TypeParameterMultipleConstraintClauseSyntax
            Debug.Assert(asKeyword IsNot Nothing AndAlso asKeyword.Kind = SyntaxKind.AsKeyword)
            Debug.Assert(openBraceToken IsNot Nothing AndAlso openBraceToken.Kind = SyntaxKind.OpenBraceToken)
            Debug.Assert(closeBraceToken IsNot Nothing AndAlso closeBraceToken.Kind = SyntaxKind.CloseBraceToken)
            Return New TypeParameterMultipleConstraintClauseSyntax(SyntaxKind.TypeParameterMultipleConstraintClause, asKeyword, openBraceToken, constraints.Node, closeBraceToken, _factoryContext)
        End Function


        ''' <summary>
        ''' One of the special type parameter constraints: New, Class or Structure. Which
        ''' kind of special constraint it is can be obtained from the Kind property and is
        ''' one of: NewConstraint, ReferenceConstraint or ValueConstraint.
        ''' </summary>
        ''' <param name="constraintKeyword">
        ''' The "New", "Class" or "Structure" keyword that denotes the kind of special
        ''' constraint.
        ''' </param>
        Friend Function NewConstraint(constraintKeyword As KeywordSyntax) As SpecialConstraintSyntax
            Debug.Assert(constraintKeyword IsNot Nothing AndAlso SyntaxFacts.IsSpecialConstraintConstraintKeyword(constraintKeyword.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.NewConstraint, constraintKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SpecialConstraintSyntax)
            End If

            Dim result = New SpecialConstraintSyntax(SyntaxKind.NewConstraint, constraintKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' One of the special type parameter constraints: New, Class or Structure. Which
        ''' kind of special constraint it is can be obtained from the Kind property and is
        ''' one of: NewConstraint, ReferenceConstraint or ValueConstraint.
        ''' </summary>
        ''' <param name="constraintKeyword">
        ''' The "New", "Class" or "Structure" keyword that denotes the kind of special
        ''' constraint.
        ''' </param>
        Friend Function ClassConstraint(constraintKeyword As KeywordSyntax) As SpecialConstraintSyntax
            Debug.Assert(constraintKeyword IsNot Nothing AndAlso SyntaxFacts.IsSpecialConstraintConstraintKeyword(constraintKeyword.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ClassConstraint, constraintKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SpecialConstraintSyntax)
            End If

            Dim result = New SpecialConstraintSyntax(SyntaxKind.ClassConstraint, constraintKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' One of the special type parameter constraints: New, Class or Structure. Which
        ''' kind of special constraint it is can be obtained from the Kind property and is
        ''' one of: NewConstraint, ReferenceConstraint or ValueConstraint.
        ''' </summary>
        ''' <param name="constraintKeyword">
        ''' The "New", "Class" or "Structure" keyword that denotes the kind of special
        ''' constraint.
        ''' </param>
        Friend Function StructureConstraint(constraintKeyword As KeywordSyntax) As SpecialConstraintSyntax
            Debug.Assert(constraintKeyword IsNot Nothing AndAlso SyntaxFacts.IsSpecialConstraintConstraintKeyword(constraintKeyword.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.StructureConstraint, constraintKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SpecialConstraintSyntax)
            End If

            Dim result = New SpecialConstraintSyntax(SyntaxKind.StructureConstraint, constraintKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' One of the special type parameter constraints: New, Class or Structure. Which
        ''' kind of special constraint it is can be obtained from the Kind property and is
        ''' one of: NewConstraint, ReferenceConstraint or ValueConstraint.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' SpecialConstraintSyntax. One of NewConstraint, ClassConstraint,
        ''' StructureConstraint.
        ''' </param>
        ''' <param name="constraintKeyword">
        ''' The "New", "Class" or "Structure" keyword that denotes the kind of special
        ''' constraint.
        ''' </param>
        Friend Function SpecialConstraint(kind As SyntaxKind, constraintKeyword As KeywordSyntax) As SpecialConstraintSyntax
            Debug.Assert(SyntaxFacts.IsSpecialConstraint(kind))
            Debug.Assert(constraintKeyword IsNot Nothing AndAlso SyntaxFacts.IsSpecialConstraintConstraintKeyword(constraintKeyword.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(kind, constraintKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SpecialConstraintSyntax)
            End If

            Dim result = New SpecialConstraintSyntax(kind, constraintKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a type parameter constraint that is a type.
        ''' </summary>
        ''' <param name="type">
        ''' The type describing the constraint.
        ''' </param>
        Friend Function TypeConstraint(type As TypeSyntax) As TypeConstraintSyntax
            Debug.Assert(type IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.TypeConstraint, type, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, TypeConstraintSyntax)
            End If

            Dim result = New TypeConstraintSyntax(SyntaxKind.TypeConstraint, type, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a name and value in an EnumDeclarationBlock.
        ''' </summary>
        ''' <param name="initializer">
        ''' An optional value for the enum member.
        ''' </param>
        Friend Function EnumMemberDeclaration(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), identifier As IdentifierTokenSyntax, initializer As EqualsValueSyntax) As EnumMemberDeclarationSyntax
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EnumMemberDeclaration, attributeLists.Node, identifier, initializer, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EnumMemberDeclarationSyntax)
            End If

            Dim result = New EnumMemberDeclarationSyntax(SyntaxKind.EnumMemberDeclaration, attributeLists.Node, identifier, initializer, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Function or Sub block declaration: A declaration that has a
        ''' beginning declaration, a body of executable statements and an end statement.
        ''' </summary>
        ''' <param name="subOrFunctionStatement">
        ''' The "Sub" or "Function" statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="endSubOrFunctionStatement">
        ''' The "End Sub" or "End Function" statement that ends the block.
        ''' </param>
        Friend Function SubBlock(subOrFunctionStatement As MethodStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endSubOrFunctionStatement As EndBlockStatementSyntax) As MethodBlockSyntax
            Debug.Assert(subOrFunctionStatement IsNot Nothing)
            Debug.Assert(endSubOrFunctionStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.SubBlock, subOrFunctionStatement, statements.Node, endSubOrFunctionStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MethodBlockSyntax)
            End If

            Dim result = New MethodBlockSyntax(SyntaxKind.SubBlock, subOrFunctionStatement, statements.Node, endSubOrFunctionStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Function or Sub block declaration: A declaration that has a
        ''' beginning declaration, a body of executable statements and an end statement.
        ''' </summary>
        ''' <param name="subOrFunctionStatement">
        ''' The "Sub" or "Function" statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="endSubOrFunctionStatement">
        ''' The "End Sub" or "End Function" statement that ends the block.
        ''' </param>
        Friend Function FunctionBlock(subOrFunctionStatement As MethodStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endSubOrFunctionStatement As EndBlockStatementSyntax) As MethodBlockSyntax
            Debug.Assert(subOrFunctionStatement IsNot Nothing)
            Debug.Assert(endSubOrFunctionStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.FunctionBlock, subOrFunctionStatement, statements.Node, endSubOrFunctionStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MethodBlockSyntax)
            End If

            Dim result = New MethodBlockSyntax(SyntaxKind.FunctionBlock, subOrFunctionStatement, statements.Node, endSubOrFunctionStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Function or Sub block declaration: A declaration that has a
        ''' beginning declaration, a body of executable statements and an end statement.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of MethodBlockSyntax.
        ''' One of SubBlock, FunctionBlock.
        ''' </param>
        ''' <param name="subOrFunctionStatement">
        ''' The "Sub" or "Function" statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="endSubOrFunctionStatement">
        ''' The "End Sub" or "End Function" statement that ends the block.
        ''' </param>
        Friend Function MethodBlock(kind As SyntaxKind, subOrFunctionStatement As MethodStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endSubOrFunctionStatement As EndBlockStatementSyntax) As MethodBlockSyntax
            Debug.Assert(SyntaxFacts.IsMethodBlock(kind))
            Debug.Assert(subOrFunctionStatement IsNot Nothing)
            Debug.Assert(endSubOrFunctionStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(kind, subOrFunctionStatement, statements.Node, endSubOrFunctionStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MethodBlockSyntax)
            End If

            Dim result = New MethodBlockSyntax(kind, subOrFunctionStatement, statements.Node, endSubOrFunctionStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a constructor block declaration: A declaration that has a beginning
        ''' declaration, a body of executable statements and an end statement.
        ''' </summary>
        ''' <param name="subNewStatement">
        ''' The "Sub New" statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="endSubStatement">
        ''' The "End Sub" statement that ends the block declaration.
        ''' </param>
        Friend Function ConstructorBlock(subNewStatement As SubNewStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endSubStatement As EndBlockStatementSyntax) As ConstructorBlockSyntax
            Debug.Assert(subNewStatement IsNot Nothing)
            Debug.Assert(endSubStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ConstructorBlock, subNewStatement, statements.Node, endSubStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ConstructorBlockSyntax)
            End If

            Dim result = New ConstructorBlockSyntax(SyntaxKind.ConstructorBlock, subNewStatement, statements.Node, endSubStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an Operator block member declaration: A declaration that has a
        ''' beginning declaration, a body of executable statements and an end statement.
        ''' </summary>
        ''' <param name="operatorStatement">
        ''' The "Operator" statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="endOperatorStatement">
        ''' The "End Operator" statement that ends the block declaration.
        ''' </param>
        Friend Function OperatorBlock(operatorStatement As OperatorStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endOperatorStatement As EndBlockStatementSyntax) As OperatorBlockSyntax
            Debug.Assert(operatorStatement IsNot Nothing)
            Debug.Assert(endOperatorStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.OperatorBlock, operatorStatement, statements.Node, endOperatorStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, OperatorBlockSyntax)
            End If

            Dim result = New OperatorBlockSyntax(SyntaxKind.OperatorBlock, operatorStatement, statements.Node, endOperatorStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an accessor block member declaration: A declaration that has a
        ''' beginning declaration, a body of executable statements and an end statement.
        ''' Examples include property accessors and custom event accessors.
        ''' </summary>
        ''' <param name="accessorStatement">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
        ''' begins the accessor block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="endAccessorStatement">
        ''' The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
        ''' RaiseEvent" statement that ends the accessor block.
        ''' </param>
        Friend Function GetAccessorBlock(accessorStatement As AccessorStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endAccessorStatement As EndBlockStatementSyntax) As AccessorBlockSyntax
            Debug.Assert(accessorStatement IsNot Nothing)
            Debug.Assert(endAccessorStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.GetAccessorBlock, accessorStatement, statements.Node, endAccessorStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AccessorBlockSyntax)
            End If

            Dim result = New AccessorBlockSyntax(SyntaxKind.GetAccessorBlock, accessorStatement, statements.Node, endAccessorStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an accessor block member declaration: A declaration that has a
        ''' beginning declaration, a body of executable statements and an end statement.
        ''' Examples include property accessors and custom event accessors.
        ''' </summary>
        ''' <param name="accessorStatement">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
        ''' begins the accessor block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="endAccessorStatement">
        ''' The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
        ''' RaiseEvent" statement that ends the accessor block.
        ''' </param>
        Friend Function SetAccessorBlock(accessorStatement As AccessorStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endAccessorStatement As EndBlockStatementSyntax) As AccessorBlockSyntax
            Debug.Assert(accessorStatement IsNot Nothing)
            Debug.Assert(endAccessorStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.SetAccessorBlock, accessorStatement, statements.Node, endAccessorStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AccessorBlockSyntax)
            End If

            Dim result = New AccessorBlockSyntax(SyntaxKind.SetAccessorBlock, accessorStatement, statements.Node, endAccessorStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an accessor block member declaration: A declaration that has a
        ''' beginning declaration, a body of executable statements and an end statement.
        ''' Examples include property accessors and custom event accessors.
        ''' </summary>
        ''' <param name="accessorStatement">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
        ''' begins the accessor block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="endAccessorStatement">
        ''' The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
        ''' RaiseEvent" statement that ends the accessor block.
        ''' </param>
        Friend Function AddHandlerAccessorBlock(accessorStatement As AccessorStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endAccessorStatement As EndBlockStatementSyntax) As AccessorBlockSyntax
            Debug.Assert(accessorStatement IsNot Nothing)
            Debug.Assert(endAccessorStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.AddHandlerAccessorBlock, accessorStatement, statements.Node, endAccessorStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AccessorBlockSyntax)
            End If

            Dim result = New AccessorBlockSyntax(SyntaxKind.AddHandlerAccessorBlock, accessorStatement, statements.Node, endAccessorStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an accessor block member declaration: A declaration that has a
        ''' beginning declaration, a body of executable statements and an end statement.
        ''' Examples include property accessors and custom event accessors.
        ''' </summary>
        ''' <param name="accessorStatement">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
        ''' begins the accessor block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="endAccessorStatement">
        ''' The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
        ''' RaiseEvent" statement that ends the accessor block.
        ''' </param>
        Friend Function RemoveHandlerAccessorBlock(accessorStatement As AccessorStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endAccessorStatement As EndBlockStatementSyntax) As AccessorBlockSyntax
            Debug.Assert(accessorStatement IsNot Nothing)
            Debug.Assert(endAccessorStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.RemoveHandlerAccessorBlock, accessorStatement, statements.Node, endAccessorStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AccessorBlockSyntax)
            End If

            Dim result = New AccessorBlockSyntax(SyntaxKind.RemoveHandlerAccessorBlock, accessorStatement, statements.Node, endAccessorStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an accessor block member declaration: A declaration that has a
        ''' beginning declaration, a body of executable statements and an end statement.
        ''' Examples include property accessors and custom event accessors.
        ''' </summary>
        ''' <param name="accessorStatement">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
        ''' begins the accessor block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="endAccessorStatement">
        ''' The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
        ''' RaiseEvent" statement that ends the accessor block.
        ''' </param>
        Friend Function RaiseEventAccessorBlock(accessorStatement As AccessorStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endAccessorStatement As EndBlockStatementSyntax) As AccessorBlockSyntax
            Debug.Assert(accessorStatement IsNot Nothing)
            Debug.Assert(endAccessorStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.RaiseEventAccessorBlock, accessorStatement, statements.Node, endAccessorStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AccessorBlockSyntax)
            End If

            Dim result = New AccessorBlockSyntax(SyntaxKind.RaiseEventAccessorBlock, accessorStatement, statements.Node, endAccessorStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an accessor block member declaration: A declaration that has a
        ''' beginning declaration, a body of executable statements and an end statement.
        ''' Examples include property accessors and custom event accessors.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' AccessorBlockSyntax. One of GetAccessorBlock, SetAccessorBlock,
        ''' AddHandlerAccessorBlock, RemoveHandlerAccessorBlock, RaiseEventAccessorBlock.
        ''' </param>
        ''' <param name="accessorStatement">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that
        ''' begins the accessor block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="endAccessorStatement">
        ''' The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End
        ''' RaiseEvent" statement that ends the accessor block.
        ''' </param>
        Friend Function AccessorBlock(kind As SyntaxKind, accessorStatement As AccessorStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endAccessorStatement As EndBlockStatementSyntax) As AccessorBlockSyntax
            Debug.Assert(SyntaxFacts.IsAccessorBlock(kind))
            Debug.Assert(accessorStatement IsNot Nothing)
            Debug.Assert(endAccessorStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(kind, accessorStatement, statements.Node, endAccessorStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AccessorBlockSyntax)
            End If

            Dim result = New AccessorBlockSyntax(kind, accessorStatement, statements.Node, endAccessorStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a block property declaration: A declaration that has a beginning
        ''' declaration, some get or set accessor blocks and an end statement.
        ''' </summary>
        ''' <param name="propertyStatement">
        ''' The property declaration that begins the block.
        ''' </param>
        ''' <param name="accessors">
        ''' The accessor blocks contained in the property, between the Property and the End
        ''' Property statements.
        ''' </param>
        ''' <param name="endPropertyStatement">
        ''' The End Property statement that ends the block.
        ''' </param>
        Friend Function PropertyBlock(propertyStatement As PropertyStatementSyntax, accessors As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endPropertyStatement As EndBlockStatementSyntax) As PropertyBlockSyntax
            Debug.Assert(propertyStatement IsNot Nothing)
            Debug.Assert(endPropertyStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.PropertyBlock, propertyStatement, accessors.Node, endPropertyStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, PropertyBlockSyntax)
            End If

            Dim result = New PropertyBlockSyntax(SyntaxKind.PropertyBlock, propertyStatement, accessors.Node, endPropertyStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a custom event declaration: A declaration that has a beginning event
        ''' declaration, some accessor blocks and an end statement.
        ''' </summary>
        ''' <param name="eventStatement">
        ''' The event declaration that begins the block.
        ''' </param>
        ''' <param name="accessors">
        ''' The accessor blocks contained in the custom event declaration, between the
        ''' Event statement and the End Event statement.
        ''' </param>
        ''' <param name="endEventStatement">
        ''' The End Event statement that ends the block.
        ''' </param>
        Friend Function EventBlock(eventStatement As EventStatementSyntax, accessors As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endEventStatement As EndBlockStatementSyntax) As EventBlockSyntax
            Debug.Assert(eventStatement IsNot Nothing)
            Debug.Assert(endEventStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EventBlock, eventStatement, accessors.Node, endEventStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EventBlockSyntax)
            End If

            Dim result = New EventBlockSyntax(SyntaxKind.EventBlock, eventStatement, accessors.Node, endEventStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the parameter list in a method declaration.
        ''' </summary>
        ''' <param name="openParenToken">
        ''' The "(" token that introduces the parameter list. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="parameters">
        ''' The list of parameters. If no parameter list was present, Nothing is returned.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token that concludes the parameter list. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        Friend Function ParameterList(openParenToken As PunctuationSyntax, parameters As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), closeParenToken As PunctuationSyntax) As ParameterListSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ParameterListSyntax)
            End If

            Dim result = New ParameterListSyntax(SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The statement that declares a Sub or Function. If this method has a body, this
        ''' statement will be the Begin of a BlockStatement with
        ''' Kind=MethodDeclarationBlock, and the body of the method will be the Body of
        ''' that BlockStatement.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword that introduces this method declaration.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the method being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic type parameters for this method.
        ''' If no generic type parameters were present, Nothing is returned.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        ''' <param name="handlesClause">
        ''' If present, a Handles clause indicated the events that this method handles.
        ''' </param>
        ''' <param name="implementsClause">
        ''' If present, an Implements clause indicated the interface methods that this
        ''' method implements.
        ''' </param>
        Friend Function SubStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), subOrFunctionKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax, handlesClause As HandlesClauseSyntax, implementsClause As ImplementsClauseSyntax) As MethodStatementSyntax
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso subOrFunctionKeyword.Kind = SyntaxKind.SubKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New MethodStatementSyntax(SyntaxKind.SubStatement, attributeLists.Node, modifiers.Node, subOrFunctionKeyword, identifier, typeParameterList, parameterList, asClause, handlesClause, implementsClause, _factoryContext)
        End Function


        ''' <summary>
        ''' The statement that declares a Sub or Function. If this method has a body, this
        ''' statement will be the Begin of a BlockStatement with
        ''' Kind=MethodDeclarationBlock, and the body of the method will be the Body of
        ''' that BlockStatement.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword that introduces this method declaration.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the method being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic type parameters for this method.
        ''' If no generic type parameters were present, Nothing is returned.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        ''' <param name="handlesClause">
        ''' If present, a Handles clause indicated the events that this method handles.
        ''' </param>
        ''' <param name="implementsClause">
        ''' If present, an Implements clause indicated the interface methods that this
        ''' method implements.
        ''' </param>
        Friend Function FunctionStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), subOrFunctionKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax, handlesClause As HandlesClauseSyntax, implementsClause As ImplementsClauseSyntax) As MethodStatementSyntax
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso subOrFunctionKeyword.Kind = SyntaxKind.FunctionKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New MethodStatementSyntax(SyntaxKind.FunctionStatement, attributeLists.Node, modifiers.Node, subOrFunctionKeyword, identifier, typeParameterList, parameterList, asClause, handlesClause, implementsClause, _factoryContext)
        End Function


        ''' <summary>
        ''' The statement that declares a Sub or Function. If this method has a body, this
        ''' statement will be the Begin of a BlockStatement with
        ''' Kind=MethodDeclarationBlock, and the body of the method will be the Body of
        ''' that BlockStatement.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' MethodStatementSyntax. One of SubStatement, FunctionStatement.
        ''' </param>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword that introduces this method declaration.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the method being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic type parameters for this method.
        ''' If no generic type parameters were present, Nothing is returned.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        ''' <param name="handlesClause">
        ''' If present, a Handles clause indicated the events that this method handles.
        ''' </param>
        ''' <param name="implementsClause">
        ''' If present, an Implements clause indicated the interface methods that this
        ''' method implements.
        ''' </param>
        Friend Function MethodStatement(kind As SyntaxKind, attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), subOrFunctionKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax, handlesClause As HandlesClauseSyntax, implementsClause As ImplementsClauseSyntax) As MethodStatementSyntax
            Debug.Assert(SyntaxFacts.IsMethodStatement(kind))
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso SyntaxFacts.IsMethodStatementSubOrFunctionKeyword(subOrFunctionKeyword.Kind))
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New MethodStatementSyntax(kind, attributeLists.Node, modifiers.Node, subOrFunctionKeyword, identifier, typeParameterList, parameterList, asClause, handlesClause, implementsClause, _factoryContext)
        End Function


        ''' <summary>
        ''' A statement that declares a constructor. This statement will be the Begin of a
        ''' BlockStatement with Kind=MethodDeclarationBlock, and the body of the method
        ''' will be the Body of that BlockStatement.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="subKeyword">
        ''' The "Sub" keyword.
        ''' </param>
        ''' <param name="newKeyword">
        ''' The "New" keyword in the constructor declaration.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        Friend Function SubNewStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), subKeyword As KeywordSyntax, newKeyword As KeywordSyntax, parameterList As ParameterListSyntax) As SubNewStatementSyntax
            Debug.Assert(subKeyword IsNot Nothing AndAlso subKeyword.Kind = SyntaxKind.SubKeyword)
            Debug.Assert(newKeyword IsNot Nothing AndAlso newKeyword.Kind = SyntaxKind.NewKeyword)
            Return New SubNewStatementSyntax(SyntaxKind.SubNewStatement, attributeLists.Node, modifiers.Node, subKeyword, newKeyword, parameterList, _factoryContext)
        End Function


        ''' <summary>
        ''' A Declare statement that declares an external DLL method.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="declareKeyword">
        ''' The "Declare" keyword.
        ''' </param>
        ''' <param name="charsetKeyword">
        ''' If present, the keyword that defines the string translation semantics of the
        ''' external method.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the method being declared.
        ''' </param>
        ''' <param name="libKeyword">
        ''' The "Lib" keyword.
        ''' </param>
        ''' <param name="libraryName">
        ''' The string literal with the library name.
        ''' </param>
        ''' <param name="aliasKeyword">
        ''' If present, the "Alias" keyword. If not present, returns Nothing.
        ''' </param>
        ''' <param name="aliasName">
        ''' The string literal with the alias. If not present, returns Nothing.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Function DeclareSubStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), declareKeyword As KeywordSyntax, charsetKeyword As KeywordSyntax, subOrFunctionKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, libKeyword As KeywordSyntax, libraryName As LiteralExpressionSyntax, aliasKeyword As KeywordSyntax, aliasName As LiteralExpressionSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax) As DeclareStatementSyntax
            Debug.Assert(declareKeyword IsNot Nothing AndAlso declareKeyword.Kind = SyntaxKind.DeclareKeyword)
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso subOrFunctionKeyword.Kind = SyntaxKind.SubKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Debug.Assert(libKeyword IsNot Nothing AndAlso libKeyword.Kind = SyntaxKind.LibKeyword)
            Debug.Assert(libraryName IsNot Nothing)
            Return New DeclareStatementSyntax(SyntaxKind.DeclareSubStatement, attributeLists.Node, modifiers.Node, declareKeyword, charsetKeyword, subOrFunctionKeyword, identifier, libKeyword, libraryName, aliasKeyword, aliasName, parameterList, asClause, _factoryContext)
        End Function


        ''' <summary>
        ''' A Declare statement that declares an external DLL method.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="declareKeyword">
        ''' The "Declare" keyword.
        ''' </param>
        ''' <param name="charsetKeyword">
        ''' If present, the keyword that defines the string translation semantics of the
        ''' external method.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the method being declared.
        ''' </param>
        ''' <param name="libKeyword">
        ''' The "Lib" keyword.
        ''' </param>
        ''' <param name="libraryName">
        ''' The string literal with the library name.
        ''' </param>
        ''' <param name="aliasKeyword">
        ''' If present, the "Alias" keyword. If not present, returns Nothing.
        ''' </param>
        ''' <param name="aliasName">
        ''' The string literal with the alias. If not present, returns Nothing.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Function DeclareFunctionStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), declareKeyword As KeywordSyntax, charsetKeyword As KeywordSyntax, subOrFunctionKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, libKeyword As KeywordSyntax, libraryName As LiteralExpressionSyntax, aliasKeyword As KeywordSyntax, aliasName As LiteralExpressionSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax) As DeclareStatementSyntax
            Debug.Assert(declareKeyword IsNot Nothing AndAlso declareKeyword.Kind = SyntaxKind.DeclareKeyword)
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso subOrFunctionKeyword.Kind = SyntaxKind.FunctionKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Debug.Assert(libKeyword IsNot Nothing AndAlso libKeyword.Kind = SyntaxKind.LibKeyword)
            Debug.Assert(libraryName IsNot Nothing)
            Return New DeclareStatementSyntax(SyntaxKind.DeclareFunctionStatement, attributeLists.Node, modifiers.Node, declareKeyword, charsetKeyword, subOrFunctionKeyword, identifier, libKeyword, libraryName, aliasKeyword, aliasName, parameterList, asClause, _factoryContext)
        End Function


        ''' <summary>
        ''' A Declare statement that declares an external DLL method.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' DeclareStatementSyntax. One of DeclareSubStatement, DeclareFunctionStatement.
        ''' </param>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="declareKeyword">
        ''' The "Declare" keyword.
        ''' </param>
        ''' <param name="charsetKeyword">
        ''' If present, the keyword that defines the string translation semantics of the
        ''' external method.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the method being declared.
        ''' </param>
        ''' <param name="libKeyword">
        ''' The "Lib" keyword.
        ''' </param>
        ''' <param name="libraryName">
        ''' The string literal with the library name.
        ''' </param>
        ''' <param name="aliasKeyword">
        ''' If present, the "Alias" keyword. If not present, returns Nothing.
        ''' </param>
        ''' <param name="aliasName">
        ''' The string literal with the alias. If not present, returns Nothing.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Function DeclareStatement(kind As SyntaxKind, attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), declareKeyword As KeywordSyntax, charsetKeyword As KeywordSyntax, subOrFunctionKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, libKeyword As KeywordSyntax, libraryName As LiteralExpressionSyntax, aliasKeyword As KeywordSyntax, aliasName As LiteralExpressionSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax) As DeclareStatementSyntax
            Debug.Assert(SyntaxFacts.IsDeclareStatement(kind))
            Debug.Assert(declareKeyword IsNot Nothing AndAlso declareKeyword.Kind = SyntaxKind.DeclareKeyword)
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso SyntaxFacts.IsDeclareStatementSubOrFunctionKeyword(subOrFunctionKeyword.Kind))
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Debug.Assert(libKeyword IsNot Nothing AndAlso libKeyword.Kind = SyntaxKind.LibKeyword)
            Debug.Assert(libraryName IsNot Nothing)
            Return New DeclareStatementSyntax(kind, attributeLists.Node, modifiers.Node, declareKeyword, charsetKeyword, subOrFunctionKeyword, identifier, libKeyword, libraryName, aliasKeyword, aliasName, parameterList, asClause, _factoryContext)
        End Function


        ''' <summary>
        ''' A statement that declares a delegate type.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="delegateKeyword">
        ''' The "Delegate" keyword.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the delegate being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic type parameters for this
        ''' delegate. If no generic type parameters were present, Nothing is returned.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Function DelegateSubStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), delegateKeyword As KeywordSyntax, subOrFunctionKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax) As DelegateStatementSyntax
            Debug.Assert(delegateKeyword IsNot Nothing AndAlso delegateKeyword.Kind = SyntaxKind.DelegateKeyword)
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso subOrFunctionKeyword.Kind = SyntaxKind.SubKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New DelegateStatementSyntax(SyntaxKind.DelegateSubStatement, attributeLists.Node, modifiers.Node, delegateKeyword, subOrFunctionKeyword, identifier, typeParameterList, parameterList, asClause, _factoryContext)
        End Function


        ''' <summary>
        ''' A statement that declares a delegate type.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="delegateKeyword">
        ''' The "Delegate" keyword.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the delegate being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic type parameters for this
        ''' delegate. If no generic type parameters were present, Nothing is returned.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Function DelegateFunctionStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), delegateKeyword As KeywordSyntax, subOrFunctionKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax) As DelegateStatementSyntax
            Debug.Assert(delegateKeyword IsNot Nothing AndAlso delegateKeyword.Kind = SyntaxKind.DelegateKeyword)
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso subOrFunctionKeyword.Kind = SyntaxKind.FunctionKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New DelegateStatementSyntax(SyntaxKind.DelegateFunctionStatement, attributeLists.Node, modifiers.Node, delegateKeyword, subOrFunctionKeyword, identifier, typeParameterList, parameterList, asClause, _factoryContext)
        End Function


        ''' <summary>
        ''' A statement that declares a delegate type.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' DelegateStatementSyntax. One of DelegateSubStatement,
        ''' DelegateFunctionStatement.
        ''' </param>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="delegateKeyword">
        ''' The "Delegate" keyword.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the delegate being declared.
        ''' </param>
        ''' <param name="typeParameterList">
        ''' If present, a type parameter list with generic type parameters for this
        ''' delegate. If no generic type parameters were present, Nothing is returned.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Function DelegateStatement(kind As SyntaxKind, attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), delegateKeyword As KeywordSyntax, subOrFunctionKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, typeParameterList As TypeParameterListSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax) As DelegateStatementSyntax
            Debug.Assert(SyntaxFacts.IsDelegateStatement(kind))
            Debug.Assert(delegateKeyword IsNot Nothing AndAlso delegateKeyword.Kind = SyntaxKind.DelegateKeyword)
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso SyntaxFacts.IsDelegateStatementSubOrFunctionKeyword(subOrFunctionKeyword.Kind))
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New DelegateStatementSyntax(kind, attributeLists.Node, modifiers.Node, delegateKeyword, subOrFunctionKeyword, identifier, typeParameterList, parameterList, asClause, _factoryContext)
        End Function


        ''' <summary>
        ''' A statement that declares an event. If the event being declared is a custom
        ''' event, this statement will be the Begin of a PropertyOrEventBlock, and the
        ''' accessors will be part of the Accessors of that node.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="customKeyword">
        ''' The optional Custom keyword for custom event declarations.
        ''' </param>
        ''' <param name="eventKeyword">
        ''' The "Event" keyword that introduces this event declaration.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the event being declared.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        ''' <param name="implementsClause">
        ''' If present, an Implements clause indicates the interface methods that this
        ''' method implements.
        ''' </param>
        Friend Function EventStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), customKeyword As KeywordSyntax, eventKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax, implementsClause As ImplementsClauseSyntax) As EventStatementSyntax
            Debug.Assert(eventKeyword IsNot Nothing AndAlso eventKeyword.Kind = SyntaxKind.EventKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New EventStatementSyntax(SyntaxKind.EventStatement, attributeLists.Node, modifiers.Node, customKeyword, eventKeyword, identifier, parameterList, asClause, implementsClause, _factoryContext)
        End Function


        ''' <summary>
        ''' A statement that declares an operator. If this operator has a body, this
        ''' statement will be the Begin of a BlockStatement with
        ''' Kind=MethodDeclarationBlock, and the body of the method will be the Body of
        ''' that BlockStatement.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="operatorKeyword">
        ''' The "Operator" keyword that introduces this operator declaration.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator being defined.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Function OperatorStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), operatorKeyword As KeywordSyntax, operatorToken As SyntaxToken, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax) As OperatorStatementSyntax
            Debug.Assert(operatorKeyword IsNot Nothing AndAlso operatorKeyword.Kind = SyntaxKind.OperatorKeyword)
            Debug.Assert(operatorToken IsNot Nothing AndAlso SyntaxFacts.IsOperatorStatementOperatorToken(operatorToken.Kind))
            Return New OperatorStatementSyntax(SyntaxKind.OperatorStatement, attributeLists.Node, modifiers.Node, operatorKeyword, operatorToken, parameterList, asClause, _factoryContext)
        End Function


        ''' <summary>
        ''' Statement that declares a property. If this property has accessors declared,
        ''' this statement will be the Begin of a BlockNode, and the accessors will be the
        ''' Body of that node. Auto properties are property declarations without a
        ''' PropertyBlock.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="propertyKeyword">
        ''' The "Property" keyword that introduces this property declaration.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the property being declared.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        ''' <param name="initializer">
        ''' If present, an "= initial-value" clause describing the initial value of the
        ''' property.
        ''' </param>
        ''' <param name="implementsClause">
        ''' If present, an Implements clause indicated the interface methods that this
        ''' method implements.
        ''' </param>
        Friend Function PropertyStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), propertyKeyword As KeywordSyntax, identifier As IdentifierTokenSyntax, parameterList As ParameterListSyntax, asClause As AsClauseSyntax, initializer As EqualsValueSyntax, implementsClause As ImplementsClauseSyntax) As PropertyStatementSyntax
            Debug.Assert(propertyKeyword IsNot Nothing AndAlso propertyKeyword.Kind = SyntaxKind.PropertyKeyword)
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New PropertyStatementSyntax(SyntaxKind.PropertyStatement, attributeLists.Node, modifiers.Node, propertyKeyword, identifier, parameterList, asClause, initializer, implementsClause, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a Get or Set accessor on a property declaration or an AddHandler,
        ''' RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
        ''' the node determines what kind of accessor this is. This statement is always the
        ''' Begin of a BlockNode, and the body of the accessor is the Body of that node.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="accessorKeyword">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
        ''' introduces this accessor declaration.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        Friend Function GetAccessorStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), accessorKeyword As KeywordSyntax, parameterList As ParameterListSyntax) As AccessorStatementSyntax
            Debug.Assert(accessorKeyword IsNot Nothing AndAlso accessorKeyword.Kind = SyntaxKind.GetKeyword)
            Return New AccessorStatementSyntax(SyntaxKind.GetAccessorStatement, attributeLists.Node, modifiers.Node, accessorKeyword, parameterList, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a Get or Set accessor on a property declaration or an AddHandler,
        ''' RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
        ''' the node determines what kind of accessor this is. This statement is always the
        ''' Begin of a BlockNode, and the body of the accessor is the Body of that node.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="accessorKeyword">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
        ''' introduces this accessor declaration.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        Friend Function SetAccessorStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), accessorKeyword As KeywordSyntax, parameterList As ParameterListSyntax) As AccessorStatementSyntax
            Debug.Assert(accessorKeyword IsNot Nothing AndAlso accessorKeyword.Kind = SyntaxKind.SetKeyword)
            Return New AccessorStatementSyntax(SyntaxKind.SetAccessorStatement, attributeLists.Node, modifiers.Node, accessorKeyword, parameterList, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a Get or Set accessor on a property declaration or an AddHandler,
        ''' RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
        ''' the node determines what kind of accessor this is. This statement is always the
        ''' Begin of a BlockNode, and the body of the accessor is the Body of that node.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="accessorKeyword">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
        ''' introduces this accessor declaration.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        Friend Function AddHandlerAccessorStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), accessorKeyword As KeywordSyntax, parameterList As ParameterListSyntax) As AccessorStatementSyntax
            Debug.Assert(accessorKeyword IsNot Nothing AndAlso accessorKeyword.Kind = SyntaxKind.AddHandlerKeyword)
            Return New AccessorStatementSyntax(SyntaxKind.AddHandlerAccessorStatement, attributeLists.Node, modifiers.Node, accessorKeyword, parameterList, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a Get or Set accessor on a property declaration or an AddHandler,
        ''' RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
        ''' the node determines what kind of accessor this is. This statement is always the
        ''' Begin of a BlockNode, and the body of the accessor is the Body of that node.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="accessorKeyword">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
        ''' introduces this accessor declaration.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        Friend Function RemoveHandlerAccessorStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), accessorKeyword As KeywordSyntax, parameterList As ParameterListSyntax) As AccessorStatementSyntax
            Debug.Assert(accessorKeyword IsNot Nothing AndAlso accessorKeyword.Kind = SyntaxKind.RemoveHandlerKeyword)
            Return New AccessorStatementSyntax(SyntaxKind.RemoveHandlerAccessorStatement, attributeLists.Node, modifiers.Node, accessorKeyword, parameterList, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a Get or Set accessor on a property declaration or an AddHandler,
        ''' RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
        ''' the node determines what kind of accessor this is. This statement is always the
        ''' Begin of a BlockNode, and the body of the accessor is the Body of that node.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="accessorKeyword">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
        ''' introduces this accessor declaration.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        Friend Function RaiseEventAccessorStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), accessorKeyword As KeywordSyntax, parameterList As ParameterListSyntax) As AccessorStatementSyntax
            Debug.Assert(accessorKeyword IsNot Nothing AndAlso accessorKeyword.Kind = SyntaxKind.RaiseEventKeyword)
            Return New AccessorStatementSyntax(SyntaxKind.RaiseEventAccessorStatement, attributeLists.Node, modifiers.Node, accessorKeyword, parameterList, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a Get or Set accessor on a property declaration or an AddHandler,
        ''' RemoveHandler or RaiseEvent accessor on a custom event declaration. The Kind of
        ''' the node determines what kind of accessor this is. This statement is always the
        ''' Begin of a BlockNode, and the body of the accessor is the Body of that node.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' AccessorStatementSyntax. One of GetAccessorStatement, SetAccessorStatement,
        ''' AddHandlerAccessorStatement, RemoveHandlerAccessorStatement,
        ''' RaiseEventAccessorStatement.
        ''' </param>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="accessorKeyword">
        ''' The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that
        ''' introduces this accessor declaration.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        Friend Function AccessorStatement(kind As SyntaxKind, attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), accessorKeyword As KeywordSyntax, parameterList As ParameterListSyntax) As AccessorStatementSyntax
            Debug.Assert(SyntaxFacts.IsAccessorStatement(kind))
            Debug.Assert(accessorKeyword IsNot Nothing AndAlso SyntaxFacts.IsAccessorStatementAccessorKeyword(accessorKeyword.Kind))
            Return New AccessorStatementSyntax(kind, attributeLists.Node, modifiers.Node, accessorKeyword, parameterList, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents the "Implements ..." clause on a type member, which describes which
        ''' interface members this member implements.
        ''' </summary>
        ''' <param name="implementsKeyword">
        ''' The "Implements" keyword.
        ''' </param>
        ''' <param name="interfaceMembers">
        ''' The list of interface members being implemented.
        ''' </param>
        Friend Function ImplementsClause(implementsKeyword As KeywordSyntax, interfaceMembers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As ImplementsClauseSyntax
            Debug.Assert(implementsKeyword IsNot Nothing AndAlso implementsKeyword.Kind = SyntaxKind.ImplementsKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ImplementsClause, implementsKeyword, interfaceMembers.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ImplementsClauseSyntax)
            End If

            Dim result = New ImplementsClauseSyntax(SyntaxKind.ImplementsClause, implementsKeyword, interfaceMembers.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the "Handles ..." clause on a method declaration that describes
        ''' which events this method handles.
        ''' </summary>
        ''' <param name="handlesKeyword">
        ''' The "Handles" keyword.
        ''' </param>
        ''' <param name="events">
        ''' The list of event members being handled.
        ''' </param>
        Friend Function HandlesClause(handlesKeyword As KeywordSyntax, events As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As HandlesClauseSyntax
            Debug.Assert(handlesKeyword IsNot Nothing AndAlso handlesKeyword.Kind = SyntaxKind.HandlesKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.HandlesClause, handlesKeyword, events.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, HandlesClauseSyntax)
            End If

            Dim result = New HandlesClauseSyntax(SyntaxKind.HandlesClause, handlesKeyword, events.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents event container specified through special keywords "Me", "MyBase" or
        ''' "MyClass"..
        ''' </summary>
        ''' <param name="keyword">
        ''' The container of the event. This can be one of the special keywords: "Me",
        ''' "MyBase" or "MyClass".
        ''' </param>
        Friend Function KeywordEventContainer(keyword As KeywordSyntax) As KeywordEventContainerSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso SyntaxFacts.IsKeywordEventContainerKeyword(keyword.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.KeywordEventContainer, keyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, KeywordEventContainerSyntax)
            End If

            Dim result = New KeywordEventContainerSyntax(SyntaxKind.KeywordEventContainer, keyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents event container that refers to a WithEvents member.
        ''' </summary>
        ''' <param name="identifier">
        ''' The container of the event. It is a simple identifier that refers to a
        ''' WithEvents member of the containing type.
        ''' </param>
        Friend Function WithEventsEventContainer(identifier As IdentifierTokenSyntax) As WithEventsEventContainerSyntax
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.WithEventsEventContainer, identifier, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, WithEventsEventContainerSyntax)
            End If

            Dim result = New WithEventsEventContainerSyntax(SyntaxKind.WithEventsEventContainer, identifier, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents event container that refers to a WithEvents member's property.
        ''' </summary>
        ''' <param name="withEventsContainer">
        ''' The container of the event.
        ''' </param>
        ''' <param name="dotToken">
        ''' The "." token.
        ''' </param>
        ''' <param name="property">
        ''' The provider of the event. It is a property of a WithEvents member of the
        ''' containing type.
        ''' </param>
        Friend Function WithEventsPropertyEventContainer(withEventsContainer As WithEventsEventContainerSyntax, dotToken As PunctuationSyntax, [property] As IdentifierNameSyntax) As WithEventsPropertyEventContainerSyntax
            Debug.Assert(withEventsContainer IsNot Nothing)
            Debug.Assert(dotToken IsNot Nothing AndAlso dotToken.Kind = SyntaxKind.DotToken)
            Debug.Assert([property] IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.WithEventsPropertyEventContainer, withEventsContainer, dotToken, [property], _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, WithEventsPropertyEventContainerSyntax)
            End If

            Dim result = New WithEventsPropertyEventContainerSyntax(SyntaxKind.WithEventsPropertyEventContainer, withEventsContainer, dotToken, [property], _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a single handled event in a "Handles ..." clause.
        ''' </summary>
        ''' <param name="eventContainer">
        ''' The container of the event. This can either be a simple identifier (identifying
        ''' a members of the containing type) or one of the special keywords "Me", "MyBase"
        ''' or "MyClass".
        ''' </param>
        ''' <param name="dotToken">
        ''' The "." token.
        ''' </param>
        ''' <param name="eventMember">
        ''' The event being handled. This must be a simple identifier.
        ''' </param>
        Friend Function HandlesClauseItem(eventContainer As EventContainerSyntax, dotToken As PunctuationSyntax, eventMember As IdentifierNameSyntax) As HandlesClauseItemSyntax
            Debug.Assert(eventContainer IsNot Nothing)
            Debug.Assert(dotToken IsNot Nothing AndAlso dotToken.Kind = SyntaxKind.DotToken)
            Debug.Assert(eventMember IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.HandlesClauseItem, eventContainer, dotToken, eventMember, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, HandlesClauseItemSyntax)
            End If

            Dim result = New HandlesClauseItemSyntax(SyntaxKind.HandlesClauseItem, eventContainer, dotToken, eventMember, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the beginning of a declaration. However, not enough syntax is
        ''' detected to classify this as a field, method, property or event. This is node
        ''' always represents a syntax error.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </param>
        ''' <param name="missingIdentifier">
        ''' The missing identifier token for this incomplete member. Should only be used to
        ''' have a location for error reporting.
        ''' </param>
        Friend Function IncompleteMember(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), missingIdentifier As IdentifierTokenSyntax) As IncompleteMemberSyntax

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.IncompleteMember, attributeLists.Node, modifiers.Node, missingIdentifier, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, IncompleteMemberSyntax)
            End If

            Dim result = New IncompleteMemberSyntax(SyntaxKind.IncompleteMember, attributeLists.Node, modifiers.Node, missingIdentifier, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the declaration of one or more variables or constants, either as
        ''' local variables or as class/structure members. In the case of a constant, it is
        ''' represented by having "Const" in the Modifiers (although technically "Const" is
        ''' not a modifier, it is represented as one in the parse trees.)
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, an empty list is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned.
        ''' </param>
        ''' <param name="declarators">
        ''' The list of variable declarator. Each declarator specifies one or more variable
        ''' names along with a type and/or initializer.
        ''' </param>
        Friend Function FieldDeclaration(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), declarators As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As FieldDeclarationSyntax

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.FieldDeclaration, attributeLists.Node, modifiers.Node, declarators.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, FieldDeclarationSyntax)
            End If

            Dim result = New FieldDeclarationSyntax(SyntaxKind.FieldDeclaration, attributeLists.Node, modifiers.Node, declarators.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the part of a variable or constant declaration statement that
        ''' associated one or more variable names with a type.
        ''' </summary>
        ''' <param name="names">
        ''' The names of the variables being declared. Each name might have a "?" or "()"
        ''' modifier(s) attached.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type, and possibly includes "New",
        ''' "With" or "From". If no As clause was present, Nothing is returned.
        ''' </param>
        ''' <param name="initializer">
        ''' If present, an "= initial-value" clause describing the initial value of the
        ''' variable or the value of the constant.
        ''' </param>
        Friend Function VariableDeclarator(names As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), asClause As AsClauseSyntax, initializer As EqualsValueSyntax) As VariableDeclaratorSyntax

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.VariableDeclarator, names.Node, asClause, initializer, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, VariableDeclaratorSyntax)
            End If

            Dim result = New VariableDeclaratorSyntax(SyntaxKind.VariableDeclarator, names.Node, asClause, initializer, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "As {type-name}" clause that does not have an initializer or
        ''' "New". The type has optional attributes associated with it, although attributes
        ''' are not permitted in all possible places where this node occurs.
        ''' </summary>
        ''' <param name="asKeyword">
        ''' The "As" keyword.
        ''' </param>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on the type. If no attributes were specified, an
        ''' empty list is returned.
        ''' </param>
        ''' <param name="type">
        ''' The type-name part of the As clause.
        ''' </param>
        Friend Function SimpleAsClause(asKeyword As KeywordSyntax, attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), type As TypeSyntax) As SimpleAsClauseSyntax
            Debug.Assert(asKeyword IsNot Nothing AndAlso asKeyword.Kind = SyntaxKind.AsKeyword)
            Debug.Assert(type IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.SimpleAsClause, asKeyword, attributeLists.Node, type, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SimpleAsClauseSyntax)
            End If

            Dim result = New SimpleAsClauseSyntax(SyntaxKind.SimpleAsClause, asKeyword, attributeLists.Node, type, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "As New {type-name} [arguments] [initializers]" clause in a
        ''' declaration. The type has optional attributes associated with it, although
        ''' attributes are not permitted in many places where this node occurs (they are
        ''' permitted, for example, on automatically implemented properties.)
        ''' </summary>
        ''' <param name="asKeyword">
        ''' The "As" keyword.
        ''' </param>
        ''' <param name="newExpression">
        ''' The New expression
        ''' </param>
        Friend Function AsNewClause(asKeyword As KeywordSyntax, newExpression As NewExpressionSyntax) As AsNewClauseSyntax
            Debug.Assert(asKeyword IsNot Nothing AndAlso asKeyword.Kind = SyntaxKind.AsKeyword)
            Debug.Assert(newExpression IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.AsNewClause, asKeyword, newExpression, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AsNewClauseSyntax)
            End If

            Dim result = New AsNewClauseSyntax(SyntaxKind.AsNewClause, asKeyword, newExpression, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "With {...} clause used to initialize a new object's members.
        ''' </summary>
        ''' <param name="withKeyword">
        ''' The "With" keyword.
        ''' </param>
        ''' <param name="openBraceToken">
        ''' The "{" token.
        ''' </param>
        ''' <param name="initializers">
        ''' The comma-separated list of field initializers.
        ''' </param>
        ''' <param name="closeBraceToken">
        ''' The "}" token.
        ''' </param>
        Friend Function ObjectMemberInitializer(withKeyword As KeywordSyntax, openBraceToken As PunctuationSyntax, initializers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), closeBraceToken As PunctuationSyntax) As ObjectMemberInitializerSyntax
            Debug.Assert(withKeyword IsNot Nothing AndAlso withKeyword.Kind = SyntaxKind.WithKeyword)
            Debug.Assert(openBraceToken IsNot Nothing AndAlso openBraceToken.Kind = SyntaxKind.OpenBraceToken)
            Debug.Assert(closeBraceToken IsNot Nothing AndAlso closeBraceToken.Kind = SyntaxKind.CloseBraceToken)
            Return New ObjectMemberInitializerSyntax(SyntaxKind.ObjectMemberInitializer, withKeyword, openBraceToken, initializers.Node, closeBraceToken, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a "From {...} clause used to initialize a new collection object's
        ''' elements.
        ''' </summary>
        ''' <param name="fromKeyword">
        ''' The "From" keyword.
        ''' </param>
        ''' <param name="initializer">
        ''' The initializer including the braces.
        ''' </param>
        Friend Function ObjectCollectionInitializer(fromKeyword As KeywordSyntax, initializer As CollectionInitializerSyntax) As ObjectCollectionInitializerSyntax
            Debug.Assert(fromKeyword IsNot Nothing AndAlso fromKeyword.Kind = SyntaxKind.FromKeyword)
            Debug.Assert(initializer IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ObjectCollectionInitializer, fromKeyword, initializer, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ObjectCollectionInitializerSyntax)
            End If

            Dim result = New ObjectCollectionInitializerSyntax(SyntaxKind.ObjectCollectionInitializer, fromKeyword, initializer, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represent a field initializer in a With {...} initializer where the field name
        ''' is inferred from the initializer expression.
        ''' </summary>
        ''' <param name="keyKeyword">
        ''' The optional "Key" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The value being assigned.
        ''' </param>
        Friend Function InferredFieldInitializer(keyKeyword As KeywordSyntax, expression As ExpressionSyntax) As InferredFieldInitializerSyntax
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.InferredFieldInitializer, keyKeyword, expression, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, InferredFieldInitializerSyntax)
            End If

            Dim result = New InferredFieldInitializerSyntax(SyntaxKind.InferredFieldInitializer, keyKeyword, expression, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represent a named field initializer in a With {...} initializer, such as ".x =
        ''' expr".
        ''' </summary>
        ''' <param name="keyKeyword">
        ''' The optional "Key" keyword.
        ''' </param>
        ''' <param name="dotToken">
        ''' The "." token.
        ''' </param>
        ''' <param name="name">
        ''' The name of the field being initialized.
        ''' </param>
        ''' <param name="equalsToken">
        ''' The "=" token.
        ''' </param>
        ''' <param name="expression">
        ''' The value being assigned to the field.
        ''' </param>
        Friend Function NamedFieldInitializer(keyKeyword As KeywordSyntax, dotToken As PunctuationSyntax, name As IdentifierNameSyntax, equalsToken As PunctuationSyntax, expression As ExpressionSyntax) As NamedFieldInitializerSyntax
            Debug.Assert(dotToken IsNot Nothing AndAlso dotToken.Kind = SyntaxKind.DotToken)
            Debug.Assert(name IsNot Nothing)
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(expression IsNot Nothing)
            Return New NamedFieldInitializerSyntax(SyntaxKind.NamedFieldInitializer, keyKeyword, dotToken, name, equalsToken, expression, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an "= initializer" clause in a declaration for a variable, parameter
        ''' or automatic property.
        ''' </summary>
        ''' <param name="equalsToken">
        ''' The "=" token.
        ''' </param>
        ''' <param name="value">
        ''' The expression used as the initial value.
        ''' </param>
        Friend Function EqualsValue(equalsToken As PunctuationSyntax, value As ExpressionSyntax) As EqualsValueSyntax
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EqualsValue, equalsToken, value, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EqualsValueSyntax)
            End If

            Dim result = New EqualsValueSyntax(SyntaxKind.EqualsValue, equalsToken, value, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represent a parameter to a method, property, constructor, etc.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this parameter. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of the modifier tokens "ByVal", "ByRef", "Optional" or "ParamArray" that
        ''' modify this parameter.
        ''' </param>
        ''' <param name="identifier">
        ''' The name of the parameter, including any "?" or "()" modifiers.
        ''' </param>
        ''' <param name="asClause">
        ''' If present, the "As type-name" clause describing the type of the parameter. If
        ''' no As clause is present, Nothing is returned.
        ''' </param>
        ''' <param name="default">
        ''' If present, an initializer with the default value of the parameter. If no
        ''' default value is present, Nothing is returned.
        ''' </param>
        Friend Function Parameter(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, [default] As EqualsValueSyntax) As ParameterSyntax
            Debug.Assert(identifier IsNot Nothing)
            Return New ParameterSyntax(SyntaxKind.Parameter, attributeLists.Node, modifiers.Node, identifier, asClause, [default], _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as
        ''' used in parameter declarations and variable declarations.
        ''' </summary>
        ''' <param name="identifier">
        ''' The identifier that names the item being declared.
        ''' </param>
        ''' <param name="nullable">
        ''' The "?" token that indicates a nullable type.
        ''' </param>
        ''' <param name="arrayBounds">
        ''' The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
        ''' </param>
        ''' <param name="arrayRankSpecifiers">
        ''' A list of array modifiers for the type. If no array modifiers were present, an
        ''' empty list is returned.
        ''' </param>
        Friend Function ModifiedIdentifier(identifier As IdentifierTokenSyntax, nullable As PunctuationSyntax, arrayBounds As ArgumentListSyntax, arrayRankSpecifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As ModifiedIdentifierSyntax
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Return New ModifiedIdentifierSyntax(SyntaxKind.ModifiedIdentifier, identifier, nullable, arrayBounds, arrayRankSpecifiers.Node, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a modifier that describes an array type, without bounds, such as
        ''' "()" or "(,)".
        ''' </summary>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="commaTokens">
        ''' The comma tokens in the array type. There is one less comma than the rank.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Function ArrayRankSpecifier(openParenToken As PunctuationSyntax, commaTokens As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), closeParenToken As PunctuationSyntax) As ArrayRankSpecifierSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ArrayRankSpecifier, openParenToken, commaTokens.Node, closeParenToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ArrayRankSpecifierSyntax)
            End If

            Dim result = New ArrayRankSpecifierSyntax(SyntaxKind.ArrayRankSpecifier, openParenToken, commaTokens.Node, closeParenToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a group of attributes within "&lt;" and "&gt;" brackets.
        ''' </summary>
        ''' <param name="lessThanToken">
        ''' The "&lt;" token.
        ''' </param>
        ''' <param name="attributes">
        ''' A comma separated list of attribute declarations in this attribute list.
        ''' </param>
        ''' <param name="greaterThanToken">
        ''' The "&gt;" token.
        ''' </param>
        Friend Function AttributeList(lessThanToken As PunctuationSyntax, attributes As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), greaterThanToken As PunctuationSyntax) As AttributeListSyntax
            Debug.Assert(lessThanToken IsNot Nothing AndAlso lessThanToken.Kind = SyntaxKind.LessThanToken)
            Debug.Assert(greaterThanToken IsNot Nothing AndAlso greaterThanToken.Kind = SyntaxKind.GreaterThanToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.AttributeList, lessThanToken, attributes.Node, greaterThanToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AttributeListSyntax)
            End If

            Dim result = New AttributeListSyntax(SyntaxKind.AttributeList, lessThanToken, attributes.Node, greaterThanToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a single attribute declaration within an attribute list.
        ''' </summary>
        ''' <param name="target">
        ''' Optional attribute target. Assembly|Module :
        ''' </param>
        ''' <param name="name">
        ''' The name of the attribute.
        ''' </param>
        ''' <param name="argumentList">
        ''' The argument list, if present. If no argument list was supplied, Nothing is
        ''' returned.
        ''' </param>
        Friend Function Attribute(target As AttributeTargetSyntax, name As TypeSyntax, argumentList As ArgumentListSyntax) As AttributeSyntax
            Debug.Assert(name IsNot Nothing)
            Return New AttributeSyntax(SyntaxKind.Attribute, target, name, argumentList, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a single attribute declaration within an attribute list.
        ''' </summary>
        ''' <param name="attributeModifier">
        ''' The "Assembly" or "Module" attribute modifier, is present. If no attribute
        ''' modifier is present, Nothing is returned.
        ''' </param>
        ''' <param name="colonToken">
        ''' The ":" token, if an attribute modifier is present. If no attribute modifier is
        ''' present, Nothing is returned.
        ''' </param>
        Friend Function AttributeTarget(attributeModifier As KeywordSyntax, colonToken As PunctuationSyntax) As AttributeTargetSyntax
            Debug.Assert(attributeModifier IsNot Nothing AndAlso SyntaxFacts.IsAttributeTargetAttributeModifier(attributeModifier.Kind))
            Debug.Assert(colonToken IsNot Nothing AndAlso colonToken.Kind = SyntaxKind.ColonToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.AttributeTarget, attributeModifier, colonToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AttributeTargetSyntax)
            End If

            Dim result = New AttributeTargetSyntax(SyntaxKind.AttributeTarget, attributeModifier, colonToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a file-level attribute, in which the attributes have no other
        ''' syntactic element they are attached to.
        ''' </summary>
        ''' <param name="attributeLists">
        ''' The list of attribute lists.
        ''' </param>
        Friend Function AttributesStatement(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As AttributesStatementSyntax

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.AttributesStatement, attributeLists.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AttributesStatementSyntax)
            End If

            Dim result = New AttributesStatementSyntax(SyntaxKind.AttributesStatement, attributeLists.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represent an expression in a statement context. This may only be a invocation
        ''' or await expression in standard code but may be any expression in VB
        ''' Interactive code.
        ''' </summary>
        ''' <param name="expression">
        ''' The expression.
        ''' </param>
        Friend Function ExpressionStatement(expression As ExpressionSyntax) As ExpressionStatementSyntax
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ExpressionStatement, expression, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExpressionStatementSyntax)
            End If

            Dim result = New ExpressionStatementSyntax(SyntaxKind.ExpressionStatement, expression, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represent a "? expression" "Print" statement in VB Interactive code.
        ''' </summary>
        ''' <param name="questionToken">
        ''' "?" token.
        ''' </param>
        ''' <param name="expression">
        ''' The expression whose value is being output.
        ''' </param>
        Friend Function PrintStatement(questionToken As PunctuationSyntax, expression As ExpressionSyntax) As PrintStatementSyntax
            Debug.Assert(questionToken IsNot Nothing AndAlso questionToken.Kind = SyntaxKind.QuestionToken)
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.PrintStatement, questionToken, expression, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, PrintStatementSyntax)
            End If

            Dim result = New PrintStatementSyntax(SyntaxKind.PrintStatement, questionToken, expression, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a While...End While statement, including the While, body and End
        ''' While.
        ''' </summary>
        ''' <param name="whileStatement">
        ''' The While statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the While...End While. This might be an empty list.
        ''' </param>
        ''' <param name="endWhileStatement">
        ''' The End While statement that ends the block.
        ''' </param>
        Friend Function WhileBlock(whileStatement As WhileStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endWhileStatement As EndBlockStatementSyntax) As WhileBlockSyntax
            Debug.Assert(whileStatement IsNot Nothing)
            Debug.Assert(endWhileStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.WhileBlock, whileStatement, statements.Node, endWhileStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, WhileBlockSyntax)
            End If

            Dim result = New WhileBlockSyntax(SyntaxKind.WhileBlock, whileStatement, statements.Node, endWhileStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an entire Using...End Using statement, including the Using, body and
        ''' End Using statements.
        ''' </summary>
        ''' <param name="usingStatement">
        ''' The UsingStatement that begins the Using...End Using block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the Using...End Using block. This might be an empty
        ''' list.
        ''' </param>
        ''' <param name="endUsingStatement">
        ''' The End Using statement that ends the block.
        ''' </param>
        Friend Function UsingBlock(usingStatement As UsingStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endUsingStatement As EndBlockStatementSyntax) As UsingBlockSyntax
            Debug.Assert(usingStatement IsNot Nothing)
            Debug.Assert(endUsingStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.UsingBlock, usingStatement, statements.Node, endUsingStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, UsingBlockSyntax)
            End If

            Dim result = New UsingBlockSyntax(SyntaxKind.UsingBlock, usingStatement, statements.Node, endUsingStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a entire SyncLock...End SyncLock block, including the SyncLock
        ''' statement, the enclosed statements, and the End SyncLock statement.
        ''' </summary>
        ''' <param name="syncLockStatement">
        ''' The SyncLock statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the SyncLock...End SyncLock statement. This might
        ''' be an empty list.
        ''' </param>
        ''' <param name="endSyncLockStatement">
        ''' The End SyncLock statement that ends the block.
        ''' </param>
        Friend Function SyncLockBlock(syncLockStatement As SyncLockStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endSyncLockStatement As EndBlockStatementSyntax) As SyncLockBlockSyntax
            Debug.Assert(syncLockStatement IsNot Nothing)
            Debug.Assert(endSyncLockStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.SyncLockBlock, syncLockStatement, statements.Node, endSyncLockStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SyncLockBlockSyntax)
            End If

            Dim result = New SyncLockBlockSyntax(SyntaxKind.SyncLockBlock, syncLockStatement, statements.Node, endSyncLockStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a With...End With block, include the With statement, the body of the
        ''' block and the End With statement.
        ''' </summary>
        ''' <param name="withStatement">
        ''' The WithStatement that begins the With...End With block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the With...End With block. This might be an empty
        ''' list.
        ''' </param>
        ''' <param name="endWithStatement">
        ''' The End With statement that ends the block.
        ''' </param>
        Friend Function WithBlock(withStatement As WithStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endWithStatement As EndBlockStatementSyntax) As WithBlockSyntax
            Debug.Assert(withStatement IsNot Nothing)
            Debug.Assert(endWithStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.WithBlock, withStatement, statements.Node, endWithStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, WithBlockSyntax)
            End If

            Dim result = New WithBlockSyntax(SyntaxKind.WithBlock, withStatement, statements.Node, endWithStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the declaration of one or more local variables or constants.
        ''' </summary>
        ''' <param name="modifiers">
        ''' The modifier token (Static, Dim or Const) that introduces this local variable
        ''' declaration.
        ''' </param>
        ''' <param name="declarators">
        ''' The list of variable declarator. Each declarator specifies one or more variable
        ''' names along with a type and/or initializer.
        ''' </param>
        Friend Function LocalDeclarationStatement(modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), declarators As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As LocalDeclarationStatementSyntax

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.LocalDeclarationStatement, modifiers.Node, declarators.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LocalDeclarationStatementSyntax)
            End If

            Dim result = New LocalDeclarationStatementSyntax(SyntaxKind.LocalDeclarationStatement, modifiers.Node, declarators.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a label statement.
        ''' </summary>
        ''' <param name="labelToken">
        ''' The name of the label. If the label is a line number, returns an IntegerLiteral
        ''' that is the line number, otherwise, returns an Identifier.
        ''' </param>
        ''' <param name="colonToken">
        ''' The ":" token of the label statement.
        ''' </param>
        Friend Function LabelStatement(labelToken As SyntaxToken, colonToken As PunctuationSyntax) As LabelStatementSyntax
            Debug.Assert(labelToken IsNot Nothing AndAlso SyntaxFacts.IsLabelStatementLabelToken(labelToken.Kind))
            Debug.Assert(colonToken IsNot Nothing AndAlso colonToken.Kind = SyntaxKind.ColonToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.LabelStatement, labelToken, colonToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LabelStatementSyntax)
            End If

            Dim result = New LabelStatementSyntax(SyntaxKind.LabelStatement, labelToken, colonToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "GoTo" statement.
        ''' </summary>
        ''' <param name="goToKeyword">
        ''' The "GoTo" keyword.
        ''' </param>
        ''' <param name="label">
        ''' The name of the label. If the label is a line number, wraps an IntegerLiteral
        ''' that is the line number, otherwise, wraps an Identifier.
        ''' </param>
        Friend Function GoToStatement(goToKeyword As KeywordSyntax, label As LabelSyntax) As GoToStatementSyntax
            Debug.Assert(goToKeyword IsNot Nothing AndAlso goToKeyword.Kind = SyntaxKind.GoToKeyword)
            Debug.Assert(label IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.GoToStatement, goToKeyword, label, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, GoToStatementSyntax)
            End If

            Dim result = New GoToStatementSyntax(SyntaxKind.GoToStatement, goToKeyword, label, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' A label for a GoTo, Resume, or On Error statement. An identifier, line number,
        ''' or next keyword.
        ''' </summary>
        ''' <param name="labelToken">
        ''' The label name (identifier), line number (integer literal), or next keyword
        ''' token.
        ''' </param>
        Friend Function IdentifierLabel(labelToken As SyntaxToken) As LabelSyntax
            Debug.Assert(labelToken IsNot Nothing AndAlso labelToken.Kind = SyntaxKind.IdentifierToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.IdentifierLabel, labelToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LabelSyntax)
            End If

            Dim result = New LabelSyntax(SyntaxKind.IdentifierLabel, labelToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' A label for a GoTo, Resume, or On Error statement. An identifier, line number,
        ''' or next keyword.
        ''' </summary>
        ''' <param name="labelToken">
        ''' The label name (identifier), line number (integer literal), or next keyword
        ''' token.
        ''' </param>
        Friend Function NumericLabel(labelToken As SyntaxToken) As LabelSyntax
            Debug.Assert(labelToken IsNot Nothing AndAlso labelToken.Kind = SyntaxKind.IntegerLiteralToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.NumericLabel, labelToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LabelSyntax)
            End If

            Dim result = New LabelSyntax(SyntaxKind.NumericLabel, labelToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' A label for a GoTo, Resume, or On Error statement. An identifier, line number,
        ''' or next keyword.
        ''' </summary>
        ''' <param name="labelToken">
        ''' The label name (identifier), line number (integer literal), or next keyword
        ''' token.
        ''' </param>
        Friend Function NextLabel(labelToken As SyntaxToken) As LabelSyntax
            Debug.Assert(labelToken IsNot Nothing AndAlso labelToken.Kind = SyntaxKind.NextKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.NextLabel, labelToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LabelSyntax)
            End If

            Dim result = New LabelSyntax(SyntaxKind.NextLabel, labelToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' A label for a GoTo, Resume, or On Error statement. An identifier, line number,
        ''' or next keyword.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of LabelSyntax. One
        ''' of IdentifierLabel, NumericLabel, NextLabel.
        ''' </param>
        ''' <param name="labelToken">
        ''' The label name (identifier), line number (integer literal), or next keyword
        ''' token.
        ''' </param>
        Friend Function Label(kind As SyntaxKind, labelToken As SyntaxToken) As LabelSyntax
            Debug.Assert(SyntaxFacts.IsLabel(kind))
            Debug.Assert(labelToken IsNot Nothing AndAlso SyntaxFacts.IsLabelLabelToken(labelToken.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(kind, labelToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LabelSyntax)
            End If

            Dim result = New LabelSyntax(kind, labelToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Stop" or "End" statement. The Kind can be used to determine which
        ''' kind of statement this is.
        ''' </summary>
        ''' <param name="stopOrEndKeyword">
        ''' The "Stop" or "End" keyword.
        ''' </param>
        Friend Function StopStatement(stopOrEndKeyword As KeywordSyntax) As StopOrEndStatementSyntax
            Debug.Assert(stopOrEndKeyword IsNot Nothing AndAlso SyntaxFacts.IsStopOrEndStatementStopOrEndKeyword(stopOrEndKeyword.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.StopStatement, stopOrEndKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, StopOrEndStatementSyntax)
            End If

            Dim result = New StopOrEndStatementSyntax(SyntaxKind.StopStatement, stopOrEndKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Stop" or "End" statement. The Kind can be used to determine which
        ''' kind of statement this is.
        ''' </summary>
        ''' <param name="stopOrEndKeyword">
        ''' The "Stop" or "End" keyword.
        ''' </param>
        Friend Function EndStatement(stopOrEndKeyword As KeywordSyntax) As StopOrEndStatementSyntax
            Debug.Assert(stopOrEndKeyword IsNot Nothing AndAlso SyntaxFacts.IsStopOrEndStatementStopOrEndKeyword(stopOrEndKeyword.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EndStatement, stopOrEndKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, StopOrEndStatementSyntax)
            End If

            Dim result = New StopOrEndStatementSyntax(SyntaxKind.EndStatement, stopOrEndKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Stop" or "End" statement. The Kind can be used to determine which
        ''' kind of statement this is.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' StopOrEndStatementSyntax. One of StopStatement, EndStatement.
        ''' </param>
        ''' <param name="stopOrEndKeyword">
        ''' The "Stop" or "End" keyword.
        ''' </param>
        Friend Function StopOrEndStatement(kind As SyntaxKind, stopOrEndKeyword As KeywordSyntax) As StopOrEndStatementSyntax
            Debug.Assert(SyntaxFacts.IsStopOrEndStatement(kind))
            Debug.Assert(stopOrEndKeyword IsNot Nothing AndAlso SyntaxFacts.IsStopOrEndStatementStopOrEndKeyword(stopOrEndKeyword.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(kind, stopOrEndKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, StopOrEndStatementSyntax)
            End If

            Dim result = New StopOrEndStatementSyntax(kind, stopOrEndKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Function ExitDoStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.DoKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ExitDoStatement, exitKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExitStatementSyntax)
            End If

            Dim result = New ExitStatementSyntax(SyntaxKind.ExitDoStatement, exitKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Function ExitForStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.ForKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ExitForStatement, exitKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExitStatementSyntax)
            End If

            Dim result = New ExitStatementSyntax(SyntaxKind.ExitForStatement, exitKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Function ExitSubStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.SubKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ExitSubStatement, exitKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExitStatementSyntax)
            End If

            Dim result = New ExitStatementSyntax(SyntaxKind.ExitSubStatement, exitKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Function ExitFunctionStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.FunctionKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ExitFunctionStatement, exitKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExitStatementSyntax)
            End If

            Dim result = New ExitStatementSyntax(SyntaxKind.ExitFunctionStatement, exitKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Function ExitOperatorStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.OperatorKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ExitOperatorStatement, exitKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExitStatementSyntax)
            End If

            Dim result = New ExitStatementSyntax(SyntaxKind.ExitOperatorStatement, exitKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Function ExitPropertyStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.PropertyKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ExitPropertyStatement, exitKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExitStatementSyntax)
            End If

            Dim result = New ExitStatementSyntax(SyntaxKind.ExitPropertyStatement, exitKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Function ExitTryStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.TryKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ExitTryStatement, exitKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExitStatementSyntax)
            End If

            Dim result = New ExitStatementSyntax(SyntaxKind.ExitTryStatement, exitKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Function ExitSelectStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.SelectKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ExitSelectStatement, exitKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExitStatementSyntax)
            End If

            Dim result = New ExitStatementSyntax(SyntaxKind.ExitSelectStatement, exitKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Function ExitWhileStatement(exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.WhileKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ExitWhileStatement, exitKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExitStatementSyntax)
            End If

            Dim result = New ExitStatementSyntax(SyntaxKind.ExitWhileStatement, exitKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An exit statement. The kind of block being exited can be found by examining the
        ''' Kind.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' ExitStatementSyntax. One of ExitDoStatement, ExitForStatement,
        ''' ExitSubStatement, ExitFunctionStatement, ExitOperatorStatement,
        ''' ExitPropertyStatement, ExitTryStatement, ExitSelectStatement,
        ''' ExitWhileStatement.
        ''' </param>
        ''' <param name="exitKeyword">
        ''' The "Exit" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The keyword describing the block to exit.
        ''' </param>
        Friend Function ExitStatement(kind As SyntaxKind, exitKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ExitStatementSyntax
            Debug.Assert(SyntaxFacts.IsExitStatement(kind))
            Debug.Assert(exitKeyword IsNot Nothing AndAlso exitKeyword.Kind = SyntaxKind.ExitKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso SyntaxFacts.IsExitStatementBlockKeyword(blockKeyword.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(kind, exitKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExitStatementSyntax)
            End If

            Dim result = New ExitStatementSyntax(kind, exitKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Continue (block)" statement. THe kind of block referenced can be
        ''' determined by examining the Kind.
        ''' </summary>
        ''' <param name="continueKeyword">
        ''' The "Continue" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The "Do", "For" or "While" keyword that identifies the kind of loop being
        ''' continued.
        ''' </param>
        Friend Function ContinueWhileStatement(continueKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ContinueStatementSyntax
            Debug.Assert(continueKeyword IsNot Nothing AndAlso continueKeyword.Kind = SyntaxKind.ContinueKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.WhileKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ContinueWhileStatement, continueKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ContinueStatementSyntax)
            End If

            Dim result = New ContinueStatementSyntax(SyntaxKind.ContinueWhileStatement, continueKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Continue (block)" statement. THe kind of block referenced can be
        ''' determined by examining the Kind.
        ''' </summary>
        ''' <param name="continueKeyword">
        ''' The "Continue" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The "Do", "For" or "While" keyword that identifies the kind of loop being
        ''' continued.
        ''' </param>
        Friend Function ContinueDoStatement(continueKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ContinueStatementSyntax
            Debug.Assert(continueKeyword IsNot Nothing AndAlso continueKeyword.Kind = SyntaxKind.ContinueKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.DoKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ContinueDoStatement, continueKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ContinueStatementSyntax)
            End If

            Dim result = New ContinueStatementSyntax(SyntaxKind.ContinueDoStatement, continueKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Continue (block)" statement. THe kind of block referenced can be
        ''' determined by examining the Kind.
        ''' </summary>
        ''' <param name="continueKeyword">
        ''' The "Continue" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The "Do", "For" or "While" keyword that identifies the kind of loop being
        ''' continued.
        ''' </param>
        Friend Function ContinueForStatement(continueKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ContinueStatementSyntax
            Debug.Assert(continueKeyword IsNot Nothing AndAlso continueKeyword.Kind = SyntaxKind.ContinueKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso blockKeyword.Kind = SyntaxKind.ForKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ContinueForStatement, continueKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ContinueStatementSyntax)
            End If

            Dim result = New ContinueStatementSyntax(SyntaxKind.ContinueForStatement, continueKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Continue (block)" statement. THe kind of block referenced can be
        ''' determined by examining the Kind.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' ContinueStatementSyntax. One of ContinueWhileStatement, ContinueDoStatement,
        ''' ContinueForStatement.
        ''' </param>
        ''' <param name="continueKeyword">
        ''' The "Continue" keyword.
        ''' </param>
        ''' <param name="blockKeyword">
        ''' The "Do", "For" or "While" keyword that identifies the kind of loop being
        ''' continued.
        ''' </param>
        Friend Function ContinueStatement(kind As SyntaxKind, continueKeyword As KeywordSyntax, blockKeyword As KeywordSyntax) As ContinueStatementSyntax
            Debug.Assert(SyntaxFacts.IsContinueStatement(kind))
            Debug.Assert(continueKeyword IsNot Nothing AndAlso continueKeyword.Kind = SyntaxKind.ContinueKeyword)
            Debug.Assert(blockKeyword IsNot Nothing AndAlso SyntaxFacts.IsContinueStatementBlockKeyword(blockKeyword.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(kind, continueKeyword, blockKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ContinueStatementSyntax)
            End If

            Dim result = New ContinueStatementSyntax(kind, continueKeyword, blockKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Return" statement.
        ''' </summary>
        ''' <param name="returnKeyword">
        ''' The "Return" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being returned, if present.
        ''' </param>
        Friend Function ReturnStatement(returnKeyword As KeywordSyntax, expression As ExpressionSyntax) As ReturnStatementSyntax
            Debug.Assert(returnKeyword IsNot Nothing AndAlso returnKeyword.Kind = SyntaxKind.ReturnKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ReturnStatement, returnKeyword, expression, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ReturnStatementSyntax)
            End If

            Dim result = New ReturnStatementSyntax(SyntaxKind.ReturnStatement, returnKeyword, expression, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a single-line "If ... Then ... Else ..." statement.
        ''' </summary>
        ''' <param name="ifKeyword">
        ''' The "If" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The condition expression to be evaluated.
        ''' </param>
        ''' <param name="thenKeyword">
        ''' The "Then" keyword.
        ''' </param>
        ''' <param name="statements">
        ''' A list of statements to be executed if the condition expression evaluates as
        ''' true. Multiple statements must be separated by colons.
        ''' </param>
        ''' <param name="elseClause">
        ''' An "Else" clause to be executed if the condition expression evaluates as false.
        ''' </param>
        Friend Function SingleLineIfStatement(ifKeyword As KeywordSyntax, condition As ExpressionSyntax, thenKeyword As KeywordSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), elseClause As SingleLineElseClauseSyntax) As SingleLineIfStatementSyntax
            Debug.Assert(ifKeyword IsNot Nothing AndAlso ifKeyword.Kind = SyntaxKind.IfKeyword)
            Debug.Assert(condition IsNot Nothing)
            Debug.Assert(thenKeyword IsNot Nothing AndAlso thenKeyword.Kind = SyntaxKind.ThenKeyword)
            Return New SingleLineIfStatementSyntax(SyntaxKind.SingleLineIfStatement, ifKeyword, condition, thenKeyword, statements.Node, elseClause, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents the "Else ..." clause of a single-line "If" statement.
        ''' </summary>
        ''' <param name="elseKeyword">
        ''' The "Else" keyword.
        ''' </param>
        ''' <param name="statements">
        ''' A list of statements to be executed. Multiple statements must be separated by
        ''' colons.
        ''' </param>
        Friend Function SingleLineElseClause(elseKeyword As KeywordSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As SingleLineElseClauseSyntax
            Debug.Assert(elseKeyword IsNot Nothing AndAlso elseKeyword.Kind = SyntaxKind.ElseKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.SingleLineElseClause, elseKeyword, statements.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SingleLineElseClauseSyntax)
            End If

            Dim result = New SingleLineElseClauseSyntax(SyntaxKind.SingleLineElseClause, elseKeyword, statements.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a multi-line "If ... Then ... ElseIf ... Then ... Else ... End If"
        ''' block.
        ''' </summary>
        ''' <param name="ifStatement">
        ''' The "If" statement that begins the "If" block.
        ''' </param>
        ''' <param name="statements">
        ''' A list of statements to be executed if the condition expression evaluates as
        ''' true.
        ''' </param>
        ''' <param name="elseIfBlocks">
        ''' A list of "ElseIf" blocks to be evaluated, in order, if the condition
        ''' expression of the "If" statement evaluates as false.
        ''' </param>
        ''' <param name="elseBlock">
        ''' An "Else" block to be executed if the condition expression of the "If"
        ''' statement and all "ElseIf" blocks evaluate as false.
        ''' </param>
        ''' <param name="endIfStatement">
        ''' Then "End If" statement.
        ''' </param>
        Friend Function MultiLineIfBlock(ifStatement As IfStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), elseIfBlocks As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), elseBlock As ElseBlockSyntax, endIfStatement As EndBlockStatementSyntax) As MultiLineIfBlockSyntax
            Debug.Assert(ifStatement IsNot Nothing)
            Debug.Assert(endIfStatement IsNot Nothing)
            Return New MultiLineIfBlockSyntax(SyntaxKind.MultiLineIfBlock, ifStatement, statements.Node, elseIfBlocks.Node, elseBlock, endIfStatement, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents the "If ... Then" statement that begins a multi-line "If" block.
        ''' </summary>
        ''' <param name="ifKeyword">
        ''' The "If" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The condition expression to be evaluated.
        ''' </param>
        ''' <param name="thenKeyword">
        ''' The "Then" keyword.
        ''' </param>
        Friend Function IfStatement(ifKeyword As KeywordSyntax, condition As ExpressionSyntax, thenKeyword As KeywordSyntax) As IfStatementSyntax
            Debug.Assert(ifKeyword IsNot Nothing AndAlso ifKeyword.Kind = SyntaxKind.IfKeyword)
            Debug.Assert(condition IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.IfStatement, ifKeyword, condition, thenKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, IfStatementSyntax)
            End If

            Dim result = New IfStatementSyntax(SyntaxKind.IfStatement, ifKeyword, condition, thenKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "ElseIf ... Then ..." block.
        ''' </summary>
        ''' <param name="elseIfStatement">
        ''' The "ElseIf ... Then" statement the begins the "ElseIf" block.
        ''' </param>
        ''' <param name="statements">
        ''' A list of statements to be executed if the condition expression of the "ElseIf"
        ''' statement evaluates as true.
        ''' </param>
        Friend Function ElseIfBlock(elseIfStatement As ElseIfStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As ElseIfBlockSyntax
            Debug.Assert(elseIfStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ElseIfBlock, elseIfStatement, statements.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ElseIfBlockSyntax)
            End If

            Dim result = New ElseIfBlockSyntax(SyntaxKind.ElseIfBlock, elseIfStatement, statements.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the "ElseIf ... Then" statement that begins an "ElseIf" block.
        ''' </summary>
        ''' <param name="elseIfKeyword">
        ''' The "ElseIf" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The condition expression to be evaluated.
        ''' </param>
        ''' <param name="thenKeyword">
        ''' The "Then" keyword.
        ''' </param>
        Friend Function ElseIfStatement(elseIfKeyword As KeywordSyntax, condition As ExpressionSyntax, thenKeyword As KeywordSyntax) As ElseIfStatementSyntax
            Debug.Assert(elseIfKeyword IsNot Nothing AndAlso elseIfKeyword.Kind = SyntaxKind.ElseIfKeyword)
            Debug.Assert(condition IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ElseIfStatement, elseIfKeyword, condition, thenKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ElseIfStatementSyntax)
            End If

            Dim result = New ElseIfStatementSyntax(SyntaxKind.ElseIfStatement, elseIfKeyword, condition, thenKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "Else ..." block.
        ''' </summary>
        ''' <param name="elseStatement">
        ''' The "Else" statement that begins the "Else" block.
        ''' </param>
        ''' <param name="statements">
        ''' A list of statements to be executed.
        ''' </param>
        Friend Function ElseBlock(elseStatement As ElseStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As ElseBlockSyntax
            Debug.Assert(elseStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ElseBlock, elseStatement, statements.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ElseBlockSyntax)
            End If

            Dim result = New ElseBlockSyntax(SyntaxKind.ElseBlock, elseStatement, statements.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the "Else" statement that begins an "Else" block.
        ''' </summary>
        ''' <param name="elseKeyword">
        ''' The "Else" keyword.
        ''' </param>
        Friend Function ElseStatement(elseKeyword As KeywordSyntax) As ElseStatementSyntax
            Debug.Assert(elseKeyword IsNot Nothing AndAlso elseKeyword.Kind = SyntaxKind.ElseKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ElseStatement, elseKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ElseStatementSyntax)
            End If

            Dim result = New ElseStatementSyntax(SyntaxKind.ElseStatement, elseKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Try ... Catch ... Finally ... End Try" block.
        ''' </summary>
        ''' <param name="tryStatement">
        ''' The "Try" statement that begins the "Try" block.
        ''' </param>
        ''' <param name="statements">
        ''' A list of statements to be executed.
        ''' </param>
        ''' <param name="catchBlocks">
        ''' A list of "Catch" blocks which may be executed if an exception is thrown while
        ''' executing the statements in the "Try" block.
        ''' </param>
        ''' <param name="finallyBlock">
        ''' A "Finally" block to be executed before execution leaves the "Try" block.
        ''' </param>
        ''' <param name="endTryStatement">
        ''' The "End Try" statement.
        ''' </param>
        Friend Function TryBlock(tryStatement As TryStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), catchBlocks As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), finallyBlock As FinallyBlockSyntax, endTryStatement As EndBlockStatementSyntax) As TryBlockSyntax
            Debug.Assert(tryStatement IsNot Nothing)
            Debug.Assert(endTryStatement IsNot Nothing)
            Return New TryBlockSyntax(SyntaxKind.TryBlock, tryStatement, statements.Node, catchBlocks.Node, finallyBlock, endTryStatement, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents the "Try" statement that begins a "Try" block.
        ''' </summary>
        ''' <param name="tryKeyword">
        ''' The "Try" keyword.
        ''' </param>
        Friend Function TryStatement(tryKeyword As KeywordSyntax) As TryStatementSyntax
            Debug.Assert(tryKeyword IsNot Nothing AndAlso tryKeyword.Kind = SyntaxKind.TryKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.TryStatement, tryKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, TryStatementSyntax)
            End If

            Dim result = New TryStatementSyntax(SyntaxKind.TryStatement, tryKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Catch ..." block.
        ''' </summary>
        ''' <param name="catchStatement">
        ''' The "Catch" statement that begins the "Catch" block.
        ''' </param>
        ''' <param name="statements">
        ''' A list of statements to be executed if an exception is caught by the "Catch"
        ''' block.
        ''' </param>
        Friend Function CatchBlock(catchStatement As CatchStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As CatchBlockSyntax
            Debug.Assert(catchStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.CatchBlock, catchStatement, statements.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CatchBlockSyntax)
            End If

            Dim result = New CatchBlockSyntax(SyntaxKind.CatchBlock, catchStatement, statements.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the "Catch ... When ..." statement that begins a "Catch" block.
        ''' </summary>
        ''' <param name="catchKeyword">
        ''' The "Catch" keyword.
        ''' </param>
        ''' <param name="identifierName">
        ''' An identifier declaring a new variable or naming an existing variable to store
        ''' the exception caught by the "Catch" statement.
        ''' </param>
        ''' <param name="asClause">
        ''' A simple "As" clause specifying the type of exception to catch.
        ''' </param>
        ''' <param name="whenClause">
        ''' A "When" clause to filter exceptions before catching.
        ''' </param>
        Friend Function CatchStatement(catchKeyword As KeywordSyntax, identifierName As IdentifierNameSyntax, asClause As SimpleAsClauseSyntax, whenClause As CatchFilterClauseSyntax) As CatchStatementSyntax
            Debug.Assert(catchKeyword IsNot Nothing AndAlso catchKeyword.Kind = SyntaxKind.CatchKeyword)
            Return New CatchStatementSyntax(SyntaxKind.CatchStatement, catchKeyword, identifierName, asClause, whenClause, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents the "When ..." clause of a "Catch" statement.
        ''' </summary>
        ''' <param name="whenKeyword">
        ''' The "When" keyword.
        ''' </param>
        ''' <param name="filter">
        ''' The filter expression to be evaluated.
        ''' </param>
        Friend Function CatchFilterClause(whenKeyword As KeywordSyntax, filter As ExpressionSyntax) As CatchFilterClauseSyntax
            Debug.Assert(whenKeyword IsNot Nothing AndAlso whenKeyword.Kind = SyntaxKind.WhenKeyword)
            Debug.Assert(filter IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.CatchFilterClause, whenKeyword, filter, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CatchFilterClauseSyntax)
            End If

            Dim result = New CatchFilterClauseSyntax(SyntaxKind.CatchFilterClause, whenKeyword, filter, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Finally ..." block of a "Try" block.
        ''' </summary>
        ''' <param name="finallyStatement">
        ''' The "Finally" statement that begins the "Finally" block.
        ''' </param>
        ''' <param name="statements">
        ''' A list of statements to be executed.
        ''' </param>
        Friend Function FinallyBlock(finallyStatement As FinallyStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As FinallyBlockSyntax
            Debug.Assert(finallyStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.FinallyBlock, finallyStatement, statements.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, FinallyBlockSyntax)
            End If

            Dim result = New FinallyBlockSyntax(SyntaxKind.FinallyBlock, finallyStatement, statements.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the "Finally" statement that begins a "Finally" block.
        ''' </summary>
        ''' <param name="finallyKeyword">
        ''' The "Finally" keyword.
        ''' </param>
        Friend Function FinallyStatement(finallyKeyword As KeywordSyntax) As FinallyStatementSyntax
            Debug.Assert(finallyKeyword IsNot Nothing AndAlso finallyKeyword.Kind = SyntaxKind.FinallyKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.FinallyStatement, finallyKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, FinallyStatementSyntax)
            End If

            Dim result = New FinallyStatementSyntax(SyntaxKind.FinallyStatement, finallyKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the "Error" statement.
        ''' </summary>
        ''' <param name="errorKeyword">
        ''' The "Error" keyword.
        ''' </param>
        ''' <param name="errorNumber">
        ''' The expression that represents the error number.
        ''' </param>
        Friend Function ErrorStatement(errorKeyword As KeywordSyntax, errorNumber As ExpressionSyntax) As ErrorStatementSyntax
            Debug.Assert(errorKeyword IsNot Nothing AndAlso errorKeyword.Kind = SyntaxKind.ErrorKeyword)
            Debug.Assert(errorNumber IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ErrorStatement, errorKeyword, errorNumber, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ErrorStatementSyntax)
            End If

            Dim result = New ErrorStatementSyntax(SyntaxKind.ErrorStatement, errorKeyword, errorNumber, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an OnError Goto statement.
        ''' </summary>
        ''' <param name="onKeyword">
        ''' The "On" keyword
        ''' </param>
        ''' <param name="errorKeyword">
        ''' The "Error" keyword.
        ''' </param>
        ''' <param name="goToKeyword">
        ''' The "GoTo" keyword
        ''' </param>
        ''' <param name="minus">
        ''' An optional minus for On Error Goto -1
        ''' </param>
        ''' <param name="label">
        ''' The name of the label. If the label is a line number, 0 or -1, wraps an
        ''' IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
        ''' </param>
        Friend Function OnErrorGoToZeroStatement(onKeyword As KeywordSyntax, errorKeyword As KeywordSyntax, goToKeyword As KeywordSyntax, minus As PunctuationSyntax, label As LabelSyntax) As OnErrorGoToStatementSyntax
            Debug.Assert(onKeyword IsNot Nothing AndAlso onKeyword.Kind = SyntaxKind.OnKeyword)
            Debug.Assert(errorKeyword IsNot Nothing AndAlso errorKeyword.Kind = SyntaxKind.ErrorKeyword)
            Debug.Assert(goToKeyword IsNot Nothing AndAlso goToKeyword.Kind = SyntaxKind.GoToKeyword)
            Debug.Assert(label IsNot Nothing)
            Return New OnErrorGoToStatementSyntax(SyntaxKind.OnErrorGoToZeroStatement, onKeyword, errorKeyword, goToKeyword, minus, label, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an OnError Goto statement.
        ''' </summary>
        ''' <param name="onKeyword">
        ''' The "On" keyword
        ''' </param>
        ''' <param name="errorKeyword">
        ''' The "Error" keyword.
        ''' </param>
        ''' <param name="goToKeyword">
        ''' The "GoTo" keyword
        ''' </param>
        ''' <param name="minus">
        ''' An optional minus for On Error Goto -1
        ''' </param>
        ''' <param name="label">
        ''' The name of the label. If the label is a line number, 0 or -1, wraps an
        ''' IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
        ''' </param>
        Friend Function OnErrorGoToMinusOneStatement(onKeyword As KeywordSyntax, errorKeyword As KeywordSyntax, goToKeyword As KeywordSyntax, minus As PunctuationSyntax, label As LabelSyntax) As OnErrorGoToStatementSyntax
            Debug.Assert(onKeyword IsNot Nothing AndAlso onKeyword.Kind = SyntaxKind.OnKeyword)
            Debug.Assert(errorKeyword IsNot Nothing AndAlso errorKeyword.Kind = SyntaxKind.ErrorKeyword)
            Debug.Assert(goToKeyword IsNot Nothing AndAlso goToKeyword.Kind = SyntaxKind.GoToKeyword)
            Debug.Assert(label IsNot Nothing)
            Return New OnErrorGoToStatementSyntax(SyntaxKind.OnErrorGoToMinusOneStatement, onKeyword, errorKeyword, goToKeyword, minus, label, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an OnError Goto statement.
        ''' </summary>
        ''' <param name="onKeyword">
        ''' The "On" keyword
        ''' </param>
        ''' <param name="errorKeyword">
        ''' The "Error" keyword.
        ''' </param>
        ''' <param name="goToKeyword">
        ''' The "GoTo" keyword
        ''' </param>
        ''' <param name="minus">
        ''' An optional minus for On Error Goto -1
        ''' </param>
        ''' <param name="label">
        ''' The name of the label. If the label is a line number, 0 or -1, wraps an
        ''' IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
        ''' </param>
        Friend Function OnErrorGoToLabelStatement(onKeyword As KeywordSyntax, errorKeyword As KeywordSyntax, goToKeyword As KeywordSyntax, minus As PunctuationSyntax, label As LabelSyntax) As OnErrorGoToStatementSyntax
            Debug.Assert(onKeyword IsNot Nothing AndAlso onKeyword.Kind = SyntaxKind.OnKeyword)
            Debug.Assert(errorKeyword IsNot Nothing AndAlso errorKeyword.Kind = SyntaxKind.ErrorKeyword)
            Debug.Assert(goToKeyword IsNot Nothing AndAlso goToKeyword.Kind = SyntaxKind.GoToKeyword)
            Debug.Assert(label IsNot Nothing)
            Return New OnErrorGoToStatementSyntax(SyntaxKind.OnErrorGoToLabelStatement, onKeyword, errorKeyword, goToKeyword, minus, label, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an OnError Goto statement.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' OnErrorGoToStatementSyntax. One of OnErrorGoToZeroStatement,
        ''' OnErrorGoToMinusOneStatement, OnErrorGoToLabelStatement.
        ''' </param>
        ''' <param name="onKeyword">
        ''' The "On" keyword
        ''' </param>
        ''' <param name="errorKeyword">
        ''' The "Error" keyword.
        ''' </param>
        ''' <param name="goToKeyword">
        ''' The "GoTo" keyword
        ''' </param>
        ''' <param name="minus">
        ''' An optional minus for On Error Goto -1
        ''' </param>
        ''' <param name="label">
        ''' The name of the label. If the label is a line number, 0 or -1, wraps an
        ''' IntegerLiteralToken that is the line number, otherwise, wraps an Identifier.
        ''' </param>
        Friend Function OnErrorGoToStatement(kind As SyntaxKind, onKeyword As KeywordSyntax, errorKeyword As KeywordSyntax, goToKeyword As KeywordSyntax, minus As PunctuationSyntax, label As LabelSyntax) As OnErrorGoToStatementSyntax
            Debug.Assert(SyntaxFacts.IsOnErrorGoToStatement(kind))
            Debug.Assert(onKeyword IsNot Nothing AndAlso onKeyword.Kind = SyntaxKind.OnKeyword)
            Debug.Assert(errorKeyword IsNot Nothing AndAlso errorKeyword.Kind = SyntaxKind.ErrorKeyword)
            Debug.Assert(goToKeyword IsNot Nothing AndAlso goToKeyword.Kind = SyntaxKind.GoToKeyword)
            Debug.Assert(label IsNot Nothing)
            Return New OnErrorGoToStatementSyntax(kind, onKeyword, errorKeyword, goToKeyword, minus, label, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an OnError Resume Next statement.
        ''' </summary>
        ''' <param name="onKeyword">
        ''' The "On" keyword
        ''' </param>
        ''' <param name="errorKeyword">
        ''' The "Error" keyword.
        ''' </param>
        ''' <param name="resumeKeyword">
        ''' The "Resume" keyword.
        ''' </param>
        ''' <param name="nextKeyword">
        ''' The "Next"
        ''' </param>
        Friend Function OnErrorResumeNextStatement(onKeyword As KeywordSyntax, errorKeyword As KeywordSyntax, resumeKeyword As KeywordSyntax, nextKeyword As KeywordSyntax) As OnErrorResumeNextStatementSyntax
            Debug.Assert(onKeyword IsNot Nothing AndAlso onKeyword.Kind = SyntaxKind.OnKeyword)
            Debug.Assert(errorKeyword IsNot Nothing AndAlso errorKeyword.Kind = SyntaxKind.ErrorKeyword)
            Debug.Assert(resumeKeyword IsNot Nothing AndAlso resumeKeyword.Kind = SyntaxKind.ResumeKeyword)
            Debug.Assert(nextKeyword IsNot Nothing AndAlso nextKeyword.Kind = SyntaxKind.NextKeyword)
            Return New OnErrorResumeNextStatementSyntax(SyntaxKind.OnErrorResumeNextStatement, onKeyword, errorKeyword, resumeKeyword, nextKeyword, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a "Resume" statement. The Kind property can be used to determine if
        ''' this is a "Resume", "Resume Next" or "Resume label" statement.
        ''' </summary>
        ''' <param name="resumeKeyword">
        ''' The "Resume" keyword.
        ''' </param>
        ''' <param name="label">
        ''' The label. The value of this depends on the Kind. If Kind=Resume, returns
        ''' Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
        ''' wraps an Identifier or IntegerLiteralToken with the label or line number.
        ''' </param>
        Friend Function ResumeStatement(resumeKeyword As KeywordSyntax, label As LabelSyntax) As ResumeStatementSyntax
            Debug.Assert(resumeKeyword IsNot Nothing AndAlso resumeKeyword.Kind = SyntaxKind.ResumeKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ResumeStatement, resumeKeyword, label, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ResumeStatementSyntax)
            End If

            Dim result = New ResumeStatementSyntax(SyntaxKind.ResumeStatement, resumeKeyword, label, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Resume" statement. The Kind property can be used to determine if
        ''' this is a "Resume", "Resume Next" or "Resume label" statement.
        ''' </summary>
        ''' <param name="resumeKeyword">
        ''' The "Resume" keyword.
        ''' </param>
        ''' <param name="label">
        ''' The label. The value of this depends on the Kind. If Kind=Resume, returns
        ''' Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
        ''' wraps an Identifier or IntegerLiteralToken with the label or line number.
        ''' </param>
        Friend Function ResumeLabelStatement(resumeKeyword As KeywordSyntax, label As LabelSyntax) As ResumeStatementSyntax
            Debug.Assert(resumeKeyword IsNot Nothing AndAlso resumeKeyword.Kind = SyntaxKind.ResumeKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ResumeLabelStatement, resumeKeyword, label, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ResumeStatementSyntax)
            End If

            Dim result = New ResumeStatementSyntax(SyntaxKind.ResumeLabelStatement, resumeKeyword, label, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Resume" statement. The Kind property can be used to determine if
        ''' this is a "Resume", "Resume Next" or "Resume label" statement.
        ''' </summary>
        ''' <param name="resumeKeyword">
        ''' The "Resume" keyword.
        ''' </param>
        ''' <param name="label">
        ''' The label. The value of this depends on the Kind. If Kind=Resume, returns
        ''' Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel,
        ''' wraps an Identifier or IntegerLiteralToken with the label or line number.
        ''' </param>
        Friend Function ResumeNextStatement(resumeKeyword As KeywordSyntax, label As LabelSyntax) As ResumeStatementSyntax
            Debug.Assert(resumeKeyword IsNot Nothing AndAlso resumeKeyword.Kind = SyntaxKind.ResumeKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ResumeNextStatement, resumeKeyword, label, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ResumeStatementSyntax)
            End If

            Dim result = New ResumeStatementSyntax(SyntaxKind.ResumeNextStatement, resumeKeyword, label, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Select Case block, including the Select Case that begins it, the
        ''' contains Case blocks and the End Select.
        ''' </summary>
        ''' <param name="selectStatement">
        ''' The Select Case statement that begins the block.
        ''' </param>
        ''' <param name="caseBlocks">
        ''' A list of the contained Case blocks.
        ''' </param>
        ''' <param name="endSelectStatement">
        ''' The End Select statement that ends the block.
        ''' </param>
        Friend Function SelectBlock(selectStatement As SelectStatementSyntax, caseBlocks As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endSelectStatement As EndBlockStatementSyntax) As SelectBlockSyntax
            Debug.Assert(selectStatement IsNot Nothing)
            Debug.Assert(endSelectStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.SelectBlock, selectStatement, caseBlocks.Node, endSelectStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SelectBlockSyntax)
            End If

            Dim result = New SelectBlockSyntax(SyntaxKind.SelectBlock, selectStatement, caseBlocks.Node, endSelectStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Select Case statement. This statement always occurs as the Begin
        ''' of a SelectBlock.
        ''' </summary>
        ''' <param name="selectKeyword">
        ''' The "Select" keyword.
        ''' </param>
        ''' <param name="caseKeyword">
        ''' The "Case" keyword, if present.
        ''' </param>
        ''' <param name="expression">
        ''' The value that branching is based on.
        ''' </param>
        Friend Function SelectStatement(selectKeyword As KeywordSyntax, caseKeyword As KeywordSyntax, expression As ExpressionSyntax) As SelectStatementSyntax
            Debug.Assert(selectKeyword IsNot Nothing AndAlso selectKeyword.Kind = SyntaxKind.SelectKeyword)
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.SelectStatement, selectKeyword, caseKeyword, expression, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SelectStatementSyntax)
            End If

            Dim result = New SelectStatementSyntax(SyntaxKind.SelectStatement, selectKeyword, caseKeyword, expression, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a case statement and its subsequent block.
        ''' </summary>
        ''' <param name="caseStatement">
        ''' The statement that begins the case block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the case block. This might be an empty list.
        ''' </param>
        Friend Function CaseBlock(caseStatement As CaseStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As CaseBlockSyntax
            Debug.Assert(caseStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.CaseBlock, caseStatement, statements.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CaseBlockSyntax)
            End If

            Dim result = New CaseBlockSyntax(SyntaxKind.CaseBlock, caseStatement, statements.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a case statement and its subsequent block.
        ''' </summary>
        ''' <param name="caseStatement">
        ''' The statement that begins the case block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the case block. This might be an empty list.
        ''' </param>
        Friend Function CaseElseBlock(caseStatement As CaseStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As CaseBlockSyntax
            Debug.Assert(caseStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.CaseElseBlock, caseStatement, statements.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CaseBlockSyntax)
            End If

            Dim result = New CaseBlockSyntax(SyntaxKind.CaseElseBlock, caseStatement, statements.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Case or Case Else statement. This statement is always the Begin of
        ''' a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
        ''' Kind=Case.
        ''' </summary>
        ''' <param name="caseKeyword">
        ''' The "Case" keyword
        ''' </param>
        ''' <param name="cases">
        ''' A list of clauses associated with this Case. If Kind=CaseElse, then this list
        ''' has exactly one child, which is a ElseCaseClause.
        ''' </param>
        Friend Function CaseStatement(caseKeyword As KeywordSyntax, cases As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As CaseStatementSyntax
            Debug.Assert(caseKeyword IsNot Nothing AndAlso caseKeyword.Kind = SyntaxKind.CaseKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.CaseStatement, caseKeyword, cases.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CaseStatementSyntax)
            End If

            Dim result = New CaseStatementSyntax(SyntaxKind.CaseStatement, caseKeyword, cases.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Case or Case Else statement. This statement is always the Begin of
        ''' a CaseBlock. If this is a Case Else statement, the Kind=CaseElse, otherwise the
        ''' Kind=Case.
        ''' </summary>
        ''' <param name="caseKeyword">
        ''' The "Case" keyword
        ''' </param>
        ''' <param name="cases">
        ''' A list of clauses associated with this Case. If Kind=CaseElse, then this list
        ''' has exactly one child, which is a ElseCaseClause.
        ''' </param>
        Friend Function CaseElseStatement(caseKeyword As KeywordSyntax, cases As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As CaseStatementSyntax
            Debug.Assert(caseKeyword IsNot Nothing AndAlso caseKeyword.Kind = SyntaxKind.CaseKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.CaseElseStatement, caseKeyword, cases.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CaseStatementSyntax)
            End If

            Dim result = New CaseStatementSyntax(SyntaxKind.CaseElseStatement, caseKeyword, cases.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The "Else" part in a Case Else statement.
        ''' </summary>
        ''' <param name="elseKeyword">
        ''' The "Else" keyword.
        ''' </param>
        Friend Function ElseCaseClause(elseKeyword As KeywordSyntax) As ElseCaseClauseSyntax
            Debug.Assert(elseKeyword IsNot Nothing AndAlso elseKeyword.Kind = SyntaxKind.ElseKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ElseCaseClause, elseKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ElseCaseClauseSyntax)
            End If

            Dim result = New ElseCaseClauseSyntax(SyntaxKind.ElseCaseClause, elseKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a single value in a Case.
        ''' </summary>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Function SimpleCaseClause(value As ExpressionSyntax) As SimpleCaseClauseSyntax
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.SimpleCaseClause, value, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SimpleCaseClauseSyntax)
            End If

            Dim result = New SimpleCaseClauseSyntax(SyntaxKind.SimpleCaseClause, value, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a range "expression To expression" in a Case.
        ''' </summary>
        ''' <param name="lowerBound">
        ''' The lower bound of the range.
        ''' </param>
        ''' <param name="toKeyword">
        ''' The "To" keyword
        ''' </param>
        ''' <param name="upperBound">
        ''' The upper bound of the range.
        ''' </param>
        Friend Function RangeCaseClause(lowerBound As ExpressionSyntax, toKeyword As KeywordSyntax, upperBound As ExpressionSyntax) As RangeCaseClauseSyntax
            Debug.Assert(lowerBound IsNot Nothing)
            Debug.Assert(toKeyword IsNot Nothing AndAlso toKeyword.Kind = SyntaxKind.ToKeyword)
            Debug.Assert(upperBound IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.RangeCaseClause, lowerBound, toKeyword, upperBound, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, RangeCaseClauseSyntax)
            End If

            Dim result = New RangeCaseClauseSyntax(SyntaxKind.RangeCaseClause, lowerBound, toKeyword, upperBound, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a relation clause in a Case statement, such as "Is &gt; expression".
        ''' </summary>
        ''' <param name="isKeyword">
        ''' The "Is" keyword, if present.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
        ''' "&gt;=".
        ''' </param>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Function CaseEqualsClause(isKeyword As KeywordSyntax, operatorToken As PunctuationSyntax, value As ExpressionSyntax) As RelationalCaseClauseSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.CaseEqualsClause, isKeyword, operatorToken, value, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, RelationalCaseClauseSyntax)
            End If

            Dim result = New RelationalCaseClauseSyntax(SyntaxKind.CaseEqualsClause, isKeyword, operatorToken, value, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a relation clause in a Case statement, such as "Is &gt; expression".
        ''' </summary>
        ''' <param name="isKeyword">
        ''' The "Is" keyword, if present.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
        ''' "&gt;=".
        ''' </param>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Function CaseNotEqualsClause(isKeyword As KeywordSyntax, operatorToken As PunctuationSyntax, value As ExpressionSyntax) As RelationalCaseClauseSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LessThanGreaterThanToken)
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.CaseNotEqualsClause, isKeyword, operatorToken, value, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, RelationalCaseClauseSyntax)
            End If

            Dim result = New RelationalCaseClauseSyntax(SyntaxKind.CaseNotEqualsClause, isKeyword, operatorToken, value, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a relation clause in a Case statement, such as "Is &gt; expression".
        ''' </summary>
        ''' <param name="isKeyword">
        ''' The "Is" keyword, if present.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
        ''' "&gt;=".
        ''' </param>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Function CaseLessThanClause(isKeyword As KeywordSyntax, operatorToken As PunctuationSyntax, value As ExpressionSyntax) As RelationalCaseClauseSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LessThanToken)
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.CaseLessThanClause, isKeyword, operatorToken, value, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, RelationalCaseClauseSyntax)
            End If

            Dim result = New RelationalCaseClauseSyntax(SyntaxKind.CaseLessThanClause, isKeyword, operatorToken, value, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a relation clause in a Case statement, such as "Is &gt; expression".
        ''' </summary>
        ''' <param name="isKeyword">
        ''' The "Is" keyword, if present.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
        ''' "&gt;=".
        ''' </param>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Function CaseLessThanOrEqualClause(isKeyword As KeywordSyntax, operatorToken As PunctuationSyntax, value As ExpressionSyntax) As RelationalCaseClauseSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LessThanEqualsToken)
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.CaseLessThanOrEqualClause, isKeyword, operatorToken, value, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, RelationalCaseClauseSyntax)
            End If

            Dim result = New RelationalCaseClauseSyntax(SyntaxKind.CaseLessThanOrEqualClause, isKeyword, operatorToken, value, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a relation clause in a Case statement, such as "Is &gt; expression".
        ''' </summary>
        ''' <param name="isKeyword">
        ''' The "Is" keyword, if present.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
        ''' "&gt;=".
        ''' </param>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Function CaseGreaterThanOrEqualClause(isKeyword As KeywordSyntax, operatorToken As PunctuationSyntax, value As ExpressionSyntax) As RelationalCaseClauseSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.GreaterThanEqualsToken)
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.CaseGreaterThanOrEqualClause, isKeyword, operatorToken, value, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, RelationalCaseClauseSyntax)
            End If

            Dim result = New RelationalCaseClauseSyntax(SyntaxKind.CaseGreaterThanOrEqualClause, isKeyword, operatorToken, value, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a relation clause in a Case statement, such as "Is &gt; expression".
        ''' </summary>
        ''' <param name="isKeyword">
        ''' The "Is" keyword, if present.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
        ''' "&gt;=".
        ''' </param>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Function CaseGreaterThanClause(isKeyword As KeywordSyntax, operatorToken As PunctuationSyntax, value As ExpressionSyntax) As RelationalCaseClauseSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.GreaterThanToken)
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.CaseGreaterThanClause, isKeyword, operatorToken, value, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, RelationalCaseClauseSyntax)
            End If

            Dim result = New RelationalCaseClauseSyntax(SyntaxKind.CaseGreaterThanClause, isKeyword, operatorToken, value, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a relation clause in a Case statement, such as "Is &gt; expression".
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' RelationalCaseClauseSyntax. One of CaseEqualsClause, CaseNotEqualsClause,
        ''' CaseLessThanClause, CaseLessThanOrEqualClause, CaseGreaterThanOrEqualClause,
        ''' CaseGreaterThanClause.
        ''' </param>
        ''' <param name="isKeyword">
        ''' The "Is" keyword, if present.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or
        ''' "&gt;=".
        ''' </param>
        ''' <param name="value">
        ''' The expression that denotes the value being tested against.
        ''' </param>
        Friend Function RelationalCaseClause(kind As SyntaxKind, isKeyword As KeywordSyntax, operatorToken As PunctuationSyntax, value As ExpressionSyntax) As RelationalCaseClauseSyntax
            Debug.Assert(SyntaxFacts.IsRelationalCaseClause(kind))
            Debug.Assert(operatorToken IsNot Nothing AndAlso SyntaxFacts.IsRelationalCaseClauseOperatorToken(operatorToken.Kind))
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(kind, isKeyword, operatorToken, value, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, RelationalCaseClauseSyntax)
            End If

            Dim result = New RelationalCaseClauseSyntax(kind, isKeyword, operatorToken, value, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the "SyncLock" statement. This statement always occurs as the Begin
        ''' of a SyncLockBlock.
        ''' </summary>
        ''' <param name="syncLockKeyword">
        ''' The "SyncLock" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being synchronized on.
        ''' </param>
        Friend Function SyncLockStatement(syncLockKeyword As KeywordSyntax, expression As ExpressionSyntax) As SyncLockStatementSyntax
            Debug.Assert(syncLockKeyword IsNot Nothing AndAlso syncLockKeyword.Kind = SyntaxKind.SyncLockKeyword)
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.SyncLockStatement, syncLockKeyword, expression, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SyncLockStatementSyntax)
            End If

            Dim result = New SyncLockStatementSyntax(SyntaxKind.SyncLockStatement, syncLockKeyword, expression, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Do-Loop block. The Kind property can be used to determine if this
        ''' is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
        ''' </summary>
        ''' <param name="doStatement">
        ''' The Do statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="loopStatement">
        ''' The Loop statement that ends the block.
        ''' </param>
        Friend Function SimpleDoLoopBlock(doStatement As DoStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), loopStatement As LoopStatementSyntax) As DoLoopBlockSyntax
            Debug.Assert(doStatement IsNot Nothing)
            Debug.Assert(loopStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.SimpleDoLoopBlock, doStatement, statements.Node, loopStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, DoLoopBlockSyntax)
            End If

            Dim result = New DoLoopBlockSyntax(SyntaxKind.SimpleDoLoopBlock, doStatement, statements.Node, loopStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Do-Loop block. The Kind property can be used to determine if this
        ''' is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
        ''' </summary>
        ''' <param name="doStatement">
        ''' The Do statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="loopStatement">
        ''' The Loop statement that ends the block.
        ''' </param>
        Friend Function DoWhileLoopBlock(doStatement As DoStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), loopStatement As LoopStatementSyntax) As DoLoopBlockSyntax
            Debug.Assert(doStatement IsNot Nothing)
            Debug.Assert(loopStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.DoWhileLoopBlock, doStatement, statements.Node, loopStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, DoLoopBlockSyntax)
            End If

            Dim result = New DoLoopBlockSyntax(SyntaxKind.DoWhileLoopBlock, doStatement, statements.Node, loopStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Do-Loop block. The Kind property can be used to determine if this
        ''' is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
        ''' </summary>
        ''' <param name="doStatement">
        ''' The Do statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="loopStatement">
        ''' The Loop statement that ends the block.
        ''' </param>
        Friend Function DoUntilLoopBlock(doStatement As DoStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), loopStatement As LoopStatementSyntax) As DoLoopBlockSyntax
            Debug.Assert(doStatement IsNot Nothing)
            Debug.Assert(loopStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.DoUntilLoopBlock, doStatement, statements.Node, loopStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, DoLoopBlockSyntax)
            End If

            Dim result = New DoLoopBlockSyntax(SyntaxKind.DoUntilLoopBlock, doStatement, statements.Node, loopStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Do-Loop block. The Kind property can be used to determine if this
        ''' is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
        ''' </summary>
        ''' <param name="doStatement">
        ''' The Do statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="loopStatement">
        ''' The Loop statement that ends the block.
        ''' </param>
        Friend Function DoLoopWhileBlock(doStatement As DoStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), loopStatement As LoopStatementSyntax) As DoLoopBlockSyntax
            Debug.Assert(doStatement IsNot Nothing)
            Debug.Assert(loopStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.DoLoopWhileBlock, doStatement, statements.Node, loopStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, DoLoopBlockSyntax)
            End If

            Dim result = New DoLoopBlockSyntax(SyntaxKind.DoLoopWhileBlock, doStatement, statements.Node, loopStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Do-Loop block. The Kind property can be used to determine if this
        ''' is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
        ''' </summary>
        ''' <param name="doStatement">
        ''' The Do statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="loopStatement">
        ''' The Loop statement that ends the block.
        ''' </param>
        Friend Function DoLoopUntilBlock(doStatement As DoStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), loopStatement As LoopStatementSyntax) As DoLoopBlockSyntax
            Debug.Assert(doStatement IsNot Nothing)
            Debug.Assert(loopStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.DoLoopUntilBlock, doStatement, statements.Node, loopStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, DoLoopBlockSyntax)
            End If

            Dim result = New DoLoopBlockSyntax(SyntaxKind.DoLoopUntilBlock, doStatement, statements.Node, loopStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Do-Loop block. The Kind property can be used to determine if this
        ''' is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of DoLoopBlockSyntax.
        ''' One of SimpleDoLoopBlock, DoWhileLoopBlock, DoUntilLoopBlock, DoLoopWhileBlock,
        ''' DoLoopUntilBlock.
        ''' </param>
        ''' <param name="doStatement">
        ''' The Do statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the block statement. This might be an empty list.
        ''' </param>
        ''' <param name="loopStatement">
        ''' The Loop statement that ends the block.
        ''' </param>
        Friend Function DoLoopBlock(kind As SyntaxKind, doStatement As DoStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), loopStatement As LoopStatementSyntax) As DoLoopBlockSyntax
            Debug.Assert(SyntaxFacts.IsDoLoopBlock(kind))
            Debug.Assert(doStatement IsNot Nothing)
            Debug.Assert(loopStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(kind, doStatement, statements.Node, loopStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, DoLoopBlockSyntax)
            End If

            Dim result = New DoLoopBlockSyntax(kind, doStatement, statements.Node, loopStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The Do statement that begins a Do-Loop block.
        ''' </summary>
        ''' <param name="doKeyword">
        ''' The "Do" keyword.
        ''' </param>
        ''' <param name="whileOrUntilClause">
        ''' The "While expression" or "Until expression" clause of the Do statement, if
        ''' present.
        ''' </param>
        Friend Function SimpleDoStatement(doKeyword As KeywordSyntax, whileOrUntilClause As WhileOrUntilClauseSyntax) As DoStatementSyntax
            Debug.Assert(doKeyword IsNot Nothing AndAlso doKeyword.Kind = SyntaxKind.DoKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.SimpleDoStatement, doKeyword, whileOrUntilClause, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, DoStatementSyntax)
            End If

            Dim result = New DoStatementSyntax(SyntaxKind.SimpleDoStatement, doKeyword, whileOrUntilClause, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The Do statement that begins a Do-Loop block.
        ''' </summary>
        ''' <param name="doKeyword">
        ''' The "Do" keyword.
        ''' </param>
        ''' <param name="whileOrUntilClause">
        ''' The "While expression" or "Until expression" clause of the Do statement, if
        ''' present.
        ''' </param>
        Friend Function DoWhileStatement(doKeyword As KeywordSyntax, whileOrUntilClause As WhileOrUntilClauseSyntax) As DoStatementSyntax
            Debug.Assert(doKeyword IsNot Nothing AndAlso doKeyword.Kind = SyntaxKind.DoKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.DoWhileStatement, doKeyword, whileOrUntilClause, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, DoStatementSyntax)
            End If

            Dim result = New DoStatementSyntax(SyntaxKind.DoWhileStatement, doKeyword, whileOrUntilClause, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The Do statement that begins a Do-Loop block.
        ''' </summary>
        ''' <param name="doKeyword">
        ''' The "Do" keyword.
        ''' </param>
        ''' <param name="whileOrUntilClause">
        ''' The "While expression" or "Until expression" clause of the Do statement, if
        ''' present.
        ''' </param>
        Friend Function DoUntilStatement(doKeyword As KeywordSyntax, whileOrUntilClause As WhileOrUntilClauseSyntax) As DoStatementSyntax
            Debug.Assert(doKeyword IsNot Nothing AndAlso doKeyword.Kind = SyntaxKind.DoKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.DoUntilStatement, doKeyword, whileOrUntilClause, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, DoStatementSyntax)
            End If

            Dim result = New DoStatementSyntax(SyntaxKind.DoUntilStatement, doKeyword, whileOrUntilClause, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The Do statement that begins a Do-Loop block.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of DoStatementSyntax.
        ''' One of SimpleDoStatement, DoWhileStatement, DoUntilStatement.
        ''' </param>
        ''' <param name="doKeyword">
        ''' The "Do" keyword.
        ''' </param>
        ''' <param name="whileOrUntilClause">
        ''' The "While expression" or "Until expression" clause of the Do statement, if
        ''' present.
        ''' </param>
        Friend Function DoStatement(kind As SyntaxKind, doKeyword As KeywordSyntax, whileOrUntilClause As WhileOrUntilClauseSyntax) As DoStatementSyntax
            Debug.Assert(SyntaxFacts.IsDoStatement(kind))
            Debug.Assert(doKeyword IsNot Nothing AndAlso doKeyword.Kind = SyntaxKind.DoKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(kind, doKeyword, whileOrUntilClause, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, DoStatementSyntax)
            End If

            Dim result = New DoStatementSyntax(kind, doKeyword, whileOrUntilClause, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The Loop statement that begins a Do-Loop block.
        ''' </summary>
        ''' <param name="loopKeyword">
        ''' The "Loop" keyword.
        ''' </param>
        ''' <param name="whileOrUntilClause">
        ''' The "While expression" or "Until expression" clause of the Loop statement, if
        ''' present.
        ''' </param>
        Friend Function SimpleLoopStatement(loopKeyword As KeywordSyntax, whileOrUntilClause As WhileOrUntilClauseSyntax) As LoopStatementSyntax
            Debug.Assert(loopKeyword IsNot Nothing AndAlso loopKeyword.Kind = SyntaxKind.LoopKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.SimpleLoopStatement, loopKeyword, whileOrUntilClause, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LoopStatementSyntax)
            End If

            Dim result = New LoopStatementSyntax(SyntaxKind.SimpleLoopStatement, loopKeyword, whileOrUntilClause, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The Loop statement that begins a Do-Loop block.
        ''' </summary>
        ''' <param name="loopKeyword">
        ''' The "Loop" keyword.
        ''' </param>
        ''' <param name="whileOrUntilClause">
        ''' The "While expression" or "Until expression" clause of the Loop statement, if
        ''' present.
        ''' </param>
        Friend Function LoopWhileStatement(loopKeyword As KeywordSyntax, whileOrUntilClause As WhileOrUntilClauseSyntax) As LoopStatementSyntax
            Debug.Assert(loopKeyword IsNot Nothing AndAlso loopKeyword.Kind = SyntaxKind.LoopKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.LoopWhileStatement, loopKeyword, whileOrUntilClause, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LoopStatementSyntax)
            End If

            Dim result = New LoopStatementSyntax(SyntaxKind.LoopWhileStatement, loopKeyword, whileOrUntilClause, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The Loop statement that begins a Do-Loop block.
        ''' </summary>
        ''' <param name="loopKeyword">
        ''' The "Loop" keyword.
        ''' </param>
        ''' <param name="whileOrUntilClause">
        ''' The "While expression" or "Until expression" clause of the Loop statement, if
        ''' present.
        ''' </param>
        Friend Function LoopUntilStatement(loopKeyword As KeywordSyntax, whileOrUntilClause As WhileOrUntilClauseSyntax) As LoopStatementSyntax
            Debug.Assert(loopKeyword IsNot Nothing AndAlso loopKeyword.Kind = SyntaxKind.LoopKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.LoopUntilStatement, loopKeyword, whileOrUntilClause, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LoopStatementSyntax)
            End If

            Dim result = New LoopStatementSyntax(SyntaxKind.LoopUntilStatement, loopKeyword, whileOrUntilClause, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The Loop statement that begins a Do-Loop block.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' LoopStatementSyntax. One of SimpleLoopStatement, LoopWhileStatement,
        ''' LoopUntilStatement.
        ''' </param>
        ''' <param name="loopKeyword">
        ''' The "Loop" keyword.
        ''' </param>
        ''' <param name="whileOrUntilClause">
        ''' The "While expression" or "Until expression" clause of the Loop statement, if
        ''' present.
        ''' </param>
        Friend Function LoopStatement(kind As SyntaxKind, loopKeyword As KeywordSyntax, whileOrUntilClause As WhileOrUntilClauseSyntax) As LoopStatementSyntax
            Debug.Assert(SyntaxFacts.IsLoopStatement(kind))
            Debug.Assert(loopKeyword IsNot Nothing AndAlso loopKeyword.Kind = SyntaxKind.LoopKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(kind, loopKeyword, whileOrUntilClause, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LoopStatementSyntax)
            End If

            Dim result = New LoopStatementSyntax(kind, loopKeyword, whileOrUntilClause, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "While expression" or "Until expression" in a Do or Loop
        ''' statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
        ''' indicate which kind of clause.
        ''' </summary>
        ''' <param name="whileOrUntilKeyword">
        ''' The "While" or "Until" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression after the While or Until.
        ''' </param>
        Friend Function WhileClause(whileOrUntilKeyword As KeywordSyntax, condition As ExpressionSyntax) As WhileOrUntilClauseSyntax
            Debug.Assert(whileOrUntilKeyword IsNot Nothing AndAlso whileOrUntilKeyword.Kind = SyntaxKind.WhileKeyword)
            Debug.Assert(condition IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.WhileClause, whileOrUntilKeyword, condition, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, WhileOrUntilClauseSyntax)
            End If

            Dim result = New WhileOrUntilClauseSyntax(SyntaxKind.WhileClause, whileOrUntilKeyword, condition, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "While expression" or "Until expression" in a Do or Loop
        ''' statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
        ''' indicate which kind of clause.
        ''' </summary>
        ''' <param name="whileOrUntilKeyword">
        ''' The "While" or "Until" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression after the While or Until.
        ''' </param>
        Friend Function UntilClause(whileOrUntilKeyword As KeywordSyntax, condition As ExpressionSyntax) As WhileOrUntilClauseSyntax
            Debug.Assert(whileOrUntilKeyword IsNot Nothing AndAlso whileOrUntilKeyword.Kind = SyntaxKind.UntilKeyword)
            Debug.Assert(condition IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.UntilClause, whileOrUntilKeyword, condition, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, WhileOrUntilClauseSyntax)
            End If

            Dim result = New WhileOrUntilClauseSyntax(SyntaxKind.UntilClause, whileOrUntilKeyword, condition, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "While expression" or "Until expression" in a Do or Loop
        ''' statement. The Kind of the clause can be "WhileClause" or "UntilClause" to
        ''' indicate which kind of clause.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' WhileOrUntilClauseSyntax. One of WhileClause, UntilClause.
        ''' </param>
        ''' <param name="whileOrUntilKeyword">
        ''' The "While" or "Until" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression after the While or Until.
        ''' </param>
        Friend Function WhileOrUntilClause(kind As SyntaxKind, whileOrUntilKeyword As KeywordSyntax, condition As ExpressionSyntax) As WhileOrUntilClauseSyntax
            Debug.Assert(SyntaxFacts.IsWhileOrUntilClause(kind))
            Debug.Assert(whileOrUntilKeyword IsNot Nothing AndAlso SyntaxFacts.IsWhileOrUntilClauseWhileOrUntilKeyword(whileOrUntilKeyword.Kind))
            Debug.Assert(condition IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(kind, whileOrUntilKeyword, condition, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, WhileOrUntilClauseSyntax)
            End If

            Dim result = New WhileOrUntilClauseSyntax(kind, whileOrUntilKeyword, condition, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The While statement that begins a While...End While block. This statement
        ''' always occurs as the Begin of a WhileBlock.
        ''' </summary>
        ''' <param name="whileKeyword">
        ''' The "While" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression that controls the While loop.
        ''' </param>
        Friend Function WhileStatement(whileKeyword As KeywordSyntax, condition As ExpressionSyntax) As WhileStatementSyntax
            Debug.Assert(whileKeyword IsNot Nothing AndAlso whileKeyword.Kind = SyntaxKind.WhileKeyword)
            Debug.Assert(condition IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.WhileStatement, whileKeyword, condition, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, WhileStatementSyntax)
            End If

            Dim result = New WhileStatementSyntax(SyntaxKind.WhileStatement, whileKeyword, condition, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a For block, including the introducing statement, the body and the
        ''' "Next" (which can be omitted if a containing For has a Next with multiple
        ''' variables).
        ''' </summary>
        ''' <param name="forStatement">
        ''' The For statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the For or For Each loop. This might be an empty
        ''' list.
        ''' </param>
        ''' <param name="nextStatement">
        ''' The Next statement that ends the block. If two For or For Each statements are
        ''' ended by a single Next statement, the inner For will not have a Next statement.
        ''' </param>
        Friend Function ForBlock(forStatement As ForStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), nextStatement As NextStatementSyntax) As ForBlockSyntax
            Debug.Assert(forStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ForBlock, forStatement, statements.Node, nextStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ForBlockSyntax)
            End If

            Dim result = New ForBlockSyntax(SyntaxKind.ForBlock, forStatement, statements.Node, nextStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a For Each block, including the introducing statement, the body and
        ''' the "Next" (which can be omitted if a containing For has a Next with multiple
        ''' variables).
        ''' </summary>
        ''' <param name="forEachStatement">
        ''' The For Each statement that begins the block.
        ''' </param>
        ''' <param name="statements">
        ''' The statements contained in the For or For Each loop. This might be an empty
        ''' list.
        ''' </param>
        ''' <param name="nextStatement">
        ''' The Next statement that ends the block. If two For or For Each statements are
        ''' ended by a single Next statement, the inner For will not have a Next statement.
        ''' </param>
        Friend Function ForEachBlock(forEachStatement As ForEachStatementSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), nextStatement As NextStatementSyntax) As ForEachBlockSyntax
            Debug.Assert(forEachStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ForEachBlock, forEachStatement, statements.Node, nextStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ForEachBlockSyntax)
            End If

            Dim result = New ForEachBlockSyntax(SyntaxKind.ForEachBlock, forEachStatement, statements.Node, nextStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The For statement that begins a For-Next block. This statement always occurs as
        ''' the Begin of a ForBlock. Most of the time, the End of that ForBlock is the
        ''' corresponding Next statement. However, multiple nested For statements are ended
        ''' by a single Next statement with multiple variables, then the inner For
        ''' statements will have End set to Nothing, and the Next statement is the End of
        ''' the outermost For statement that is being ended.
        ''' </summary>
        ''' <param name="forKeyword">
        ''' The "For" keyword.
        ''' </param>
        ''' <param name="controlVariable">
        ''' If the For or For Each statement is of a form that does not declare a new loop
        ''' control variable, this is the expression that denotes the loop control
        ''' variable. If this loop is of a form that does declare a new control variable,
        ''' this is a VariableDeclarator that has the variable being declared.
        ''' </param>
        ''' <param name="equalsToken">
        ''' The "=" token.
        ''' </param>
        ''' <param name="fromValue">
        ''' The expression denoting the initial value of the iteration.
        ''' </param>
        ''' <param name="toKeyword">
        ''' The "To" keyword.
        ''' </param>
        ''' <param name="toValue">
        ''' The expression denoting the final value of the iteration.
        ''' </param>
        ''' <param name="stepClause">
        ''' The optional Step clause.
        ''' </param>
        Friend Function ForStatement(forKeyword As KeywordSyntax, controlVariable As VisualBasicSyntaxNode, equalsToken As PunctuationSyntax, fromValue As ExpressionSyntax, toKeyword As KeywordSyntax, toValue As ExpressionSyntax, stepClause As ForStepClauseSyntax) As ForStatementSyntax
            Debug.Assert(forKeyword IsNot Nothing AndAlso forKeyword.Kind = SyntaxKind.ForKeyword)
            Debug.Assert(controlVariable IsNot Nothing)
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(fromValue IsNot Nothing)
            Debug.Assert(toKeyword IsNot Nothing AndAlso toKeyword.Kind = SyntaxKind.ToKeyword)
            Debug.Assert(toValue IsNot Nothing)
            Return New ForStatementSyntax(SyntaxKind.ForStatement, forKeyword, controlVariable, equalsToken, fromValue, toKeyword, toValue, stepClause, _factoryContext)
        End Function


        ''' <summary>
        ''' The Step clause in a For Statement.
        ''' </summary>
        ''' <param name="stepKeyword">
        ''' The "Step" keyword.
        ''' </param>
        ''' <param name="stepValue">
        ''' The expression denoting the step increment.
        ''' </param>
        Friend Function ForStepClause(stepKeyword As KeywordSyntax, stepValue As ExpressionSyntax) As ForStepClauseSyntax
            Debug.Assert(stepKeyword IsNot Nothing AndAlso stepKeyword.Kind = SyntaxKind.StepKeyword)
            Debug.Assert(stepValue IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ForStepClause, stepKeyword, stepValue, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ForStepClauseSyntax)
            End If

            Dim result = New ForStepClauseSyntax(SyntaxKind.ForStepClause, stepKeyword, stepValue, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The For Each statement that begins a For Each-Next block. This statement always
        ''' occurs as the Begin of a ForBlock, and the body of the For Each-Next is the
        ''' Body of that ForBlock. Most of the time, the End of that ForBlock is the
        ''' corresponding Next statement. However, multiple nested For statements are ended
        ''' by a single Next statement with multiple variables, then the inner For
        ''' statements will have End set to Nothing, and the Next statement is the End of
        ''' the outermost For statement that is being ended.
        ''' </summary>
        ''' <param name="forKeyword">
        ''' The "For" keyword.
        ''' </param>
        ''' <param name="eachKeyword">
        ''' The "Each" keyword.
        ''' </param>
        ''' <param name="controlVariable">
        ''' If the For or For Each statement is of a form that does not declare a new loop
        ''' control variable, this is the expression that denotes the loop control
        ''' variable. If this loop is of a form that does declare a new control variable,
        ''' this is a VariableDeclarator that has the variable being declared.
        ''' </param>
        ''' <param name="inKeyword">
        ''' The "In" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression denoting the collection to iterate over.
        ''' </param>
        Friend Function ForEachStatement(forKeyword As KeywordSyntax, eachKeyword As KeywordSyntax, controlVariable As VisualBasicSyntaxNode, inKeyword As KeywordSyntax, expression As ExpressionSyntax) As ForEachStatementSyntax
            Debug.Assert(forKeyword IsNot Nothing AndAlso forKeyword.Kind = SyntaxKind.ForKeyword)
            Debug.Assert(eachKeyword IsNot Nothing AndAlso eachKeyword.Kind = SyntaxKind.EachKeyword)
            Debug.Assert(controlVariable IsNot Nothing)
            Debug.Assert(inKeyword IsNot Nothing AndAlso inKeyword.Kind = SyntaxKind.InKeyword)
            Debug.Assert(expression IsNot Nothing)
            Return New ForEachStatementSyntax(SyntaxKind.ForEachStatement, forKeyword, eachKeyword, controlVariable, inKeyword, expression, _factoryContext)
        End Function


        ''' <summary>
        ''' The Next statement that ends a For-Next or For Each-Next block. This statement
        ''' always occurs as the End of a ForBlock (with Kind=ForBlock or ForEachBlock),
        ''' and the body of the For-Next is the Body of that ForBlock. The Begin of that
        ''' ForBlock has the corresponding For or For Each statement.
        ''' </summary>
        ''' <param name="nextKeyword">
        ''' The "Next" keyword.
        ''' </param>
        ''' <param name="controlVariables">
        ''' The variables in the Next statement, if present
        ''' </param>
        Friend Function NextStatement(nextKeyword As KeywordSyntax, controlVariables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As NextStatementSyntax
            Debug.Assert(nextKeyword IsNot Nothing AndAlso nextKeyword.Kind = SyntaxKind.NextKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.NextStatement, nextKeyword, controlVariables.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, NextStatementSyntax)
            End If

            Dim result = New NextStatementSyntax(SyntaxKind.NextStatement, nextKeyword, controlVariables.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' The Using statement that begins a Using block. This statement always occurs as
        ''' the Begin of a UsingBlock, and the body of the Using is the Body of that
        ''' UsingBlock.
        ''' </summary>
        ''' <param name="usingKeyword">
        ''' The "Using" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' If the Using statement is of a form that does not declare a new variable, this
        ''' is the expression used in the using. Otherwise, Nothing is returned.
        ''' </param>
        ''' <param name="variables">
        ''' If the Using statement is of a form that declares one or more new variables,
        ''' this is the list of variable declarations. Otherwise, Nothing is returned.
        ''' </param>
        Friend Function UsingStatement(usingKeyword As KeywordSyntax, expression As ExpressionSyntax, variables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As UsingStatementSyntax
            Debug.Assert(usingKeyword IsNot Nothing AndAlso usingKeyword.Kind = SyntaxKind.UsingKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.UsingStatement, usingKeyword, expression, variables.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, UsingStatementSyntax)
            End If

            Dim result = New UsingStatementSyntax(SyntaxKind.UsingStatement, usingKeyword, expression, variables.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Throw statement.
        ''' </summary>
        ''' <param name="throwKeyword">
        ''' The "Throw" keyword
        ''' </param>
        ''' <param name="expression">
        ''' The expression denoting the value being thrown.
        ''' </param>
        Friend Function ThrowStatement(throwKeyword As KeywordSyntax, expression As ExpressionSyntax) As ThrowStatementSyntax
            Debug.Assert(throwKeyword IsNot Nothing AndAlso throwKeyword.Kind = SyntaxKind.ThrowKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ThrowStatement, throwKeyword, expression, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ThrowStatementSyntax)
            End If

            Dim result = New ThrowStatementSyntax(SyntaxKind.ThrowStatement, throwKeyword, expression, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Function SimpleAssignmentStatement(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.SimpleAssignmentStatement, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(SyntaxKind.SimpleAssignmentStatement, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Function MidAssignmentStatement(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.MidAssignmentStatement, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(SyntaxKind.MidAssignmentStatement, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Function AddAssignmentStatement(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.PlusEqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.AddAssignmentStatement, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(SyntaxKind.AddAssignmentStatement, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Function SubtractAssignmentStatement(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.MinusEqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.SubtractAssignmentStatement, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(SyntaxKind.SubtractAssignmentStatement, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Function MultiplyAssignmentStatement(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.AsteriskEqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.MultiplyAssignmentStatement, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(SyntaxKind.MultiplyAssignmentStatement, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Function DivideAssignmentStatement(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.SlashEqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.DivideAssignmentStatement, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(SyntaxKind.DivideAssignmentStatement, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Function IntegerDivideAssignmentStatement(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.BackslashEqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.IntegerDivideAssignmentStatement, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(SyntaxKind.IntegerDivideAssignmentStatement, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Function ExponentiateAssignmentStatement(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.CaretEqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ExponentiateAssignmentStatement, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(SyntaxKind.ExponentiateAssignmentStatement, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Function LeftShiftAssignmentStatement(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LessThanLessThanEqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.LeftShiftAssignmentStatement, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(SyntaxKind.LeftShiftAssignmentStatement, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Function RightShiftAssignmentStatement(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.GreaterThanGreaterThanEqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.RightShiftAssignmentStatement, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(SyntaxKind.RightShiftAssignmentStatement, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Function ConcatenateAssignmentStatement(left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.AmpersandEqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ConcatenateAssignmentStatement, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(SyntaxKind.ConcatenateAssignmentStatement, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple, compound, or Mid assignment statement. Which one can be
        ''' determined by checking the Kind.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' AssignmentStatementSyntax. One of SimpleAssignmentStatement,
        ''' MidAssignmentStatement, AddAssignmentStatement, SubtractAssignmentStatement,
        ''' MultiplyAssignmentStatement, DivideAssignmentStatement,
        ''' IntegerDivideAssignmentStatement, ExponentiateAssignmentStatement,
        ''' LeftShiftAssignmentStatement, RightShiftAssignmentStatement,
        ''' ConcatenateAssignmentStatement.
        ''' </param>
        ''' <param name="left">
        ''' The target (left hand side) of the assignment.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The operator used in the assignment statement. One of "=", "+=", "-=", "*=",
        ''' "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".
        ''' </param>
        ''' <param name="right">
        ''' The source (right hand side) of the assignment.
        ''' </param>
        Friend Function AssignmentStatement(kind As SyntaxKind, left As ExpressionSyntax, operatorToken As PunctuationSyntax, right As ExpressionSyntax) As AssignmentStatementSyntax
            Debug.Assert(SyntaxFacts.IsAssignmentStatement(kind))
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso SyntaxFacts.IsAssignmentStatementOperatorToken(operatorToken.Kind))
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(kind, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AssignmentStatementSyntax)
            End If

            Dim result = New AssignmentStatementSyntax(kind, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a left-hand side of a MidAssignment statement.
        ''' </summary>
        ''' <param name="mid">
        ''' The "Mid" possibly followed by a type character.
        ''' </param>
        ''' <param name="argumentList">
        ''' The argument list.
        ''' </param>
        Friend Function MidExpression(mid As IdentifierTokenSyntax, argumentList As ArgumentListSyntax) As MidExpressionSyntax
            Debug.Assert(mid IsNot Nothing AndAlso mid.Kind = SyntaxKind.IdentifierToken)
            Debug.Assert(argumentList IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.MidExpression, mid, argumentList, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MidExpressionSyntax)
            End If

            Dim result = New MidExpressionSyntax(SyntaxKind.MidExpression, mid, argumentList, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represent a call statement (also known as a invocation statement).
        ''' </summary>
        ''' <param name="callKeyword">
        ''' The "Call" keyword.
        ''' </param>
        ''' <param name="invocation">
        ''' The expression denoting the call. This could be an Invocation or a MemberAccess
        ''' (in the case where no parentheses were supplied.)
        ''' </param>
        Friend Function CallStatement(callKeyword As KeywordSyntax, invocation As ExpressionSyntax) As CallStatementSyntax
            Debug.Assert(callKeyword IsNot Nothing AndAlso callKeyword.Kind = SyntaxKind.CallKeyword)
            Debug.Assert(invocation IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.CallStatement, callKeyword, invocation, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CallStatementSyntax)
            End If

            Dim result = New CallStatementSyntax(SyntaxKind.CallStatement, callKeyword, invocation, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an AddHandler or RemoveHandler statement. The Kind property
        ''' determines which one.
        ''' </summary>
        ''' <param name="addHandlerOrRemoveHandlerKeyword">
        ''' The "AddHandler" or "RemoveHandler" keyword.
        ''' </param>
        ''' <param name="eventExpression">
        ''' The event being accessed.
        ''' </param>
        ''' <param name="commaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="delegateExpression">
        ''' The delegate being added or removed.
        ''' </param>
        Friend Function AddHandlerStatement(addHandlerOrRemoveHandlerKeyword As KeywordSyntax, eventExpression As ExpressionSyntax, commaToken As PunctuationSyntax, delegateExpression As ExpressionSyntax) As AddRemoveHandlerStatementSyntax
            Debug.Assert(addHandlerOrRemoveHandlerKeyword IsNot Nothing AndAlso addHandlerOrRemoveHandlerKeyword.Kind = SyntaxKind.AddHandlerKeyword)
            Debug.Assert(eventExpression IsNot Nothing)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(delegateExpression IsNot Nothing)
            Return New AddRemoveHandlerStatementSyntax(SyntaxKind.AddHandlerStatement, addHandlerOrRemoveHandlerKeyword, eventExpression, commaToken, delegateExpression, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an AddHandler or RemoveHandler statement. The Kind property
        ''' determines which one.
        ''' </summary>
        ''' <param name="addHandlerOrRemoveHandlerKeyword">
        ''' The "AddHandler" or "RemoveHandler" keyword.
        ''' </param>
        ''' <param name="eventExpression">
        ''' The event being accessed.
        ''' </param>
        ''' <param name="commaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="delegateExpression">
        ''' The delegate being added or removed.
        ''' </param>
        Friend Function RemoveHandlerStatement(addHandlerOrRemoveHandlerKeyword As KeywordSyntax, eventExpression As ExpressionSyntax, commaToken As PunctuationSyntax, delegateExpression As ExpressionSyntax) As AddRemoveHandlerStatementSyntax
            Debug.Assert(addHandlerOrRemoveHandlerKeyword IsNot Nothing AndAlso addHandlerOrRemoveHandlerKeyword.Kind = SyntaxKind.RemoveHandlerKeyword)
            Debug.Assert(eventExpression IsNot Nothing)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(delegateExpression IsNot Nothing)
            Return New AddRemoveHandlerStatementSyntax(SyntaxKind.RemoveHandlerStatement, addHandlerOrRemoveHandlerKeyword, eventExpression, commaToken, delegateExpression, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an AddHandler or RemoveHandler statement. The Kind property
        ''' determines which one.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' AddRemoveHandlerStatementSyntax. One of AddHandlerStatement,
        ''' RemoveHandlerStatement.
        ''' </param>
        ''' <param name="addHandlerOrRemoveHandlerKeyword">
        ''' The "AddHandler" or "RemoveHandler" keyword.
        ''' </param>
        ''' <param name="eventExpression">
        ''' The event being accessed.
        ''' </param>
        ''' <param name="commaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="delegateExpression">
        ''' The delegate being added or removed.
        ''' </param>
        Friend Function AddRemoveHandlerStatement(kind As SyntaxKind, addHandlerOrRemoveHandlerKeyword As KeywordSyntax, eventExpression As ExpressionSyntax, commaToken As PunctuationSyntax, delegateExpression As ExpressionSyntax) As AddRemoveHandlerStatementSyntax
            Debug.Assert(SyntaxFacts.IsAddRemoveHandlerStatement(kind))
            Debug.Assert(addHandlerOrRemoveHandlerKeyword IsNot Nothing AndAlso SyntaxFacts.IsAddRemoveHandlerStatementAddHandlerOrRemoveHandlerKeyword(addHandlerOrRemoveHandlerKeyword.Kind))
            Debug.Assert(eventExpression IsNot Nothing)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(delegateExpression IsNot Nothing)
            Return New AddRemoveHandlerStatementSyntax(kind, addHandlerOrRemoveHandlerKeyword, eventExpression, commaToken, delegateExpression, _factoryContext)
        End Function


        ''' <summary>
        ''' Represent a RaiseEvent statement.
        ''' </summary>
        ''' <param name="raiseEventKeyword">
        ''' The "RaiseEvent" keyword
        ''' </param>
        ''' <param name="name">
        ''' The name of the event being raised.
        ''' </param>
        ''' <param name="argumentList">
        ''' The argument list, if present.
        ''' </param>
        Friend Function RaiseEventStatement(raiseEventKeyword As KeywordSyntax, name As IdentifierNameSyntax, argumentList As ArgumentListSyntax) As RaiseEventStatementSyntax
            Debug.Assert(raiseEventKeyword IsNot Nothing AndAlso raiseEventKeyword.Kind = SyntaxKind.RaiseEventKeyword)
            Debug.Assert(name IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.RaiseEventStatement, raiseEventKeyword, name, argumentList, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, RaiseEventStatementSyntax)
            End If

            Dim result = New RaiseEventStatementSyntax(SyntaxKind.RaiseEventStatement, raiseEventKeyword, name, argumentList, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "With" statement. This statement always occurs as the
        ''' BeginStatement of a WithBlock, and the body of the With is the Body of that
        ''' WithBlock.
        ''' </summary>
        ''' <param name="withKeyword">
        ''' The "With" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression that is the operand of the With statement.
        ''' </param>
        Friend Function WithStatement(withKeyword As KeywordSyntax, expression As ExpressionSyntax) As WithStatementSyntax
            Debug.Assert(withKeyword IsNot Nothing AndAlso withKeyword.Kind = SyntaxKind.WithKeyword)
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.WithStatement, withKeyword, expression, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, WithStatementSyntax)
            End If

            Dim result = New WithStatementSyntax(SyntaxKind.WithStatement, withKeyword, expression, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a ReDim statement.
        ''' </summary>
        ''' <param name="reDimKeyword">
        ''' The "ReDim" keyword.
        ''' </param>
        ''' <param name="preserveKeyword">
        ''' Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
        ''' Kind=RedimPreserve.
        ''' </param>
        ''' <param name="clauses">
        ''' The list of ReDim clauses.
        ''' </param>
        Friend Function ReDimStatement(reDimKeyword As KeywordSyntax, preserveKeyword As KeywordSyntax, clauses As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As ReDimStatementSyntax
            Debug.Assert(reDimKeyword IsNot Nothing AndAlso reDimKeyword.Kind = SyntaxKind.ReDimKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ReDimStatement, reDimKeyword, preserveKeyword, clauses.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ReDimStatementSyntax)
            End If

            Dim result = New ReDimStatementSyntax(SyntaxKind.ReDimStatement, reDimKeyword, preserveKeyword, clauses.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a ReDim statement.
        ''' </summary>
        ''' <param name="reDimKeyword">
        ''' The "ReDim" keyword.
        ''' </param>
        ''' <param name="preserveKeyword">
        ''' Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if
        ''' Kind=RedimPreserve.
        ''' </param>
        ''' <param name="clauses">
        ''' The list of ReDim clauses.
        ''' </param>
        Friend Function ReDimPreserveStatement(reDimKeyword As KeywordSyntax, preserveKeyword As KeywordSyntax, clauses As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As ReDimStatementSyntax
            Debug.Assert(reDimKeyword IsNot Nothing AndAlso reDimKeyword.Kind = SyntaxKind.ReDimKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ReDimPreserveStatement, reDimKeyword, preserveKeyword, clauses.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ReDimStatementSyntax)
            End If

            Dim result = New ReDimStatementSyntax(SyntaxKind.ReDimPreserveStatement, reDimKeyword, preserveKeyword, clauses.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a ReDim statement clause.
        ''' </summary>
        ''' <param name="expression">
        ''' The target of the ReDim statement.
        ''' </param>
        ''' <param name="arrayBounds">
        ''' The ArraySizeInitializationModifier.
        ''' </param>
        Friend Function RedimClause(expression As ExpressionSyntax, arrayBounds As ArgumentListSyntax) As RedimClauseSyntax
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(arrayBounds IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.RedimClause, expression, arrayBounds, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, RedimClauseSyntax)
            End If

            Dim result = New RedimClauseSyntax(SyntaxKind.RedimClause, expression, arrayBounds, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an "Erase" statement.
        ''' </summary>
        ''' <param name="eraseKeyword">
        ''' The "Erase" keyword.
        ''' </param>
        ''' <param name="expressions">
        ''' A list of expressions denoting the arrays to erase.
        ''' </param>
        Friend Function EraseStatement(eraseKeyword As KeywordSyntax, expressions As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As EraseStatementSyntax
            Debug.Assert(eraseKeyword IsNot Nothing AndAlso eraseKeyword.Kind = SyntaxKind.EraseKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EraseStatement, eraseKeyword, expressions.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, EraseStatementSyntax)
            End If

            Dim result = New EraseStatementSyntax(SyntaxKind.EraseStatement, eraseKeyword, expressions.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Function CharacterLiteralExpression(token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(token IsNot Nothing AndAlso SyntaxFacts.IsLiteralExpressionToken(token.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.CharacterLiteralExpression, token, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LiteralExpressionSyntax)
            End If

            Dim result = New LiteralExpressionSyntax(SyntaxKind.CharacterLiteralExpression, token, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Function TrueLiteralExpression(token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(token IsNot Nothing AndAlso SyntaxFacts.IsLiteralExpressionToken(token.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.TrueLiteralExpression, token, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LiteralExpressionSyntax)
            End If

            Dim result = New LiteralExpressionSyntax(SyntaxKind.TrueLiteralExpression, token, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Function FalseLiteralExpression(token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(token IsNot Nothing AndAlso SyntaxFacts.IsLiteralExpressionToken(token.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.FalseLiteralExpression, token, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LiteralExpressionSyntax)
            End If

            Dim result = New LiteralExpressionSyntax(SyntaxKind.FalseLiteralExpression, token, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Function NumericLiteralExpression(token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(token IsNot Nothing AndAlso SyntaxFacts.IsLiteralExpressionToken(token.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.NumericLiteralExpression, token, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LiteralExpressionSyntax)
            End If

            Dim result = New LiteralExpressionSyntax(SyntaxKind.NumericLiteralExpression, token, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Function DateLiteralExpression(token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(token IsNot Nothing AndAlso SyntaxFacts.IsLiteralExpressionToken(token.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.DateLiteralExpression, token, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LiteralExpressionSyntax)
            End If

            Dim result = New LiteralExpressionSyntax(SyntaxKind.DateLiteralExpression, token, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Function StringLiteralExpression(token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(token IsNot Nothing AndAlso SyntaxFacts.IsLiteralExpressionToken(token.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.StringLiteralExpression, token, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LiteralExpressionSyntax)
            End If

            Dim result = New LiteralExpressionSyntax(SyntaxKind.StringLiteralExpression, token, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Function NothingLiteralExpression(token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(token IsNot Nothing AndAlso SyntaxFacts.IsLiteralExpressionToken(token.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.NothingLiteralExpression, token, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LiteralExpressionSyntax)
            End If

            Dim result = New LiteralExpressionSyntax(SyntaxKind.NothingLiteralExpression, token, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a literal. The kind of literal is determined by the Kind property:
        ''' IntegerLiteral, CharacterLiteral, BooleanLiteral, DecimalLiteral,
        ''' FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be
        ''' determined by casting the associated Token to the correct type and getting the
        ''' value from the token.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' LiteralExpressionSyntax. One of CharacterLiteralExpression,
        ''' TrueLiteralExpression, FalseLiteralExpression, NumericLiteralExpression,
        ''' DateLiteralExpression, StringLiteralExpression, NothingLiteralExpression.
        ''' </param>
        ''' <param name="token">
        ''' The token that represents the literal. The Kind property determines what type
        ''' this property returns: Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
        ''' Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken. Kind=DecimalLiteral
        ''' ==&gt; Returns DecimalLiteralToken Kind=FloatingLiteral ==&gt; Returns
        ''' FloatingLiteralToken Kind=DateLiteral ==&gt; Returns DateLiteralToken
        ''' Kind=StringLiteral ==&gt; Returns StringLiteralToken Kind=BooleanLiteral ==&gt;
        ''' Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
        ''' Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being
        ''' NothingKeyword)
        ''' </param>
        Friend Function LiteralExpression(kind As SyntaxKind, token As SyntaxToken) As LiteralExpressionSyntax
            Debug.Assert(SyntaxFacts.IsLiteralExpression(kind))
            Debug.Assert(token IsNot Nothing AndAlso SyntaxFacts.IsLiteralExpressionToken(token.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(kind, token, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LiteralExpressionSyntax)
            End If

            Dim result = New LiteralExpressionSyntax(kind, token, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a parenthesized expression.
        ''' </summary>
        ''' <param name="openParenToken">
        ''' The "(" token
        ''' </param>
        ''' <param name="expression">
        ''' The expression inside the parentheses.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token
        ''' </param>
        Friend Function ParenthesizedExpression(openParenToken As PunctuationSyntax, expression As ExpressionSyntax, closeParenToken As PunctuationSyntax) As ParenthesizedExpressionSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ParenthesizedExpressionSyntax)
            End If

            Dim result = New ParenthesizedExpressionSyntax(SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a tuple literal expression.
        ''' </summary>
        ''' <param name="openParenToken">
        ''' The "(" token
        ''' </param>
        ''' <param name="arguments">
        ''' The list of tuple arguments.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token
        ''' </param>
        Friend Function TupleExpression(openParenToken As PunctuationSyntax, arguments As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), closeParenToken As PunctuationSyntax) As TupleExpressionSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.TupleExpression, openParenToken, arguments.Node, closeParenToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, TupleExpressionSyntax)
            End If

            Dim result = New TupleExpressionSyntax(SyntaxKind.TupleExpression, openParenToken, arguments.Node, closeParenToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a tuple type expression.
        ''' </summary>
        ''' <param name="openParenToken">
        ''' The "(" token
        ''' </param>
        ''' <param name="elements">
        ''' The list of tuple elements.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token
        ''' </param>
        Friend Function TupleType(openParenToken As PunctuationSyntax, elements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), closeParenToken As PunctuationSyntax) As TupleTypeSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.TupleType, openParenToken, elements.Node, closeParenToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, TupleTypeSyntax)
            End If

            Dim result = New TupleTypeSyntax(SyntaxKind.TupleType, openParenToken, elements.Node, closeParenToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a single declaration of a tuple element supplying only the type.
        ''' </summary>
        ''' <param name="type">
        ''' The type-name part of the tuple element syntax.
        ''' </param>
        Friend Function TypedTupleElement(type As TypeSyntax) As TypedTupleElementSyntax
            Debug.Assert(type IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.TypedTupleElement, type, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, TypedTupleElementSyntax)
            End If

            Dim result = New TypedTupleElementSyntax(SyntaxKind.TypedTupleElement, type, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a single declaration of a tuple element supplying element name and
        ''' optionally a type.
        ''' </summary>
        ''' <param name="identifier">
        ''' The name of the element.
        ''' </param>
        ''' <param name="asClause">
        ''' A simple "As" clause specifying the type of the tuple element.
        ''' </param>
        Friend Function NamedTupleElement(identifier As IdentifierTokenSyntax, asClause As SimpleAsClauseSyntax) As NamedTupleElementSyntax
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.NamedTupleElement, identifier, asClause, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, NamedTupleElementSyntax)
            End If

            Dim result = New NamedTupleElementSyntax(SyntaxKind.NamedTupleElement, identifier, asClause, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Identifies the special instance "Me"
        ''' </summary>
        ''' <param name="keyword">
        ''' The "Me", "MyClass" or "MyBase" keyword.
        ''' </param>
        Friend Function MeExpression(keyword As KeywordSyntax) As MeExpressionSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.MeKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.MeExpression, keyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MeExpressionSyntax)
            End If

            Dim result = New MeExpressionSyntax(SyntaxKind.MeExpression, keyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Identifies the special instance "MyBase"
        ''' </summary>
        ''' <param name="keyword">
        ''' The "Me", "MyClass" or "MyBase" keyword.
        ''' </param>
        Friend Function MyBaseExpression(keyword As KeywordSyntax) As MyBaseExpressionSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.MyBaseKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.MyBaseExpression, keyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MyBaseExpressionSyntax)
            End If

            Dim result = New MyBaseExpressionSyntax(SyntaxKind.MyBaseExpression, keyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Identifies the special instance "MyClass"
        ''' </summary>
        ''' <param name="keyword">
        ''' The "Me", "MyClass" or "MyBase" keyword.
        ''' </param>
        Friend Function MyClassExpression(keyword As KeywordSyntax) As MyClassExpressionSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.MyClassKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.MyClassExpression, keyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MyClassExpressionSyntax)
            End If

            Dim result = New MyClassExpressionSyntax(SyntaxKind.MyClassExpression, keyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a GetType expression.
        ''' </summary>
        ''' <param name="getTypeKeyword">
        ''' The "GetType" keyword.
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="type">
        ''' The type to get the Type object for. This can be an open generic type.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Function GetTypeExpression(getTypeKeyword As KeywordSyntax, openParenToken As PunctuationSyntax, type As TypeSyntax, closeParenToken As PunctuationSyntax) As GetTypeExpressionSyntax
            Debug.Assert(getTypeKeyword IsNot Nothing AndAlso getTypeKeyword.Kind = SyntaxKind.GetTypeKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(type IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New GetTypeExpressionSyntax(SyntaxKind.GetTypeExpression, getTypeKeyword, openParenToken, type, closeParenToken, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a TypeOf...Is or IsNot expression.
        ''' </summary>
        ''' <param name="typeOfKeyword">
        ''' The "TypeOf" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being tested.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The "Is" or "IsNot" keyword.
        ''' </param>
        ''' <param name="type">
        ''' The name of the type being tested against.
        ''' </param>
        Friend Function TypeOfIsExpression(typeOfKeyword As KeywordSyntax, expression As ExpressionSyntax, operatorToken As KeywordSyntax, type As TypeSyntax) As TypeOfExpressionSyntax
            Debug.Assert(typeOfKeyword IsNot Nothing AndAlso typeOfKeyword.Kind = SyntaxKind.TypeOfKeyword)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.IsKeyword)
            Debug.Assert(type IsNot Nothing)
            Return New TypeOfExpressionSyntax(SyntaxKind.TypeOfIsExpression, typeOfKeyword, expression, operatorToken, type, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a TypeOf...Is or IsNot expression.
        ''' </summary>
        ''' <param name="typeOfKeyword">
        ''' The "TypeOf" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being tested.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The "Is" or "IsNot" keyword.
        ''' </param>
        ''' <param name="type">
        ''' The name of the type being tested against.
        ''' </param>
        Friend Function TypeOfIsNotExpression(typeOfKeyword As KeywordSyntax, expression As ExpressionSyntax, operatorToken As KeywordSyntax, type As TypeSyntax) As TypeOfExpressionSyntax
            Debug.Assert(typeOfKeyword IsNot Nothing AndAlso typeOfKeyword.Kind = SyntaxKind.TypeOfKeyword)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.IsNotKeyword)
            Debug.Assert(type IsNot Nothing)
            Return New TypeOfExpressionSyntax(SyntaxKind.TypeOfIsNotExpression, typeOfKeyword, expression, operatorToken, type, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a TypeOf...Is or IsNot expression.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' TypeOfExpressionSyntax. One of TypeOfIsExpression, TypeOfIsNotExpression.
        ''' </param>
        ''' <param name="typeOfKeyword">
        ''' The "TypeOf" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being tested.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The "Is" or "IsNot" keyword.
        ''' </param>
        ''' <param name="type">
        ''' The name of the type being tested against.
        ''' </param>
        Friend Function TypeOfExpression(kind As SyntaxKind, typeOfKeyword As KeywordSyntax, expression As ExpressionSyntax, operatorToken As KeywordSyntax, type As TypeSyntax) As TypeOfExpressionSyntax
            Debug.Assert(SyntaxFacts.IsTypeOfExpression(kind))
            Debug.Assert(typeOfKeyword IsNot Nothing AndAlso typeOfKeyword.Kind = SyntaxKind.TypeOfKeyword)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso SyntaxFacts.IsTypeOfExpressionOperatorToken(operatorToken.Kind))
            Debug.Assert(type IsNot Nothing)
            Return New TypeOfExpressionSyntax(kind, typeOfKeyword, expression, operatorToken, type, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a GetXmlNamespace expression.
        ''' </summary>
        ''' <param name="getXmlNamespaceKeyword">
        ''' The "GetXmlNamespace" keyword.
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="name">
        ''' The Xml namespace name being referenced.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Function GetXmlNamespaceExpression(getXmlNamespaceKeyword As KeywordSyntax, openParenToken As PunctuationSyntax, name As XmlPrefixNameSyntax, closeParenToken As PunctuationSyntax) As GetXmlNamespaceExpressionSyntax
            Debug.Assert(getXmlNamespaceKeyword IsNot Nothing AndAlso getXmlNamespaceKeyword.Kind = SyntaxKind.GetXmlNamespaceKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New GetXmlNamespaceExpressionSyntax(SyntaxKind.GetXmlNamespaceExpression, getXmlNamespaceKeyword, openParenToken, name, closeParenToken, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents member access (.name) or dictionary access (!name). The Kind
        ''' property determines which kind of access.
        ''' </summary>
        ''' <param name="expression">
        ''' The expression on the left-hand-side of the "." or "!" token.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The "." or "!" token.
        ''' </param>
        ''' <param name="name">
        ''' The identifier after the "." or "!" token.
        ''' </param>
        Friend Function SimpleMemberAccessExpression(expression As ExpressionSyntax, operatorToken As PunctuationSyntax, name As SimpleNameSyntax) As MemberAccessExpressionSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.DotToken)
            Debug.Assert(name IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.SimpleMemberAccessExpression, expression, operatorToken, name, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MemberAccessExpressionSyntax)
            End If

            Dim result = New MemberAccessExpressionSyntax(SyntaxKind.SimpleMemberAccessExpression, expression, operatorToken, name, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents member access (.name) or dictionary access (!name). The Kind
        ''' property determines which kind of access.
        ''' </summary>
        ''' <param name="expression">
        ''' The expression on the left-hand-side of the "." or "!" token.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The "." or "!" token.
        ''' </param>
        ''' <param name="name">
        ''' The identifier after the "." or "!" token.
        ''' </param>
        Friend Function DictionaryAccessExpression(expression As ExpressionSyntax, operatorToken As PunctuationSyntax, name As SimpleNameSyntax) As MemberAccessExpressionSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.ExclamationToken)
            Debug.Assert(name IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.DictionaryAccessExpression, expression, operatorToken, name, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MemberAccessExpressionSyntax)
            End If

            Dim result = New MemberAccessExpressionSyntax(SyntaxKind.DictionaryAccessExpression, expression, operatorToken, name, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents member access (.name) or dictionary access (!name). The Kind
        ''' property determines which kind of access.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' MemberAccessExpressionSyntax. One of SimpleMemberAccessExpression,
        ''' DictionaryAccessExpression.
        ''' </param>
        ''' <param name="expression">
        ''' The expression on the left-hand-side of the "." or "!" token.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The "." or "!" token.
        ''' </param>
        ''' <param name="name">
        ''' The identifier after the "." or "!" token.
        ''' </param>
        Friend Function MemberAccessExpression(kind As SyntaxKind, expression As ExpressionSyntax, operatorToken As PunctuationSyntax, name As SimpleNameSyntax) As MemberAccessExpressionSyntax
            Debug.Assert(SyntaxFacts.IsMemberAccessExpression(kind))
            Debug.Assert(operatorToken IsNot Nothing AndAlso SyntaxFacts.IsMemberAccessExpressionOperatorToken(operatorToken.Kind))
            Debug.Assert(name IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(kind, expression, operatorToken, name, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MemberAccessExpressionSyntax)
            End If

            Dim result = New MemberAccessExpressionSyntax(kind, expression, operatorToken, name, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an XML member element access (node.&lt;Element&gt;), attribute
        ''' access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
        ''' Kind property determines which kind of access.
        ''' </summary>
        ''' <param name="base">
        ''' The expression on the left-hand-side of the ".", ".@" or "..." .
        ''' </param>
        ''' <param name="token1">
        ''' The initial dot "." part of the separator.
        ''' </param>
        ''' <param name="token2">
        ''' The "@" part of .@ or the second "." of "...".
        ''' </param>
        ''' <param name="token3">
        ''' The third "." in a "..." separator.
        ''' </param>
        ''' <param name="name">
        ''' The identifier after the ".", ".@" or "..."
        ''' </param>
        Friend Function XmlElementAccessExpression(base As ExpressionSyntax, token1 As PunctuationSyntax, token2 As PunctuationSyntax, token3 As PunctuationSyntax, name As XmlNodeSyntax) As XmlMemberAccessExpressionSyntax
            Debug.Assert(token1 IsNot Nothing AndAlso token1.Kind = SyntaxKind.DotToken)
            Debug.Assert(name IsNot Nothing)
            Return New XmlMemberAccessExpressionSyntax(SyntaxKind.XmlElementAccessExpression, base, token1, token2, token3, name, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an XML member element access (node.&lt;Element&gt;), attribute
        ''' access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
        ''' Kind property determines which kind of access.
        ''' </summary>
        ''' <param name="base">
        ''' The expression on the left-hand-side of the ".", ".@" or "..." .
        ''' </param>
        ''' <param name="token1">
        ''' The initial dot "." part of the separator.
        ''' </param>
        ''' <param name="token2">
        ''' The "@" part of .@ or the second "." of "...".
        ''' </param>
        ''' <param name="token3">
        ''' The third "." in a "..." separator.
        ''' </param>
        ''' <param name="name">
        ''' The identifier after the ".", ".@" or "..."
        ''' </param>
        Friend Function XmlDescendantAccessExpression(base As ExpressionSyntax, token1 As PunctuationSyntax, token2 As PunctuationSyntax, token3 As PunctuationSyntax, name As XmlNodeSyntax) As XmlMemberAccessExpressionSyntax
            Debug.Assert(token1 IsNot Nothing AndAlso token1.Kind = SyntaxKind.DotToken)
            Debug.Assert(name IsNot Nothing)
            Return New XmlMemberAccessExpressionSyntax(SyntaxKind.XmlDescendantAccessExpression, base, token1, token2, token3, name, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an XML member element access (node.&lt;Element&gt;), attribute
        ''' access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
        ''' Kind property determines which kind of access.
        ''' </summary>
        ''' <param name="base">
        ''' The expression on the left-hand-side of the ".", ".@" or "..." .
        ''' </param>
        ''' <param name="token1">
        ''' The initial dot "." part of the separator.
        ''' </param>
        ''' <param name="token2">
        ''' The "@" part of .@ or the second "." of "...".
        ''' </param>
        ''' <param name="token3">
        ''' The third "." in a "..." separator.
        ''' </param>
        ''' <param name="name">
        ''' The identifier after the ".", ".@" or "..."
        ''' </param>
        Friend Function XmlAttributeAccessExpression(base As ExpressionSyntax, token1 As PunctuationSyntax, token2 As PunctuationSyntax, token3 As PunctuationSyntax, name As XmlNodeSyntax) As XmlMemberAccessExpressionSyntax
            Debug.Assert(token1 IsNot Nothing AndAlso token1.Kind = SyntaxKind.DotToken)
            Debug.Assert(name IsNot Nothing)
            Return New XmlMemberAccessExpressionSyntax(SyntaxKind.XmlAttributeAccessExpression, base, token1, token2, token3, name, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an XML member element access (node.&lt;Element&gt;), attribute
        ''' access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;). The
        ''' Kind property determines which kind of access.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' XmlMemberAccessExpressionSyntax. One of XmlElementAccessExpression,
        ''' XmlDescendantAccessExpression, XmlAttributeAccessExpression.
        ''' </param>
        ''' <param name="base">
        ''' The expression on the left-hand-side of the ".", ".@" or "..." .
        ''' </param>
        ''' <param name="token1">
        ''' The initial dot "." part of the separator.
        ''' </param>
        ''' <param name="token2">
        ''' The "@" part of .@ or the second "." of "...".
        ''' </param>
        ''' <param name="token3">
        ''' The third "." in a "..." separator.
        ''' </param>
        ''' <param name="name">
        ''' The identifier after the ".", ".@" or "..."
        ''' </param>
        Friend Function XmlMemberAccessExpression(kind As SyntaxKind, base As ExpressionSyntax, token1 As PunctuationSyntax, token2 As PunctuationSyntax, token3 As PunctuationSyntax, name As XmlNodeSyntax) As XmlMemberAccessExpressionSyntax
            Debug.Assert(SyntaxFacts.IsXmlMemberAccessExpression(kind))
            Debug.Assert(token1 IsNot Nothing AndAlso token1.Kind = SyntaxKind.DotToken)
            Debug.Assert(name IsNot Nothing)
            Return New XmlMemberAccessExpressionSyntax(kind, base, token1, token2, token3, name, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an invocation expression consisting of an invocation target and an
        ''' optional argument list or an array, parameterized property or object default
        ''' property index.
        ''' </summary>
        ''' <param name="expression">
        ''' The target of the call or index expression.
        ''' </param>
        ''' <param name="argumentList">
        ''' The argument list.
        ''' </param>
        Friend Function InvocationExpression(expression As ExpressionSyntax, argumentList As ArgumentListSyntax) As InvocationExpressionSyntax

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.InvocationExpression, expression, argumentList, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, InvocationExpressionSyntax)
            End If

            Dim result = New InvocationExpressionSyntax(SyntaxKind.InvocationExpression, expression, argumentList, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a New expression that creates a new non-array object, possibly with
        ''' a "With" or "From" clause.
        ''' </summary>
        ''' <param name="newKeyword">
        ''' The "New" keyword.
        ''' </param>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on the type. If no attributes were specified, an
        ''' empty list is returned.
        ''' </param>
        ''' <param name="type">
        ''' The type of the object being initialized.
        ''' </param>
        ''' <param name="argumentList">
        ''' The argument list, if present. If no argument list was supplied, Nothing is
        ''' returned.
        ''' </param>
        ''' <param name="initializer">
        ''' An optional From or With clause to initialize the new object.
        ''' </param>
        Friend Function ObjectCreationExpression(newKeyword As KeywordSyntax, attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), type As TypeSyntax, argumentList As ArgumentListSyntax, initializer As ObjectCreationInitializerSyntax) As ObjectCreationExpressionSyntax
            Debug.Assert(newKeyword IsNot Nothing AndAlso newKeyword.Kind = SyntaxKind.NewKeyword)
            Debug.Assert(type IsNot Nothing)
            Return New ObjectCreationExpressionSyntax(SyntaxKind.ObjectCreationExpression, newKeyword, attributeLists.Node, type, argumentList, initializer, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a New expression that create an object of anonymous type.
        ''' </summary>
        ''' <param name="newKeyword">
        ''' The "New" keyword.
        ''' </param>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on the type. If no attributes were specified, an
        ''' empty list is returned.
        ''' </param>
        ''' <param name="initializer">
        ''' The With clause to initialize the new object.
        ''' </param>
        Friend Function AnonymousObjectCreationExpression(newKeyword As KeywordSyntax, attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), initializer As ObjectMemberInitializerSyntax) As AnonymousObjectCreationExpressionSyntax
            Debug.Assert(newKeyword IsNot Nothing AndAlso newKeyword.Kind = SyntaxKind.NewKeyword)
            Debug.Assert(initializer IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.AnonymousObjectCreationExpression, newKeyword, attributeLists.Node, initializer, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AnonymousObjectCreationExpressionSyntax)
            End If

            Dim result = New AnonymousObjectCreationExpressionSyntax(SyntaxKind.AnonymousObjectCreationExpression, newKeyword, attributeLists.Node, initializer, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an expression that creates a new array.
        ''' </summary>
        ''' <param name="newKeyword">
        ''' The "New" keyword.
        ''' </param>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on the type. If no attributes were specified, an
        ''' empty list is returned.
        ''' </param>
        ''' <param name="type">
        ''' The element type of the array being created.
        ''' </param>
        ''' <param name="arrayBounds">
        ''' The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".
        ''' </param>
        ''' <param name="rankSpecifiers">
        ''' A list of array modifiers such as "()" or "(,)". If no array modifiers were
        ''' present, an empty list is returned.
        ''' </param>
        ''' <param name="initializer">
        ''' The initializer including the braces.
        ''' </param>
        Friend Function ArrayCreationExpression(newKeyword As KeywordSyntax, attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), type As TypeSyntax, arrayBounds As ArgumentListSyntax, rankSpecifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), initializer As CollectionInitializerSyntax) As ArrayCreationExpressionSyntax
            Debug.Assert(newKeyword IsNot Nothing AndAlso newKeyword.Kind = SyntaxKind.NewKeyword)
            Debug.Assert(type IsNot Nothing)
            Debug.Assert(initializer IsNot Nothing)
            Return New ArrayCreationExpressionSyntax(SyntaxKind.ArrayCreationExpression, newKeyword, attributeLists.Node, type, arrayBounds, rankSpecifiers.Node, initializer, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an expression that creates a new array without naming the element
        ''' type.
        ''' </summary>
        ''' <param name="openBraceToken">
        ''' The "{" token.
        ''' </param>
        ''' <param name="initializers">
        ''' The list of initializers between the braces.
        ''' </param>
        ''' <param name="closeBraceToken">
        ''' The "}" token.
        ''' </param>
        Friend Function CollectionInitializer(openBraceToken As PunctuationSyntax, initializers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), closeBraceToken As PunctuationSyntax) As CollectionInitializerSyntax
            Debug.Assert(openBraceToken IsNot Nothing AndAlso openBraceToken.Kind = SyntaxKind.OpenBraceToken)
            Debug.Assert(closeBraceToken IsNot Nothing AndAlso closeBraceToken.Kind = SyntaxKind.CloseBraceToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.CollectionInitializer, openBraceToken, initializers.Node, closeBraceToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CollectionInitializerSyntax)
            End If

            Dim result = New CollectionInitializerSyntax(SyntaxKind.CollectionInitializer, openBraceToken, initializers.Node, closeBraceToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <param name="keyword">
        ''' The "CType", "DirectCast" or "TryCast" keyword.
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being cast.
        ''' </param>
        ''' <param name="commaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="type">
        ''' The type the expression is being cast to.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Function CTypeExpression(keyword As KeywordSyntax, openParenToken As PunctuationSyntax, expression As ExpressionSyntax, commaToken As PunctuationSyntax, type As TypeSyntax, closeParenToken As PunctuationSyntax) As CTypeExpressionSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.CTypeKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(type IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New CTypeExpressionSyntax(SyntaxKind.CTypeExpression, keyword, openParenToken, expression, commaToken, type, closeParenToken, _factoryContext)
        End Function


        ''' <param name="keyword">
        ''' The "CType", "DirectCast" or "TryCast" keyword.
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being cast.
        ''' </param>
        ''' <param name="commaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="type">
        ''' The type the expression is being cast to.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Function DirectCastExpression(keyword As KeywordSyntax, openParenToken As PunctuationSyntax, expression As ExpressionSyntax, commaToken As PunctuationSyntax, type As TypeSyntax, closeParenToken As PunctuationSyntax) As DirectCastExpressionSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.DirectCastKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(type IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New DirectCastExpressionSyntax(SyntaxKind.DirectCastExpression, keyword, openParenToken, expression, commaToken, type, closeParenToken, _factoryContext)
        End Function


        ''' <param name="keyword">
        ''' The "CType", "DirectCast" or "TryCast" keyword.
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being cast.
        ''' </param>
        ''' <param name="commaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="type">
        ''' The type the expression is being cast to.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Function TryCastExpression(keyword As KeywordSyntax, openParenToken As PunctuationSyntax, expression As ExpressionSyntax, commaToken As PunctuationSyntax, type As TypeSyntax, closeParenToken As PunctuationSyntax) As TryCastExpressionSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso keyword.Kind = SyntaxKind.TryCastKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(type IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New TryCastExpressionSyntax(SyntaxKind.TryCastExpression, keyword, openParenToken, expression, commaToken, type, closeParenToken, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a cast to a pre-defined type using a pre-defined cast expression,
        ''' such as CInt or CLng.
        ''' </summary>
        ''' <param name="keyword">
        ''' The keyword that was used in the cast operation.
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being cast.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Function PredefinedCastExpression(keyword As KeywordSyntax, openParenToken As PunctuationSyntax, expression As ExpressionSyntax, closeParenToken As PunctuationSyntax) As PredefinedCastExpressionSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso SyntaxFacts.IsPredefinedCastExpressionKeyword(keyword.Kind))
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New PredefinedCastExpressionSyntax(SyntaxKind.PredefinedCastExpression, keyword, openParenToken, expression, closeParenToken, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function AddExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.PlusToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.AddExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.AddExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function SubtractExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.MinusToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.SubtractExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.SubtractExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function MultiplyExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.AsteriskToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.MultiplyExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.MultiplyExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function DivideExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.SlashToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.DivideExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.DivideExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function IntegerDivideExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.BackslashToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.IntegerDivideExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.IntegerDivideExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function ExponentiateExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.CaretToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ExponentiateExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.ExponentiateExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function LeftShiftExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LessThanLessThanToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.LeftShiftExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.LeftShiftExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function RightShiftExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.GreaterThanGreaterThanToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.RightShiftExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.RightShiftExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function ConcatenateExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.AmpersandToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ConcatenateExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.ConcatenateExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function ModuloExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.ModKeyword)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ModuloExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.ModuloExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function EqualsExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.EqualsExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.EqualsExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function NotEqualsExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LessThanGreaterThanToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.NotEqualsExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.NotEqualsExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function LessThanExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LessThanToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.LessThanExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.LessThanExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function LessThanOrEqualExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LessThanEqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.LessThanOrEqualExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.LessThanOrEqualExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function GreaterThanOrEqualExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.GreaterThanEqualsToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.GreaterThanOrEqualExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.GreaterThanOrEqualExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function GreaterThanExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.GreaterThanToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.GreaterThanExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.GreaterThanExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function IsExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.IsKeyword)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.IsExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.IsExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function IsNotExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.IsNotKeyword)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.IsNotExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.IsNotExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function LikeExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.LikeKeyword)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.LikeExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.LikeExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function OrExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.OrKeyword)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.OrExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.OrExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function ExclusiveOrExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.XorKeyword)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ExclusiveOrExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.ExclusiveOrExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function AndExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.AndKeyword)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.AndExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.AndExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function OrElseExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.OrElseKeyword)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.OrElseExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.OrElseExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function AndAlsoExpression(left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.AndAlsoKeyword)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.AndAlsoExpression, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(SyntaxKind.AndAlsoExpression, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a binary operator. The Kind property classifies the operators into
        ''' similar kind of operators (arithmetic, relational, logical or string); the
        ''' exact operation being performed is determined by the Operator property.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' BinaryExpressionSyntax. One of AddExpression, SubtractExpression,
        ''' MultiplyExpression, DivideExpression, IntegerDivideExpression,
        ''' ExponentiateExpression, LeftShiftExpression, RightShiftExpression,
        ''' ConcatenateExpression, ModuloExpression, EqualsExpression, NotEqualsExpression,
        ''' LessThanExpression, LessThanOrEqualExpression, GreaterThanOrEqualExpression,
        ''' GreaterThanExpression, IsExpression, IsNotExpression, LikeExpression,
        ''' OrExpression, ExclusiveOrExpression, AndExpression, OrElseExpression,
        ''' AndAlsoExpression.
        ''' </param>
        ''' <param name="left">
        ''' The left operand.
        ''' </param>
        ''' <param name="right">
        ''' The right operand.
        ''' </param>
        Friend Function BinaryExpression(kind As SyntaxKind, left As ExpressionSyntax, operatorToken As SyntaxToken, right As ExpressionSyntax) As BinaryExpressionSyntax
            Debug.Assert(SyntaxFacts.IsBinaryExpression(kind))
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(operatorToken IsNot Nothing AndAlso SyntaxFacts.IsBinaryExpressionOperatorToken(operatorToken.Kind))
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(kind, left, operatorToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, BinaryExpressionSyntax)
            End If

            Dim result = New BinaryExpressionSyntax(kind, left, operatorToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Describes a unary operator: Plus, Negate, Not or AddressOf.
        ''' </summary>
        ''' <param name="operatorToken">
        ''' The token that is the operator.
        ''' </param>
        ''' <param name="operand">
        ''' The expression being operated on.
        ''' </param>
        Friend Function UnaryPlusExpression(operatorToken As SyntaxToken, operand As ExpressionSyntax) As UnaryExpressionSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.PlusToken)
            Debug.Assert(operand IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.UnaryPlusExpression, operatorToken, operand, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, UnaryExpressionSyntax)
            End If

            Dim result = New UnaryExpressionSyntax(SyntaxKind.UnaryPlusExpression, operatorToken, operand, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Describes a unary operator: Plus, Negate, Not or AddressOf.
        ''' </summary>
        ''' <param name="operatorToken">
        ''' The token that is the operator.
        ''' </param>
        ''' <param name="operand">
        ''' The expression being operated on.
        ''' </param>
        Friend Function UnaryMinusExpression(operatorToken As SyntaxToken, operand As ExpressionSyntax) As UnaryExpressionSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.MinusToken)
            Debug.Assert(operand IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.UnaryMinusExpression, operatorToken, operand, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, UnaryExpressionSyntax)
            End If

            Dim result = New UnaryExpressionSyntax(SyntaxKind.UnaryMinusExpression, operatorToken, operand, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Describes a unary operator: Plus, Negate, Not or AddressOf.
        ''' </summary>
        ''' <param name="operatorToken">
        ''' The token that is the operator.
        ''' </param>
        ''' <param name="operand">
        ''' The expression being operated on.
        ''' </param>
        Friend Function NotExpression(operatorToken As SyntaxToken, operand As ExpressionSyntax) As UnaryExpressionSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.NotKeyword)
            Debug.Assert(operand IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.NotExpression, operatorToken, operand, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, UnaryExpressionSyntax)
            End If

            Dim result = New UnaryExpressionSyntax(SyntaxKind.NotExpression, operatorToken, operand, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Describes a unary operator: Plus, Negate, Not or AddressOf.
        ''' </summary>
        ''' <param name="operatorToken">
        ''' The token that is the operator.
        ''' </param>
        ''' <param name="operand">
        ''' The expression being operated on.
        ''' </param>
        Friend Function AddressOfExpression(operatorToken As SyntaxToken, operand As ExpressionSyntax) As UnaryExpressionSyntax
            Debug.Assert(operatorToken IsNot Nothing AndAlso operatorToken.Kind = SyntaxKind.AddressOfKeyword)
            Debug.Assert(operand IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.AddressOfExpression, operatorToken, operand, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, UnaryExpressionSyntax)
            End If

            Dim result = New UnaryExpressionSyntax(SyntaxKind.AddressOfExpression, operatorToken, operand, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Describes a unary operator: Plus, Negate, Not or AddressOf.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' UnaryExpressionSyntax. One of UnaryPlusExpression, UnaryMinusExpression,
        ''' NotExpression, AddressOfExpression.
        ''' </param>
        ''' <param name="operatorToken">
        ''' The token that is the operator.
        ''' </param>
        ''' <param name="operand">
        ''' The expression being operated on.
        ''' </param>
        Friend Function UnaryExpression(kind As SyntaxKind, operatorToken As SyntaxToken, operand As ExpressionSyntax) As UnaryExpressionSyntax
            Debug.Assert(SyntaxFacts.IsUnaryExpression(kind))
            Debug.Assert(operatorToken IsNot Nothing AndAlso SyntaxFacts.IsUnaryExpressionOperatorToken(operatorToken.Kind))
            Debug.Assert(operand IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(kind, operatorToken, operand, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, UnaryExpressionSyntax)
            End If

            Dim result = New UnaryExpressionSyntax(kind, operatorToken, operand, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a conditional expression, If(condition, true-expr, false-expr) or
        ''' If(expr, nothing-expr).
        ''' </summary>
        ''' <param name="ifKeyword">
        ''' The "If" keyword
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token
        ''' </param>
        ''' <param name="firstExpression">
        ''' The first expression inside the parentheses.
        ''' </param>
        ''' <param name="commaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="secondExpression">
        ''' The second expression inside the parentheses.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token
        ''' </param>
        Friend Function BinaryConditionalExpression(ifKeyword As KeywordSyntax, openParenToken As PunctuationSyntax, firstExpression As ExpressionSyntax, commaToken As PunctuationSyntax, secondExpression As ExpressionSyntax, closeParenToken As PunctuationSyntax) As BinaryConditionalExpressionSyntax
            Debug.Assert(ifKeyword IsNot Nothing AndAlso ifKeyword.Kind = SyntaxKind.IfKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(firstExpression IsNot Nothing)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(secondExpression IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New BinaryConditionalExpressionSyntax(SyntaxKind.BinaryConditionalExpression, ifKeyword, openParenToken, firstExpression, commaToken, secondExpression, closeParenToken, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a conditional expression, If(condition, true-expr, false-expr) or
        ''' If(expr, nothing-expr).
        ''' </summary>
        ''' <param name="ifKeyword">
        ''' The "If" keyword
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token
        ''' </param>
        ''' <param name="condition">
        ''' The first expression inside the parentheses.
        ''' </param>
        ''' <param name="firstCommaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="whenTrue">
        ''' The second expression inside the parentheses.
        ''' </param>
        ''' <param name="secondCommaToken">
        ''' The "," token.
        ''' </param>
        ''' <param name="whenFalse">
        ''' The second expression inside the parentheses.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token
        ''' </param>
        Friend Function TernaryConditionalExpression(ifKeyword As KeywordSyntax, openParenToken As PunctuationSyntax, condition As ExpressionSyntax, firstCommaToken As PunctuationSyntax, whenTrue As ExpressionSyntax, secondCommaToken As PunctuationSyntax, whenFalse As ExpressionSyntax, closeParenToken As PunctuationSyntax) As TernaryConditionalExpressionSyntax
            Debug.Assert(ifKeyword IsNot Nothing AndAlso ifKeyword.Kind = SyntaxKind.IfKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(condition IsNot Nothing)
            Debug.Assert(firstCommaToken IsNot Nothing AndAlso firstCommaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(whenTrue IsNot Nothing)
            Debug.Assert(secondCommaToken IsNot Nothing AndAlso secondCommaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(whenFalse IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New TernaryConditionalExpressionSyntax(SyntaxKind.TernaryConditionalExpression, ifKeyword, openParenToken, condition, firstCommaToken, whenTrue, secondCommaToken, whenFalse, closeParenToken, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a single line lambda expression.
        ''' </summary>
        ''' <param name="subOrFunctionHeader">
        ''' The header part of the lambda that includes the "Sub" or "Function" keyword,
        ''' the argument list and return type.
        ''' </param>
        ''' <param name="body">
        ''' The body of the lambda. Depending on the kind of lambda, this is either a
        ''' Statement (single-line Sub lambda) or Expression (single-line Function).
        ''' </param>
        Friend Function SingleLineFunctionLambdaExpression(subOrFunctionHeader As LambdaHeaderSyntax, body As VisualBasicSyntaxNode) As SingleLineLambdaExpressionSyntax
            Debug.Assert(subOrFunctionHeader IsNot Nothing)
            Debug.Assert(body IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.SingleLineFunctionLambdaExpression, subOrFunctionHeader, body, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SingleLineLambdaExpressionSyntax)
            End If

            Dim result = New SingleLineLambdaExpressionSyntax(SyntaxKind.SingleLineFunctionLambdaExpression, subOrFunctionHeader, body, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a single line lambda expression.
        ''' </summary>
        ''' <param name="subOrFunctionHeader">
        ''' The header part of the lambda that includes the "Sub" or "Function" keyword,
        ''' the argument list and return type.
        ''' </param>
        ''' <param name="body">
        ''' The body of the lambda. Depending on the kind of lambda, this is either a
        ''' Statement (single-line Sub lambda) or Expression (single-line Function).
        ''' </param>
        Friend Function SingleLineSubLambdaExpression(subOrFunctionHeader As LambdaHeaderSyntax, body As VisualBasicSyntaxNode) As SingleLineLambdaExpressionSyntax
            Debug.Assert(subOrFunctionHeader IsNot Nothing)
            Debug.Assert(body IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.SingleLineSubLambdaExpression, subOrFunctionHeader, body, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SingleLineLambdaExpressionSyntax)
            End If

            Dim result = New SingleLineLambdaExpressionSyntax(SyntaxKind.SingleLineSubLambdaExpression, subOrFunctionHeader, body, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a single line lambda expression.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' SingleLineLambdaExpressionSyntax. One of SingleLineFunctionLambdaExpression,
        ''' SingleLineSubLambdaExpression.
        ''' </param>
        ''' <param name="subOrFunctionHeader">
        ''' The header part of the lambda that includes the "Sub" or "Function" keyword,
        ''' the argument list and return type.
        ''' </param>
        ''' <param name="body">
        ''' The body of the lambda. Depending on the kind of lambda, this is either a
        ''' Statement (single-line Sub lambda) or Expression (single-line Function).
        ''' </param>
        Friend Function SingleLineLambdaExpression(kind As SyntaxKind, subOrFunctionHeader As LambdaHeaderSyntax, body As VisualBasicSyntaxNode) As SingleLineLambdaExpressionSyntax
            Debug.Assert(SyntaxFacts.IsSingleLineLambdaExpression(kind))
            Debug.Assert(subOrFunctionHeader IsNot Nothing)
            Debug.Assert(body IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(kind, subOrFunctionHeader, body, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SingleLineLambdaExpressionSyntax)
            End If

            Dim result = New SingleLineLambdaExpressionSyntax(kind, subOrFunctionHeader, body, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a multi-line lambda expression.
        ''' </summary>
        ''' <param name="subOrFunctionHeader">
        ''' The header part of the lambda that includes the "Sub" or "Function" keyword,
        ''' the argument list and return type.
        ''' </param>
        ''' <param name="statements">
        ''' The body of the lambda. Depending on the kind of lambda, this is either a
        ''' StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
        ''' Expression (single-line Function). This might be an empty list.
        ''' </param>
        ''' <param name="endSubOrFunctionStatement">
        ''' Returns the "End Sub" or "End Function" statement if this is a multi-line
        ''' lambda.
        ''' </param>
        Friend Function MultiLineFunctionLambdaExpression(subOrFunctionHeader As LambdaHeaderSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endSubOrFunctionStatement As EndBlockStatementSyntax) As MultiLineLambdaExpressionSyntax
            Debug.Assert(subOrFunctionHeader IsNot Nothing)
            Debug.Assert(endSubOrFunctionStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.MultiLineFunctionLambdaExpression, subOrFunctionHeader, statements.Node, endSubOrFunctionStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MultiLineLambdaExpressionSyntax)
            End If

            Dim result = New MultiLineLambdaExpressionSyntax(SyntaxKind.MultiLineFunctionLambdaExpression, subOrFunctionHeader, statements.Node, endSubOrFunctionStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a multi-line lambda expression.
        ''' </summary>
        ''' <param name="subOrFunctionHeader">
        ''' The header part of the lambda that includes the "Sub" or "Function" keyword,
        ''' the argument list and return type.
        ''' </param>
        ''' <param name="statements">
        ''' The body of the lambda. Depending on the kind of lambda, this is either a
        ''' StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
        ''' Expression (single-line Function). This might be an empty list.
        ''' </param>
        ''' <param name="endSubOrFunctionStatement">
        ''' Returns the "End Sub" or "End Function" statement if this is a multi-line
        ''' lambda.
        ''' </param>
        Friend Function MultiLineSubLambdaExpression(subOrFunctionHeader As LambdaHeaderSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endSubOrFunctionStatement As EndBlockStatementSyntax) As MultiLineLambdaExpressionSyntax
            Debug.Assert(subOrFunctionHeader IsNot Nothing)
            Debug.Assert(endSubOrFunctionStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.MultiLineSubLambdaExpression, subOrFunctionHeader, statements.Node, endSubOrFunctionStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MultiLineLambdaExpressionSyntax)
            End If

            Dim result = New MultiLineLambdaExpressionSyntax(SyntaxKind.MultiLineSubLambdaExpression, subOrFunctionHeader, statements.Node, endSubOrFunctionStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a multi-line lambda expression.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' MultiLineLambdaExpressionSyntax. One of MultiLineFunctionLambdaExpression,
        ''' MultiLineSubLambdaExpression.
        ''' </param>
        ''' <param name="subOrFunctionHeader">
        ''' The header part of the lambda that includes the "Sub" or "Function" keyword,
        ''' the argument list and return type.
        ''' </param>
        ''' <param name="statements">
        ''' The body of the lambda. Depending on the kind of lambda, this is either a
        ''' StatementBody (multi-line lambda), Statement (single-line Sub lambda) or
        ''' Expression (single-line Function). This might be an empty list.
        ''' </param>
        ''' <param name="endSubOrFunctionStatement">
        ''' Returns the "End Sub" or "End Function" statement if this is a multi-line
        ''' lambda.
        ''' </param>
        Friend Function MultiLineLambdaExpression(kind As SyntaxKind, subOrFunctionHeader As LambdaHeaderSyntax, statements As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endSubOrFunctionStatement As EndBlockStatementSyntax) As MultiLineLambdaExpressionSyntax
            Debug.Assert(SyntaxFacts.IsMultiLineLambdaExpression(kind))
            Debug.Assert(subOrFunctionHeader IsNot Nothing)
            Debug.Assert(endSubOrFunctionStatement IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(kind, subOrFunctionHeader, statements.Node, endSubOrFunctionStatement, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, MultiLineLambdaExpressionSyntax)
            End If

            Dim result = New MultiLineLambdaExpressionSyntax(kind, subOrFunctionHeader, statements.Node, endSubOrFunctionStatement, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the header part of a lambda expression
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword that introduces this lambda expression.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Function SubLambdaHeader(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), subOrFunctionKeyword As KeywordSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax) As LambdaHeaderSyntax
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso subOrFunctionKeyword.Kind = SyntaxKind.SubKeyword)
            Return New LambdaHeaderSyntax(SyntaxKind.SubLambdaHeader, attributeLists.Node, modifiers.Node, subOrFunctionKeyword, parameterList, asClause, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents the header part of a lambda expression
        ''' </summary>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword that introduces this lambda expression.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Function FunctionLambdaHeader(attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), subOrFunctionKeyword As KeywordSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax) As LambdaHeaderSyntax
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso subOrFunctionKeyword.Kind = SyntaxKind.FunctionKeyword)
            Return New LambdaHeaderSyntax(SyntaxKind.FunctionLambdaHeader, attributeLists.Node, modifiers.Node, subOrFunctionKeyword, parameterList, asClause, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents the header part of a lambda expression
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' LambdaHeaderSyntax. One of SubLambdaHeader, FunctionLambdaHeader.
        ''' </param>
        ''' <param name="attributeLists">
        ''' A list of all attribute lists on this declaration. If no attributes were
        ''' specified, Nothing is returned.
        ''' </param>
        ''' <param name="modifiers">
        ''' A list of all the modifier tokens that were present on this declaration. If no
        ''' modifiers were specified, an empty list is returned. A bitfield version of all
        ''' the modifiers ORed together, which is in many cases easier to use, can be
        ''' obtained with the Modifiers property.
        ''' </param>
        ''' <param name="subOrFunctionKeyword">
        ''' The "Sub" or "Function" keyword that introduces this lambda expression.
        ''' </param>
        ''' <param name="parameterList">
        ''' The method's parameter list including the parentheses. If no parameter list was
        ''' present, Nothing is returned.
        ''' </param>
        ''' <param name="asClause">
        ''' The "As" clause that describes the return type. If no As clause was present,
        ''' Nothing is returned.
        ''' </param>
        Friend Function LambdaHeader(kind As SyntaxKind, attributeLists As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), modifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), subOrFunctionKeyword As KeywordSyntax, parameterList As ParameterListSyntax, asClause As SimpleAsClauseSyntax) As LambdaHeaderSyntax
            Debug.Assert(SyntaxFacts.IsLambdaHeader(kind))
            Debug.Assert(subOrFunctionKeyword IsNot Nothing AndAlso SyntaxFacts.IsLambdaHeaderSubOrFunctionKeyword(subOrFunctionKeyword.Kind))
            Return New LambdaHeaderSyntax(kind, attributeLists.Node, modifiers.Node, subOrFunctionKeyword, parameterList, asClause, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a parenthesized argument list.
        ''' </summary>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="arguments">
        ''' The list of arguments. This may be empty. Omitted argument are represented by
        ''' an OmittedArgumentSyntax node.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Function ArgumentList(openParenToken As PunctuationSyntax, arguments As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), closeParenToken As PunctuationSyntax) As ArgumentListSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ArgumentListSyntax)
            End If

            Dim result = New ArgumentListSyntax(SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an omitted argument in an argument list. An omitted argument is not
        ''' considered a syntax error but a valid case when no argument is required.
        ''' </summary>
        ''' <param name="empty">
        ''' An empty token because all non terminals must have a token.
        ''' </param>
        Friend Function OmittedArgument(empty As PunctuationSyntax) As OmittedArgumentSyntax
            Debug.Assert(empty IsNot Nothing AndAlso empty.Kind = SyntaxKind.EmptyToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.OmittedArgument, empty, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, OmittedArgumentSyntax)
            End If

            Dim result = New OmittedArgumentSyntax(SyntaxKind.OmittedArgument, empty, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an argument that is just an optional argument name and an
        ''' expression.
        ''' </summary>
        ''' <param name="nameColonEquals">
        ''' The optional name and ":=" prefix of a named argument.
        ''' </param>
        ''' <param name="expression">
        ''' The expression that is the argument.
        ''' </param>
        Friend Function SimpleArgument(nameColonEquals As NameColonEqualsSyntax, expression As ExpressionSyntax) As SimpleArgumentSyntax
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.SimpleArgument, nameColonEquals, expression, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SimpleArgumentSyntax)
            End If

            Dim result = New SimpleArgumentSyntax(SyntaxKind.SimpleArgument, nameColonEquals, expression, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an identifier name followed by a ":=" token in a named argument.
        ''' </summary>
        ''' <param name="name">
        ''' The name used to identify the named argument.
        ''' </param>
        ''' <param name="colonEqualsToken">
        ''' The ":=" token.
        ''' </param>
        Friend Function NameColonEquals(name As IdentifierNameSyntax, colonEqualsToken As PunctuationSyntax) As NameColonEqualsSyntax
            Debug.Assert(name IsNot Nothing)
            Debug.Assert(colonEqualsToken IsNot Nothing AndAlso colonEqualsToken.Kind = SyntaxKind.ColonEqualsToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.NameColonEquals, name, colonEqualsToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, NameColonEqualsSyntax)
            End If

            Dim result = New NameColonEqualsSyntax(SyntaxKind.NameColonEquals, name, colonEqualsToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a range argument, such as "0 to 5", used in array bounds. The
        ''' "Value" property represents the upper bound of the range.
        ''' </summary>
        ''' <param name="lowerBound">
        ''' The lower bound of the range. This is typically the integer constant zero.
        ''' </param>
        ''' <param name="toKeyword">
        ''' The "To" keyword.
        ''' </param>
        ''' <param name="upperBound">
        ''' The upper bound of the range.
        ''' </param>
        Friend Function RangeArgument(lowerBound As ExpressionSyntax, toKeyword As KeywordSyntax, upperBound As ExpressionSyntax) As RangeArgumentSyntax
            Debug.Assert(lowerBound IsNot Nothing)
            Debug.Assert(toKeyword IsNot Nothing AndAlso toKeyword.Kind = SyntaxKind.ToKeyword)
            Debug.Assert(upperBound IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.RangeArgument, lowerBound, toKeyword, upperBound, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, RangeArgumentSyntax)
            End If

            Dim result = New RangeArgumentSyntax(SyntaxKind.RangeArgument, lowerBound, toKeyword, upperBound, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' This class represents a query expression. A query expression is composed of one
        ''' or more query operators in a row. The first query operator must be a From or
        ''' Aggregate.
        ''' </summary>
        ''' <param name="clauses">
        ''' A list of all the query operators in this query expression. This list always
        ''' contains at least one operator.
        ''' </param>
        Friend Function QueryExpression(clauses As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As QueryExpressionSyntax

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.QueryExpression, clauses.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, QueryExpressionSyntax)
            End If

            Dim result = New QueryExpressionSyntax(SyntaxKind.QueryExpression, clauses.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Describes a single variable of the form "x [As Type] In expression" for use in
        ''' query expressions.
        ''' </summary>
        ''' <param name="identifier">
        ''' The name of the range variable being defined.
        ''' </param>
        ''' <param name="asClause">
        ''' Describes the type of the variable being defined.
        ''' </param>
        ''' <param name="inKeyword">
        ''' The "In" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression that serves as the source of items for the range variable.
        ''' </param>
        Friend Function CollectionRangeVariable(identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, inKeyword As KeywordSyntax, expression As ExpressionSyntax) As CollectionRangeVariableSyntax
            Debug.Assert(identifier IsNot Nothing)
            Debug.Assert(inKeyword IsNot Nothing AndAlso inKeyword.Kind = SyntaxKind.InKeyword)
            Debug.Assert(expression IsNot Nothing)
            Return New CollectionRangeVariableSyntax(SyntaxKind.CollectionRangeVariable, identifier, asClause, inKeyword, expression, _factoryContext)
        End Function


        ''' <summary>
        ''' Describes a single variable of the form "[x [As Type] =] expression" for use in
        ''' query expressions.
        ''' </summary>
        ''' <param name="nameEquals">
        ''' The optional name and type of the expression range variable. If omitted, the
        ''' name of the expression range variable is inferred from the expression.
        ''' </param>
        ''' <param name="expression">
        ''' The expression used to initialize the expression variable.
        ''' </param>
        Friend Function ExpressionRangeVariable(nameEquals As VariableNameEqualsSyntax, expression As ExpressionSyntax) As ExpressionRangeVariableSyntax
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ExpressionRangeVariable, nameEquals, expression, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ExpressionRangeVariableSyntax)
            End If

            Dim result = New ExpressionRangeVariableSyntax(SyntaxKind.ExpressionRangeVariable, nameEquals, expression, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Describes a single variable of the form "[x [As Type] =] aggregation-function"
        ''' for use in the Into clause of Aggregate or Group By or Group Join query
        ''' operators.
        ''' </summary>
        ''' <param name="nameEquals">
        ''' The optional name and type of the expression range variable. If omitted, the
        ''' name of the expression range variable is inferred from the aggregation
        ''' expression.
        ''' </param>
        ''' <param name="aggregation">
        ''' The name of the aggregation function. The "Group" aggregation function is
        ''' represented by the identifier "Group".
        ''' </param>
        Friend Function AggregationRangeVariable(nameEquals As VariableNameEqualsSyntax, aggregation As AggregationSyntax) As AggregationRangeVariableSyntax
            Debug.Assert(aggregation IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.AggregationRangeVariable, nameEquals, aggregation, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AggregationRangeVariableSyntax)
            End If

            Dim result = New AggregationRangeVariableSyntax(SyntaxKind.AggregationRangeVariable, nameEquals, aggregation, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the name and optional type of an expression range variable.
        ''' </summary>
        ''' <param name="identifier">
        ''' The name of the variable being defined.
        ''' </param>
        ''' <param name="asClause">
        ''' Describes the type of the variable being defined.
        ''' </param>
        ''' <param name="equalsToken">
        ''' The "=" token.
        ''' </param>
        Friend Function VariableNameEquals(identifier As ModifiedIdentifierSyntax, asClause As SimpleAsClauseSyntax, equalsToken As PunctuationSyntax) As VariableNameEqualsSyntax
            Debug.Assert(identifier IsNot Nothing)
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.VariableNameEquals, identifier, asClause, equalsToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, VariableNameEqualsSyntax)
            End If

            Dim result = New VariableNameEqualsSyntax(SyntaxKind.VariableNameEquals, identifier, asClause, equalsToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an invocation of an Aggregation function in the aggregation range
        ''' variable declaration of a Group By, Group Join or Aggregate query operator.
        ''' </summary>
        ''' <param name="functionName">
        ''' The name of the aggregation function.
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token if present.
        ''' </param>
        ''' <param name="argument">
        ''' The argument to the aggregation function.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token, if present.
        ''' </param>
        Friend Function FunctionAggregation(functionName As IdentifierTokenSyntax, openParenToken As PunctuationSyntax, argument As ExpressionSyntax, closeParenToken As PunctuationSyntax) As FunctionAggregationSyntax
            Debug.Assert(functionName IsNot Nothing AndAlso functionName.Kind = SyntaxKind.IdentifierToken)
            Return New FunctionAggregationSyntax(SyntaxKind.FunctionAggregation, functionName, openParenToken, argument, closeParenToken, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents the use of "Group" as the aggregation function in the in the
        ''' aggregation range variable declaration of a Group By or Group Join query
        ''' operator.
        ''' </summary>
        ''' <param name="groupKeyword">
        ''' The "Group" keyword.
        ''' </param>
        Friend Function GroupAggregation(groupKeyword As KeywordSyntax) As GroupAggregationSyntax
            Debug.Assert(groupKeyword IsNot Nothing AndAlso groupKeyword.Kind = SyntaxKind.GroupKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.GroupAggregation, groupKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, GroupAggregationSyntax)
            End If

            Dim result = New GroupAggregationSyntax(SyntaxKind.GroupAggregation, groupKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "From" query operator. If this is the beginning of a query, the
        ''' Source will be Nothing. Otherwise, the Source will be the part of the query to
        ''' the left of the From.
        ''' </summary>
        ''' <param name="fromKeyword">
        ''' The "From" keyword.
        ''' </param>
        ''' <param name="variables">
        ''' The list of collection variables declared by this From operator.
        ''' </param>
        Friend Function FromClause(fromKeyword As KeywordSyntax, variables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As FromClauseSyntax
            Debug.Assert(fromKeyword IsNot Nothing AndAlso fromKeyword.Kind = SyntaxKind.FromKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.FromClause, fromKeyword, variables.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, FromClauseSyntax)
            End If

            Dim result = New FromClauseSyntax(SyntaxKind.FromClause, fromKeyword, variables.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Let" query operator.
        ''' </summary>
        ''' <param name="letKeyword">
        ''' The "Let" keyword.
        ''' </param>
        ''' <param name="variables">
        ''' The list of expression range variable being defined by the Let operator.
        ''' </param>
        Friend Function LetClause(letKeyword As KeywordSyntax, variables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As LetClauseSyntax
            Debug.Assert(letKeyword IsNot Nothing AndAlso letKeyword.Kind = SyntaxKind.LetKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.LetClause, letKeyword, variables.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, LetClauseSyntax)
            End If

            Dim result = New LetClauseSyntax(SyntaxKind.LetClause, letKeyword, variables.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an Aggregate query operator.
        ''' </summary>
        ''' <param name="aggregateKeyword">
        ''' The "Aggregate" keyword.
        ''' </param>
        ''' <param name="variables">
        ''' The list of collection range variables declared by this Aggregate operator.
        ''' </param>
        ''' <param name="additionalQueryOperators">
        ''' A list of additional query operators. It may be empty.
        ''' </param>
        ''' <param name="intoKeyword">
        ''' The "Into" keyword.
        ''' </param>
        ''' <param name="aggregationVariables">
        ''' The list of new variables being defined by the aggregation.
        ''' </param>
        Friend Function AggregateClause(aggregateKeyword As KeywordSyntax, variables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), additionalQueryOperators As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), intoKeyword As KeywordSyntax, aggregationVariables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As AggregateClauseSyntax
            Debug.Assert(aggregateKeyword IsNot Nothing AndAlso aggregateKeyword.Kind = SyntaxKind.AggregateKeyword)
            Debug.Assert(intoKeyword IsNot Nothing AndAlso intoKeyword.Kind = SyntaxKind.IntoKeyword)
            Return New AggregateClauseSyntax(SyntaxKind.AggregateClause, aggregateKeyword, variables.Node, additionalQueryOperators.Node, intoKeyword, aggregationVariables.Node, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents the "Distinct" query operator.
        ''' </summary>
        ''' <param name="distinctKeyword">
        ''' The "Distinct" keyword.
        ''' </param>
        Friend Function DistinctClause(distinctKeyword As KeywordSyntax) As DistinctClauseSyntax
            Debug.Assert(distinctKeyword IsNot Nothing AndAlso distinctKeyword.Kind = SyntaxKind.DistinctKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.DistinctClause, distinctKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, DistinctClauseSyntax)
            End If

            Dim result = New DistinctClauseSyntax(SyntaxKind.DistinctClause, distinctKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Where" query operator.
        ''' </summary>
        ''' <param name="whereKeyword">
        ''' The "Where" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression used for filtering.
        ''' </param>
        Friend Function WhereClause(whereKeyword As KeywordSyntax, condition As ExpressionSyntax) As WhereClauseSyntax
            Debug.Assert(whereKeyword IsNot Nothing AndAlso whereKeyword.Kind = SyntaxKind.WhereKeyword)
            Debug.Assert(condition IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.WhereClause, whereKeyword, condition, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, WhereClauseSyntax)
            End If

            Dim result = New WhereClauseSyntax(SyntaxKind.WhereClause, whereKeyword, condition, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Skip While" or "Take While" query operator. The Kind property
        ''' tells which.
        ''' </summary>
        ''' <param name="skipOrTakeKeyword">
        ''' The "Skip" or "Take" keyword.
        ''' </param>
        ''' <param name="whileKeyword">
        ''' The "While" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression used for partitioning.
        ''' </param>
        Friend Function SkipWhileClause(skipOrTakeKeyword As KeywordSyntax, whileKeyword As KeywordSyntax, condition As ExpressionSyntax) As PartitionWhileClauseSyntax
            Debug.Assert(skipOrTakeKeyword IsNot Nothing AndAlso skipOrTakeKeyword.Kind = SyntaxKind.SkipKeyword)
            Debug.Assert(whileKeyword IsNot Nothing AndAlso whileKeyword.Kind = SyntaxKind.WhileKeyword)
            Debug.Assert(condition IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.SkipWhileClause, skipOrTakeKeyword, whileKeyword, condition, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, PartitionWhileClauseSyntax)
            End If

            Dim result = New PartitionWhileClauseSyntax(SyntaxKind.SkipWhileClause, skipOrTakeKeyword, whileKeyword, condition, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Skip While" or "Take While" query operator. The Kind property
        ''' tells which.
        ''' </summary>
        ''' <param name="skipOrTakeKeyword">
        ''' The "Skip" or "Take" keyword.
        ''' </param>
        ''' <param name="whileKeyword">
        ''' The "While" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression used for partitioning.
        ''' </param>
        Friend Function TakeWhileClause(skipOrTakeKeyword As KeywordSyntax, whileKeyword As KeywordSyntax, condition As ExpressionSyntax) As PartitionWhileClauseSyntax
            Debug.Assert(skipOrTakeKeyword IsNot Nothing AndAlso skipOrTakeKeyword.Kind = SyntaxKind.TakeKeyword)
            Debug.Assert(whileKeyword IsNot Nothing AndAlso whileKeyword.Kind = SyntaxKind.WhileKeyword)
            Debug.Assert(condition IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.TakeWhileClause, skipOrTakeKeyword, whileKeyword, condition, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, PartitionWhileClauseSyntax)
            End If

            Dim result = New PartitionWhileClauseSyntax(SyntaxKind.TakeWhileClause, skipOrTakeKeyword, whileKeyword, condition, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Skip While" or "Take While" query operator. The Kind property
        ''' tells which.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' PartitionWhileClauseSyntax. One of SkipWhileClause, TakeWhileClause.
        ''' </param>
        ''' <param name="skipOrTakeKeyword">
        ''' The "Skip" or "Take" keyword.
        ''' </param>
        ''' <param name="whileKeyword">
        ''' The "While" keyword.
        ''' </param>
        ''' <param name="condition">
        ''' The boolean expression used for partitioning.
        ''' </param>
        Friend Function PartitionWhileClause(kind As SyntaxKind, skipOrTakeKeyword As KeywordSyntax, whileKeyword As KeywordSyntax, condition As ExpressionSyntax) As PartitionWhileClauseSyntax
            Debug.Assert(SyntaxFacts.IsPartitionWhileClause(kind))
            Debug.Assert(skipOrTakeKeyword IsNot Nothing AndAlso SyntaxFacts.IsPartitionWhileClauseSkipOrTakeKeyword(skipOrTakeKeyword.Kind))
            Debug.Assert(whileKeyword IsNot Nothing AndAlso whileKeyword.Kind = SyntaxKind.WhileKeyword)
            Debug.Assert(condition IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(kind, skipOrTakeKeyword, whileKeyword, condition, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, PartitionWhileClauseSyntax)
            End If

            Dim result = New PartitionWhileClauseSyntax(kind, skipOrTakeKeyword, whileKeyword, condition, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Skip" or "Take" query operator. The Kind property tells which.
        ''' </summary>
        ''' <param name="skipOrTakeKeyword">
        ''' The "Skip" or "Take" keyword.
        ''' </param>
        ''' <param name="count">
        ''' Represents the expression with the number of items to take or skip.
        ''' </param>
        Friend Function SkipClause(skipOrTakeKeyword As KeywordSyntax, count As ExpressionSyntax) As PartitionClauseSyntax
            Debug.Assert(skipOrTakeKeyword IsNot Nothing AndAlso skipOrTakeKeyword.Kind = SyntaxKind.SkipKeyword)
            Debug.Assert(count IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.SkipClause, skipOrTakeKeyword, count, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, PartitionClauseSyntax)
            End If

            Dim result = New PartitionClauseSyntax(SyntaxKind.SkipClause, skipOrTakeKeyword, count, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Skip" or "Take" query operator. The Kind property tells which.
        ''' </summary>
        ''' <param name="skipOrTakeKeyword">
        ''' The "Skip" or "Take" keyword.
        ''' </param>
        ''' <param name="count">
        ''' Represents the expression with the number of items to take or skip.
        ''' </param>
        Friend Function TakeClause(skipOrTakeKeyword As KeywordSyntax, count As ExpressionSyntax) As PartitionClauseSyntax
            Debug.Assert(skipOrTakeKeyword IsNot Nothing AndAlso skipOrTakeKeyword.Kind = SyntaxKind.TakeKeyword)
            Debug.Assert(count IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.TakeClause, skipOrTakeKeyword, count, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, PartitionClauseSyntax)
            End If

            Dim result = New PartitionClauseSyntax(SyntaxKind.TakeClause, skipOrTakeKeyword, count, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a "Skip" or "Take" query operator. The Kind property tells which.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' PartitionClauseSyntax. One of SkipClause, TakeClause.
        ''' </param>
        ''' <param name="skipOrTakeKeyword">
        ''' The "Skip" or "Take" keyword.
        ''' </param>
        ''' <param name="count">
        ''' Represents the expression with the number of items to take or skip.
        ''' </param>
        Friend Function PartitionClause(kind As SyntaxKind, skipOrTakeKeyword As KeywordSyntax, count As ExpressionSyntax) As PartitionClauseSyntax
            Debug.Assert(SyntaxFacts.IsPartitionClause(kind))
            Debug.Assert(skipOrTakeKeyword IsNot Nothing AndAlso SyntaxFacts.IsPartitionClauseSkipOrTakeKeyword(skipOrTakeKeyword.Kind))
            Debug.Assert(count IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(kind, skipOrTakeKeyword, count, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, PartitionClauseSyntax)
            End If

            Dim result = New PartitionClauseSyntax(kind, skipOrTakeKeyword, count, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the "Group By" query operator.
        ''' </summary>
        ''' <param name="groupKeyword">
        ''' The "Group" keyword.
        ''' </param>
        ''' <param name="items">
        ''' The optional list of variables being grouped; the contents of the Group clause.
        ''' If none were specified, an empty list is returned.
        ''' </param>
        ''' <param name="byKeyword">
        ''' The "By" keyword.
        ''' </param>
        ''' <param name="keys">
        ''' The key values being used for grouping.
        ''' </param>
        ''' <param name="aggregationVariables">
        ''' The list of new variables that calculate aggregations.
        ''' </param>
        Friend Function GroupByClause(groupKeyword As KeywordSyntax, items As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), byKeyword As KeywordSyntax, keys As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), intoKeyword As KeywordSyntax, aggregationVariables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As GroupByClauseSyntax
            Debug.Assert(groupKeyword IsNot Nothing AndAlso groupKeyword.Kind = SyntaxKind.GroupKeyword)
            Debug.Assert(byKeyword IsNot Nothing AndAlso byKeyword.Kind = SyntaxKind.ByKeyword)
            Debug.Assert(intoKeyword IsNot Nothing AndAlso intoKeyword.Kind = SyntaxKind.IntoKeyword)
            Return New GroupByClauseSyntax(SyntaxKind.GroupByClause, groupKeyword, items.Node, byKeyword, keys.Node, intoKeyword, aggregationVariables.Node, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents the "expression Equals expression" condition in a Join.
        ''' </summary>
        ''' <param name="left">
        ''' The left expression in the Join condition.
        ''' </param>
        ''' <param name="equalsKeyword">
        ''' The "Equals" keyword.
        ''' </param>
        ''' <param name="right">
        ''' The right expression in the Join condition.
        ''' </param>
        Friend Function JoinCondition(left As ExpressionSyntax, equalsKeyword As KeywordSyntax, right As ExpressionSyntax) As JoinConditionSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(equalsKeyword IsNot Nothing AndAlso equalsKeyword.Kind = SyntaxKind.EqualsKeyword)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.JoinCondition, left, equalsKeyword, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, JoinConditionSyntax)
            End If

            Dim result = New JoinConditionSyntax(SyntaxKind.JoinCondition, left, equalsKeyword, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a Join query operator.
        ''' </summary>
        ''' <param name="joinKeyword">
        ''' The "Join" keyword.
        ''' </param>
        ''' <param name="joinedVariables">
        ''' Defines the collection range variables being joined to.
        ''' </param>
        ''' <param name="additionalJoins">
        ''' An additional Join or Group Join query operator.
        ''' </param>
        ''' <param name="onKeyword">
        ''' The "On" keyword.
        ''' </param>
        ''' <param name="joinConditions">
        ''' The conditions indicating what expressions to compare during the join. Each
        ''' condition is a JoinCondition, and the separators are "And" keywords.
        ''' </param>
        Friend Function SimpleJoinClause(joinKeyword As KeywordSyntax, joinedVariables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), additionalJoins As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), onKeyword As KeywordSyntax, joinConditions As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As SimpleJoinClauseSyntax
            Debug.Assert(joinKeyword IsNot Nothing AndAlso joinKeyword.Kind = SyntaxKind.JoinKeyword)
            Debug.Assert(onKeyword IsNot Nothing AndAlso onKeyword.Kind = SyntaxKind.OnKeyword)
            Return New SimpleJoinClauseSyntax(SyntaxKind.SimpleJoinClause, joinKeyword, joinedVariables.Node, additionalJoins.Node, onKeyword, joinConditions.Node, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents the "Group Join" query operator.
        ''' </summary>
        ''' <param name="groupKeyword">
        ''' The "Group" keyword.
        ''' </param>
        ''' <param name="joinKeyword">
        ''' The "Join" keyword.
        ''' </param>
        ''' <param name="joinedVariables">
        ''' Defines the collection range variables being joined to.
        ''' </param>
        ''' <param name="additionalJoins">
        ''' An additional Join or Group Join query operator.
        ''' </param>
        ''' <param name="onKeyword">
        ''' The "On" keyword.
        ''' </param>
        ''' <param name="joinConditions">
        ''' The conditions indicating what expressions to compare during the join. Each
        ''' condition is a JoinCondition, and the separators are "And" keywords.
        ''' </param>
        ''' <param name="intoKeyword">
        ''' The "Into" keyword.
        ''' </param>
        ''' <param name="aggregationVariables">
        ''' The list of new variables that calculate aggregations.
        ''' </param>
        Friend Function GroupJoinClause(groupKeyword As KeywordSyntax, joinKeyword As KeywordSyntax, joinedVariables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), additionalJoins As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), onKeyword As KeywordSyntax, joinConditions As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), intoKeyword As KeywordSyntax, aggregationVariables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As GroupJoinClauseSyntax
            Debug.Assert(groupKeyword IsNot Nothing AndAlso groupKeyword.Kind = SyntaxKind.GroupKeyword)
            Debug.Assert(joinKeyword IsNot Nothing AndAlso joinKeyword.Kind = SyntaxKind.JoinKeyword)
            Debug.Assert(onKeyword IsNot Nothing AndAlso onKeyword.Kind = SyntaxKind.OnKeyword)
            Debug.Assert(intoKeyword IsNot Nothing AndAlso intoKeyword.Kind = SyntaxKind.IntoKeyword)
            Return New GroupJoinClauseSyntax(SyntaxKind.GroupJoinClause, groupKeyword, joinKeyword, joinedVariables.Node, additionalJoins.Node, onKeyword, joinConditions.Node, intoKeyword, aggregationVariables.Node, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents the "Order By" query operator.
        ''' </summary>
        ''' <param name="orderKeyword">
        ''' The "Order" keyword
        ''' </param>
        ''' <param name="byKeyword">
        ''' The "By" keyword.
        ''' </param>
        ''' <param name="orderings">
        ''' The list of OrderExpression's to sort by.
        ''' </param>
        Friend Function OrderByClause(orderKeyword As KeywordSyntax, byKeyword As KeywordSyntax, orderings As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As OrderByClauseSyntax
            Debug.Assert(orderKeyword IsNot Nothing AndAlso orderKeyword.Kind = SyntaxKind.OrderKeyword)
            Debug.Assert(byKeyword IsNot Nothing AndAlso byKeyword.Kind = SyntaxKind.ByKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.OrderByClause, orderKeyword, byKeyword, orderings.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, OrderByClauseSyntax)
            End If

            Dim result = New OrderByClauseSyntax(SyntaxKind.OrderByClause, orderKeyword, byKeyword, orderings.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An expression to order by, plus an optional ordering. The Kind indicates
        ''' whether to order in ascending or descending order.
        ''' </summary>
        ''' <param name="expression">
        ''' The expression to sort by.
        ''' </param>
        ''' <param name="ascendingOrDescendingKeyword">
        ''' The "Ascending" or "Descending" keyword, if present. To determine whether to
        ''' sort in ascending or descending order, checking the Kind property is easier.
        ''' </param>
        Friend Function AscendingOrdering(expression As ExpressionSyntax, ascendingOrDescendingKeyword As KeywordSyntax) As OrderingSyntax
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.AscendingOrdering, expression, ascendingOrDescendingKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, OrderingSyntax)
            End If

            Dim result = New OrderingSyntax(SyntaxKind.AscendingOrdering, expression, ascendingOrDescendingKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An expression to order by, plus an optional ordering. The Kind indicates
        ''' whether to order in ascending or descending order.
        ''' </summary>
        ''' <param name="expression">
        ''' The expression to sort by.
        ''' </param>
        ''' <param name="ascendingOrDescendingKeyword">
        ''' The "Ascending" or "Descending" keyword, if present. To determine whether to
        ''' sort in ascending or descending order, checking the Kind property is easier.
        ''' </param>
        Friend Function DescendingOrdering(expression As ExpressionSyntax, ascendingOrDescendingKeyword As KeywordSyntax) As OrderingSyntax
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.DescendingOrdering, expression, ascendingOrDescendingKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, OrderingSyntax)
            End If

            Dim result = New OrderingSyntax(SyntaxKind.DescendingOrdering, expression, ascendingOrDescendingKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' An expression to order by, plus an optional ordering. The Kind indicates
        ''' whether to order in ascending or descending order.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of OrderingSyntax.
        ''' One of AscendingOrdering, DescendingOrdering.
        ''' </param>
        ''' <param name="expression">
        ''' The expression to sort by.
        ''' </param>
        ''' <param name="ascendingOrDescendingKeyword">
        ''' The "Ascending" or "Descending" keyword, if present. To determine whether to
        ''' sort in ascending or descending order, checking the Kind property is easier.
        ''' </param>
        Friend Function Ordering(kind As SyntaxKind, expression As ExpressionSyntax, ascendingOrDescendingKeyword As KeywordSyntax) As OrderingSyntax
            Debug.Assert(SyntaxFacts.IsOrdering(kind))
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(kind, expression, ascendingOrDescendingKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, OrderingSyntax)
            End If

            Dim result = New OrderingSyntax(kind, expression, ascendingOrDescendingKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the "Select" query operator.
        ''' </summary>
        ''' <param name="selectKeyword">
        ''' The "Select" keyword.
        ''' </param>
        ''' <param name="variables">
        ''' The list of expression range variables being defined by the Select query
        ''' operator.
        ''' </param>
        Friend Function SelectClause(selectKeyword As KeywordSyntax, variables As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As SelectClauseSyntax
            Debug.Assert(selectKeyword IsNot Nothing AndAlso selectKeyword.Kind = SyntaxKind.SelectKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.SelectClause, selectKeyword, variables.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, SelectClauseSyntax)
            End If

            Dim result = New SelectClauseSyntax(SyntaxKind.SelectClause, selectKeyword, variables.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an XML Document literal expression.
        ''' </summary>
        Friend Function XmlDocument(declaration As XmlDeclarationSyntax, precedingMisc As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), root As XmlNodeSyntax, followingMisc As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As XmlDocumentSyntax
            Debug.Assert(declaration IsNot Nothing)
            Debug.Assert(root IsNot Nothing)
            Return New XmlDocumentSyntax(SyntaxKind.XmlDocument, declaration, precedingMisc.Node, root, followingMisc.Node, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents the XML declaration prologue in an XML literal expression.
        ''' </summary>
        Friend Function XmlDeclaration(lessThanQuestionToken As PunctuationSyntax, xmlKeyword As KeywordSyntax, version As XmlDeclarationOptionSyntax, encoding As XmlDeclarationOptionSyntax, standalone As XmlDeclarationOptionSyntax, questionGreaterThanToken As PunctuationSyntax) As XmlDeclarationSyntax
            Debug.Assert(lessThanQuestionToken IsNot Nothing AndAlso lessThanQuestionToken.Kind = SyntaxKind.LessThanQuestionToken)
            Debug.Assert(xmlKeyword IsNot Nothing AndAlso xmlKeyword.Kind = SyntaxKind.XmlKeyword)
            Debug.Assert(version IsNot Nothing)
            Debug.Assert(questionGreaterThanToken IsNot Nothing AndAlso questionGreaterThanToken.Kind = SyntaxKind.QuestionGreaterThanToken)
            Return New XmlDeclarationSyntax(SyntaxKind.XmlDeclaration, lessThanQuestionToken, xmlKeyword, version, encoding, standalone, questionGreaterThanToken, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an XML document prologue option - version, encoding, standalone or
        ''' whitespace in an XML literal expression.
        ''' </summary>
        Friend Function XmlDeclarationOption(name As XmlNameTokenSyntax, equals As PunctuationSyntax, value As XmlStringSyntax) As XmlDeclarationOptionSyntax
            Debug.Assert(name IsNot Nothing AndAlso name.Kind = SyntaxKind.XmlNameToken)
            Debug.Assert(equals IsNot Nothing AndAlso equals.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.XmlDeclarationOption, name, equals, value, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlDeclarationOptionSyntax)
            End If

            Dim result = New XmlDeclarationOptionSyntax(SyntaxKind.XmlDeclarationOption, name, equals, value, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an XML element with content in an XML literal expression.
        ''' </summary>
        Friend Function XmlElement(startTag As XmlElementStartTagSyntax, content As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endTag As XmlElementEndTagSyntax) As XmlElementSyntax
            Debug.Assert(startTag IsNot Nothing)
            Debug.Assert(endTag IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.XmlElement, startTag, content.Node, endTag, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlElementSyntax)
            End If

            Dim result = New XmlElementSyntax(SyntaxKind.XmlElement, startTag, content.Node, endTag, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents Xml text.
        ''' </summary>
        ''' <param name="textTokens">
        ''' A list of all the text tokens in the Xml text. This list always contains at
        ''' least one token.
        ''' </param>
        Friend Function XmlText(textTokens As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As XmlTextSyntax

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.XmlText, textTokens.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlTextSyntax)
            End If

            Dim result = New XmlTextSyntax(SyntaxKind.XmlText, textTokens.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents the start tag of an XML element of the form &lt;element&gt;.
        ''' </summary>
        Friend Function XmlElementStartTag(lessThanToken As PunctuationSyntax, name As XmlNodeSyntax, attributes As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), greaterThanToken As PunctuationSyntax) As XmlElementStartTagSyntax
            Debug.Assert(lessThanToken IsNot Nothing AndAlso lessThanToken.Kind = SyntaxKind.LessThanToken)
            Debug.Assert(name IsNot Nothing)
            Debug.Assert(greaterThanToken IsNot Nothing AndAlso greaterThanToken.Kind = SyntaxKind.GreaterThanToken)
            Return New XmlElementStartTagSyntax(SyntaxKind.XmlElementStartTag, lessThanToken, name, attributes.Node, greaterThanToken, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents the end tag of an XML element of the form &lt;/element&gt;.
        ''' </summary>
        Friend Function XmlElementEndTag(lessThanSlashToken As PunctuationSyntax, name As XmlNameSyntax, greaterThanToken As PunctuationSyntax) As XmlElementEndTagSyntax
            Debug.Assert(lessThanSlashToken IsNot Nothing AndAlso lessThanSlashToken.Kind = SyntaxKind.LessThanSlashToken)
            Debug.Assert(greaterThanToken IsNot Nothing AndAlso greaterThanToken.Kind = SyntaxKind.GreaterThanToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlElementEndTagSyntax)
            End If

            Dim result = New XmlElementEndTagSyntax(SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an empty XML element of the form &lt;element /&gt;
        ''' </summary>
        Friend Function XmlEmptyElement(lessThanToken As PunctuationSyntax, name As XmlNodeSyntax, attributes As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), slashGreaterThanToken As PunctuationSyntax) As XmlEmptyElementSyntax
            Debug.Assert(lessThanToken IsNot Nothing AndAlso lessThanToken.Kind = SyntaxKind.LessThanToken)
            Debug.Assert(name IsNot Nothing)
            Debug.Assert(slashGreaterThanToken IsNot Nothing AndAlso slashGreaterThanToken.Kind = SyntaxKind.SlashGreaterThanToken)
            Return New XmlEmptyElementSyntax(SyntaxKind.XmlEmptyElement, lessThanToken, name, attributes.Node, slashGreaterThanToken, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an XML attribute in an XML literal expression.
        ''' </summary>
        Friend Function XmlAttribute(name As XmlNodeSyntax, equalsToken As PunctuationSyntax, value As XmlNodeSyntax) As XmlAttributeSyntax
            Debug.Assert(name IsNot Nothing)
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.XmlAttribute, name, equalsToken, value, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlAttributeSyntax)
            End If

            Dim result = New XmlAttributeSyntax(SyntaxKind.XmlAttribute, name, equalsToken, value, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a string of XML characters embedded as the content of an XML
        ''' element.
        ''' </summary>
        Friend Function XmlString(startQuoteToken As PunctuationSyntax, textTokens As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endQuoteToken As PunctuationSyntax) As XmlStringSyntax
            Debug.Assert(startQuoteToken IsNot Nothing AndAlso SyntaxFacts.IsXmlStringStartQuoteToken(startQuoteToken.Kind))
            Debug.Assert(endQuoteToken IsNot Nothing AndAlso SyntaxFacts.IsXmlStringEndQuoteToken(endQuoteToken.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.XmlString, startQuoteToken, textTokens.Node, endQuoteToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlStringSyntax)
            End If

            Dim result = New XmlStringSyntax(SyntaxKind.XmlString, startQuoteToken, textTokens.Node, endQuoteToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an XML name of the form 'name' appearing in GetXmlNamespace().
        ''' </summary>
        Friend Function XmlPrefixName(name As XmlNameTokenSyntax) As XmlPrefixNameSyntax
            Debug.Assert(name IsNot Nothing AndAlso name.Kind = SyntaxKind.XmlNameToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.XmlPrefixName, name, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlPrefixNameSyntax)
            End If

            Dim result = New XmlPrefixNameSyntax(SyntaxKind.XmlPrefixName, name, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an XML name of the form 'name' or 'namespace:name' appearing in
        ''' source as part of an XML literal or member access expression or an XML
        ''' namespace import clause.
        ''' </summary>
        Friend Function XmlName(prefix As XmlPrefixSyntax, localName As XmlNameTokenSyntax) As XmlNameSyntax
            Debug.Assert(localName IsNot Nothing AndAlso localName.Kind = SyntaxKind.XmlNameToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.XmlName, prefix, localName, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlNameSyntax)
            End If

            Dim result = New XmlNameSyntax(SyntaxKind.XmlName, prefix, localName, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an XML name of the form &lt;xml-name&gt; appearing in source as part
        ''' of an XML literal or member access expression or an XML namespace import
        ''' clause.
        ''' </summary>
        Friend Function XmlBracketedName(lessThanToken As PunctuationSyntax, name As XmlNameSyntax, greaterThanToken As PunctuationSyntax) As XmlBracketedNameSyntax
            Debug.Assert(lessThanToken IsNot Nothing AndAlso lessThanToken.Kind = SyntaxKind.LessThanToken)
            Debug.Assert(name IsNot Nothing)
            Debug.Assert(greaterThanToken IsNot Nothing AndAlso greaterThanToken.Kind = SyntaxKind.GreaterThanToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.XmlBracketedName, lessThanToken, name, greaterThanToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlBracketedNameSyntax)
            End If

            Dim result = New XmlBracketedNameSyntax(SyntaxKind.XmlBracketedName, lessThanToken, name, greaterThanToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an XML namespace prefix of the form 'prefix:' as in xml:ns="".
        ''' </summary>
        Friend Function XmlPrefix(name As XmlNameTokenSyntax, colonToken As PunctuationSyntax) As XmlPrefixSyntax
            Debug.Assert(name IsNot Nothing AndAlso name.Kind = SyntaxKind.XmlNameToken)
            Debug.Assert(colonToken IsNot Nothing AndAlso colonToken.Kind = SyntaxKind.ColonToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.XmlPrefix, name, colonToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlPrefixSyntax)
            End If

            Dim result = New XmlPrefixSyntax(SyntaxKind.XmlPrefix, name, colonToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an XML comment of the form &lt;!-- Comment --&gt; appearing in an
        ''' XML literal expression.
        ''' </summary>
        Friend Function XmlComment(lessThanExclamationMinusMinusToken As PunctuationSyntax, textTokens As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), minusMinusGreaterThanToken As PunctuationSyntax) As XmlCommentSyntax
            Debug.Assert(lessThanExclamationMinusMinusToken IsNot Nothing AndAlso lessThanExclamationMinusMinusToken.Kind = SyntaxKind.LessThanExclamationMinusMinusToken)
            Debug.Assert(minusMinusGreaterThanToken IsNot Nothing AndAlso minusMinusGreaterThanToken.Kind = SyntaxKind.MinusMinusGreaterThanToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlCommentSyntax)
            End If

            Dim result = New XmlCommentSyntax(SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an XML processing instruction of the form '&lt;? XMLProcessingTarget
        ''' XMLProcessingValue ?&gt;'.
        ''' </summary>
        Friend Function XmlProcessingInstruction(lessThanQuestionToken As PunctuationSyntax, name As XmlNameTokenSyntax, textTokens As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), questionGreaterThanToken As PunctuationSyntax) As XmlProcessingInstructionSyntax
            Debug.Assert(lessThanQuestionToken IsNot Nothing AndAlso lessThanQuestionToken.Kind = SyntaxKind.LessThanQuestionToken)
            Debug.Assert(name IsNot Nothing AndAlso name.Kind = SyntaxKind.XmlNameToken)
            Debug.Assert(questionGreaterThanToken IsNot Nothing AndAlso questionGreaterThanToken.Kind = SyntaxKind.QuestionGreaterThanToken)
            Return New XmlProcessingInstructionSyntax(SyntaxKind.XmlProcessingInstruction, lessThanQuestionToken, name, textTokens.Node, questionGreaterThanToken, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an XML CDATA section in an XML literal expression.
        ''' </summary>
        Friend Function XmlCDataSection(beginCDataToken As PunctuationSyntax, textTokens As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), endCDataToken As PunctuationSyntax) As XmlCDataSectionSyntax
            Debug.Assert(beginCDataToken IsNot Nothing AndAlso beginCDataToken.Kind = SyntaxKind.BeginCDataToken)
            Debug.Assert(endCDataToken IsNot Nothing AndAlso endCDataToken.Kind = SyntaxKind.EndCDataToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.XmlCDataSection, beginCDataToken, textTokens.Node, endCDataToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlCDataSectionSyntax)
            End If

            Dim result = New XmlCDataSectionSyntax(SyntaxKind.XmlCDataSection, beginCDataToken, textTokens.Node, endCDataToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an embedded expression in an XML literal e.g. '&lt;name&gt;&lt;%=
        ''' obj.Name =%&gt;&lt;/name&gt;'.
        ''' </summary>
        Friend Function XmlEmbeddedExpression(lessThanPercentEqualsToken As PunctuationSyntax, expression As ExpressionSyntax, percentGreaterThanToken As PunctuationSyntax) As XmlEmbeddedExpressionSyntax
            Debug.Assert(lessThanPercentEqualsToken IsNot Nothing AndAlso lessThanPercentEqualsToken.Kind = SyntaxKind.LessThanPercentEqualsToken)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(percentGreaterThanToken IsNot Nothing AndAlso percentGreaterThanToken.Kind = SyntaxKind.PercentGreaterThanToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.XmlEmbeddedExpression, lessThanPercentEqualsToken, expression, percentGreaterThanToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, XmlEmbeddedExpressionSyntax)
            End If

            Dim result = New XmlEmbeddedExpressionSyntax(SyntaxKind.XmlEmbeddedExpression, lessThanPercentEqualsToken, expression, percentGreaterThanToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an array type, such as "A() or "A(,)", without bounds specified for
        ''' the array.
        ''' </summary>
        ''' <param name="elementType">
        ''' The type of the elements of the array.
        ''' </param>
        ''' <param name="rankSpecifiers">
        ''' Represents the list of "()" or "(,,)" modifiers on the array type.
        ''' </param>
        Friend Function ArrayType(elementType As TypeSyntax, rankSpecifiers As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As ArrayTypeSyntax
            Debug.Assert(elementType IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ArrayType, elementType, rankSpecifiers.Node, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ArrayTypeSyntax)
            End If

            Dim result = New ArrayTypeSyntax(SyntaxKind.ArrayType, elementType, rankSpecifiers.Node, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' A type name that represents a nullable type, such as "Integer?".
        ''' </summary>
        ''' <param name="elementType">
        ''' The kind of type that is this type is a nullable of. Cannot be an array type or
        ''' a nullable type.
        ''' </param>
        ''' <param name="questionMarkToken">
        ''' The "?" token.
        ''' </param>
        Friend Function NullableType(elementType As TypeSyntax, questionMarkToken As PunctuationSyntax) As NullableTypeSyntax
            Debug.Assert(elementType IsNot Nothing)
            Debug.Assert(questionMarkToken IsNot Nothing AndAlso questionMarkToken.Kind = SyntaxKind.QuestionToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.NullableType, elementType, questionMarkToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, NullableTypeSyntax)
            End If

            Dim result = New NullableTypeSyntax(SyntaxKind.NullableType, elementType, questionMarkToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an occurrence of a Visual Basic built-in type such as Integer or
        ''' String in source code.
        ''' </summary>
        ''' <param name="keyword">
        ''' The keyword that was used to describe the built-in type.
        ''' </param>
        Friend Function PredefinedType(keyword As KeywordSyntax) As PredefinedTypeSyntax
            Debug.Assert(keyword IsNot Nothing AndAlso SyntaxFacts.IsPredefinedTypeKeyword(keyword.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.PredefinedType, keyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, PredefinedTypeSyntax)
            End If

            Dim result = New PredefinedTypeSyntax(SyntaxKind.PredefinedType, keyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a type name consisting of a single identifier (which might include
        ''' brackets or a type character).
        ''' </summary>
        ''' <param name="identifier">
        ''' The identifier in the name.
        ''' </param>
        Friend Function IdentifierName(identifier As IdentifierTokenSyntax) As IdentifierNameSyntax
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.IdentifierName, identifier, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, IdentifierNameSyntax)
            End If

            Dim result = New IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a simple type name with one or more generic arguments, such as "X(Of
        ''' Y, Z).
        ''' </summary>
        ''' <param name="identifier">
        ''' The identifier in the name.
        ''' </param>
        ''' <param name="typeArgumentList">
        ''' The generic argument list.
        ''' </param>
        Friend Function GenericName(identifier As IdentifierTokenSyntax, typeArgumentList As TypeArgumentListSyntax) As GenericNameSyntax
            Debug.Assert(identifier IsNot Nothing AndAlso identifier.Kind = SyntaxKind.IdentifierToken)
            Debug.Assert(typeArgumentList IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.GenericName, identifier, typeArgumentList, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, GenericNameSyntax)
            End If

            Dim result = New GenericNameSyntax(SyntaxKind.GenericName, identifier, typeArgumentList, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a qualified type name, for example X.Y or X(Of Z).Y.
        ''' </summary>
        ''' <param name="left">
        ''' The part of the name that appears to the left of the dot. This can itself be
        ''' any name.
        ''' </param>
        ''' <param name="dotToken">
        ''' The "." token that separates the names.
        ''' </param>
        ''' <param name="right">
        ''' The part of the name that appears to the right of the dot. This must be a
        ''' simple identifier.
        ''' </param>
        Friend Function QualifiedName(left As NameSyntax, dotToken As PunctuationSyntax, right As SimpleNameSyntax) As QualifiedNameSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(dotToken IsNot Nothing AndAlso dotToken.Kind = SyntaxKind.DotToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.QualifiedName, left, dotToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, QualifiedNameSyntax)
            End If

            Dim result = New QualifiedNameSyntax(SyntaxKind.QualifiedName, left, dotToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a name in the global namespace.
        ''' </summary>
        ''' <param name="globalKeyword">
        ''' The "Global" keyword.
        ''' </param>
        Friend Function GlobalName(globalKeyword As KeywordSyntax) As GlobalNameSyntax
            Debug.Assert(globalKeyword IsNot Nothing AndAlso globalKeyword.Kind = SyntaxKind.GlobalKeyword)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.GlobalName, globalKeyword, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, GlobalNameSyntax)
            End If

            Dim result = New GlobalNameSyntax(SyntaxKind.GlobalName, globalKeyword, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a parenthesized list of generic type arguments.
        ''' </summary>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="ofKeyword">
        ''' The "Of" keyword.
        ''' </param>
        ''' <param name="arguments">
        ''' A list of all the type arguments.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Function TypeArgumentList(openParenToken As PunctuationSyntax, ofKeyword As KeywordSyntax, arguments As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), closeParenToken As PunctuationSyntax) As TypeArgumentListSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(ofKeyword IsNot Nothing AndAlso ofKeyword.Kind = SyntaxKind.OfKeyword)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New TypeArgumentListSyntax(SyntaxKind.TypeArgumentList, openParenToken, ofKeyword, arguments.Node, closeParenToken, _factoryContext)
        End Function


        ''' <summary>
        ''' Syntax node class that represents a value of 'cref' attribute inside
        ''' documentation comment trivia.
        ''' </summary>
        Friend Function CrefReference(name As TypeSyntax, signature As CrefSignatureSyntax, asClause As SimpleAsClauseSyntax) As CrefReferenceSyntax
            Debug.Assert(name IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.CrefReference, name, signature, asClause, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CrefReferenceSyntax)
            End If

            Dim result = New CrefReferenceSyntax(SyntaxKind.CrefReference, name, signature, asClause, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a parenthesized list of argument types for a signature inside
        ''' CrefReferenceSyntax syntax.
        ''' </summary>
        Friend Function CrefSignature(openParenToken As PunctuationSyntax, argumentTypes As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode), closeParenToken As PunctuationSyntax) As CrefSignatureSyntax
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.CrefSignature, openParenToken, argumentTypes.Node, closeParenToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CrefSignatureSyntax)
            End If

            Dim result = New CrefSignatureSyntax(SyntaxKind.CrefSignature, openParenToken, argumentTypes.Node, closeParenToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        Friend Function CrefSignaturePart(modifier As KeywordSyntax, type As TypeSyntax) As CrefSignaturePartSyntax

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.CrefSignaturePart, modifier, type, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CrefSignaturePartSyntax)
            End If

            Dim result = New CrefSignaturePartSyntax(SyntaxKind.CrefSignaturePart, modifier, type, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        Friend Function CrefOperatorReference(operatorKeyword As KeywordSyntax, operatorToken As SyntaxToken) As CrefOperatorReferenceSyntax
            Debug.Assert(operatorKeyword IsNot Nothing AndAlso operatorKeyword.Kind = SyntaxKind.OperatorKeyword)
            Debug.Assert(operatorToken IsNot Nothing AndAlso SyntaxFacts.IsCrefOperatorReferenceOperatorToken(operatorToken.Kind))

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.CrefOperatorReference, operatorKeyword, operatorToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, CrefOperatorReferenceSyntax)
            End If

            Dim result = New CrefOperatorReferenceSyntax(SyntaxKind.CrefOperatorReference, operatorKeyword, operatorToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        Friend Function QualifiedCrefOperatorReference(left As NameSyntax, dotToken As PunctuationSyntax, right As CrefOperatorReferenceSyntax) As QualifiedCrefOperatorReferenceSyntax
            Debug.Assert(left IsNot Nothing)
            Debug.Assert(dotToken IsNot Nothing AndAlso dotToken.Kind = SyntaxKind.DotToken)
            Debug.Assert(right IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.QualifiedCrefOperatorReference, left, dotToken, right, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, QualifiedCrefOperatorReferenceSyntax)
            End If

            Dim result = New QualifiedCrefOperatorReferenceSyntax(SyntaxKind.QualifiedCrefOperatorReference, left, dotToken, right, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represent a Yield statement.
        ''' </summary>
        ''' <param name="yieldKeyword">
        ''' The "Yield" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression whose value is being yielded.
        ''' </param>
        Friend Function YieldStatement(yieldKeyword As KeywordSyntax, expression As ExpressionSyntax) As YieldStatementSyntax
            Debug.Assert(yieldKeyword IsNot Nothing AndAlso yieldKeyword.Kind = SyntaxKind.YieldKeyword)
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.YieldStatement, yieldKeyword, expression, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, YieldStatementSyntax)
            End If

            Dim result = New YieldStatementSyntax(SyntaxKind.YieldStatement, yieldKeyword, expression, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an Await expression.
        ''' </summary>
        ''' <param name="awaitKeyword">
        ''' The "Await" keyword.
        ''' </param>
        ''' <param name="expression">
        ''' The expression being awaited.
        ''' </param>
        Friend Function AwaitExpression(awaitKeyword As KeywordSyntax, expression As ExpressionSyntax) As AwaitExpressionSyntax
            Debug.Assert(awaitKeyword IsNot Nothing AndAlso awaitKeyword.Kind = SyntaxKind.AwaitKeyword)
            Debug.Assert(expression IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.AwaitExpression, awaitKeyword, expression, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, AwaitExpressionSyntax)
            End If

            Dim result = New AwaitExpressionSyntax(SyntaxKind.AwaitExpression, awaitKeyword, expression, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an Xml NCName per Namespaces in XML 1.0
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Function XmlNameToken(text as String, possibleKeywordKind As SyntaxKind, leadingTrivia As GreenNode, trailingTrivia As GreenNode) As XmlNameTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New XmlNameTokenSyntax(SyntaxKind.XmlNameToken, text, leadingTrivia, trailingTrivia, possibleKeywordKind, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents character data in Xml content also known as PCData or in an Xml
        ''' attribute value. All text is here for now even text that does not need
        ''' normalization such as comment, pi and cdata text.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Function XmlTextLiteralToken(text as String, value As String, leadingTrivia As GreenNode, trailingTrivia As GreenNode) As XmlTextTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New XmlTextTokenSyntax(SyntaxKind.XmlTextLiteralToken, text, leadingTrivia, trailingTrivia, value, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents character data in Xml content also known as PCData or in an Xml
        ''' attribute value. All text is here for now even text that does not need
        ''' normalization such as comment, pi and cdata text.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Function XmlEntityLiteralToken(text as String, value As String, leadingTrivia As GreenNode, trailingTrivia As GreenNode) As XmlTextTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New XmlTextTokenSyntax(SyntaxKind.XmlEntityLiteralToken, text, leadingTrivia, trailingTrivia, value, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents character data in Xml content also known as PCData or in an Xml
        ''' attribute value. All text is here for now even text that does not need
        ''' normalization such as comment, pi and cdata text.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Function DocumentationCommentLineBreakToken(text as String, value As String, leadingTrivia As GreenNode, trailingTrivia As GreenNode) As XmlTextTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New XmlTextTokenSyntax(SyntaxKind.DocumentationCommentLineBreakToken, text, leadingTrivia, trailingTrivia, value, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents character data in Xml content also known as PCData or in an Xml
        ''' attribute value. All text is here for now even text that does not need
        ''' normalization such as comment, pi and cdata text.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of
        ''' XmlTextTokenSyntax. One of XmlTextLiteralToken, XmlEntityLiteralToken,
        ''' DocumentationCommentLineBreakToken.
        ''' </param>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Function XmlTextToken(kind As SyntaxKind, text as String, value As String, leadingTrivia As GreenNode, trailingTrivia As GreenNode) As XmlTextTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Debug.Assert(SyntaxFacts.IsXmlTextToken(kind))
            Return New XmlTextTokenSyntax(kind, text, leadingTrivia, trailingTrivia, value, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents literal character data in interpolated string expression.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Function InterpolatedStringTextToken(text as String, value As String, leadingTrivia As GreenNode, trailingTrivia As GreenNode) As InterpolatedStringTextTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New InterpolatedStringTextTokenSyntax(SyntaxKind.InterpolatedStringTextToken, text, leadingTrivia, trailingTrivia, value, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a Decimal literal token.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Function DecimalLiteralToken(text as String, typeSuffix As TypeCharacter, value As System.Decimal, leadingTrivia As GreenNode, trailingTrivia As GreenNode) As DecimalLiteralTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New DecimalLiteralTokenSyntax(SyntaxKind.DecimalLiteralToken, text, leadingTrivia, trailingTrivia, typeSuffix, value, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a Date literal token.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Function DateLiteralToken(text as String, value As DateTime, leadingTrivia As GreenNode, trailingTrivia As GreenNode) As DateLiteralTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New DateLiteralTokenSyntax(SyntaxKind.DateLiteralToken, text, leadingTrivia, trailingTrivia, value, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a string literal token.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Function StringLiteralToken(text as String, value As String, leadingTrivia As GreenNode, trailingTrivia As GreenNode) As StringLiteralTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New StringLiteralTokenSyntax(SyntaxKind.StringLiteralToken, text, leadingTrivia, trailingTrivia, value, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a string literal token.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Function CharacterLiteralToken(text as String, value As Char, leadingTrivia As GreenNode, trailingTrivia As GreenNode) As CharacterLiteralTokenSyntax
            Debug.Assert(text IsNot Nothing)
            Return New CharacterLiteralTokenSyntax(SyntaxKind.CharacterLiteralToken, text, leadingTrivia, trailingTrivia, value, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents tokens that were skipped by the parser as part of error recovery,
        ''' and thus are not part of any syntactic structure.
        ''' </summary>
        ''' <param name="tokens">
        ''' The list of tokens that were skipped by the parser.
        ''' </param>
        Friend Function SkippedTokensTrivia(tokens As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As SkippedTokensTriviaSyntax
            Return New SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, tokens.Node, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a documentation comment e.g. ''' &lt;Summary&gt; appearing in
        ''' source.
        ''' </summary>
        Friend Function DocumentationCommentTrivia(content As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode)) As DocumentationCommentTriviaSyntax
            Return New DocumentationCommentTriviaSyntax(SyntaxKind.DocumentationCommentTrivia, content.Node, _factoryContext)
        End Function


        ''' <summary>
        ''' A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or
        ''' &lt;seealso&gt; documentation comment tag). For example, the M in &lt;see
        ''' cref="M" /&gt;.
        ''' </summary>
        Friend Function XmlCrefAttribute(name As XmlNameSyntax, equalsToken As PunctuationSyntax, startQuoteToken As PunctuationSyntax, reference As CrefReferenceSyntax, endQuoteToken As PunctuationSyntax) As XmlCrefAttributeSyntax
            Debug.Assert(name IsNot Nothing)
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(startQuoteToken IsNot Nothing AndAlso SyntaxFacts.IsXmlCrefAttributeStartQuoteToken(startQuoteToken.Kind))
            Debug.Assert(reference IsNot Nothing)
            Debug.Assert(endQuoteToken IsNot Nothing AndAlso SyntaxFacts.IsXmlCrefAttributeEndQuoteToken(endQuoteToken.Kind))
            Return New XmlCrefAttributeSyntax(SyntaxKind.XmlCrefAttribute, name, equalsToken, startQuoteToken, reference, endQuoteToken, _factoryContext)
        End Function


        ''' <summary>
        ''' A param or type param symbol referenced by a name attribute (e.g. in a
        ''' &lt;param&gt; or &lt;typeparam&gt; documentation comment tag). For example, the
        ''' M in &lt;param name="M" /&gt;.
        ''' </summary>
        Friend Function XmlNameAttribute(name As XmlNameSyntax, equalsToken As PunctuationSyntax, startQuoteToken As PunctuationSyntax, reference As IdentifierNameSyntax, endQuoteToken As PunctuationSyntax) As XmlNameAttributeSyntax
            Debug.Assert(name IsNot Nothing)
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(startQuoteToken IsNot Nothing AndAlso SyntaxFacts.IsXmlNameAttributeStartQuoteToken(startQuoteToken.Kind))
            Debug.Assert(reference IsNot Nothing)
            Debug.Assert(endQuoteToken IsNot Nothing AndAlso SyntaxFacts.IsXmlNameAttributeEndQuoteToken(endQuoteToken.Kind))
            Return New XmlNameAttributeSyntax(SyntaxKind.XmlNameAttribute, name, equalsToken, startQuoteToken, reference, endQuoteToken, _factoryContext)
        End Function


        ''' <summary>
        ''' ExpressionSyntax node representing the object conditionally accessed.
        ''' </summary>
        ''' <param name="expression">
        ''' The expression on the left-hand-side of the "?".
        ''' </param>
        ''' <param name="questionMarkToken">
        ''' "?" token.
        ''' </param>
        ''' <param name="whenNotNull">
        ''' ExpressionSyntax node representing the access expression to be executed when
        ''' the object is not null."
        ''' </param>
        Friend Function ConditionalAccessExpression(expression As ExpressionSyntax, questionMarkToken As PunctuationSyntax, whenNotNull As ExpressionSyntax) As ConditionalAccessExpressionSyntax
            Debug.Assert(questionMarkToken IsNot Nothing AndAlso questionMarkToken.Kind = SyntaxKind.QuestionToken)
            Debug.Assert(whenNotNull IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.ConditionalAccessExpression, expression, questionMarkToken, whenNotNull, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, ConditionalAccessExpressionSyntax)
            End If

            Dim result = New ConditionalAccessExpressionSyntax(SyntaxKind.ConditionalAccessExpression, expression, questionMarkToken, whenNotNull, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a NameOf expression.
        ''' </summary>
        ''' <param name="nameOfKeyword">
        ''' The "NameOf" keyword.
        ''' </param>
        ''' <param name="openParenToken">
        ''' The "(" token.
        ''' </param>
        ''' <param name="argument">
        ''' The argument.
        ''' </param>
        ''' <param name="closeParenToken">
        ''' The ")" token.
        ''' </param>
        Friend Function NameOfExpression(nameOfKeyword As KeywordSyntax, openParenToken As PunctuationSyntax, argument As ExpressionSyntax, closeParenToken As PunctuationSyntax) As NameOfExpressionSyntax
            Debug.Assert(nameOfKeyword IsNot Nothing AndAlso nameOfKeyword.Kind = SyntaxKind.NameOfKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(argument IsNot Nothing)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New NameOfExpressionSyntax(SyntaxKind.NameOfExpression, nameOfKeyword, openParenToken, argument, closeParenToken, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an interpolated string expression.
        ''' </summary>
        ''' <param name="dollarSignDoubleQuoteToken">
        ''' The opening '$"', '$“', or '$”' token.
        ''' </param>
        ''' <param name="contents">
        ''' The contents of the interpolated string.
        ''' </param>
        ''' <param name="doubleQuoteToken">
        ''' The closing '"', '”', or '“' token.
        ''' </param>
        Friend Function InterpolatedStringExpression(dollarSignDoubleQuoteToken As PunctuationSyntax, contents As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList(of GreenNode), doubleQuoteToken As PunctuationSyntax) As InterpolatedStringExpressionSyntax
            Debug.Assert(dollarSignDoubleQuoteToken IsNot Nothing AndAlso dollarSignDoubleQuoteToken.Kind = SyntaxKind.DollarSignDoubleQuoteToken)
            Debug.Assert(doubleQuoteToken IsNot Nothing AndAlso doubleQuoteToken.Kind = SyntaxKind.DoubleQuoteToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.InterpolatedStringExpression, dollarSignDoubleQuoteToken, contents.Node, doubleQuoteToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, InterpolatedStringExpressionSyntax)
            End If

            Dim result = New InterpolatedStringExpressionSyntax(SyntaxKind.InterpolatedStringExpression, dollarSignDoubleQuoteToken, contents.Node, doubleQuoteToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents literal text content in an interpolated string.
        ''' </summary>
        ''' <param name="textToken">
        ''' The text token.
        ''' </param>
        Friend Function InterpolatedStringText(textToken As InterpolatedStringTextTokenSyntax) As InterpolatedStringTextSyntax
            Debug.Assert(textToken IsNot Nothing AndAlso textToken.Kind = SyntaxKind.InterpolatedStringTextToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.InterpolatedStringText, textToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, InterpolatedStringTextSyntax)
            End If

            Dim result = New InterpolatedStringTextSyntax(SyntaxKind.InterpolatedStringText, textToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents an interpolation of an expression in an interpolated string
        ''' expression e.g. '{expression[,alignment][:formatString]}'.
        ''' </summary>
        ''' <param name="openBraceToken">
        ''' The opening curly brace '{' token.
        ''' </param>
        ''' <param name="expression">
        ''' The expression whose formatted value should be embedded in the resultant
        ''' string.
        ''' </param>
        ''' <param name="alignmentClause">
        ''' Optional. The alignment clause ',alignment' of the embedded expression.
        ''' </param>
        ''' <param name="formatClause">
        ''' Optional. The format string clause ':formatString' of the embedded expression.
        ''' </param>
        ''' <param name="closeBraceToken">
        ''' The closing curly brace '}' token of the embedded expression.
        ''' </param>
        Friend Function Interpolation(openBraceToken As PunctuationSyntax, expression As ExpressionSyntax, alignmentClause As InterpolationAlignmentClauseSyntax, formatClause As InterpolationFormatClauseSyntax, closeBraceToken As PunctuationSyntax) As InterpolationSyntax
            Debug.Assert(openBraceToken IsNot Nothing AndAlso openBraceToken.Kind = SyntaxKind.OpenBraceToken)
            Debug.Assert(expression IsNot Nothing)
            Debug.Assert(closeBraceToken IsNot Nothing AndAlso closeBraceToken.Kind = SyntaxKind.CloseBraceToken)
            Return New InterpolationSyntax(SyntaxKind.Interpolation, openBraceToken, expression, alignmentClause, formatClause, closeBraceToken, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an alignment clause ',alignment' of an interpolated string embedded
        ''' expression.
        ''' </summary>
        ''' <param name="commaToken">
        ''' The comma ',' token.
        ''' </param>
        ''' <param name="value">
        ''' An expression representing the alignment of the interpolated expression.
        ''' </param>
        Friend Function InterpolationAlignmentClause(commaToken As PunctuationSyntax, value As ExpressionSyntax) As InterpolationAlignmentClauseSyntax
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(value IsNot Nothing)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.InterpolationAlignmentClause, commaToken, value, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, InterpolationAlignmentClauseSyntax)
            End If

            Dim result = New InterpolationAlignmentClauseSyntax(SyntaxKind.InterpolationAlignmentClause, commaToken, value, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Represents a format string clause ':formatString' of an interpolated string
        ''' embedded expression.
        ''' </summary>
        ''' <param name="colonToken">
        ''' The ':' token.
        ''' </param>
        ''' <param name="formatStringToken">
        ''' The format string.
        ''' </param>
        Friend Function InterpolationFormatClause(colonToken As PunctuationSyntax, formatStringToken As InterpolatedStringTextTokenSyntax) As InterpolationFormatClauseSyntax
            Debug.Assert(colonToken IsNot Nothing AndAlso colonToken.Kind = SyntaxKind.ColonToken)
            Debug.Assert(formatStringToken IsNot Nothing AndAlso formatStringToken.Kind = SyntaxKind.InterpolatedStringTextToken)

            Dim hash As Integer
            Dim cached = VisualBasicSyntaxNodeCache.TryGetNode(SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken, _factoryContext, hash)
            If cached IsNot Nothing Then
                Return DirectCast(cached, InterpolationFormatClauseSyntax)
            End If

            Dim result = New InterpolationFormatClauseSyntax(SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken, _factoryContext)
            If hash >= 0 Then
                SyntaxNodeCache.AddNode(result, hash)
            End If

            Return result
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Function WhitespaceTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.WhitespaceTrivia, text, _factoryContext)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Function EndOfLineTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.EndOfLineTrivia, text, _factoryContext)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Function ColonTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.ColonTrivia, text, _factoryContext)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Function CommentTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.CommentTrivia, text, _factoryContext)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Function ConflictMarkerTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.ConflictMarkerTrivia, text, _factoryContext)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Function LineContinuationTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.LineContinuationTrivia, text, _factoryContext)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Function DocumentationCommentExteriorTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.DocumentationCommentExteriorTrivia, text, _factoryContext)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Function DisabledTextTrivia(text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Return New SyntaxTrivia(SyntaxKind.DisabledTextTrivia, text, _factoryContext)
        End Function


        ''' <summary>
        ''' Trivia nodes represents parts of the program text that are not parts of the
        ''' syntactic grammar, such as spaces, newlines, comments, preprocessors
        ''' directives, and disabled code.
        ''' </summary>
        ''' <param name="kind">
        ''' A <see cref="SyntaxKind"/> representing the specific kind of SyntaxTrivia. One
        ''' of WhitespaceTrivia, EndOfLineTrivia, ColonTrivia, CommentTrivia,
        ''' ConflictMarkerTrivia, LineContinuationTrivia,
        ''' DocumentationCommentExteriorTrivia, DisabledTextTrivia.
        ''' </param>
        ''' <param name="text">
        ''' The actual text of this token.
        ''' </param>
        Friend Function SyntaxTrivia(kind As SyntaxKind, text as String) As SyntaxTrivia
            Debug.Assert(text IsNot Nothing)
            Debug.Assert(SyntaxFacts.IsSyntaxTrivia(kind))
            Return New SyntaxTrivia(kind, text, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents a #Const pre-processing constant declaration appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        ''' <param name="constKeyword">
        ''' The "Const" keyword.
        ''' </param>
        ''' <param name="name">
        ''' The name of the pre-processing constant being defined.
        ''' </param>
        ''' <param name="equalsToken">
        ''' The "=" token.
        ''' </param>
        ''' <param name="value">
        ''' An expression representing the value of the pre-processing constant being
        ''' defined.
        ''' </param>
        Friend Function ConstDirectiveTrivia(hashToken As PunctuationSyntax, constKeyword As KeywordSyntax, name As IdentifierTokenSyntax, equalsToken As PunctuationSyntax, value As ExpressionSyntax) As ConstDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(constKeyword IsNot Nothing AndAlso constKeyword.Kind = SyntaxKind.ConstKeyword)
            Debug.Assert(name IsNot Nothing AndAlso name.Kind = SyntaxKind.IdentifierToken)
            Debug.Assert(equalsToken IsNot Nothing AndAlso equalsToken.Kind = SyntaxKind.EqualsToken)
            Debug.Assert(value IsNot Nothing)
            Return New ConstDirectiveTriviaSyntax(SyntaxKind.ConstDirectiveTrivia, hashToken, constKeyword, name, equalsToken, value, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents the beginning of an #If pre-processing directive appearing in
        ''' source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Function IfDirectiveTrivia(hashToken As PunctuationSyntax, elseKeyword As KeywordSyntax, ifOrElseIfKeyword As KeywordSyntax, condition As ExpressionSyntax, thenKeyword As KeywordSyntax) As IfDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(ifOrElseIfKeyword IsNot Nothing AndAlso SyntaxFacts.IsIfDirectiveTriviaIfOrElseIfKeyword(ifOrElseIfKeyword.Kind))
            Debug.Assert(condition IsNot Nothing)
            Return New IfDirectiveTriviaSyntax(SyntaxKind.IfDirectiveTrivia, hashToken, elseKeyword, ifOrElseIfKeyword, condition, thenKeyword, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents the beginning of an #If pre-processing directive appearing in
        ''' source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Function ElseIfDirectiveTrivia(hashToken As PunctuationSyntax, elseKeyword As KeywordSyntax, ifOrElseIfKeyword As KeywordSyntax, condition As ExpressionSyntax, thenKeyword As KeywordSyntax) As IfDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(ifOrElseIfKeyword IsNot Nothing AndAlso SyntaxFacts.IsIfDirectiveTriviaIfOrElseIfKeyword(ifOrElseIfKeyword.Kind))
            Debug.Assert(condition IsNot Nothing)
            Return New IfDirectiveTriviaSyntax(SyntaxKind.ElseIfDirectiveTrivia, hashToken, elseKeyword, ifOrElseIfKeyword, condition, thenKeyword, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an #Else pre-processing directive appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Function ElseDirectiveTrivia(hashToken As PunctuationSyntax, elseKeyword As KeywordSyntax) As ElseDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(elseKeyword IsNot Nothing AndAlso elseKeyword.Kind = SyntaxKind.ElseKeyword)
            Return New ElseDirectiveTriviaSyntax(SyntaxKind.ElseDirectiveTrivia, hashToken, elseKeyword, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an #End If pre-processing directive appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Function EndIfDirectiveTrivia(hashToken As PunctuationSyntax, endKeyword As KeywordSyntax, ifKeyword As KeywordSyntax) As EndIfDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(ifKeyword IsNot Nothing AndAlso ifKeyword.Kind = SyntaxKind.IfKeyword)
            Return New EndIfDirectiveTriviaSyntax(SyntaxKind.EndIfDirectiveTrivia, hashToken, endKeyword, ifKeyword, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents the beginning of a #Region directive appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        ''' <param name="regionKeyword">
        ''' The "Region" keyword.
        ''' </param>
        ''' <param name="name">
        ''' The label of the code region being defined.
        ''' </param>
        Friend Function RegionDirectiveTrivia(hashToken As PunctuationSyntax, regionKeyword As KeywordSyntax, name As StringLiteralTokenSyntax) As RegionDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(regionKeyword IsNot Nothing AndAlso regionKeyword.Kind = SyntaxKind.RegionKeyword)
            Debug.Assert(name IsNot Nothing AndAlso name.Kind = SyntaxKind.StringLiteralToken)
            Return New RegionDirectiveTriviaSyntax(SyntaxKind.RegionDirectiveTrivia, hashToken, regionKeyword, name, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an #End Region directive appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        ''' <param name="endKeyword">
        ''' The "End" keyword.
        ''' </param>
        ''' <param name="regionKeyword">
        ''' The "Region" keyword.
        ''' </param>
        Friend Function EndRegionDirectiveTrivia(hashToken As PunctuationSyntax, endKeyword As KeywordSyntax, regionKeyword As KeywordSyntax) As EndRegionDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(regionKeyword IsNot Nothing AndAlso regionKeyword.Kind = SyntaxKind.RegionKeyword)
            Return New EndRegionDirectiveTriviaSyntax(SyntaxKind.EndRegionDirectiveTrivia, hashToken, endKeyword, regionKeyword, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents the beginning of a #ExternalSource pre-processing directive
        ''' appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Function ExternalSourceDirectiveTrivia(hashToken As PunctuationSyntax, externalSourceKeyword As KeywordSyntax, openParenToken As PunctuationSyntax, externalSource As StringLiteralTokenSyntax, commaToken As PunctuationSyntax, lineStart As IntegerLiteralTokenSyntax, closeParenToken As PunctuationSyntax) As ExternalSourceDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(externalSourceKeyword IsNot Nothing AndAlso externalSourceKeyword.Kind = SyntaxKind.ExternalSourceKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(externalSource IsNot Nothing AndAlso externalSource.Kind = SyntaxKind.StringLiteralToken)
            Debug.Assert(commaToken IsNot Nothing AndAlso commaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(lineStart IsNot Nothing AndAlso lineStart.Kind = SyntaxKind.IntegerLiteralToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New ExternalSourceDirectiveTriviaSyntax(SyntaxKind.ExternalSourceDirectiveTrivia, hashToken, externalSourceKeyword, openParenToken, externalSource, commaToken, lineStart, closeParenToken, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an #End ExternalSource pre-processing directive appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Function EndExternalSourceDirectiveTrivia(hashToken As PunctuationSyntax, endKeyword As KeywordSyntax, externalSourceKeyword As KeywordSyntax) As EndExternalSourceDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(endKeyword IsNot Nothing AndAlso endKeyword.Kind = SyntaxKind.EndKeyword)
            Debug.Assert(externalSourceKeyword IsNot Nothing AndAlso externalSourceKeyword.Kind = SyntaxKind.ExternalSourceKeyword)
            Return New EndExternalSourceDirectiveTriviaSyntax(SyntaxKind.EndExternalSourceDirectiveTrivia, hashToken, endKeyword, externalSourceKeyword, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an #ExternalChecksum pre-processing directive appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Function ExternalChecksumDirectiveTrivia(hashToken As PunctuationSyntax, externalChecksumKeyword As KeywordSyntax, openParenToken As PunctuationSyntax, externalSource As StringLiteralTokenSyntax, firstCommaToken As PunctuationSyntax, guid As StringLiteralTokenSyntax, secondCommaToken As PunctuationSyntax, checksum As StringLiteralTokenSyntax, closeParenToken As PunctuationSyntax) As ExternalChecksumDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(externalChecksumKeyword IsNot Nothing AndAlso externalChecksumKeyword.Kind = SyntaxKind.ExternalChecksumKeyword)
            Debug.Assert(openParenToken IsNot Nothing AndAlso openParenToken.Kind = SyntaxKind.OpenParenToken)
            Debug.Assert(externalSource IsNot Nothing AndAlso externalSource.Kind = SyntaxKind.StringLiteralToken)
            Debug.Assert(firstCommaToken IsNot Nothing AndAlso firstCommaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(guid IsNot Nothing AndAlso guid.Kind = SyntaxKind.StringLiteralToken)
            Debug.Assert(secondCommaToken IsNot Nothing AndAlso secondCommaToken.Kind = SyntaxKind.CommaToken)
            Debug.Assert(checksum IsNot Nothing AndAlso checksum.Kind = SyntaxKind.StringLiteralToken)
            Debug.Assert(closeParenToken IsNot Nothing AndAlso closeParenToken.Kind = SyntaxKind.CloseParenToken)
            Return New ExternalChecksumDirectiveTriviaSyntax(SyntaxKind.ExternalChecksumDirectiveTrivia, hashToken, externalChecksumKeyword, openParenToken, externalSource, firstCommaToken, guid, secondCommaToken, checksum, closeParenToken, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents #Enable Warning pre-processing directive appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Function EnableWarningDirectiveTrivia(hashToken As PunctuationSyntax, enableKeyword As KeywordSyntax, warningKeyword As KeywordSyntax, errorCodes As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As EnableWarningDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(enableKeyword IsNot Nothing AndAlso enableKeyword.Kind = SyntaxKind.EnableKeyword)
            Debug.Assert(warningKeyword IsNot Nothing AndAlso warningKeyword.Kind = SyntaxKind.WarningKeyword)
            Return New EnableWarningDirectiveTriviaSyntax(SyntaxKind.EnableWarningDirectiveTrivia, hashToken, enableKeyword, warningKeyword, errorCodes.Node, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents #Disable Warning pre-processing directive appearing in source.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Function DisableWarningDirectiveTrivia(hashToken As PunctuationSyntax, disableKeyword As KeywordSyntax, warningKeyword As KeywordSyntax, errorCodes As Global.Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList(of GreenNode)) As DisableWarningDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(disableKeyword IsNot Nothing AndAlso disableKeyword.Kind = SyntaxKind.DisableKeyword)
            Debug.Assert(warningKeyword IsNot Nothing AndAlso warningKeyword.Kind = SyntaxKind.WarningKeyword)
            Return New DisableWarningDirectiveTriviaSyntax(SyntaxKind.DisableWarningDirectiveTrivia, hashToken, disableKeyword, warningKeyword, errorCodes.Node, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an #r directive appearing in scripts.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Function ReferenceDirectiveTrivia(hashToken As PunctuationSyntax, referenceKeyword As KeywordSyntax, file As StringLiteralTokenSyntax) As ReferenceDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Debug.Assert(referenceKeyword IsNot Nothing AndAlso referenceKeyword.Kind = SyntaxKind.ReferenceKeyword)
            Debug.Assert(file IsNot Nothing AndAlso file.Kind = SyntaxKind.StringLiteralToken)
            Return New ReferenceDirectiveTriviaSyntax(SyntaxKind.ReferenceDirectiveTrivia, hashToken, referenceKeyword, file, _factoryContext)
        End Function


        ''' <summary>
        ''' Represents an unrecognized pre-processing directive. This occurs when the
        ''' parser encounters a hash '#' token at the beginning of a physical line but does
        ''' recognize the text that follows as a valid Visual Basic pre-processing
        ''' directive.
        ''' </summary>
        ''' <param name="hashToken">
        ''' The "#" token in a preprocessor directive.
        ''' </param>
        Friend Function BadDirectiveTrivia(hashToken As PunctuationSyntax) As BadDirectiveTriviaSyntax
            Debug.Assert(hashToken IsNot Nothing AndAlso hashToken.Kind = SyntaxKind.HashToken)
            Return New BadDirectiveTriviaSyntax(SyntaxKind.BadDirectiveTrivia, hashToken, _factoryContext)
        End Function

    End Class
End Namespace
