<?xml version="1.0" encoding="UTF-8"?>
<!-- Copyright (c)  Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information. -->
<Tree Root="IOperation">


  <!--
      To regenerate the operation nodes, run eng/generate-compiler-code.cmd

      The operations in this file are _ordered_! If you change the order in here,
      you will affect the ordering in the generated OperationKind enum, which will
      break the public api analyzer. All new types should be put at the end of this
      file in order to ensure that the kind does not continue to change.

      UnusedOperationKinds indicates kinds that are currently skipped by the OperationKind
      enum. They can be used by future nodes by inserting those nodes at the correct point
      in the list.
        -->

  <UnusedOperationKinds>
    <Entry Value="0x1D"/>
    <Entry Value="0x62"/>
    <Entry Value="0x64"/>
  </UnusedOperationKinds>

  <Node Name="IInvalidOperation" Base="IOperation" SkipClassGeneration="true">
    <Comments>
      <summary>
        Represents an invalid operation with one or more child operations.
        <para>
        Current usage:
         (1) C# invalid expression or invalid statement.
         (2) VB invalid expression or invalid statement.
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="IBlockOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a block containing a sequence of operations and local declarations.
        <para>
        Current usage:
         (1) C# "{ ... }" block statement.
         (2) VB implicit block statement for method bodies and other block scoped statements.
        </para>
      </summary>
    </Comments>
    <Property Name="Operations" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>Operations contained within the block.</summary>
      </Comments>
    </Property>
    <Property Name="Locals" Type="ImmutableArray&lt;ILocalSymbol&gt;">
      <Comments>
        <summary>Local declarations contained within the block.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IVariableDeclarationGroupOperation" Base="IOperation">
    <Comments>
      <summary>Represents a variable declaration statement.</summary>
      <para>
        Current Usage:
          (1) C# local declaration statement
          (2) C# fixed statement
          (3) C# using statement
          (4) VB Dim statement
          (5) VB Using statement
      </para>
    </Comments>
    <Property Name="Declarations" Type="ImmutableArray&lt;IVariableDeclarationOperation&gt;">
      <Comments>
        <summary>Variable declaration in the statement.</summary>
        <remarks>
          In C#, this will always be a single declaration, with all variables in <see cref="IVariableDeclarationOperation.Declarators" />.
        </remarks>
      </Comments>
    </Property>
  </Node>
  <Node Name="ISwitchOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a switch operation with a value to be switched upon and switch cases.
        <para>
        Current usage:
         (1) C# switch statement.
         (2) VB Select Case statement.
        </para>
      </summary>
    </Comments>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Value to be switched upon.</summary>
      </Comments>
    </Property>
    <Property Name="Cases" Type="ImmutableArray&lt;ISwitchCaseOperation&gt;">
      <Comments>
        <summary>Cases of the switch.</summary>
      </Comments>
    </Property>
    <Property Name="ExitLabel" Type="ILabelSymbol">
      <Comments>
        <summary>Exit label for the switch statement.</summary>
      </Comments>
    </Property>
    <Property Name="Locals" Type="ImmutableArray&lt;ILocalSymbol&gt;">
      <Comments>
        <summary>
          Locals declared within the switch operation with scope spanning across all <see cref="Cases" />.
        </summary>
      </Comments>
    </Property>
  </Node>
  <AbstractNode Name="ILoopOperation" Base="IOperation">
    <OperationKind Include ="true" ExtraDescription="This is further differentiated by &lt;see cref=&quot;ILoopOperation.LoopKind&quot;/&gt;."/>
    <Comments>
      <summary>
        Represents a loop operation.
        <para>
        Current usage:
          (1) C# 'while', 'for', 'foreach' and 'do' loop statements
          (2) VB 'While', 'ForTo', 'ForEach', 'Do While' and 'Do Until' loop statements
        </para>
      </summary>
    </Comments>
    <Property Name="LoopKind" Type="LoopKind">
      <Comments>
        <summary>Kind of the loop.</summary>
      </Comments>
    </Property>
    <Property Name="Body" Type="IOperation">
      <Comments>
        <summary>Body of the loop.</summary>
      </Comments>
    </Property>
    <Property Name="Locals" Type="ImmutableArray&lt;ILocalSymbol&gt;">
      <Comments>
        <summary>Declared locals.</summary>
      </Comments>
    </Property>
    <Property Name="ContinueLabel" Type="ILabelSymbol">
      <Comments>
        <summary>Loop continue label.</summary>
      </Comments>
    </Property>
    <Property Name="ExitLabel" Type="ILabelSymbol">
      <Comments>
        <summary>Loop exit/break label.</summary>
      </Comments>
    </Property>
  </AbstractNode>
  <Node Name="IForEachLoopOperation" Base="ILoopOperation">
    <OperationKind Include="false" />
    <Comments>
      <summary>
        Represents a for each loop.
        <para>
        Current usage:
         (1) C# 'foreach' loop statement
         (2) VB 'For Each' loop statement
        </para>
      </summary>
    </Comments>
    <Property Name="LoopControlVariable" Type="IOperation">
      <Comments>
        <summary>Refers to the operation for declaring a new local variable or reference an existing variable or an expression.</summary>
      </Comments>
    </Property>
    <Property Name="Collection" Type="IOperation">
      <Comments>
        <summary>Collection value over which the loop iterates.</summary>
      </Comments>
    </Property>
    <Property Name="NextVariables" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>
          Optional list of comma separated next variables at loop bottom in VB.
          This list is always empty for C#.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IForLoopOperation" Base="ILoopOperation">
    <OperationKind Include="false" />
    <Comments>
      <summary>
        Represents a for loop.
        <para>
        Current usage:
         (1) C# 'for' loop statement
        </para>
      </summary>
    </Comments>
    <Property Name="Before" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>List of operations to execute before entry to the loop. For C#, this comes from the first clause of the for statement.</summary>
      </Comments>
    </Property>
    <Property Name="ConditionLocals" Type="ImmutableArray&lt;ILocalSymbol&gt;">
      <Comments>
        <summary>
          Locals declared within the loop Condition and are in scope throughout the <see cref="Condition" />,
          <see cref="ILoopOperation.Body" /> and <see cref="AtLoopBottom" />.
          They are considered to be declared per iteration.
        </summary>
      </Comments>
    </Property>
    <Property Name="Condition" Type="IOperation">
      <Comments>
        <summary>Condition of the loop. For C#, this comes from the second clause of the for statement.</summary>
      </Comments>
    </Property>
    <Property Name="AtLoopBottom" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>List of operations to execute at the bottom of the loop. For C#, this comes from the third clause of the for statement.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IForToLoopOperation" Base="ILoopOperation">
    <OperationKind Include="false" />
    <Comments>
      <summary>
        Represents a for to loop with loop control variable and initial, limit and step values for the control variable.
        <para>
        Current usage:
         (1) VB 'For ... To ... Step' loop statement
        </para>
      </summary>
    </Comments>
    <Property Name="LoopControlVariable" Type="IOperation">
      <Comments>
        <summary>Refers to the operation for declaring a new local variable or reference an existing variable or an expression.</summary>
      </Comments>
    </Property>
    <Property Name="InitialValue" Type="IOperation">
      <Comments>
        <summary>Operation for setting the initial value of the loop control variable. This comes from the expression between the 'For' and 'To' keywords.</summary>
      </Comments>
    </Property>
    <Property Name="LimitValue" Type="IOperation">
      <Comments>
        <summary>Operation for the limit value of the loop control variable. This comes from the expression after the 'To' keyword.</summary>
      </Comments>
    </Property>
    <Property Name="StepValue" Type="IOperation">
      <Comments>
        <summary>
          Operation for the step value of the loop control variable. This comes from the expression after the 'Step' keyword,
          or inferred by the compiler if 'Step' clause is omitted.
        </summary>
      </Comments>
    </Property>
    <Property Name="IsChecked" Type="bool">
      <Comments>
        <summary>
          <code>true</code> if arithmetic operations behind this loop are 'checked'.</summary>
      </Comments>
    </Property>
    <Property Name="NextVariables" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>Optional list of comma separated next variables at loop bottom.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IWhileLoopOperation" Base="ILoopOperation">
    <OperationKind Include="false" />
    <Comments>
      <summary>
        Represents a while or do while loop.
        <para>
        Current usage:
         (1) C# 'while' and 'do while' loop statements.
         (2) VB 'While', 'Do While' and 'Do Until' loop statements.
        </para>
      </summary>
    </Comments>
    <Property Name="Condition" Type="IOperation">
      <Comments>
        <summary>Condition of the loop.</summary>
      </Comments>
    </Property>
    <Property Name="ConditionIsTop" Type="bool">
      <Comments>
        <summary>
          True if the <see cref="Condition" /> is evaluated at start of each loop iteration.
          False if it is evaluated at the end of each loop iteration.
        </summary>
      </Comments>
    </Property>
    <Property Name="ConditionIsUntil" Type="bool">
      <Comments>
        <summary>True if the loop has 'Until' loop semantics and the loop is executed while <see cref="Condition" /> is false.</summary>
      </Comments>
    </Property>
    <Property Name="IgnoredCondition" Type="IOperation">
      <Comments>
        <summary>
          Additional conditional supplied for loop in error cases, which is ignored by the compiler.
          For example, for VB 'Do While' or 'Do Until' loop with syntax errors where both the top and bottom conditions are provided.
          The top condition is preferred and exposed as <see cref="Condition" /> and the bottom condition is ignored and exposed by this property.
          This property should be null for all non-error cases.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ILabeledOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an operation with a label.
        <para>
        Current usage:
         (1) C# labeled statement.
         (2) VB label statement.
        </para>
      </summary>
    </Comments>
    <Property Name="Label" Type="ILabelSymbol">
      <Comments>
        <summary>Label that can be the target of branches.</summary>
      </Comments>
    </Property>
    <Property Name="Operation" Type="IOperation">
      <Comments>
        <summary>Operation that has been labeled. In VB, this is always null.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IBranchOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a branch operation.
        <para>
        Current usage:
         (1) C# goto, break, or continue statement.
         (2) VB GoTo, Exit ***, or Continue *** statement.
        </para>
      </summary>
    </Comments>
    <Property Name="Target" Type="ILabelSymbol">
      <Comments>
        <summary>Label that is the target of the branch.</summary>
      </Comments>
    </Property>
    <Property Name="BranchKind" Type="BranchKind">
      <Comments>
        <summary>Kind of the branch.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IEmptyOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an empty or no-op operation.
        <para>
        Current usage:
         (1) C# empty statement.
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="IReturnOperation" Base="IOperation">
    <OperationKind>
      <Entry Name="Return" Value="0x9"/>
      <Entry Name="YieldBreak" Value="0xa" ExtraDescription="This has yield break semantics."/>
      <Entry Name="YieldReturn" Value="0xe" ExtraDescription="This has yield return semantics."/>
    </OperationKind>
    <Comments>
      <summary>
        Represents a return from the method with an optional return value.
        <para>
        Current usage:
         (1) C# return statement and yield statement.
         (2) VB Return statement.
        </para>
      </summary>
    </Comments>
    <Property Name="ReturnedValue" Type="IOperation">
      <Comments>
        <summary>Value to be returned.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ILockOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a <see cref="Body" /> of operations that are executed while holding a lock onto the <see cref="LockedValue" />.
        <para>
        Current usage:
         (1) C# lock statement.
         (2) VB SyncLock statement.
        </para>
      </summary>
    </Comments>
    <Property Name="LockedValue" Type="IOperation">
      <Comments>
        <summary>Operation producing a value to be locked.</summary>
      </Comments>
    </Property>
    <Property Name="Body" Type="IOperation">
      <Comments>
        <summary>Body of the lock, to be executed while holding the lock.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ITryOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a try operation for exception handling code with a body, catch clauses and a finally handler.
        <para>
        Current usage:
         (1) C# try statement.
         (2) VB Try statement.
        </para>
      </summary>
    </Comments>
    <Property Name="Body" Type="IBlockOperation">
      <Comments>
        <summary>Body of the try, over which the handlers are active.</summary>
      </Comments>
    </Property>
    <Property Name="Catches" Type="ImmutableArray&lt;ICatchClauseOperation&gt;">
      <Comments>
        <summary>Catch clauses of the try.</summary>
      </Comments>
    </Property>
    <Property Name="Finally" Type="IBlockOperation">
      <Comments>
        <summary>Finally handler of the try.</summary>
      </Comments>
    </Property>
    <Property Name="ExitLabel" Type="ILabelSymbol">
      <Comments>
        <summary>Exit label for the try. This will always be null for C#.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IUsingOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a <see cref="Body" /> of operations that are executed while using disposable <see cref="Resources" />.
        <para>
        Current usage:
         (1) C# using statement.
         (2) VB Using statement.
        </para>
      </summary>
    </Comments>
    <Property Name="Body" Type="IOperation">
      <Comments>
        <summary>Body of the using, over which the resources of the using are maintained.</summary>
      </Comments>
    </Property>
    <Property Name="Resources" Type="IOperation">
      <Comments>
        <summary>Declaration introduced or resource held by the using.</summary>
      </Comments>
    </Property>
    <Property Name="Locals" Type="ImmutableArray&lt;ILocalSymbol&gt;">
      <Comments>
        <summary>
          Locals declared within the <see cref="Resources" /> with scope spanning across this entire <see cref="IUsingOperation" />.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IExpressionStatementOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an operation that drops the resulting value and the type of the underlying wrapped <see cref="Operation" />.
        <para>
        Current usage:
         (1) C# expression statement.
         (2) VB expression statement.
        </para>
      </summary>
    </Comments>
    <Property Name="Operation" Type="IOperation">
      <Comments>
        <summary>Underlying operation with a value and type.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ILocalFunctionOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a local function defined within a method.
        <para>
        Current usage:
         (1) C# local function statement.
        </para>
      </summary>
    </Comments>
    <Property Name="Symbol" Type="IMethodSymbol">
      <Comments>
        <summary>Local function symbol.</summary>
      </Comments>
    </Property>
    <Property Name="Body" Type="IBlockOperation">
      <Comments>
        <summary>Body of the local function.</summary>
      </Comments>
    </Property>
    <Property Name="IgnoredBody" Type="IBlockOperation">
      <Comments>
        <summary>An extra body for the local function, if both a block body and expression body are specified in source.</summary>
        <remarks>This is only ever non-null in error situations.</remarks>
      </Comments>
    </Property>
  </Node>
  <Node Name="IStopOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an operation to stop or suspend execution of code.
        <para>
        Current usage:
         (1) VB Stop statement.
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="IEndOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an operation that stops the execution of code abruptly.
        <para>
        Current usage:
         (1) VB End Statement.
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="IRaiseEventOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an operation for raising an event.
        <para>
        Current usage:
         (1) VB raise event statement.
        </para>
      </summary>
    </Comments>
    <Property Name="EventReference" Type="IEventReferenceOperation">
      <Comments>
        <summary>Reference to the event to be raised.</summary>
      </Comments>
    </Property>
    <Property Name="Arguments" Type="ImmutableArray&lt;IArgumentOperation&gt;">
      <Comments>
        <summary>Arguments of the invocation, excluding the instance argument. Arguments are in evaluation order.</summary>
        <remarks>
          If the invocation is in its expanded form, then params/ParamArray arguments would be collected into arrays.
          Default values are supplied for optional arguments missing in source.
        </remarks>
      </Comments>
    </Property>
  </Node>
  <Node Name="ILiteralOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a textual literal numeric, string, etc.
        <para>
        Current usage:
         (1) C# literal expression.
         (2) VB literal expression.
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="IConversionOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a type conversion.
        <para>
        Current usage:
         (1) C# conversion expression.
         (2) VB conversion expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Operand" Type="IOperation">
      <Comments>
        <summary>Value to be converted.</summary>
      </Comments>
    </Property>
    <Property Name="OperatorMethod" Type="IMethodSymbol">
      <Comments>
        <summary>Operator method used by the operation, null if the operation does not use an operator method.</summary>
      </Comments>
    </Property>
    <Property Name="Conversion" Type="CommonConversion">
      <Comments>
        <summary>Gets the underlying common conversion information.</summary>
        <remarks>
          If you need conversion information that is language specific, use either
          <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion(IConversionOperation)" /> or
          <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetConversion(IConversionOperation)" />.
        </remarks>
      </Comments>
    </Property>
    <Property Name="IsTryCast" Type="bool">
      <Comments>
        <summary>
          False if the conversion will fail with a <see cref="InvalidCastException" /> at runtime if the cast fails. This is true for C#'s
          <c>as</c> operator and for VB's <c>TryCast</c> operator.
        </summary>
      </Comments>
    </Property>
    <Property Name="IsChecked" Type="bool">
      <Comments>
        <summary>True if the conversion can fail at runtime with an overflow exception. This corresponds to C# checked and unchecked blocks.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IInvocationOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an invocation of a method.
        <para>
        Current usage:
         (1) C# method invocation expression.
         (2) C# collection element initializer.
             For example, in the following collection initializer: <code>new C() { 1, 2, 3 }</code>, we will have
             3 <see cref="IInvocationOperation" /> nodes, each of which will be a call to the corresponding Add method
             with either 1, 2, 3 as the argument.
         (3) VB method invocation expression.
         (4) VB collection element initializer.
             Similar to the C# example, <code>New C() From {1, 2, 3}</code> will have 3 <see cref="IInvocationOperation" />
             nodes with 1, 2, and 3 as their arguments, respectively.
        </para>
      </summary>
    </Comments>
    <Property Name="TargetMethod" Type="IMethodSymbol">
      <Comments>
        <summary>Method to be invoked.</summary>
      </Comments>
    </Property>
    <Property Name="Instance" Type="IOperation">
      <Comments>
        <summary>'This' or 'Me' instance to be supplied to the method, or null if the method is static.</summary>
      </Comments>
    </Property>
    <Property Name="IsVirtual" Type="bool">
      <Comments>
        <summary>True if the invocation uses a virtual mechanism, and false otherwise.</summary>
      </Comments>
    </Property>
    <Property Name="Arguments" Type="ImmutableArray&lt;IArgumentOperation&gt;">
      <Comments>
        <summary>Arguments of the invocation, excluding the instance argument. Arguments are in evaluation order.</summary>
        <remarks>
          If the invocation is in its expanded form, then params/ParamArray arguments would be collected into arrays.
          Default values are supplied for optional arguments missing in source.
        </remarks>
      </Comments>
    </Property>
  </Node>
  <Node Name="IArrayElementReferenceOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a reference to an array element.
        <para>
        Current usage:
         (1) C# array element reference expression.
         (2) VB array element reference expression.
        </para>
      </summary>
    </Comments>
    <Property Name="ArrayReference" Type="IOperation">
      <Comments>
        <summary>Array to be indexed.</summary>
      </Comments>
    </Property>
    <Property Name="Indices" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>Indices that specify an individual element.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ILocalReferenceOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a reference to a declared local variable.
        <para>
        Current usage:
         (1) C# local reference expression.
         (2) VB local reference expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Local" Type="ILocalSymbol">
      <Comments>
        <summary>Referenced local variable.</summary>
      </Comments>
    </Property>
    <Property Name="IsDeclaration" Type="bool">
      <Comments>
        <summary>
          True if this reference is also the declaration site of this variable. This is true in out variable declarations
          and in deconstruction operations where a new variable is being declared.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IParameterReferenceOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a reference to a parameter.
        <para>
        Current usage:
         (1) C# parameter reference expression.
         (2) VB parameter reference expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Parameter" Type="IParameterSymbol">
      <Comments>
        <summary>Referenced parameter.</summary>
      </Comments>
    </Property>
  </Node>
  <AbstractNode Name="IMemberReferenceOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a reference to a member of a class, struct, or interface.
        <para>
        Current usage:
         (1) C# member reference expression.
         (2) VB member reference expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Instance" Type="IOperation">
      <Comments>
        <summary>Instance of the type. Null if the reference is to a static/shared member.</summary>
      </Comments>
    </Property>
    <Property Name="Member" Type="ISymbol">
      <Comments>
        <summary>Referenced member.</summary>
      </Comments>
    </Property>
  </AbstractNode>
  <Node Name="IFieldReferenceOperation" Base="IMemberReferenceOperation">
    <Comments>
      <summary>
        Represents a reference to a field.
        <para>
        Current usage:
         (1) C# field reference expression.
         (2) VB field reference expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Field" Type="IFieldSymbol">
      <Comments>
        <summary>Referenced field.</summary>
      </Comments>
    </Property>
    <Property Name="IsDeclaration" Type="bool">
      <Comments>
        <summary>If the field reference is also where the field was declared.</summary>
        <remarks>
          This is only ever true in CSharp scripts, where a top-level statement creates a new variable
          in a reference, such as an out variable declaration or a deconstruction declaration.
        </remarks>
      </Comments>
    </Property>
  </Node>
  <Node Name="IMethodReferenceOperation" Base="IMemberReferenceOperation">
    <Comments>
      <summary>
        Represents a reference to a method other than as the target of an invocation.
        <para>
        Current usage:
         (1) C# method reference expression.
         (2) VB method reference expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Method" Type="IMethodSymbol">
      <Comments>
        <summary>Referenced method.</summary>
      </Comments>
    </Property>
    <Property Name="IsVirtual" Type="bool">
      <Comments>
        <summary>Indicates whether the reference uses virtual semantics.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IPropertyReferenceOperation" Base="IMemberReferenceOperation">
    <Comments>
      <summary>
        Represents a reference to a property.
        <para>
        Current usage:
         (1) C# property reference expression.
         (2) VB property reference expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Property" Type="IPropertySymbol">
      <Comments>
        <summary>Referenced property.</summary>
      </Comments>
    </Property>
    <Property Name="Arguments" Type="ImmutableArray&lt;IArgumentOperation&gt;">
      <Comments>
        <summary>Arguments of the indexer property reference, excluding the instance argument. Arguments are in evaluation order.</summary>
        <remarks>
          If the invocation is in its expanded form, then params/ParamArray arguments would be collected into arrays.
          Default values are supplied for optional arguments missing in source.
        </remarks>
      </Comments>
    </Property>
  </Node>
  <Node Name="IEventReferenceOperation" Base="IMemberReferenceOperation">
    <Comments>
      <summary>
        Represents a reference to an event.
        <para>
        Current usage:
         (1) C# event reference expression.
         (2) VB event reference expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Event" Type="IEventSymbol">
      <Comments>
        <summary>Referenced event.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IUnaryOperation" Base="IOperation" VisitorName="VisitUnaryOperator">
    <OperationKind>
      <Entry Name="Unary" Value="0x1f" />
      <Entry Name="UnaryOperator" Value="0x1f" EditorBrowsable="false" ExtraDescription="Use &lt;see cref=&quot;Unary&quot;/&gt; instead." />
    </OperationKind>
    <Comments>
      <summary>
        Represents an operation with one operand and a unary operator.
        <para>
        Current usage:
         (1) C# unary operation expression.
         (2) VB unary operation expression.
        </para>
      </summary>
    </Comments>
    <Property Name="OperatorKind" Type="UnaryOperatorKind">
      <Comments>
        <summary>Kind of unary operation.</summary>
      </Comments>
    </Property>
    <Property Name="Operand" Type="IOperation">
      <Comments>
        <summary>Operand.</summary>
      </Comments>
    </Property>
    <Property Name="OperatorMethod" Type="IMethodSymbol">
      <Comments>
        <summary>Operator method used by the operation, null if the operation does not use an operator method.</summary>
      </Comments>
    </Property>
    <Property Name="IsLifted" Type="bool">
      <Comments>
        <summary>
          <see langword="true" /> if this is a 'lifted' unary operator.  When there is an
          operator that is defined to work on a value type, 'lifted' operators are
          created to work on the <see cref="System.Nullable{T}" /> versions of those
          value types.
        </summary>
      </Comments>
    </Property>
    <Property Name="IsChecked" Type="bool">
      <Comments>
        <summary>
          <see langword="true" /> if overflow checking is performed for the arithmetic operation.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IBinaryOperation" Base="IOperation" VisitorName="VisitBinaryOperator">
    <OperationKind>
      <Entry Name="Binary" Value="0x20" />
      <Entry Name="BinaryOperator" Value="0x20" EditorBrowsable="false" ExtraDescription="Use &lt;see cref=&quot;Binary&quot;/&gt; instead." />
    </OperationKind>
    <Comments>
      <summary>
        Represents an operation with two operands and a binary operator that produces a result with a non-null type.
        <para>
        Current usage:
         (1) C# binary operator expression.
         (2) VB binary operator expression.
        </para>
      </summary>
    </Comments>
    <Property Name="OperatorKind" Type="BinaryOperatorKind">
      <Comments>
        <summary>Kind of binary operation.</summary>
      </Comments>
    </Property>
    <Property Name="LeftOperand" Type="IOperation">
      <Comments>
        <summary>Left operand.</summary>
      </Comments>
    </Property>
    <Property Name="RightOperand" Type="IOperation">
      <Comments>
        <summary>Right operand.</summary>
      </Comments>
    </Property>
    <Property Name="OperatorMethod" Type="IMethodSymbol">
      <Comments>
        <summary>Operator method used by the operation, null if the operation does not use an operator method.</summary>
      </Comments>
    </Property>
    <Property Name="IsLifted" Type="bool">
      <Comments>
        <summary>
          <see langword="true" /> if this is a 'lifted' binary operator.  When there is an
          operator that is defined to work on a value type, 'lifted' operators are
          created to work on the <see cref="System.Nullable{T}" /> versions of those
          value types.
        </summary>
      </Comments>
    </Property>
    <Property Name="IsChecked" Type="bool">
      <Comments>
        <summary>
          <see langword="true" /> if this is a 'checked' binary operator.
        </summary>
      </Comments>
    </Property>
    <Property Name="IsCompareText" Type="bool">
      <Comments>
        <summary>
          <see langword="true" /> if the comparison is text based for string or object comparison in VB.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IConditionalOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a conditional operation with:
        (1) <see cref="Condition" /> to be tested,
        (2) <see cref="WhenTrue" /> operation to be executed when <see cref="Condition" /> is true and
        (3) <see cref="WhenFalse" /> operation to be executed when the <see cref="Condition" /> is false.
        <para>
        Current usage:
         (1) C# ternary expression "a ? b : c" and if statement.
         (2) VB ternary expression "If(a, b, c)" and If Else statement.
        </para>
      </summary>
    </Comments>
    <Property Name="Condition" Type="IOperation">
      <Comments>
        <summary>Condition to be tested.</summary>
      </Comments>
    </Property>
    <Property Name="WhenTrue" Type="IOperation">
      <Comments>
        <summary>
          Operation to be executed if the <see cref="Condition" /> is true.
        </summary>
      </Comments>
    </Property>
    <Property Name="WhenFalse" Type="IOperation">
      <Comments>
        <summary>
          Operation to be executed if the <see cref="Condition" /> is false.
        </summary>
      </Comments>
    </Property>
    <Property Name="IsRef" Type="bool">
      <Comments>
        <summary>Is result a managed reference</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ICoalesceOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a coalesce operation with two operands:
        (1) <see cref="Value" />, which is the first operand that is unconditionally evaluated and is the result of the operation if non null.
        (2) <see cref="WhenNull" />, which is the second operand that is conditionally evaluated and is the result of the operation if <see cref="Value" /> is null.
        <para>
        Current usage:
         (1) C# null-coalescing expression "Value ?? WhenNull".
         (2) VB binary conditional expression "If(Value, WhenNull)".
        </para>
      </summary>
    </Comments>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Operation to be unconditionally evaluated.</summary>
      </Comments>
    </Property>
    <Property Name="WhenNull" Type="IOperation">
      <Comments>
        <summary>
          Operation to be conditionally evaluated if <see cref="Value" /> evaluates to null/Nothing.
        </summary>
      </Comments>
    </Property>
    <Property Name="ValueConversion" Type="CommonConversion">
      <Comments>
        <summary>
          Conversion associated with <see cref="Value" /> when it is not null/Nothing.

          Identity if result type of the operation is the same as type of <see cref="Value" />.
          Otherwise, if type of <see cref="Value" /> is nullable, then conversion is applied to an
          unwrapped <see cref="Value" />, otherwise to the <see cref="Value" /> itself.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IAnonymousFunctionOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an anonymous function operation.
        <para>
        Current usage:
         (1) C# lambda expression.
         (2) VB anonymous delegate expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Symbol" Type="IMethodSymbol">
      <Comments>
        <summary>Symbol of the anonymous function.</summary>
      </Comments>
    </Property>
    <Property Name="Body" Type="IBlockOperation">
      <Comments>
        <summary>Body of the anonymous function.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IObjectCreationOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents creation of an object instance.
        <para>
        Current usage:
         (1) C# new expression.
         (2) VB New expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Constructor" Type="IMethodSymbol">
      <Comments>
        <summary>Constructor to be invoked on the created instance.</summary>
      </Comments>
    </Property>
    <Property Name="Arguments" Type="ImmutableArray&lt;IArgumentOperation&gt;">
      <Comments>
        <summary>Arguments of the object creation, excluding the instance argument. Arguments are in evaluation order.</summary>
        <remarks>
          If the invocation is in its expanded form, then params/ParamArray arguments would be collected into arrays.
          Default values are supplied for optional arguments missing in source.
        </remarks>
      </Comments>
    </Property>
    <Property Name="Initializer" Type="IObjectOrCollectionInitializerOperation">
      <Comments>
        <summary>Object or collection initializer, if any.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ITypeParameterObjectCreationOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a creation of a type parameter object, i.e. new T(), where T is a type parameter with new constraint.
        <para>
        Current usage:
         (1) C# type parameter object creation expression.
         (2) VB type parameter object creation expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Initializer" Type="IObjectOrCollectionInitializerOperation">
      <Comments>
        <summary>Object or collection initializer, if any.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IArrayCreationOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents the creation of an array instance.
        <para>
        Current usage:
         (1) C# array creation expression.
         (2) VB array creation expression.
        </para>
      </summary>
    </Comments>
    <Property Name="DimensionSizes" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>Sizes of the dimensions of the created array instance.</summary>
      </Comments>
    </Property>
    <Property Name="Initializer" Type="IArrayInitializerOperation">
      <Comments>
        <summary>Values of elements of the created array instance.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IInstanceReferenceOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an implicit/explicit reference to an instance.
        <para>
        Current usage:
         (1) C# this or base expression.
         (2) VB Me, MyClass, or MyBase expression.
         (3) C# object or collection initializers.
         (4) VB With statements, object or collection initializers.
        </para>
      </summary>
    </Comments>
    <Property Name="ReferenceKind" Type="InstanceReferenceKind">
      <Comments>
        <summary>The kind of reference that is being made.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IIsTypeOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an operation that tests if a value is of a specific type.
        <para>
        Current usage:
         (1) C# "is" operator expression.
         (2) VB "TypeOf" and "TypeOf IsNot" expression.
        </para>
      </summary>
    </Comments>
    <Property Name="ValueOperand" Type="IOperation">
      <Comments>
        <summary>Value to test.</summary>
      </Comments>
    </Property>
    <Property Name="TypeOperand" Type="ITypeSymbol">
      <Comments>
        <summary>Type for which to test.</summary>
      </Comments>
    </Property>
    <Property Name="IsNegated" Type="bool">
      <Comments>
        <summary>
          Flag indicating if this is an "is not" type expression.
          True for VB "TypeOf ... IsNot ..." expression.
          False, otherwise.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IAwaitOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an await operation.
        <para>
        Current usage:
         (1) C# await expression.
         (2) VB await expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Operation" Type="IOperation">
      <Comments>
        <summary>Awaited operation.</summary>
      </Comments>
    </Property>
  </Node>
  <AbstractNode Name="IAssignmentOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a base interface for assignments.
        <para>
        Current usage:
         (1) C# simple, compound and deconstruction assignment expressions.
         (2) VB simple and compound assignment expressions.
        </para>
      </summary>
    </Comments>
    <Property Name="Target" Type="IOperation">
      <Comments>
        <summary>Target of the assignment.</summary>
      </Comments>
    </Property>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Value to be assigned to the target of the assignment.</summary>
      </Comments>
    </Property>
  </AbstractNode>
  <Node Name="ISimpleAssignmentOperation" Base="IAssignmentOperation">
    <Comments>
      <summary>
        Represents a simple assignment operation.
        <para>
        Current usage:
         (1) C# simple assignment expression.
         (2) VB simple assignment expression.
        </para>
      </summary>
    </Comments>
    <Property Name="IsRef" Type="bool">
      <Comments>
        <summary>Is this a ref assignment</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ICompoundAssignmentOperation" Base="IAssignmentOperation">
    <Comments>
      <summary>
        Represents a compound assignment that mutates the target with the result of a binary operation.
        <para>
        Current usage:
         (1) C# compound assignment expression.
         (2) VB compound assignment expression.
        </para>
      </summary>
    </Comments>
    <Property Name="OperatorKind" Type="BinaryOperatorKind">
      <Comments>
        <summary>Kind of binary operation.</summary>
      </Comments>
    </Property>
    <Property Name="OperatorMethod" Type="IMethodSymbol">
      <Comments>
        <summary>Operator method used by the operation, null if the operation does not use an operator method.</summary>
      </Comments>
    </Property>
    <Property Name="IsLifted" Type="bool">
      <Comments>
        <summary>
          <see langword="true" /> if this assignment contains a 'lifted' binary operation.
        </summary>
      </Comments>
    </Property>
    <Property Name="IsChecked" Type="bool">
      <Comments>
        <summary>
          <see langword="true" /> if overflow checking is performed for the arithmetic operation.
        </summary>
      </Comments>
    </Property>
    <Property Name="InConversion" Type="CommonConversion">
      <Comments>
        <summary>
          Conversion applied to <see cref="IAssignmentOperation.Target" /> before the operation occurs.
        </summary>
      </Comments>
    </Property>
    <Property Name="OutConversion" Type="CommonConversion">
      <Comments>
        <summary>
          Conversion applied to the result of the binary operation, before it is assigned back to
          <see cref="IAssignmentOperation.Target" />.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IParenthesizedOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a parenthesized operation.
        <para>
        Current usage:
         (1) VB parenthesized expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Operand" Type="IOperation">
      <Comments>
        <summary>Operand enclosed in parentheses.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IEventAssignmentOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a binding of an event.
        <para>
        Current usage:
         (1) C# event assignment expression.
         (2) VB Add/Remove handler statement.
        </para>
      </summary>
    </Comments>
    <Property Name="EventReference" Type="IOperation">
      <Comments>
        <summary>Reference to the event being bound.</summary>
      </Comments>
    </Property>
    <Property Name="HandlerValue" Type="IOperation">
      <Comments>
        <summary>Handler supplied for the event.</summary>
      </Comments>
    </Property>
    <Property Name="Adds" Type="bool">
      <Comments>
        <summary>True for adding a binding, false for removing one.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IConditionalAccessOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a conditionally accessed operation. Note that <see cref="IConditionalAccessInstanceOperation" /> is used to refer to the value
        of <see cref="Operation" /> within <see cref="WhenNotNull" />.
        <para>
        Current usage:
         (1) C# conditional access expression (? or ?. operator).
         (2) VB conditional access expression (? or ?. operator).
        </para>
      </summary>
    </Comments>
    <Property Name="Operation" Type="IOperation">
      <Comments>
        <summary>Operation that will be evaluated and accessed if non null.</summary>
      </Comments>
    </Property>
    <Property Name="WhenNotNull" Type="IOperation">
      <Comments>
        <summary>
          Operation to be evaluated if <see cref="Operation" /> is non null.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IConditionalAccessInstanceOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents the value of a conditionally-accessed operation within <see cref="IConditionalAccessOperation.WhenNotNull" />.
        For a conditional access operation of the form <c>someExpr?.Member</c>, this operation is used as the InstanceReceiver for the right operation <c>Member</c>.
        See https://github.com/dotnet/roslyn/issues/21279#issuecomment-323153041 for more details.
        <para>
        Current usage:
         (1) C# conditional access instance expression.
         (2) VB conditional access instance expression.
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="IInterpolatedStringOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an interpolated string.
        <para>
        Current usage:
         (1) C# interpolated string expression.
         (2) VB interpolated string expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Parts" Type="ImmutableArray&lt;IInterpolatedStringContentOperation&gt;">
      <Comments>
        <summary>
          Constituent parts of interpolated string, each of which is an <see cref="IInterpolatedStringContentOperation" />.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IAnonymousObjectCreationOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a creation of anonymous object.
        <para>
        Current usage:
         (1) C# "new { ... }" expression
         (2) VB "New With { ... }" expression
        </para>
      </summary>
    </Comments>
    <Property Name="Initializers" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>
          Property initializers.
          Each initializer is an <see cref="ISimpleAssignmentOperation" />, with an <see cref="IPropertyReferenceOperation" />
          as the target whose Instance is an <see cref="IInstanceReferenceOperation" /> with <see cref="InstanceReferenceKind.ImplicitReceiver" /> kind.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IObjectOrCollectionInitializerOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an initialization for an object or collection creation.
        <para>
        Current usage:
         (1) C# object or collection initializer expression.
         (2) VB object or collection initializer expression.
        For example, object initializer "{ X = x }" within object creation "new Class() { X = x }" and
        collection initializer "{ x, y, 3 }" within collection creation "new MyList() { x, y, 3 }".
        </para>
      </summary>
    </Comments>
    <Property Name="Initializers" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>Object member or collection initializers.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IMemberInitializerOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an initialization of member within an object initializer with a nested object or collection initializer.
        <para>
        Current usage:
         (1) C# nested member initializer expression.
          For example, given an object creation with initializer "new Class() { X = x, Y = { x, y, 3 }, Z = { X = z } }",
          member initializers for Y and Z, i.e. "Y = { x, y, 3 }", and "Z = { X = z }" are nested member initializers represented by this operation.
        </para>
      </summary>
    </Comments>
    <Property Name="InitializedMember" Type="IOperation">
      <Comments>
        <summary>
          Initialized member reference <see cref="IMemberReferenceOperation" /> or an invalid operation for error cases.
        </summary>
      </Comments>
    </Property>
    <Property Name="Initializer" Type="IObjectOrCollectionInitializerOperation">
      <Comments>
        <summary>Member initializer.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ICollectionElementInitializerOperation" Base="IOperation">
    <Obsolete Error="true">"ICollectionElementInitializerOperation has been replaced with " + nameof(IInvocationOperation) + " and " + nameof(IDynamicInvocationOperation)</Obsolete>
    <Comments>
      <summary>
        Obsolete interface that used to represent a collection element initializer. It has been replaced by
        <see cref="IInvocationOperation" /> and <see cref="IDynamicInvocationOperation" />, as appropriate.
        <para>
        Current usage:
          None. This API has been obsoleted in favor of <see cref="IInvocationOperation" /> and <see cref="IDynamicInvocationOperation" />.
        </para>
      </summary>
    </Comments>
    <Property Name="AddMethod" Type="IMethodSymbol" />
    <Property Name="Arguments" Type="ImmutableArray&lt;IOperation&gt;" />
    <Property Name="IsDynamic" Type="bool" />
  </Node>
  <Node Name="INameOfOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an operation that gets a string value for the <see cref="Argument" /> name.
        <para>
        Current usage:
         (1) C# nameof expression.
         (2) VB NameOf expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Argument" Type="IOperation">
      <Comments>
        <summary>Argument to the name of operation.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ITupleOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a tuple with one or more elements.
        <para>
        Current usage:
         (1) C# tuple expression.
         (2) VB tuple expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Elements" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>Tuple elements.</summary>
      </Comments>
    </Property>
    <Property Name="NaturalType" Type="ITypeSymbol">
      <Comments>
        <summary>
          Natural type of the tuple, or null if tuple doesn't have a natural type.
          Natural type can be different from <see cref="IOperation.Type" /> depending on the
          conversion context, in which the tuple is used.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IDynamicObjectCreationOperation" Base="IOperation" SkipClassGeneration="true">
    <Comments>
      <summary>
        Represents an object creation with a dynamically bound constructor.
        <para>
        Current usage:
         (1) C# "new" expression with dynamic argument(s).
         (2) VB late bound "New" expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Initializer" Type="IObjectOrCollectionInitializerOperation">
      <Comments>
        <summary>Object or collection initializer, if any.</summary>
      </Comments>
    </Property>
    <Property Name="Arguments" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>Dynamically bound arguments, excluding the instance argument.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IDynamicMemberReferenceOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a reference to a member of a class, struct, or module that is dynamically bound.
        <para>
        Current usage:
         (1) C# dynamic member reference expression.
         (2) VB late bound member reference expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Instance" Type="IOperation">
      <Comments>
        <summary>Instance receiver. In VB, this can be null.</summary>
      </Comments>
    </Property>
    <Property Name="MemberName" Type="string">
      <Comments>
        <summary>Referenced member.</summary>
      </Comments>
    </Property>
    <Property Name="TypeArguments" Type="ImmutableArray&lt;ITypeSymbol&gt;">
      <Comments>
        <summary>Type arguments.</summary>
      </Comments>
    </Property>
    <Property Name="ContainingType" Type="ITypeSymbol">
      <Comments>
        <summary>
          The containing type of the referenced member, if different from type of the <see cref="Instance" />.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IDynamicInvocationOperation" Base="IOperation" SkipClassGeneration="true">
    <Comments>
      <summary>
        Represents a invocation that is dynamically bound.
        <para>
        Current usage:
         (1) C# dynamic invocation expression.
         (2) C# dynamic collection element initializer.
             For example, in the following collection initializer: <code>new C() { do1, do2, do3 }</code> where
             the doX objects are of type dynamic, we'll have 3 <see cref="IDynamicInvocationOperation" /> with do1, do2, and
             do3 as their arguments.
         (3) VB late bound invocation expression.
         (4) VB dynamic collection element initializer.
             Similar to the C# example, <code>New C() From {do1, do2, do3}</code> will generate 3 <see cref="IDynamicInvocationOperation" />
             nodes with do1, do2, and do3 as their arguments, respectively.
        </para>
      </summary>
    </Comments>
    <Property Name="Operation" Type="IOperation">
      <Comments>
        <summary>Dynamically or late bound operation.</summary>
      </Comments>
    </Property>
    <Property Name="Arguments" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>Dynamically bound arguments, excluding the instance argument.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IDynamicIndexerAccessOperation" Base="IOperation" SkipClassGeneration="true">
    <Comments>
      <summary>
        Represents an indexer access that is dynamically bound.
        <para>
        Current usage:
         (1) C# dynamic indexer access expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Operation" Type="IOperation">
      <Comments>
        <summary>Dynamically indexed operation.</summary>
      </Comments>
    </Property>
    <Property Name="Arguments" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>Dynamically bound arguments, excluding the instance argument.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ITranslatedQueryOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an unrolled/lowered query operation.
        For example, for a C# query expression "from x in set where x.Name != null select x.Name", the Operation tree has the following shape:
          ITranslatedQueryExpression
            IInvocationExpression ('Select' invocation for "select x.Name")
              IInvocationExpression ('Where' invocation for "where x.Name != null")
                IInvocationExpression ('From' invocation for "from x in set")
        <para>
        Current usage:
         (1) C# query expression.
         (2) VB query expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Operation" Type="IOperation">
      <Comments>
        <summary>Underlying unrolled operation.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IDelegateCreationOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a delegate creation. This is created whenever a new delegate is created.
        <para>
        Current usage:
         (1) C# delegate creation expression.
         (2) VB delegate creation expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Target" Type="IOperation">
      <Comments>
        <summary>The lambda or method binding that this delegate is created from.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IDefaultValueOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a default value operation.
        <para>
        Current usage:
         (1) C# default value expression.
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="ITypeOfOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an operation that gets <see cref="System.Type" /> for the given <see cref="TypeOperand" />.
        <para>
        Current usage:
         (1) C# typeof expression.
         (2) VB GetType expression.
        </para>
      </summary>
    </Comments>
    <Property Name="TypeOperand" Type="ITypeSymbol">
      <Comments>
        <summary>Type operand.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ISizeOfOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an operation to compute the size of a given type.
        <para>
        Current usage:
         (1) C# sizeof expression.
        </para>
      </summary>
    </Comments>
    <Property Name="TypeOperand" Type="ITypeSymbol">
      <Comments>
        <summary>Type operand.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IAddressOfOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an operation that creates a pointer value by taking the address of a reference.
        <para>
        Current usage:
         (1) C# address of expression
        </para>
      </summary>
    </Comments>
    <Property Name="Reference" Type="IOperation">
      <Comments>
        <summary>Addressed reference.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IIsPatternOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an operation that tests if a value matches a specific pattern.
        <para>
        Current usage:
         (1) C# is pattern expression. For example, "x is int i".
        </para>
      </summary>
    </Comments>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Underlying operation to test.</summary>
      </Comments>
    </Property>
    <Property Name="Pattern" Type="IPatternOperation">
      <Comments>
        <summary>Pattern.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IIncrementOrDecrementOperation" Base="IOperation">
    <OperationKind>
      <Entry Name="Increment" Value="0x42" ExtraDescription="This is used as an increment operator"/>
      <Entry Name="Decrement" Value="0x44" ExtraDescription="This is used as an decrement operator"/>
    </OperationKind>
    <Comments>
      <summary>
        Represents an <see cref="OperationKind.Increment" /> or <see cref="OperationKind.Decrement" /> operation.
        Note that this operation is different from an <see cref="IUnaryOperation" /> as it mutates the <see cref="Target" />,
        while unary operator expression does not mutate it's operand.
        <para>
        Current usage:
         (1) C# increment expression or decrement expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Target" Type="IOperation">
      <Comments>
        <summary>Target of the assignment.</summary>
      </Comments>
    </Property>
    <Property Name="OperatorMethod" Type="IMethodSymbol">
      <Comments>
        <summary>Operator method used by the operation, null if the operation does not use an operator method.</summary>
      </Comments>
    </Property>
    <Property Name="IsPostfix" Type="bool">
      <Comments>
        <summary>
          <see langword="true" /> if this is a postfix expression. <see langword="false" /> if this is a prefix expression.
        </summary>
      </Comments>
    </Property>
    <Property Name="IsLifted" Type="bool">
      <Comments>
        <summary>
          <see langword="true" /> if this is a 'lifted' increment operator.  When there
          is an operator that is defined to work on a value type, 'lifted' operators are
          created to work on the <see cref="System.Nullable{T}" /> versions of those
          value types.
        </summary>
      </Comments>
    </Property>
    <Property Name="IsChecked" Type="bool">
      <Comments>
        <summary>
          <see langword="true" /> if overflow checking is performed for the arithmetic operation.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IThrowOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an operation to throw an exception.
        <para>
        Current usage:
         (1) C# throw expression.
         (2) C# throw statement.
         (2) VB Throw statement.
        </para>
      </summary>
    </Comments>
    <Property Name="Exception" Type="IOperation">
      <Comments>
        <summary>Instance of an exception being thrown.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IDeconstructionAssignmentOperation" Base="IAssignmentOperation">
    <Comments>
      <summary>
        Represents a assignment with a deconstruction.
        <para>
        Current usage:
         (1) C# deconstruction assignment expression.
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="IDeclarationExpressionOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a declaration expression operation. Unlike a regular variable declaration <see cref="IVariableDeclaratorOperation" /> and <see cref="IVariableDeclarationOperation" />, this operation represents an "expression" declaring a variable.
        <para>
        Current usage:
         (1) C# declaration expression. For example,
         (a) "var (x, y)" is a deconstruction declaration expression with variables x and y.
         (b) "(var x, var y)" is a tuple expression with two declaration expressions.
         (c) "M(out var x);" is an invocation expression with an out "var x" declaration expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Expression" Type="IOperation">
      <Comments>
        <summary>Underlying expression.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IOmittedArgumentOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an argument value that has been omitted in an invocation.
        <para>
        Current usage:
         (1) VB omitted argument in an invocation expression.
        </para>
      </summary>
    </Comments>
  </Node>
  <AbstractNode Name="ISymbolInitializerOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an initializer for a field, property, parameter or a local variable declaration.
        <para>
        Current usage:
         (1) C# field, property, parameter or local variable initializer.
         (2) VB field(s), property, parameter or local variable initializer.
        </para>
      </summary>
    </Comments>
    <Property Name="Locals" Type="ImmutableArray&lt;ILocalSymbol&gt;">
      <Comments>
        <summary>
          Local declared in and scoped to the <see cref="Value" />.
        </summary>
      </Comments>
    </Property>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Underlying initializer value.</summary>
      </Comments>
    </Property>
  </AbstractNode>
  <Node Name="IFieldInitializerOperation" Base="ISymbolInitializerOperation">
    <Comments>
      <summary>
        Represents an initialization of a field.
        <para>
        Current usage:
         (1) C# field initializer with equals value clause.
         (2) VB field(s) initializer with equals value clause or AsNew clause. Multiple fields can be initialized with AsNew clause in VB.
        </para>
      </summary>
    </Comments>
    <Property Name="InitializedFields" Type="ImmutableArray&lt;IFieldSymbol&gt;">
      <Comments>
        <summary>Initialized fields. There can be multiple fields for Visual Basic fields declared with AsNew clause.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IVariableInitializerOperation" Base="ISymbolInitializerOperation">
    <Comments>
      <summary>
        Represents an initialization of a local variable.
        <para>
        Current usage:
         (1) C# local variable initializer with equals value clause.
         (2) VB local variable initializer with equals value clause or AsNew clause.
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="IPropertyInitializerOperation" Base="ISymbolInitializerOperation">
    <Comments>
      <summary>
        Represents an initialization of a property.
        <para>
        Current usage:
         (1) C# property initializer with equals value clause.
         (2) VB property initializer with equals value clause or AsNew clause. Multiple properties can be initialized with 'WithEvents' declaration with AsNew clause in VB.
        </para>
      </summary>
    </Comments>
    <Property Name="InitializedProperties" Type="ImmutableArray&lt;IPropertySymbol&gt;">
      <Comments>
        <summary>Initialized properties. There can be multiple properties for Visual Basic 'WithEvents' declaration with AsNew clause.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IParameterInitializerOperation" Base="ISymbolInitializerOperation">
    <Comments>
      <summary>
        Represents an initialization of a parameter at the point of declaration.
        <para>
        Current usage:
         (1) C# parameter initializer with equals value clause.
         (2) VB parameter initializer with equals value clause.
        </para>
      </summary>
    </Comments>
    <Property Name="Parameter" Type="IParameterSymbol">
      <Comments>
        <summary>Initialized parameter.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IArrayInitializerOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents the initialization of an array instance.
        <para>
        Current usage:
         (1) C# array initializer.
         (2) VB array initializer.
        </para>
      </summary>
    </Comments>
    <Property Name="ElementValues" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>Values to initialize array elements.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IVariableDeclaratorOperation" Base="IOperation">
    <Comments>
      <summary>Represents a single variable declarator and initializer.</summary>
      <para>
        Current Usage:
          (1) C# variable declarator
          (2) C# catch variable declaration
          (3) VB single variable declaration
          (4) VB catch variable declaration
      </para>
      <remarks>
        In VB, the initializer for this node is only ever used for explicit array bounds initializers. This node corresponds to
        the VariableDeclaratorSyntax in C# and the ModifiedIdentifierSyntax in VB.
      </remarks>
    </Comments>
    <Property Name="Symbol" Type="ILocalSymbol">
      <Comments>
        <summary>Symbol declared by this variable declaration</summary>
      </Comments>
    </Property>
    <Property Name="Initializer" Type="IVariableInitializerOperation">
      <Comments>
        <summary>Optional initializer of the variable.</summary>
        <remarks>
          If this variable is in an <see cref="IVariableDeclarationOperation" />, the initializer may be located
          in the parent operation. Call <see cref="OperationExtensions.GetVariableInitializer(IVariableDeclaratorOperation)" />
          to check in all locations. It is only possible to have initializers in both locations in VB invalid code scenarios.
        </remarks>
      </Comments>
    </Property>
    <Property Name="IgnoredArguments" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>
          Additional arguments supplied to the declarator in error cases, ignored by the compiler. This only used for the C# case of
          DeclaredArgumentSyntax nodes on a VariableDeclaratorSyntax.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IVariableDeclarationOperation" Base="IOperation">
    <Comments>
      <summary>Represents a declarator that declares multiple individual variables.</summary>
      <para>
        Current Usage:
          (1) C# VariableDeclaration
          (2) C# fixed declarations
          (3) C# using declarations
          (4) VB Dim statement declaration groups
          (5) VB Using statement variable declarations
      </para>
      <remarks>
        The initializer of this node is applied to all individual declarations in <see cref="Declarators" />. There cannot
        be initializers in both locations except in invalid code scenarios.
        In C#, this node will never have an initializer.
        This corresponds to the VariableDeclarationSyntax in C#, and the VariableDeclaratorSyntax in Visual Basic.
      </remarks>
    </Comments>
    <Property Name="Declarators" Type="ImmutableArray&lt;IVariableDeclaratorOperation&gt;">
      <Comments>
        <summary>Individual variable declarations declared by this multiple declaration.</summary>
        <remarks>
          All <see cref="IVariableDeclarationGroupOperation" /> will have at least 1 <see cref="IVariableDeclarationOperation" />,
          even if the declaration group only declares 1 variable.
        </remarks>
      </Comments>
    </Property>
    <Property Name="Initializer" Type="IVariableInitializerOperation">
      <Comments>
        <summary>Optional initializer of the variable.</summary>
        <remarks>In C#, this will always be null.</remarks>
      </Comments>
    </Property>
    <Property Name="IgnoredDimensions" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>
          Array dimensions supplied to an array declaration in error cases, ignored by the compiler. This is only used for the C# case of
          RankSpecifierSyntax nodes on an ArrayTypeSyntax.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IArgumentOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an argument to a method invocation.
        <para>
        Current usage:
         (1) C# argument to an invocation expression, object creation expression, etc.
         (2) VB argument to an invocation expression, object creation expression, etc.
        </para>
      </summary>
    </Comments>
    <Property Name="ArgumentKind" Type="ArgumentKind">
      <Comments>
        <summary>Kind of argument.</summary>
      </Comments>
    </Property>
    <Property Name="Parameter" Type="IParameterSymbol">
      <Comments>
        <summary>Parameter the argument matches.</summary>
      </Comments>
    </Property>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Value supplied for the argument.</summary>
      </Comments>
    </Property>
    <Property Name="InConversion" Type="CommonConversion">
      <Comments>
        <summary>Information of the conversion applied to the argument value passing it into the target method. Applicable only to VB Reference arguments.</summary>
      </Comments>
    </Property>
    <Property Name="OutConversion" Type="CommonConversion">
      <Comments>
        <summary>Information of the conversion applied to the argument value after the invocation. Applicable only to VB Reference arguments.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ICatchClauseOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a catch clause.
        <para>
        Current usage:
         (1) C# catch clause.
         (2) VB Catch clause.
        </para>
      </summary>
    </Comments>
    <Property Name="Handler" Type="IBlockOperation">
      <Comments>
        <summary>Body of the exception handler.</summary>
      </Comments>
    </Property>
    <Property Name="Locals" Type="ImmutableArray&lt;ILocalSymbol&gt;">
      <Comments>
        <summary>
          Locals declared by the <see cref="ExceptionDeclarationOrExpression" /> and/or <see cref="Filter" /> clause.
        </summary>
      </Comments>
    </Property>
    <Property Name="ExceptionType" Type="ITypeSymbol">
      <Comments>
        <summary>Type of the exception handled by the catch clause.</summary>
      </Comments>
    </Property>
    <Property Name="ExceptionDeclarationOrExpression" Type="IOperation">
      <Comments>
        <summary>
          Optional source for exception. This could be any of the following operation:
          1. Declaration for the local catch variable bound to the caught exception (C# and VB) OR
          2. Null, indicating no declaration or expression (C# and VB)
          3. Reference to an existing local or parameter (VB) OR
          4. Other expression for error scenarios (VB)
        </summary>
      </Comments>
    </Property>
    <Property Name="Filter" Type="IOperation">
      <Comments>
        <summary>Filter operation to be executed to determine whether to handle the exception.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ISwitchCaseOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a switch case section with one or more case clauses to match and one or more operations to execute within the section.
        <para>
        Current usage:
         (1) C# switch section for one or more case clause and set of statements to execute.
         (2) VB case block with a case statement for one or more case clause and set of statements to execute.
        </para>
      </summary>
    </Comments>
    <Property Name="Clauses" Type="ImmutableArray&lt;ICaseClauseOperation&gt;">
      <Comments>
        <summary>Clauses of the case.</summary>
      </Comments>
    </Property>
    <Property Name="Body" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>One or more operations to execute within the switch section.</summary>
      </Comments>
    </Property>
    <Property Name="Locals" Type="ImmutableArray&lt;ILocalSymbol&gt;">
      <Comments>
        <summary>Locals declared within the switch case section scoped to the section.</summary>
      </Comments>
    </Property>
  </Node>
  <AbstractNode Name="ICaseClauseOperation" Base="IOperation">
    <OperationKind Include="true" ExtraDescription="This is further differentiated by &lt;see cref=&quot;ICaseClauseOperation.CaseKind&quot;/&gt;." />
    <Comments>
      <summary>
        Represents a case clause.
        <para>
        Current usage:
         (1) C# case clause.
         (2) VB Case clause.
        </para>
      </summary>
    </Comments>
    <Property Name="CaseKind" Type="CaseKind">
      <Comments>
        <summary>Kind of the clause.</summary>
      </Comments>
    </Property>
    <Property Name="Label" Type="ILabelSymbol">
      <Comments>
        <summary>Label associated with the case clause, if any.</summary>
      </Comments>
    </Property>
  </AbstractNode>
  <Node Name="IDefaultCaseClauseOperation" Base="ICaseClauseOperation">
    <OperationKind Include="false" />
    <Comments>
      <summary>
        Represents a default case clause.
        <para>
        Current usage:
         (1) C# default clause.
         (2) VB Case Else clause.
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="IPatternCaseClauseOperation" Base="ICaseClauseOperation">
    <OperationKind Include="false" />
    <Comments>
      <summary>
        Represents a case clause with a pattern and an optional guard operation.
        <para>
        Current usage:
         (1) C# pattern case clause.
        </para>
      </summary>
    </Comments>
    <Property Name="Label" Type="ILabelSymbol" New="true">
      <Comments>
        <summary>
          Label associated with the case clause.
          https://github.com/dotnet/roslyn/issues/27602: Similar property was added to the base interface, consider if we can remove this one.
        </summary>
      </Comments>
    </Property>
    <Property Name="Pattern" Type="IPatternOperation">
      <Comments>
        <summary>Pattern associated with case clause.</summary>
      </Comments>
    </Property>
    <Property Name="Guard" Type="IOperation">
      <Comments>
        <summary>Guard associated with the pattern case clause.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IRangeCaseClauseOperation" Base="ICaseClauseOperation">
    <OperationKind Include="false" />
    <Comments>
      <summary>
        Represents a case clause with range of values for comparison.
        <para>
        Current usage:
         (1) VB range case clause of the form "Case x To y".
        </para>
      </summary>
    </Comments>
    <Property Name="MinimumValue" Type="IOperation">
      <Comments>
        <summary>Minimum value of the case range.</summary>
      </Comments>
    </Property>
    <Property Name="MaximumValue" Type="IOperation">
      <Comments>
        <summary>Maximum value of the case range.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IRelationalCaseClauseOperation" Base="ICaseClauseOperation">
    <OperationKind Include="false" />
    <Comments>
      <summary>
        Represents a case clause with custom relational operator for comparison.
        <para>
        Current usage:
         (1) VB relational case clause of the form "Case Is op x".
        </para>
      </summary>
    </Comments>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Case value.</summary>
      </Comments>
    </Property>
    <Property Name="Relation" Type="BinaryOperatorKind">
      <Comments>
        <summary>Relational operator used to compare the switch value with the case value.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ISingleValueCaseClauseOperation" Base="ICaseClauseOperation">
    <OperationKind Include="false" />
    <Comments>
      <summary>
        Represents a case clause with a single value for comparison.
        <para>
        Current usage:
         (1) C# case clause of the form "case x"
         (2) VB case clause of the form "Case x".
        </para>
      </summary>
    </Comments>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Case value.</summary>
      </Comments>
    </Property>
  </Node>
  <AbstractNode Name="IInterpolatedStringContentOperation" Base="IOperation" SkipClassGeneration="true">
    <Comments>
      <summary>
        Represents a constituent part of an interpolated string.
        <para>
        Current usage:
         (1) C# interpolated string content.
         (2) VB interpolated string content.
        </para>
      </summary>
    </Comments>
  </AbstractNode>
  <Node Name="IInterpolatedStringTextOperation" Base="IInterpolatedStringContentOperation">
    <Comments>
      <summary>
        Represents a constituent string literal part of an interpolated string operation.
        <para>
        Current usage:
         (1) C# interpolated string text.
         (2) VB interpolated string text.
        </para>
      </summary>
    </Comments>
    <Property Name="Text" Type="IOperation">
      <Comments>
        <summary>Text content.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IInterpolationOperation" Base="IInterpolatedStringContentOperation">
    <Comments>
      <summary>
        Represents a constituent interpolation part of an interpolated string operation.
        <para>
        Current usage:
         (1) C# interpolation part.
         (2) VB interpolation part.
        </para>
      </summary>
    </Comments>
    <Property Name="Expression" Type="IOperation">
      <Comments>
        <summary>Expression of the interpolation.</summary>
      </Comments>
    </Property>
    <Property Name="Alignment" Type="IOperation">
      <Comments>
        <summary>Optional alignment of the interpolation.</summary>
      </Comments>
    </Property>
    <Property Name="FormatString" Type="IOperation">
      <Comments>
        <summary>Optional format string of the interpolation.</summary>
      </Comments>
    </Property>
  </Node>
  <AbstractNode Name="IPatternOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a pattern matching operation.
        <para>
        Current usage:
         (1) C# pattern.
        </para>
      </summary>
    </Comments>
    <Property Name="InputType" Type="ITypeSymbol">
      <Comments>
        <summary>The input type to the pattern-matching operation.</summary>
      </Comments>
    </Property>
  </AbstractNode>
  <Node Name="IConstantPatternOperation" Base="IPatternOperation">
    <Comments>
      <summary>
        Represents a pattern with a constant value.
        <para>
        Current usage:
         (1) C# constant pattern.
        </para>
      </summary>
    </Comments>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Constant value of the pattern operation.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IDeclarationPatternOperation" Base="IPatternOperation">
    <Comments>
      <summary>
        Represents a pattern that declares a symbol.
        <para>
        Current usage:
         (1) C# declaration pattern.
        </para>
      </summary>
    </Comments>
    <Property Name="MatchedType" Type="ITypeSymbol">
      <Comments>
        <summary>
          The type explicitly specified, or null if it was inferred (e.g. using <code>var</code> in C#).
        </summary>
      </Comments>
    </Property>
    <Property Name="MatchesNull" Type="bool">
      <Comments>
        <summary>
          True if the pattern is of a form that accepts null.
          For example, in C# the pattern `var x` will match a null input,
          while the pattern `string x` will not.
        </summary>
      </Comments>
    </Property>
    <Property Name="DeclaredSymbol" Type="ISymbol">
      <Comments>
        <summary>Symbol declared by the pattern, if any.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ITupleBinaryOperation" Base="IOperation" VisitorName="VisitTupleBinaryOperator">
    <OperationKind>
      <Entry Name="TupleBinary" Value="0x57" />
      <Entry Name="TupleBinaryOperator" Value="0x57" EditorBrowsable="false" ExtraDescription="Use &lt;see cref=&quot;TupleBinary&quot;/&gt; instead." />
    </OperationKind>
    <Comments>
      <summary>
        Represents a comparison of two operands that returns a bool type.
        <para>
        Current usage:
         (1) C# tuple binary operator expression.
        </para>
      </summary>
    </Comments>
    <Property Name="OperatorKind" Type="BinaryOperatorKind">
      <Comments>
        <summary>Kind of binary operation.</summary>
      </Comments>
    </Property>
    <Property Name="LeftOperand" Type="IOperation">
      <Comments>
        <summary>Left operand.</summary>
      </Comments>
    </Property>
    <Property Name="RightOperand" Type="IOperation">
      <Comments>
        <summary>Right operand.</summary>
      </Comments>
    </Property>
  </Node>
  <AbstractNode Name="IMethodBodyBaseOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a method body operation.
        <para>
        Current usage:
         (1) C# method body
        </para>
      </summary>
    </Comments>
    <Property Name="BlockBody" Type="IBlockOperation">
      <Comments>
        <summary>Method body corresponding to BaseMethodDeclarationSyntax.Body or AccessorDeclarationSyntax.Body</summary>
      </Comments>
    </Property>
    <Property Name="ExpressionBody" Type="IBlockOperation">
      <Comments>
        <summary>Method body corresponding to BaseMethodDeclarationSyntax.ExpressionBody or AccessorDeclarationSyntax.ExpressionBody</summary>
      </Comments>
    </Property>
  </AbstractNode>
  <Node Name="IMethodBodyOperation" Base="IMethodBodyBaseOperation" VisitorName="VisitMethodBodyOperation">
    <OperationKind>
      <Entry Name="MethodBody" Value="0x58" />
      <Entry Name="MethodBodyOperation" Value="0x58" EditorBrowsable="false" ExtraDescription="Use &lt;see cref=&quot;MethodBody&quot;/&gt; instead." />
    </OperationKind>
    <Comments>
      <summary>
        Represents a method body operation.
        <para>
        Current usage:
         (1) C# method body for non-constructor
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="IConstructorBodyOperation" Base="IMethodBodyBaseOperation" VisitorName="VisitConstructorBodyOperation">
    <OperationKind>
      <Entry Name="ConstructorBody" Value="0x59" />
      <Entry Name="ConstructorBodyOperation" Value="0x59" EditorBrowsable="false" ExtraDescription="Use &lt;see cref=&quot;ConstructorBody&quot;/&gt; instead." />
    </OperationKind>
    <Comments>
      <summary>
        Represents a constructor method body operation.
        <para>
        Current usage:
         (1) C# method body for constructor declaration
        </para>
      </summary>
    </Comments>
    <Property Name="Locals" Type="ImmutableArray&lt;ILocalSymbol&gt;">
      <Comments>
        <summary>Local declarations contained within the <see cref="Initializer" />.</summary>
      </Comments>
    </Property>
    <Property Name="Initializer" Type="IOperation">
      <Comments>
        <summary>Constructor initializer, if any.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IDiscardOperation" Base="IOperation" VisitorName="VisitDiscardOperation">
    <Comments>
      <summary>
        Represents a discard operation.
        <para>
        Current usage: C# discard expressions
        </para>
      </summary>
    </Comments>
    <Property Name="DiscardSymbol" Type="IDiscardSymbol">
      <Comments>
        <summary>The symbol of the discard operation.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IFlowCaptureOperation" Base="IOperation" Namespace="FlowAnalysis">
    <Comments>
      <summary>
        Represents that an intermediate result is being captured.
        This node is produced only as part of a <see cref="ControlFlowGraph" />.
      </summary>
    </Comments>
    <Property Name="Id" Type="CaptureId">
      <Comments>
        <summary>An id used to match references to the same intermediate result.</summary>
      </Comments>
    </Property>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Value to be captured.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IFlowCaptureReferenceOperation" Base="IOperation" Namespace="FlowAnalysis">
    <Comments>
      <summary>
        Represents a point of use of an intermediate result captured earlier.
        The fact of capturing the result is represented by <see cref="IFlowCaptureOperation" />.
        This node is produced only as part of a <see cref="ControlFlowGraph" />.
      </summary>
    </Comments>
    <Property Name="Id" Type="CaptureId">
      <Comments>
        <summary>An id used to match references to the same intermediate result.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IIsNullOperation" Base="IOperation" Namespace="FlowAnalysis">
    <Comments>
      <summary>
        Represents result of checking whether the <see cref="Operand" /> is null.
        For reference types this checks if the <see cref="Operand" /> is a null reference,
        for nullable types this checks if the <see cref="Operand" /> doesn’t have a value.
        The node is produced as part of a flow graph during rewrite of <see cref="ICoalesceOperation" />
        and <see cref="IConditionalAccessOperation" /> nodes.
      </summary>
    </Comments>
    <Property Name="Operand" Type="IOperation">
      <Comments>
        <summary>Value to check.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ICaughtExceptionOperation" Base="IOperation" Namespace="FlowAnalysis">
    <Comments>
      <summary>
        Represents a exception instance passed by an execution environment to an exception filter or handler.
        This node is produced only as part of a <see cref="ControlFlowGraph" />.
      </summary>
    </Comments>
  </Node>
  <Node Name="IStaticLocalInitializationSemaphoreOperation" Base="IOperation" Namespace="FlowAnalysis">
    <Comments>
      <summary>
        Represents the check during initialization of a VB static local that is initialized on the first call of the function, and never again.
        If the semaphore operation returns true, the static local has not yet been initialized, and the initializer will be run. If it returns
        false, then the local has already been initialized, and the static local initializer region will be skipped.
        This node is produced only as part of a <see cref="ControlFlowGraph" />.
      </summary>
    </Comments>
    <Property Name="Local" Type="ILocalSymbol">
      <Comments>
        <summary>The static local variable that is possibly initialized.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IFlowAnonymousFunctionOperation" Base="IOperation" Namespace="FlowAnalysis" SkipClassGeneration="true">
    <Comments>
      <summary>
        Represents an anonymous function operation in context of a <see cref="ControlFlowGraph" />.
        <para>
        Current usage:
         (1) C# lambda expression.
         (2) VB anonymous delegate expression.
        </para>
        A <see cref="ControlFlowGraph" /> for the body of the anonymous function is available from
        the enclosing <see cref="ControlFlowGraph" />.
      </summary>
    </Comments>
    <Property Name="Symbol" Type="IMethodSymbol">
      <Comments>
        <summary>Symbol of the anonymous function.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ICoalesceAssignmentOperation" Base="IAssignmentOperation">
    <Comments>
      <summary>
        Represents a coalesce assignment operation with a target and a conditionally-evaluated value:
        (1) <see cref="IAssignmentOperation.Target" /> is evaluated for null. If it is null, <see cref="IAssignmentOperation.Value" /> is evaluated and assigned to target.
        (2) <see cref="IAssignmentOperation.Value" /> is conditionally evaluated if <see cref="IAssignmentOperation.Target" /> is null, and the result is assigned into <see cref="IAssignmentOperation.Target" />.
        The result of the entire expression is<see cref="IAssignmentOperation.Target" />, which is only evaluated once.
        <para>
        Current usage:
         (1) C# null-coalescing assignment operation <code>Target ??= Value</code>.
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="IRangeOperation" Base="IOperation" VisitorName="VisitRangeOperation">
    <Comments>
      <summary>
        Represents a range operation.
        <para>
        Current usage:
         (1) C# range expressions
        </para>
      </summary>
    </Comments>
    <Property Name="LeftOperand" Type="IOperation">
      <Comments>
        <summary>Left operand.</summary>
      </Comments>
    </Property>
    <Property Name="RightOperand" Type="IOperation">
      <Comments>
        <summary>Right operand.</summary>
      </Comments>
    </Property>
    <Property Name="IsLifted" Type="bool">
      <Comments>
        <summary>
          <code>true</code> if this is a 'lifted' range operation.  When there is an
          operator that is defined to work on a value type, 'lifted' operators are
          created to work on the <see cref="System.Nullable{T}" /> versions of those
          value types.
        </summary>
      </Comments>
    </Property>
    <Property Name="Method" Type="IMethodSymbol">
      <Comments>
        <summary>
          Factory method used to create this Range value. Can be null if appropriate
          symbol was not found.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IReDimOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents the ReDim operation to re-allocate storage space for array variables.
        <para>
        Current usage:
         (1) VB ReDim statement.
        </para>
      </summary>
    </Comments>
    <Property Name="Clauses" Type="ImmutableArray&lt;IReDimClauseOperation&gt;">
      <Comments>
        <summary>Individual clauses of the ReDim operation.</summary>
      </Comments>
    </Property>
    <Property Name="Preserve" Type="bool">
      <Comments>
        <summary>Modifier used to preserve the data in the existing array when you change the size of only the last dimension.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IReDimClauseOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an individual clause of an <see cref="IReDimOperation" /> to re-allocate storage space for a single array variable.
        <para>
        Current usage:
         (1) VB ReDim clause.
        </para>
      </summary>
    </Comments>
    <Property Name="Operand" Type="IOperation">
      <Comments>
        <summary>Operand whose storage space needs to be re-allocated.</summary>
      </Comments>
    </Property>
    <Property Name="DimensionSizes" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>Sizes of the dimensions of the created array instance.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IRecursivePatternOperation" Base="IPatternOperation">
    <Comments>
      <summary>Represents a C# recursive pattern.</summary>
    </Comments>
    <Property Name="MatchedType" Type="ITypeSymbol">
      <Comments>
        <summary>The type accepted for the recursive pattern.</summary>
      </Comments>
    </Property>
    <Property Name="DeconstructSymbol" Type="ISymbol">
      <Comments>
        <summary>
          The symbol, if any, used for the fetching values for subpatterns. This is either a <code>Deconstruct</code>
          method, the type <code>System.Runtime.CompilerServices.ITuple</code>, or null (for example, in
          error cases or when matching a tuple type).
        </summary>
      </Comments>
    </Property>
    <Property Name="DeconstructionSubpatterns" Type="ImmutableArray&lt;IPatternOperation&gt;">
      <Comments>
        <summary>This contains the patterns contained within a deconstruction or positional subpattern.</summary>
      </Comments>
    </Property>
    <Property Name="PropertySubpatterns" Type="ImmutableArray&lt;IPropertySubpatternOperation&gt;">
      <Comments>
        <summary>This contains the (symbol, property) pairs within a property subpattern.</summary>
      </Comments>
    </Property>
    <Property Name="DeclaredSymbol" Type="ISymbol">
      <Comments>
        <summary>Symbol declared by the pattern.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IDiscardPatternOperation" Base="IPatternOperation">
    <Comments>
      <summary>
        Represents a discard pattern.
        <para>
        Current usage: C# discard pattern
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="ISwitchExpressionOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a switch expression.
        <para>
        Current usage:
         (1) C# switch expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Value to be switched upon.</summary>
      </Comments>
    </Property>
    <Property Name="Arms" Type="ImmutableArray&lt;ISwitchExpressionArmOperation&gt;">
      <Comments>
        <summary>Arms of the switch expression.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ISwitchExpressionArmOperation" Base="IOperation">
    <Comments>
      <summary>Represents one arm of a switch expression.</summary>
    </Comments>
    <Property Name="Pattern" Type="IPatternOperation">
      <Comments>
        <summary>The pattern to match.</summary>
      </Comments>
    </Property>
    <Property Name="Guard" Type="IOperation">
      <Comments>
        <summary>Guard (when clause expression) associated with the switch arm, if any.</summary>
      </Comments>
    </Property>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Result value of the enclosing switch expression when this arm matches.</summary>
      </Comments>
    </Property>
    <Property Name="Locals" Type="ImmutableArray&lt;ILocalSymbol&gt;">
      <Comments>
        <summary>Locals declared within the switch arm (e.g. pattern locals and locals declared in the guard) scoped to the arm.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IPropertySubpatternOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an element of a property subpattern, which identifies a member to be matched and the
        pattern to match it against.
      </summary>
    </Comments>
    <Property Name="Member" Type="IOperation">
      <Comments>
        <summary>
          The member being matched in a property subpattern.  This can be a <see cref="IMemberReferenceOperation" />
          in non-error cases, or an <see cref="IInvalidOperation" /> in error cases.
        </summary>
      </Comments>
    </Property>
    <Property Name="Pattern" Type="IPatternOperation">
      <Comments>
        <summary>The pattern to which the member is matched in a property subpattern.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IAggregateQueryOperation" Base="IOperation" Internal="true">
    <Comments>
      <summary>Represents a standalone VB query Aggregate operation with more than one item in Into clause.</summary>
    </Comments>
    <Property Name="Group" Type="IOperation" />
    <Property Name="Aggregation" Type="IOperation" />
  </Node>
  <Node Name="IFixedOperation" Base="IOperation" Internal="true" SkipInVisitor ="true">
    <Comments>
      <summary>Represents a C# fixed statement.</summary>
    </Comments>
    <Property Name="Locals" Type="ImmutableArray&lt;ILocalSymbol&gt;">
      <Comments>
        <summary>Locals declared.</summary>
      </Comments>
    </Property>
    <Property Name="Variables" Type="IVariableDeclarationGroupOperation">
      <Comments>
        <summary>Variables to be fixed.</summary>
      </Comments>
    </Property>
    <Property Name="Body" Type="IOperation">
      <Comments>
        <summary>Body of the fixed, over which the variables are fixed.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="INoPiaObjectCreationOperation" Base="IOperation" Internal="true">
    <Comments>
      <summary>
        Represents a creation of an instance of a NoPia interface, i.e. new I(), where I is an embedded NoPia interface.
        <para>
        Current usage:
         (1) C# NoPia interface instance creation expression.
         (2) VB NoPia interface instance creation expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Initializer" Type="IObjectOrCollectionInitializerOperation">
      <Comments>
        <summary>Object or collection initializer, if any.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IPlaceholderOperation" Base="IOperation" Internal="true">
    <Comments>
      <summary>
        Represents a general placeholder when no more specific kind of placeholder is available.
        A placeholder is an expression whose meaning is inferred from context.
      </summary>
    </Comments>
    <Property Name="PlaceholderKind" Type="PlaceholderKind" />
  </Node>
  <Node Name="IPointerIndirectionReferenceOperation" Base="IOperation" Internal="true">
    <Comments>
      <summary>
        Represents a reference through a pointer.
        <para>
        Current usage:
         (1) C# pointer indirection reference expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Pointer" Type="IOperation">
      <Comments>
        <summary>Pointer to be dereferenced.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IWithOperation" Base="IOperation" Internal="true">
    <Comments>
      <summary>
        Represents a <see cref="Body" /> of operations that are executed with implicit reference to the <see cref="Value" /> for member references.
        <para>
        Current usage:
         (1) VB With statement.
        </para>
      </summary>
    </Comments>
    <Property Name="Body" Type="IOperation">
      <Comments>
        <summary>Body of the with.</summary>
      </Comments>
    </Property>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Value to whose members leading-dot-qualified references within the with body bind.</summary>
      </Comments>
    </Property>
  </Node>
</Tree>