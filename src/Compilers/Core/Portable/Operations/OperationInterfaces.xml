<?xml version="1.0" encoding="UTF-8"?>
<!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the LICENSE file in the project root for more information. -->
<Tree Root="IOperation">

  <!--
      To regenerate the operation nodes, run eng/generate-compiler-code.cmd

      The operations in this file are _ordered_! If you change the order in here,
      you will affect the ordering in the generated OperationKind enum, which will
      break the public api analyzer. All new types should be put at the end of this
      file in order to ensure that the kind does not continue to change.

      UnusedOperationKinds indicates kinds that are currently skipped by the OperationKind
      enum. They can be used by future nodes by inserting those nodes at the correct point
      in the list.

      When implementing new operations, run tests with additional IOperation validation enabled.
      You can test with `Build.cmd -testIOperation`.
      Or to repro in VS, you can do `set ROSLYN_TEST_IOPERATION=true` then `devenv`.
        -->

  <UnusedOperationKinds>
    <Entry Value="0x1D"/>
    <Entry Value="0x62"/>
    <Entry Value="0x64"/>
  </UnusedOperationKinds>

  <Node Name="IInvalidOperation" Base="IOperation" SkipClassGeneration="true">
    <Comments>
      <summary>
        Represents an invalid operation with one or more child operations.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# invalid expression or invalid statement</description></item>
          <item><description>VB invalid expression or invalid statement</description></item>
        </list>
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="IBlockOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a block containing a sequence of operations and local declarations.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# "{ ... }" block statement</description></item>
          <item><description>VB implicit block statement for method bodies and other block scoped statements</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Operations" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>Operations contained within the block.</summary>
      </Comments>
    </Property>
    <Property Name="Locals" Type="ImmutableArray&lt;ILocalSymbol&gt;">
      <Comments>
        <summary>Local declarations contained within the block.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IVariableDeclarationGroupOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a variable declaration statement.
        <para>
        Current Usage:
        <list type="number">
          <item><description>C# local declaration statement</description></item>
          <item><description>C# fixed statement</description></item>
          <item><description>C# using statement</description></item>
          <item><description>C# using declaration</description></item>
          <item><description>VB Dim statement</description></item>
          <item><description>VB Using statement</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Declarations" Type="ImmutableArray&lt;IVariableDeclarationOperation&gt;">
      <Comments>
        <summary>Variable declaration in the statement.</summary>
        <remarks>
          In C#, this will always be a single declaration, with all variables in <see cref="IVariableDeclarationOperation.Declarators" />.
        </remarks>
      </Comments>
    </Property>
  </Node>
  <Node Name="ISwitchOperation" Base="IOperation" ChildrenOrder="Value,Cases">
    <Comments>
      <summary>
        Represents a switch operation with a value to be switched upon and switch cases.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# switch statement</description></item>
          <item><description>VB Select Case statement</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Locals" Type="ImmutableArray&lt;ILocalSymbol&gt;">
      <Comments>
        <summary>
          Locals declared within the switch operation with scope spanning across all <see cref="Cases" />.
        </summary>
      </Comments>
    </Property>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Value to be switched upon.</summary>
      </Comments>
    </Property>
    <Property Name="Cases" Type="ImmutableArray&lt;ISwitchCaseOperation&gt;">
      <Comments>
        <summary>Cases of the switch.</summary>
      </Comments>
    </Property>
    <Property Name="ExitLabel" Type="ILabelSymbol">
      <Comments>
        <summary>Exit label for the switch statement.</summary>
      </Comments>
    </Property>
  </Node>
  <AbstractNode Name="ILoopOperation" Base="IOperation">
    <OperationKind Include="true" ExtraDescription="This is further differentiated by &lt;see cref=&quot;ILoopOperation.LoopKind&quot;/&gt;." />
    <Comments>
      <summary>
        Represents a loop operation.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# 'while', 'for', 'foreach' and 'do' loop statements</description></item>
          <item><description>VB 'While', 'ForTo', 'ForEach', 'Do While' and 'Do Until' loop statements</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="LoopKind" Type="LoopKind" MakeAbstract="true">
      <Comments>
        <summary>Kind of the loop.</summary>
      </Comments>
    </Property>
    <Property Name="Body" Type="IOperation">
      <Comments>
        <summary>Body of the loop.</summary>
      </Comments>
    </Property>
    <Property Name="Locals" Type="ImmutableArray&lt;ILocalSymbol&gt;">
      <Comments>
        <summary>Declared locals.</summary>
      </Comments>
    </Property>
    <Property Name="ContinueLabel" Type="ILabelSymbol">
      <Comments>
        <summary>Loop continue label.</summary>
      </Comments>
    </Property>
    <Property Name="ExitLabel" Type="ILabelSymbol">
      <Comments>
        <summary>Loop exit/break label.</summary>
      </Comments>
    </Property>
  </AbstractNode>
  <Node Name="IForEachLoopOperation" Base="ILoopOperation" ChildrenOrder="Collection,LoopControlVariable,Body,NextVariables">
    <OperationKind Include="false" />
    <Comments>
      <summary>
        Represents a for each loop.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# 'foreach' loop statement</description></item>
          <item><description>VB 'For Each' loop statement</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="LoopControlVariable" Type="IOperation">
      <Comments>
        <summary>Refers to the operation for declaring a new local variable or reference an existing variable or an expression.</summary>
      </Comments>
    </Property>
    <Property Name="Collection" Type="IOperation">
      <Comments>
        <summary>Collection value over which the loop iterates.</summary>
      </Comments>
    </Property>
    <Property Name="NextVariables" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>
          Optional list of comma separated next variables at loop bottom in VB.
          This list is always empty for C#.
        </summary>
      </Comments>
    </Property>
    <Property Name="Info" Type="ForEachLoopOperationInfo?" Internal="true" />
    <Property Name="IsAsynchronous" Type="bool">
      <Comments>
        <summary>
          Whether this for each loop is asynchronous.
          Always false for VB.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IForLoopOperation" Base="ILoopOperation" ChildrenOrder="Before,Condition,Body,AtLoopBottom">
    <OperationKind Include="false" />
    <Comments>
      <summary>
        Represents a for loop.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# 'for' loop statement</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Before" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>List of operations to execute before entry to the loop. For C#, this comes from the first clause of the for statement.</summary>
      </Comments>
    </Property>
    <Property Name="ConditionLocals" Type="ImmutableArray&lt;ILocalSymbol&gt;">
      <Comments>
        <summary>
          Locals declared within the loop Condition and are in scope throughout the <see cref="Condition" />,
          <see cref="ILoopOperation.Body" /> and <see cref="AtLoopBottom" />.
          They are considered to be declared per iteration.
        </summary>
      </Comments>
    </Property>
    <Property Name="Condition" Type="IOperation?">
      <Comments>
        <summary>Condition of the loop. For C#, this comes from the second clause of the for statement.</summary>
      </Comments>
    </Property>
    <Property Name="AtLoopBottom" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>List of operations to execute at the bottom of the loop. For C#, this comes from the third clause of the for statement.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IForToLoopOperation" Base="ILoopOperation" ChildrenOrder="LoopControlVariable,InitialValue,LimitValue,StepValue,Body,NextVariables">
    <OperationKind Include="false" />
    <Comments>
      <summary>
        Represents a for to loop with loop control variable and initial, limit and step values for the control variable.
        <para>
        Current usage:
        <list type="number">
          <item><description>VB 'For ... To ... Step' loop statement</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="LoopControlVariable" Type="IOperation">
      <Comments>
        <summary>Refers to the operation for declaring a new local variable or reference an existing variable or an expression.</summary>
      </Comments>
    </Property>
    <Property Name="InitialValue" Type="IOperation">
      <Comments>
        <summary>Operation for setting the initial value of the loop control variable. This comes from the expression between the 'For' and 'To' keywords.</summary>
      </Comments>
    </Property>
    <Property Name="LimitValue" Type="IOperation">
      <Comments>
        <summary>Operation for the limit value of the loop control variable. This comes from the expression after the 'To' keyword.</summary>
      </Comments>
    </Property>
    <Property Name="StepValue" Type="IOperation">
      <Comments>
        <summary>
          Operation for the step value of the loop control variable. This comes from the expression after the 'Step' keyword,
          or inferred by the compiler if 'Step' clause is omitted.
        </summary>
      </Comments>
    </Property>
    <Property Name="IsChecked" Type="bool">
      <Comments>
        <summary>
          <see langword="true" /> if arithmetic operations behind this loop are 'checked'.</summary>
      </Comments>
    </Property>
    <Property Name="NextVariables" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>Optional list of comma separated next variables at loop bottom.</summary>
      </Comments>
    </Property>
    <Property Name="Info"  Type="(ILocalSymbol LoopObject, ForToLoopOperationUserDefinedInfo UserDefinedInfo)" Internal="true" />
  </Node>
  <Node Name="IWhileLoopOperation" Base="ILoopOperation" SkipChildrenGeneration="true">
    <OperationKind Include="false" />
    <Comments>
      <summary>
        Represents a while or do while loop.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# 'while' and 'do while' loop statements</description></item>
          <item><description>VB 'While', 'Do While' and 'Do Until' loop statements</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Condition" Type="IOperation?">
      <Comments>
        <summary>Condition of the loop. This can only be null in error scenarios.</summary>
      </Comments>
    </Property>
    <Property Name="ConditionIsTop" Type="bool">
      <Comments>
        <summary>
          True if the <see cref="Condition" /> is evaluated at start of each loop iteration.
          False if it is evaluated at the end of each loop iteration.
        </summary>
      </Comments>
    </Property>
    <Property Name="ConditionIsUntil" Type="bool">
      <Comments>
        <summary>True if the loop has 'Until' loop semantics and the loop is executed while <see cref="Condition" /> is false.</summary>
      </Comments>
    </Property>
    <Property Name="IgnoredCondition" Type="IOperation?">
      <Comments>
        <summary>
          Additional conditional supplied for loop in error cases, which is ignored by the compiler.
          For example, for VB 'Do While' or 'Do Until' loop with syntax errors where both the top and bottom conditions are provided.
          The top condition is preferred and exposed as <see cref="Condition" /> and the bottom condition is ignored and exposed by this property.
          This property should be null for all non-error cases.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ILabeledOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an operation with a label.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# labeled statement</description></item>
          <item><description>VB label statement</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Label" Type="ILabelSymbol">
      <Comments>
        <summary>Label that can be the target of branches.</summary>
      </Comments>
    </Property>
    <Property Name="Operation" Type="IOperation?">
      <Comments>
        <summary>Operation that has been labeled. In VB, this is always null.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IBranchOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a branch operation.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# goto, break, or continue statement</description></item>
          <item><description>VB GoTo, Exit ***, or Continue *** statement</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Target" Type="ILabelSymbol">
      <Comments>
        <summary>Label that is the target of the branch.</summary>
      </Comments>
    </Property>
    <Property Name="BranchKind" Type="BranchKind">
      <Comments>
        <summary>Kind of the branch.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IEmptyOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an empty or no-op operation.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# empty statement</description></item>
        </list>
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="IReturnOperation" Base="IOperation">
    <OperationKind>
      <Entry Name="Return" Value="0x9"/>
      <Entry Name="YieldBreak" Value="0xa" ExtraDescription="This has yield break semantics."/>
      <Entry Name="YieldReturn" Value="0xe" ExtraDescription="This has yield return semantics."/>
    </OperationKind>
    <Comments>
      <summary>
        Represents a return from the method with an optional return value.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# return statement and yield statement</description></item>
          <item><description>VB Return statement</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="ReturnedValue" Type="IOperation?">
      <Comments>
        <summary>Value to be returned.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ILockOperation" Base="IOperation" ChildrenOrder="LockedValue,Body">
    <Comments>
      <summary>
        Represents a <see cref="Body" /> of operations that are executed while holding a lock onto the <see cref="LockedValue" />.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# lock statement</description></item>
          <item><description>VB SyncLock statement</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="LockedValue" Type="IOperation">
      <Comments>
        <summary>Operation producing a value to be locked.</summary>
      </Comments>
    </Property>
    <Property Name="Body" Type="IOperation">
      <Comments>
        <summary>Body of the lock, to be executed while holding the lock.</summary>
      </Comments>
    </Property>
    <Property Name="LockTakenSymbol" Type="ILocalSymbol?" Internal="true"/>
  </Node>
  <Node Name="ITryOperation" Base="IOperation" ChildrenOrder="Body,Catches,Finally">
    <Comments>
      <summary>
        Represents a try operation for exception handling code with a body, catch clauses and a finally handler.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# try statement</description></item>
          <item><description>VB Try statement</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Body" Type="IBlockOperation">
      <Comments>
        <summary>Body of the try, over which the handlers are active.</summary>
      </Comments>
    </Property>
    <Property Name="Catches" Type="ImmutableArray&lt;ICatchClauseOperation&gt;">
      <Comments>
        <summary>Catch clauses of the try.</summary>
      </Comments>
    </Property>
    <Property Name="Finally" Type="IBlockOperation?">
      <Comments>
        <summary>Finally handler of the try.</summary>
      </Comments>
    </Property>
    <Property Name="ExitLabel" Type="ILabelSymbol?">
      <Comments>
        <summary>Exit label for the try. This will always be null for C#.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IUsingOperation" Base="IOperation" ChildrenOrder="Resources,Body">
    <Comments>
      <summary>
        Represents a <see cref="Body" /> of operations that are executed while using disposable <see cref="Resources" />.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# using statement</description></item>
          <item><description>VB Using statement</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Resources" Type="IOperation">
      <Comments>
        <summary>Declaration introduced or resource held by the using.</summary>
      </Comments>
    </Property>
    <Property Name="Body" Type="IOperation">
      <Comments>
        <summary>Body of the using, over which the resources of the using are maintained.</summary>
      </Comments>
    </Property>
    <Property Name="Locals" Type="ImmutableArray&lt;ILocalSymbol&gt;">
      <Comments>
        <summary>
          Locals declared within the <see cref="Resources" /> with scope spanning across this entire <see cref="IUsingOperation" />.
        </summary>
      </Comments>
    </Property>
    <Property Name="IsAsynchronous" Type="bool">
      <Comments>
        <summary>
          Whether this using is asynchronous.
          Always false for VB.
        </summary>
      </Comments>
    </Property>
    <Property Name="DisposeInfo" Type="DisposeOperationInfo" Internal="true">
      <Comments>
        <summary>Information about the method that will be invoked to dispose the <see cref="Resources" /> when pattern based disposal is used.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IExpressionStatementOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an operation that drops the resulting value and the type of the underlying wrapped <see cref="Operation" />.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# expression statement</description></item>
          <item><description>VB expression statement</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Operation" Type="IOperation">
      <Comments>
        <summary>Underlying operation with a value and type.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ILocalFunctionOperation" Base="IOperation" ChildrenOrder="Body,IgnoredBody">
    <Comments>
      <summary>
        Represents a local function defined within a method.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# local function statement</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Symbol" Type="IMethodSymbol">
      <Comments>
        <summary>Local function symbol.</summary>
      </Comments>
    </Property>
    <Property Name="Body" Type="IBlockOperation?">
      <Comments>
        <summary>Body of the local function.</summary>
        <remarks>This can be null in error scenarios, or when the method is an extern method.</remarks>
      </Comments>
    </Property>
    <Property Name="IgnoredBody" Type="IBlockOperation?">
      <Comments>
        <summary>An extra body for the local function, if both a block body and expression body are specified in source.</summary>
        <remarks>This is only ever non-null in error situations.</remarks>
      </Comments>
    </Property>
  </Node>
  <Node Name="IStopOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an operation to stop or suspend execution of code.
        <para>
        Current usage:
        <list type="number">
          <item><description>VB Stop statement</description></item>
        </list>
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="IEndOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an operation that stops the execution of code abruptly.
        <para>
        Current usage:
        <list type="number">
          <item><description>VB End Statement</description></item>
        </list>
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="IRaiseEventOperation" Base="IOperation" ChildrenOrder="EventReference,Arguments">
    <Comments>
      <summary>
        Represents an operation for raising an event.
        <para>
        Current usage:
        <list type="number">
          <item><description>VB raise event statement</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="EventReference" Type="IEventReferenceOperation">
      <Comments>
        <summary>Reference to the event to be raised.</summary>
      </Comments>
    </Property>
    <Property Name="Arguments" Type="ImmutableArray&lt;IArgumentOperation&gt;">
      <Comments>
        <summary>Arguments of the invocation, excluding the instance argument. Arguments are in evaluation order.</summary>
        <remarks>
          If the invocation is in its expanded form, then params/ParamArray arguments would be collected into arrays.
          Default values are supplied for optional arguments missing in source.
        </remarks>
      </Comments>
    </Property>
  </Node>
  <Node Name="ILiteralOperation" Base="IOperation" HasType="true" HasConstantValue="true">
    <Comments>
      <summary>
        Represents a textual literal numeric, string, etc.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# literal expression</description></item>
          <item><description>VB literal expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="IConversionOperation" Base="IOperation" HasType="true" HasConstantValue="true">
    <Comments>
      <summary>
        Represents a type conversion.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# conversion expression</description></item>
          <item><description>VB conversion expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Operand" Type="IOperation">
      <Comments>
        <summary>Value to be converted.</summary>
      </Comments>
    </Property>
    <Property Name="OperatorMethod" Type="IMethodSymbol?" SkipGeneration="true">
      <Comments>
        <summary>Operator method used by the operation, null if the operation does not use an operator method.</summary>
      </Comments>
    </Property>
    <Property Name="ConstrainedToType" Type="ITypeSymbol?" SkipGeneration="true">
      <Comments>
        <summary>
          Type parameter which runtime type will be used to resolve virtual invocation of the <see cref="OperatorMethod" />, if any.
          Null if <see cref="OperatorMethod" /> is resolved statically, or is null.
        </summary>
      </Comments>
    </Property>
    <Property Name="Conversion" Type="CommonConversion">
      <Comments>
        <summary>Gets the underlying common conversion information.</summary>
        <remarks>
          If you need conversion information that is language specific, use either
          <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetConversion(IConversionOperation)" /> or
          <see cref="T:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.GetConversion(IConversionOperation)" />.
        </remarks>
      </Comments>
    </Property>
    <Property Name="IsTryCast" Type="bool">
      <Comments>
        <summary>
          False if the conversion will fail with a <see cref="InvalidCastException" /> at runtime if the cast fails. This is true for C#'s
          <c>as</c> operator and for VB's <c>TryCast</c> operator.
        </summary>
      </Comments>
    </Property>
    <Property Name="IsChecked" Type="bool">
      <Comments>
        <summary>True if the conversion can fail at runtime with an overflow exception. This corresponds to C# checked and unchecked blocks.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IInvocationOperation" Base="IOperation" ChildrenOrder="Instance,Arguments" HasType="true">
    <Comments>
      <summary>
        Represents an invocation of a method.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# method invocation expression</description></item>
          <item>
            <description>
              C# collection element initializer.
              For example, in the following collection initializer: <c>new C() { 1, 2, 3 }</c>, we will have
              3 <see cref="IInvocationOperation" /> nodes, each of which will be a call to the corresponding <c>Add</c> method
              with either 1, 2, 3 as the argument
            </description>
          </item>
          <item><description>VB method invocation expression</description></item>
          <item>
            <description>
              VB collection element initializer.
              Similar to the C# example, <c>New C() From {1, 2, 3}</c> will have 3 <see cref="IInvocationOperation" />
              nodes with 1, 2, and 3 as their arguments, respectively
            </description>
          </item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="TargetMethod" Type="IMethodSymbol">
      <Comments>
        <summary>Method to be invoked.</summary>
      </Comments>
    </Property>
    <Property Name="ConstrainedToType" Type="ITypeSymbol?">
      <Comments>
        <summary>
          Type parameter which runtime type will be used to resolve virtual invocation of the <see cref="TargetMethod" />.
          Null if <see cref="TargetMethod" /> is resolved statically, or is an instance method.
        </summary>
      </Comments>
    </Property>
    <Property Name="Instance" Type="IOperation?">
      <Comments>
        <summary>'This' or 'Me' instance to be supplied to the method, or null if the method is static.</summary>
      </Comments>
    </Property>
    <Property Name="IsVirtual" Type="bool">
      <Comments>
        <summary>True if the invocation uses a virtual mechanism, and false otherwise.</summary>
      </Comments>
    </Property>
    <Property Name="Arguments" Type="ImmutableArray&lt;IArgumentOperation&gt;">
      <Comments>
        <summary>Arguments of the invocation, excluding the instance argument. Arguments are in evaluation order.</summary>
        <remarks>
          If the invocation is in its expanded form, then params/ParamArray arguments would be collected into arrays.
          Default values are supplied for optional arguments missing in source.
        </remarks>
      </Comments>
    </Property>
  </Node>
  <Node Name="IArrayElementReferenceOperation" Base="IOperation" ChildrenOrder="ArrayReference,Indices" HasType="true">
    <Comments>
      <summary>
        Represents a reference to an array element.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# array element reference expression</description></item>
          <item><description>VB array element reference expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="ArrayReference" Type="IOperation">
      <Comments>
        <summary>Array to be indexed.</summary>
      </Comments>
    </Property>
    <Property Name="Indices" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>Indices that specify an individual element.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ILocalReferenceOperation" Base="IOperation" HasType="true" HasConstantValue="true">
    <Comments>
      <summary>
        Represents a reference to a declared local variable.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# local reference expression</description></item>
          <item><description>VB local reference expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Local" Type="ILocalSymbol">
      <Comments>
        <summary>Referenced local variable.</summary>
      </Comments>
    </Property>
    <Property Name="IsDeclaration" Type="bool">
      <Comments>
        <summary>
          True if this reference is also the declaration site of this variable. This is true in out variable declarations
          and in deconstruction operations where a new variable is being declared.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IParameterReferenceOperation" Base="IOperation" HasType="true">
    <Comments>
      <summary>
        Represents a reference to a parameter.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# parameter reference expression</description></item>
          <item><description>VB parameter reference expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Parameter" Type="IParameterSymbol">
      <Comments>
        <summary>Referenced parameter.</summary>
      </Comments>
    </Property>
  </Node>
  <AbstractNode Name="IMemberReferenceOperation" Base="IOperation" >
    <Comments>
      <summary>
        Represents a reference to a member of a class, struct, or interface.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# member reference expression</description></item>
          <item><description>VB member reference expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Instance" Type="IOperation?">
      <Comments>
        <summary>Instance of the type. Null if the reference is to a static/shared member.</summary>
      </Comments>
    </Property>
    <Property Name="Member" Type="ISymbol" SkipGeneration="true">
      <Comments>
        <summary>Referenced member.</summary>
      </Comments>
    </Property>
    <Property Name="ConstrainedToType" Type="ITypeSymbol?" MakeAbstract="true">
      <Comments>
        <summary>
          Type parameter which runtime type will be used to resolve virtual invocation of the <see cref="Member" />.
          Null if <see cref="Member" /> is resolved statically, or is an instance member.
        </summary>
      </Comments>
    </Property>
  </AbstractNode>
  <Node Name="IFieldReferenceOperation" Base="IMemberReferenceOperation" HasType="true" HasConstantValue="true">
    <Comments>
      <summary>
        Represents a reference to a field.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# field reference expression</description></item>
          <item><description>VB field reference expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Field" Type="IFieldSymbol">
      <Comments>
        <summary>Referenced field.</summary>
      </Comments>
    </Property>
    <Property Name="IsDeclaration" Type="bool">
      <Comments>
        <summary>If the field reference is also where the field was declared.</summary>
        <remarks>
          This is only ever true in CSharp scripts, where a top-level statement creates a new variable
          in a reference, such as an out variable declaration or a deconstruction declaration.
        </remarks>
      </Comments>
    </Property>
  </Node>
  <Node Name="IMethodReferenceOperation" Base="IMemberReferenceOperation" HasType="true">
    <Comments>
      <summary>
        Represents a reference to a method other than as the target of an invocation.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# method reference expression</description></item>
          <item><description>VB method reference expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Method" Type="IMethodSymbol">
      <Comments>
        <summary>Referenced method.</summary>
      </Comments>
    </Property>
    <Property Name="ConstrainedToType" Type="ITypeSymbol?" Override="true"/>
    <Property Name="IsVirtual" Type="bool">
      <Comments>
        <summary>Indicates whether the reference uses virtual semantics.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IPropertyReferenceOperation" Base="IMemberReferenceOperation" ChildrenOrder="Instance,Arguments" HasType="true">
    <Comments>
      <summary>
        Represents a reference to a property.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# property reference expression</description></item>
          <item><description>VB property reference expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Property" Type="IPropertySymbol">
      <Comments>
        <summary>Referenced property.</summary>
      </Comments>
    </Property>
    <Property Name="ConstrainedToType" Type="ITypeSymbol?" Override="true"/>
    <Property Name="Arguments" Type="ImmutableArray&lt;IArgumentOperation&gt;">
      <Comments>
        <summary>Arguments of the indexer property reference, excluding the instance argument. Arguments are in evaluation order.</summary>
        <remarks>
          If the invocation is in its expanded form, then params/ParamArray arguments would be collected into arrays.
          Default values are supplied for optional arguments missing in source.
        </remarks>
      </Comments>
    </Property>
  </Node>
  <Node Name="IEventReferenceOperation" Base="IMemberReferenceOperation" HasType="true">
    <Comments>
      <summary>
        Represents a reference to an event.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# event reference expression</description></item>
          <item><description>VB event reference expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Event" Type="IEventSymbol">
      <Comments>
        <summary>Referenced event.</summary>
      </Comments>
    </Property>
    <Property Name="ConstrainedToType" Type="ITypeSymbol?" Override="true"/>
  </Node>
  <Node Name="IUnaryOperation" Base="IOperation" VisitorName="VisitUnaryOperator" HasType="true" HasConstantValue="true">
    <OperationKind>
      <Entry Name="Unary" Value="0x1f" />
      <Entry Name="UnaryOperator" Value="0x1f" EditorBrowsable="false" ExtraDescription="Use &lt;see cref=&quot;Unary&quot;/&gt; instead." />
    </OperationKind>
    <Comments>
      <summary>
        Represents an operation with one operand and a unary operator.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# unary operation expression</description></item>
          <item><description>VB unary operation expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="OperatorKind" Type="UnaryOperatorKind">
      <Comments>
        <summary>Kind of unary operation.</summary>
      </Comments>
    </Property>
    <Property Name="Operand" Type="IOperation">
      <Comments>
        <summary>Operand.</summary>
      </Comments>
    </Property>
    <Property Name="IsLifted" Type="bool">
      <Comments>
        <summary>
          <see langword="true" /> if this is a 'lifted' unary operator.  When there is an
          operator that is defined to work on a value type, 'lifted' operators are
          created to work on the <see cref="System.Nullable{T}" /> versions of those
          value types.
        </summary>
      </Comments>
    </Property>
    <Property Name="IsChecked" Type="bool">
      <Comments>
        <summary>
          <see langword="true" /> if overflow checking is performed for the arithmetic operation.
        </summary>
      </Comments>
    </Property>
    <Property Name="OperatorMethod" Type="IMethodSymbol?">
      <Comments>
        <summary>Operator method used by the operation, null if the operation does not use an operator method.</summary>
      </Comments>
    </Property>
    <Property Name="ConstrainedToType" Type="ITypeSymbol?">
      <Comments>
        <summary>
          Type parameter which runtime type will be used to resolve virtual invocation of the <see cref="OperatorMethod" />, if any.
          Null if <see cref="OperatorMethod" /> is resolved statically, or is null.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IBinaryOperation" Base="IOperation" VisitorName="VisitBinaryOperator" ChildrenOrder="LeftOperand,RightOperand" HasType="true" HasConstantValue="true">
    <OperationKind>
      <Entry Name="Binary" Value="0x20" />
      <Entry Name="BinaryOperator" Value="0x20" EditorBrowsable="false" ExtraDescription="Use &lt;see cref=&quot;Binary&quot;/&gt; instead." />
    </OperationKind>
    <Comments>
      <summary>
        Represents an operation with two operands and a binary operator that produces a result with a non-null type.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# binary operator expression</description></item>
          <item><description>VB binary operator expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="OperatorKind" Type="BinaryOperatorKind">
      <Comments>
        <summary>Kind of binary operation.</summary>
      </Comments>
    </Property>
    <Property Name="LeftOperand" Type="IOperation">
      <Comments>
        <summary>Left operand.</summary>
      </Comments>
    </Property>
    <Property Name="RightOperand" Type="IOperation">
      <Comments>
        <summary>Right operand.</summary>
      </Comments>
    </Property>
    <Property Name="IsLifted" Type="bool">
      <Comments>
        <summary>
          <see langword="true" /> if this is a 'lifted' binary operator.  When there is an
          operator that is defined to work on a value type, 'lifted' operators are
          created to work on the <see cref="System.Nullable{T}" /> versions of those
          value types.
        </summary>
      </Comments>
    </Property>
    <Property Name="IsChecked" Type="bool">
      <Comments>
        <summary>
          <see langword="true" /> if this is a 'checked' binary operator.
        </summary>
      </Comments>
    </Property>
    <Property Name="IsCompareText" Type="bool">
      <Comments>
        <summary>
          <see langword="true" /> if the comparison is text based for string or object comparison in VB.
        </summary>
      </Comments>
    </Property>
    <Property Name="OperatorMethod" Type="IMethodSymbol?">
      <Comments>
        <summary>Operator method used by the operation, null if the operation does not use an operator method.</summary>
      </Comments>
    </Property>
    <Property Name="ConstrainedToType" Type="ITypeSymbol?">
      <Comments>
        <summary>
          Type parameter which runtime type will be used to resolve virtual invocation of the <see cref="OperatorMethod" />
          or corresponding true/false operator, if any.
          Null if operators are resolved statically, or are not used.
        </summary>
      </Comments>
    </Property>
    <Property Name="UnaryOperatorMethod" Type="IMethodSymbol?" Internal="true">
      <Comments>
        <summary>
          True/False operator method used for short circuiting.
          https://github.com/dotnet/roslyn/issues/27598 tracks exposing this information through public API
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IConditionalOperation" Base="IOperation" ChildrenOrder="Condition,WhenTrue,WhenFalse" HasType="true" HasConstantValue="true">
    <Comments>
      <summary>
        Represents a conditional operation with:
        <list type="number">
          <item><description><see cref="Condition" /> to be tested</description></item>
          <item><description><see cref="WhenTrue" /> operation to be executed when <see cref="Condition" /> is true and</description></item>
          <item><description><see cref="WhenFalse" /> operation to be executed when the <see cref="Condition" /> is false</description></item>
        </list>
        <para>
        Current usage:
        <list type="number">
          <item><description>C# ternary expression <c>a ? b : c</c> and if statement</description></item>
          <item><description>VB ternary expression <c>If(a, b, c)</c> and If Else statement</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Condition" Type="IOperation">
      <Comments>
        <summary>Condition to be tested.</summary>
      </Comments>
    </Property>
    <Property Name="WhenTrue" Type="IOperation">
      <Comments>
        <summary>
          Operation to be executed if the <see cref="Condition" /> is true.
        </summary>
      </Comments>
    </Property>
    <Property Name="WhenFalse" Type="IOperation?">
      <Comments>
        <summary>
          Operation to be executed if the <see cref="Condition" /> is false.
        </summary>
      </Comments>
    </Property>
    <Property Name="IsRef" Type="bool">
      <Comments>
        <summary><see langword="true"/> if the result is by-reference.</summary>
        <remarks>This occurs in C# for ternaries whose branches use <see langword="ref"/>.</remarks>
      </Comments>
    </Property>
  </Node>
  <Node Name="ICoalesceOperation" Base="IOperation" ChildrenOrder="Value,WhenNull" HasType="true" HasConstantValue="true">
    <Comments>
      <summary>
        Represents a coalesce operation with two operands:
        <list type="number">
          <item><description><see cref="Value" />, which is the first operand that is unconditionally evaluated and is the result of the operation if non null</description></item>
          <item><description><see cref="WhenNull" />, which is the second operand that is conditionally evaluated and is the result of the operation if <see cref="Value" /> is null</description></item>
        </list>
        <para>
        Current usage:
        <list type="number">
          <item><description>C# null-coalescing expression <c>Value ?? WhenNull</c></description></item>
          <item><description>VB binary conditional expression <c>If(Value, WhenNull)</c></description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Operation to be unconditionally evaluated.</summary>
      </Comments>
    </Property>
    <Property Name="WhenNull" Type="IOperation">
      <Comments>
        <summary>
          Operation to be conditionally evaluated if <see cref="Value" /> evaluates to null/Nothing.
        </summary>
      </Comments>
    </Property>
    <Property Name="ValueConversion" Type="CommonConversion">
      <Comments>
        <summary>
          Conversion associated with <see cref="Value" /> when it is not null/Nothing.

          Identity if result type of the operation is the same as type of <see cref="Value" />.
          Otherwise, if type of <see cref="Value" /> is nullable, then conversion is applied to an
          unwrapped <see cref="Value" />, otherwise to the <see cref="Value" /> itself.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IAnonymousFunctionOperation" Base="IOperation">
    <!--
      IAnonymousFunctionOperations do not have a type, users must look at the IConversionOperation
      on top of this node to get the type of lambda, matching SemanticModel.GetType behavior.
    -->
    <Comments>
      <summary>
        Represents an anonymous function operation.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# lambda expression</description></item>
          <item><description>VB anonymous delegate expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Symbol" Type="IMethodSymbol">
      <Comments>
        <summary>Symbol of the anonymous function.</summary>
      </Comments>
    </Property>
    <Property Name="Body" Type="IBlockOperation">
      <Comments>
        <summary>Body of the anonymous function.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IObjectCreationOperation" Base="IOperation" ChildrenOrder="Arguments,Initializer" HasType="true" HasConstantValue="true">
    <Comments>
      <summary>
        Represents creation of an object instance.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# new expression</description></item>
          <item><description>VB New expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Constructor" Type="IMethodSymbol?">
      <Comments>
        <summary>Constructor to be invoked on the created instance.</summary>
      </Comments>
    </Property>
    <Property Name="Initializer" Type="IObjectOrCollectionInitializerOperation?">
      <Comments>
        <summary>Object or collection initializer, if any.</summary>
      </Comments>
    </Property>
    <Property Name="Arguments" Type="ImmutableArray&lt;IArgumentOperation&gt;">
      <Comments>
        <summary>Arguments of the object creation, excluding the instance argument. Arguments are in evaluation order.</summary>
        <remarks>
          If the invocation is in its expanded form, then params/ParamArray arguments would be collected into arrays.
          Default values are supplied for optional arguments missing in source.
        </remarks>
      </Comments>
    </Property>
  </Node>
  <Node Name="ITypeParameterObjectCreationOperation" Base="IOperation" HasType="true">
    <Comments>
      <summary>
        Represents a creation of a type parameter object, i.e. new T(), where T is a type parameter with new constraint.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# type parameter object creation expression</description></item>
          <item><description>VB type parameter object creation expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Initializer" Type="IObjectOrCollectionInitializerOperation?">
      <Comments>
        <summary>Object or collection initializer, if any.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IArrayCreationOperation" Base="IOperation" ChildrenOrder="DimensionSizes,Initializer" HasType="true">
    <Comments>
      <summary>
        Represents the creation of an array instance.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# array creation expression</description></item>
          <item><description>VB array creation expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="DimensionSizes" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>Sizes of the dimensions of the created array instance.</summary>
      </Comments>
    </Property>
    <Property Name="Initializer" Type="IArrayInitializerOperation?">
      <Comments>
        <summary>Values of elements of the created array instance.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IInstanceReferenceOperation" Base="IOperation" HasType="true">
    <Comments>
      <summary>
        Represents an implicit/explicit reference to an instance.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# this or base expression</description></item>
          <item><description>VB Me, MyClass, or MyBase expression</description></item>
          <item><description>C# object or collection or 'with' expression initializers</description></item>
          <item><description>VB With statements, object or collection initializers</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="ReferenceKind" Type="InstanceReferenceKind">
      <Comments>
        <summary>The kind of reference that is being made.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IIsTypeOperation" Base="IOperation" HasType="true">
    <Comments>
      <summary>
        Represents an operation that tests if a value is of a specific type.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# "is" operator expression</description></item>
          <item><description>VB "TypeOf" and "TypeOf IsNot" expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="ValueOperand" Type="IOperation">
      <Comments>
        <summary>Value to test.</summary>
      </Comments>
    </Property>
    <Property Name="TypeOperand" Type="ITypeSymbol">
      <Comments>
        <summary>Type for which to test.</summary>
      </Comments>
    </Property>
    <Property Name="IsNegated" Type="bool">
      <Comments>
        <summary>
          Flag indicating if this is an "is not" type expression.
          True for VB "TypeOf ... IsNot ..." expression.
          False, otherwise.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IAwaitOperation" Base="IOperation" HasType="true">
    <Comments>
      <summary>
        Represents an await operation.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# await expression</description></item>
          <item><description>VB await expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Operation" Type="IOperation">
      <Comments>
        <summary>Awaited operation.</summary>
      </Comments>
    </Property>
  </Node>
  <AbstractNode Name="IAssignmentOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a base interface for assignments.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# simple, compound and deconstruction assignment expressions</description></item>
          <item><description>VB simple and compound assignment expressions</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Target" Type="IOperation">
      <Comments>
        <summary>Target of the assignment.</summary>
      </Comments>
    </Property>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Value to be assigned to the target of the assignment.</summary>
      </Comments>
    </Property>
  </AbstractNode>
  <Node Name="ISimpleAssignmentOperation" Base="IAssignmentOperation" ChildrenOrder="Target,Value" HasType="true" HasConstantValue="true">
    <Comments>
      <summary>
        Represents a simple assignment operation.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# simple assignment expression</description></item>
          <item><description>VB simple assignment expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="IsRef" Type="bool">
      <Comments>
        <summary>Is this a ref assignment</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ICompoundAssignmentOperation" Base="IAssignmentOperation" ChildrenOrder="Target,Value" HasType="true">
    <Comments>
      <summary>
        Represents a compound assignment that mutates the target with the result of a binary operation.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# compound assignment expression</description></item>
          <item><description>VB compound assignment expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="InConversion" Type="CommonConversion">
      <Comments>
        <summary>
          Conversion applied to <see cref="IAssignmentOperation.Target" /> before the operation occurs.
        </summary>
      </Comments>
    </Property>
    <Property Name="OutConversion" Type="CommonConversion">
      <Comments>
        <summary>
          Conversion applied to the result of the binary operation, before it is assigned back to
          <see cref="IAssignmentOperation.Target" />.
        </summary>
      </Comments>
    </Property>
    <Property Name="OperatorKind" Type="BinaryOperatorKind">
      <Comments>
        <summary>Kind of binary operation.</summary>
      </Comments>
    </Property>
    <Property Name="IsLifted" Type="bool">
      <Comments>
        <summary>
          <see langword="true" /> if this assignment contains a 'lifted' binary operation.
        </summary>
      </Comments>
    </Property>
    <Property Name="IsChecked" Type="bool">
      <Comments>
        <summary>
          <see langword="true" /> if overflow checking is performed for the arithmetic operation.
        </summary>
      </Comments>
    </Property>
    <Property Name="OperatorMethod" Type="IMethodSymbol?">
      <Comments>
        <summary>Operator method used by the operation, null if the operation does not use an operator method.</summary>
      </Comments>
    </Property>
    <Property Name="ConstrainedToType" Type="ITypeSymbol?">
      <Comments>
        <summary>
          Type parameter which runtime type will be used to resolve virtual invocation of the <see cref="OperatorMethod" />, if any.
          Null if <see cref="OperatorMethod" /> is resolved statically, or is null.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IParenthesizedOperation" Base="IOperation" HasType="true" HasConstantValue="true">
    <Comments>
      <summary>
        Represents a parenthesized operation.
        <para>
        Current usage:
        <list type="number">
          <item><description>VB parenthesized expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Operand" Type="IOperation">
      <Comments>
        <summary>Operand enclosed in parentheses.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IEventAssignmentOperation" Base="IOperation" ChildrenOrder="EventReference,HandlerValue" HasType="true">
    <Comments>
      <summary>
        Represents a binding of an event.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# event assignment expression</description></item>
          <item><description>VB Add/Remove handler statement</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="EventReference" Type="IOperation">
      <Comments>
        <summary>Reference to the event being bound.</summary>
      </Comments>
    </Property>
    <Property Name="HandlerValue" Type="IOperation">
      <Comments>
        <summary>Handler supplied for the event.</summary>
      </Comments>
    </Property>
    <Property Name="Adds" Type="bool">
      <Comments>
        <summary>True for adding a binding, false for removing one.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IConditionalAccessOperation" Base="IOperation" ChildrenOrder="Operation,WhenNotNull" HasType="true">
    <Comments>
      <summary>
        Represents a conditionally accessed operation. Note that <see cref="IConditionalAccessInstanceOperation" /> is used to refer to the value
        of <see cref="Operation" /> within <see cref="WhenNotNull" />.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# conditional access expression (<c>?</c> or <c>?.</c> operator)</description></item>
          <item><description>VB conditional access expression (<c>?</c> or <c>?.</c> operator)</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Operation" Type="IOperation">
      <Comments>
        <summary>Operation that will be evaluated and accessed if non null.</summary>
      </Comments>
    </Property>
    <Property Name="WhenNotNull" Type="IOperation">
      <Comments>
        <summary>
          Operation to be evaluated if <see cref="Operation" /> is non null.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IConditionalAccessInstanceOperation" Base="IOperation" HasType="true">
    <Comments>
      <summary>
        Represents the value of a conditionally-accessed operation within <see cref="IConditionalAccessOperation.WhenNotNull" />.
        For a conditional access operation of the form <c>someExpr?.Member</c>, this operation is used as the InstanceReceiver for the right operation <c>Member</c>.
        See https://github.com/dotnet/roslyn/issues/21279#issuecomment-323153041 for more details.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# conditional access instance expression</description></item>
          <item><description>VB conditional access instance expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="IInterpolatedStringOperation" Base="IOperation" HasType="true" HasConstantValue="true">
    <Comments>
      <summary>
        Represents an interpolated string.
        <para>
        Current usage:
         (1) C# interpolated string expression.
         (2) VB interpolated string expression.
        </para>
      </summary>
    </Comments>
    <Property Name="Parts" Type="ImmutableArray&lt;IInterpolatedStringContentOperation&gt;">
      <Comments>
        <summary>
          Constituent parts of interpolated string, each of which is an <see cref="IInterpolatedStringContentOperation" />.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IAnonymousObjectCreationOperation" Base="IOperation" HasType="true">
    <Comments>
      <summary>
        Represents a creation of anonymous object.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# <c>new { ... }</c> expression</description></item>
          <item><description>VB <c>New With { ... }</c> expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Initializers" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>
          Property initializers.
          Each initializer is an <see cref="ISimpleAssignmentOperation" />, with an <see cref="IPropertyReferenceOperation" />
          as the target whose Instance is an <see cref="IInstanceReferenceOperation" /> with <see cref="InstanceReferenceKind.ImplicitReceiver" /> kind.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IObjectOrCollectionInitializerOperation" Base="IOperation" HasType="true">
    <Comments>
      <summary>
        Represents an initialization for an object or collection creation.
        <para>
        Current usage:
        <list type="number">
          <item>
            <description>
              C# object or collection initializer expression.
              For example, object initializer <c>{ X = x }</c> within object creation <c>new Class() { X = x }</c> and
              collection initializer <c>{ x, y, 3 }</c> within collection creation <c>new MyList() { x, y, 3 }</c>
            </description>
          </item>
          <item><description>VB object or collection initializer expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Initializers" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>Object member or collection initializers.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IMemberInitializerOperation" Base="IOperation" ChildrenOrder="InitializedMember,Initializer" HasType="true">
    <Comments>
      <summary>
        Represents an initialization of member within an object initializer with a nested object or collection initializer.
        <para>
        Current usage:
        <list type="number">
          <item>
            <description>
              C# nested member initializer expression.
              For example, given an object creation with initializer <c>new Class() { X = x, Y = { x, y, 3 }, Z = { X = z } }</c>,
              member initializers for Y and Z, i.e. <c>Y = { x, y, 3 }</c>, and <c>Z = { X = z }</c> are nested member initializers represented by this operation
            </description>
          </item>
          <item><description>VB object or collection initializer expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="InitializedMember" Type="IOperation">
      <Comments>
        <summary>
          Initialized member reference <see cref="IMemberReferenceOperation" /> or an invalid operation for error cases.
        </summary>
      </Comments>
    </Property>
    <Property Name="Initializer" Type="IObjectOrCollectionInitializerOperation">
      <Comments>
        <summary>Member initializer.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ICollectionElementInitializerOperation" Base="IOperation" SkipClassGeneration="true">
    <Obsolete Error="true">"ICollectionElementInitializerOperation has been replaced with " + nameof(IInvocationOperation) + " and " + nameof(IDynamicInvocationOperation)</Obsolete>
    <Comments>
      <summary>
        Obsolete interface that used to represent a collection element initializer. It has been replaced by
        <see cref="IInvocationOperation" /> and <see cref="IDynamicInvocationOperation" />, as appropriate.
        <para>
        Current usage:
          None. This API has been obsoleted in favor of <see cref="IInvocationOperation" /> and <see cref="IDynamicInvocationOperation" />.
        </para>
      </summary>
    </Comments>
    <Property Name="AddMethod" Type="IMethodSymbol" />
    <Property Name="Arguments" Type="ImmutableArray&lt;IOperation&gt;" />
    <Property Name="IsDynamic" Type="bool" />
  </Node>
  <Node Name="INameOfOperation" Base="IOperation" HasType="true" HasConstantValue="true">
    <Comments>
      <summary>
        Represents an operation that gets a string value for the <see cref="Argument" /> name.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# nameof expression</description></item>
          <item><description>VB NameOf expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Argument" Type="IOperation">
      <Comments>
        <summary>Argument to the name of operation.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ITupleOperation" Base="IOperation" HasType="true">
    <Comments>
      <summary>
        Represents a tuple with one or more elements.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# tuple expression</description></item>
          <item><description>VB tuple expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Elements" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>Tuple elements.</summary>
      </Comments>
    </Property>
    <Property Name="NaturalType" Type="ITypeSymbol?">
      <Comments>
        <summary>
          Natural type of the tuple, or null if tuple doesn't have a natural type.
          Natural type can be different from <see cref="IOperation.Type" /> depending on the
          conversion context, in which the tuple is used.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IDynamicObjectCreationOperation" Base="IOperation" SkipClassGeneration="true">
    <Comments>
      <summary>
        Represents an object creation with a dynamically bound constructor.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# <c>new</c> expression with dynamic argument(s)</description></item>
          <item><description>VB late bound <c>New</c> expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Initializer" Type="IObjectOrCollectionInitializerOperation?">
      <Comments>
        <summary>Object or collection initializer, if any.</summary>
      </Comments>
    </Property>
    <Property Name="Arguments" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>Dynamically bound arguments, excluding the instance argument.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IDynamicMemberReferenceOperation" Base="IOperation" HasType="true">
    <Comments>
      <summary>
        Represents a reference to a member of a class, struct, or module that is dynamically bound.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# dynamic member reference expression</description></item>
          <item><description>VB late bound member reference expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Instance" Type="IOperation?">
      <Comments>
        <summary>Instance receiver, if it exists.</summary>
      </Comments>
    </Property>
    <Property Name="MemberName" Type="string">
      <Comments>
        <summary>Referenced member.</summary>
      </Comments>
    </Property>
    <Property Name="TypeArguments" Type="ImmutableArray&lt;ITypeSymbol&gt;">
      <Comments>
        <summary>Type arguments.</summary>
      </Comments>
    </Property>
    <Property Name="ContainingType" Type="ITypeSymbol?">
      <Comments>
        <summary>
          The containing type of the referenced member, if different from type of the <see cref="Instance" />.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IDynamicInvocationOperation" Base="IOperation" SkipClassGeneration="true">
    <Comments>
      <summary>
        Represents a invocation that is dynamically bound.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# dynamic invocation expression</description></item>
          <item>
            <description>
              C# dynamic collection element initializer.
              For example, in the following collection initializer: <c>new C() { do1, do2, do3 }</c> where
              the doX objects are of type dynamic, we'll have 3 <see cref="IDynamicInvocationOperation" /> with do1, do2, and
              do3 as their arguments
            </description>
          </item>
          <item><description>VB late bound invocation expression</description></item>
          <item>
            <description>
              VB dynamic collection element initializer.
              Similar to the C# example, <c>New C() From {do1, do2, do3}</c> will generate 3 <see cref="IDynamicInvocationOperation" />
              nodes with do1, do2, and do3 as their arguments, respectively
            </description>
          </item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Operation" Type="IOperation">
      <Comments>
        <summary>Dynamically or late bound operation.</summary>
      </Comments>
    </Property>
    <Property Name="Arguments" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>Dynamically bound arguments, excluding the instance argument.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IDynamicIndexerAccessOperation" Base="IOperation" SkipClassGeneration="true">
    <Comments>
      <summary>
        Represents an indexer access that is dynamically bound.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# dynamic indexer access expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Operation" Type="IOperation">
      <Comments>
        <summary>Dynamically indexed operation.</summary>
      </Comments>
    </Property>
    <Property Name="Arguments" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>Dynamically bound arguments, excluding the instance argument.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ITranslatedQueryOperation" Base="IOperation" HasType="true">
    <Comments>
      <summary>
        Represents an unrolled/lowered query operation.
        For example, for a C# query expression "from x in set where x.Name != null select x.Name", the Operation tree has the following shape:
          ITranslatedQueryExpression
            IInvocationExpression ('Select' invocation for "select x.Name")
              IInvocationExpression ('Where' invocation for "where x.Name != null")
                IInvocationExpression ('From' invocation for "from x in set")
        <para>
        Current usage:
        <list type="number">
          <item><description>C# query expression</description></item>
          <item><description>VB query expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Operation" Type="IOperation">
      <Comments>
        <summary>Underlying unrolled operation.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IDelegateCreationOperation" Base="IOperation" HasType="true">
    <Comments>
      <summary>
        Represents a delegate creation. This is created whenever a new delegate is created.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# delegate creation expression</description></item>
          <item><description>VB delegate creation expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Target" Type="IOperation">
      <Comments>
        <summary>The lambda or method binding that this delegate is created from.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IDefaultValueOperation" Base="IOperation" HasType="true" HasConstantValue="true">
    <Comments>
      <summary>
        Represents a default value operation.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# default value expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="ITypeOfOperation" Base="IOperation" HasType="true">
    <Comments>
      <summary>
        Represents an operation that gets <see cref="System.Type" /> for the given <see cref="TypeOperand" />.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# typeof expression</description></item>
          <item><description>VB GetType expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="TypeOperand" Type="ITypeSymbol">
      <Comments>
        <summary>Type operand.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ISizeOfOperation" Base="IOperation" HasType="true" HasConstantValue="true">
    <Comments>
      <summary>
        Represents an operation to compute the size of a given type.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# sizeof expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="TypeOperand" Type="ITypeSymbol">
      <Comments>
        <summary>Type operand.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IAddressOfOperation" Base="IOperation" HasType="true">
    <Comments>
      <summary>
        Represents an operation that creates a pointer value by taking the address of a reference.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# address of expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Reference" Type="IOperation">
      <Comments>
        <summary>Addressed reference.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IIsPatternOperation" Base="IOperation" ChildrenOrder="Value,Pattern" HasType="true">
    <Comments>
      <summary>
        Represents an operation that tests if a value matches a specific pattern.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# is pattern expression. For example, <c>x is int i</c></description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Underlying operation to test.</summary>
      </Comments>
    </Property>
    <Property Name="Pattern" Type="IPatternOperation">
      <Comments>
        <summary>Pattern.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IIncrementOrDecrementOperation" Base="IOperation" HasType="true">
    <OperationKind>
      <Entry Name="Increment" Value="0x42" ExtraDescription="This is used as an increment operator"/>
      <Entry Name="Decrement" Value="0x44" ExtraDescription="This is used as a decrement operator"/>
    </OperationKind>
    <Comments>
      <summary>
        Represents an <see cref="OperationKind.Increment" /> or <see cref="OperationKind.Decrement" /> operation.
        Note that this operation is different from an <see cref="IUnaryOperation" /> as it mutates the <see cref="Target" />,
        while unary operator expression does not mutate it's operand.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# increment expression or decrement expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="IsPostfix" Type="bool">
      <Comments>
        <summary>
          <see langword="true" /> if this is a postfix expression. <see langword="false" /> if this is a prefix expression.
        </summary>
      </Comments>
    </Property>
    <Property Name="IsLifted" Type="bool">
      <Comments>
        <summary>
          <see langword="true" /> if this is a 'lifted' increment operator.  When there
          is an operator that is defined to work on a value type, 'lifted' operators are
          created to work on the <see cref="System.Nullable{T}" /> versions of those
          value types.
        </summary>
      </Comments>
    </Property>
    <Property Name="IsChecked" Type="bool">
      <Comments>
        <summary>
          <see langword="true" /> if overflow checking is performed for the arithmetic operation.
        </summary>
      </Comments>
    </Property>
    <Property Name="Target" Type="IOperation">
      <Comments>
        <summary>Target of the assignment.</summary>
      </Comments>
    </Property>
    <Property Name="OperatorMethod" Type="IMethodSymbol?">
      <Comments>
        <summary>Operator method used by the operation, null if the operation does not use an operator method.</summary>
      </Comments>
    </Property>
    <Property Name="ConstrainedToType" Type="ITypeSymbol?">
      <Comments>
        <summary>
          Type parameter which runtime type will be used to resolve virtual invocation of the <see cref="OperatorMethod" />, if any.
          Null if <see cref="OperatorMethod" /> is resolved statically, or is null.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IThrowOperation" Base="IOperation" HasType="true">
    <Comments>
      <summary>
        Represents an operation to throw an exception.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# throw expression</description></item>
          <item><description>C# throw statement</description></item>
          <item><description>VB Throw statement</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Exception" Type="IOperation?">
      <Comments>
        <summary>Instance of an exception being thrown.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IDeconstructionAssignmentOperation" Base="IAssignmentOperation" ChildrenOrder="Target,Value" HasType="true">
    <Comments>
      <summary>
        Represents a assignment with a deconstruction.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# deconstruction assignment expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="IDeclarationExpressionOperation" Base="IOperation" HasType="true">
    <Comments>
      <summary>
        Represents a declaration expression operation. Unlike a regular variable declaration <see cref="IVariableDeclaratorOperation" /> and <see cref="IVariableDeclarationOperation" />, this operation represents an "expression" declaring a variable.
        <para>
        Current usage:
        <list type="number">
          <item>
            <description>
              C# deconstruction assignment expression. For example:
              <list type="bullet">
                <item><description><c>var (x, y)</c> is a deconstruction declaration expression with variables <c>x</c> and <c>y</c></description></item>
                <item><description><c>(var x, var y)</c> is a tuple expression with two declaration expressions</description></item>
                <item><description><c>M(out var x);</c> is an invocation expression with an out <c>var x</c> declaration expression</description></item>
              </list>
            </description>
          </item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Expression" Type="IOperation">
      <Comments>
        <summary>Underlying expression.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IOmittedArgumentOperation" Base="IOperation" HasType="true">
    <Comments>
      <summary>
        Represents an argument value that has been omitted in an invocation.
        <para>
        Current usage:
        <list type="number">
          <item><description>VB omitted argument in an invocation expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
  </Node>
  <AbstractNode Name="ISymbolInitializerOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an initializer for a field, property, parameter or a local variable declaration.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# field, property, parameter or local variable initializer</description></item>
          <item><description>VB field(s), property, parameter or local variable initializer</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Locals" Type="ImmutableArray&lt;ILocalSymbol&gt;">
      <Comments>
        <summary>
          Local declared in and scoped to the <see cref="Value" />.
        </summary>
      </Comments>
    </Property>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Underlying initializer value.</summary>
      </Comments>
    </Property>
  </AbstractNode>
  <Node Name="IFieldInitializerOperation" Base="ISymbolInitializerOperation">
    <Comments>
      <summary>
        Represents an initialization of a field.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# field initializer with equals value clause</description></item>
          <item><description>VB field(s) initializer with equals value clause or AsNew clause. Multiple fields can be initialized with AsNew clause in VB</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="InitializedFields" Type="ImmutableArray&lt;IFieldSymbol&gt;">
      <Comments>
        <summary>Initialized fields. There can be multiple fields for Visual Basic fields declared with AsNew clause.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IVariableInitializerOperation" Base="ISymbolInitializerOperation">
    <Comments>
      <summary>
        Represents an initialization of a local variable.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# local variable initializer with equals value clause</description></item>
          <item><description>VB local variable initializer with equals value clause or AsNew clause</description></item>
        </list>
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="IPropertyInitializerOperation" Base="ISymbolInitializerOperation">
    <Comments>
      <summary>
        Represents an initialization of a property.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# property initializer with equals value clause</description></item>
          <item><description>VB property initializer with equals value clause or AsNew clause. Multiple properties can be initialized with 'WithEvents' declaration with AsNew clause in VB</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="InitializedProperties" Type="ImmutableArray&lt;IPropertySymbol&gt;">
      <Comments>
        <summary>Initialized properties. There can be multiple properties for Visual Basic 'WithEvents' declaration with AsNew clause.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IParameterInitializerOperation" Base="ISymbolInitializerOperation">
    <Comments>
      <summary>
        Represents an initialization of a parameter at the point of declaration.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# parameter initializer with equals value clause</description></item>
          <item><description>VB parameter initializer with equals value clause</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Parameter" Type="IParameterSymbol">
      <Comments>
        <summary>Initialized parameter.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IArrayInitializerOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents the initialization of an array instance.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# array initializer</description></item>
          <item><description>VB array initializer</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="ElementValues" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>Values to initialize array elements.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IVariableDeclaratorOperation" Base="IOperation" ChildrenOrder="IgnoredArguments,Initializer">
    <Comments>
      <summary>
        Represents a single variable declarator and initializer.
        <para>
        Current Usage:
        <list type="number">
          <item><description>C# variable declarator</description></item>
          <item><description>C# catch variable declaration</description></item>
          <item><description>VB single variable declaration</description></item>
          <item><description>VB catch variable declaration</description></item>
        </list>
        </para>
      </summary>
      <remarks>
        In VB, the initializer for this node is only ever used for explicit array bounds initializers. This node corresponds to
        the VariableDeclaratorSyntax in C# and the ModifiedIdentifierSyntax in VB.
      </remarks>
    </Comments>
    <Property Name="Symbol" Type="ILocalSymbol">
      <Comments>
        <summary>Symbol declared by this variable declaration</summary>
      </Comments>
    </Property>
    <Property Name="Initializer" Type="IVariableInitializerOperation?">
      <Comments>
        <summary>Optional initializer of the variable.</summary>
        <remarks>
          If this variable is in an <see cref="IVariableDeclarationOperation" />, the initializer may be located
          in the parent operation. Call <see cref="OperationExtensions.GetVariableInitializer(IVariableDeclaratorOperation)" />
          to check in all locations. It is only possible to have initializers in both locations in VB invalid code scenarios.
        </remarks>
      </Comments>
    </Property>
    <Property Name="IgnoredArguments" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>
          Additional arguments supplied to the declarator in error cases, ignored by the compiler. This only used for the C# case of
          DeclaredArgumentSyntax nodes on a VariableDeclaratorSyntax.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IVariableDeclarationOperation" Base="IOperation" ChildrenOrder="IgnoredDimensions,Declarators,Initializer">
    <Comments>
      <summary>
        Represents a declarator that declares multiple individual variables.
        <para>
        Current Usage:
        <list type="number">
          <item><description>C# VariableDeclaration</description></item>
          <item><description>C# fixed declarations</description></item>
          <item><description>VB Dim statement declaration groups</description></item>
          <item><description>VB Using statement variable declarations</description></item>
        </list>
        </para>
      </summary>
      <remarks>
        The initializer of this node is applied to all individual declarations in <see cref="Declarators" />. There cannot
        be initializers in both locations except in invalid code scenarios.
        In C#, this node will never have an initializer.
        This corresponds to the VariableDeclarationSyntax in C#, and the VariableDeclaratorSyntax in Visual Basic.
      </remarks>
    </Comments>
    <Property Name="Declarators" Type="ImmutableArray&lt;IVariableDeclaratorOperation&gt;">
      <Comments>
        <summary>Individual variable declarations declared by this multiple declaration.</summary>
        <remarks>
          All <see cref="IVariableDeclarationGroupOperation" /> will have at least 1 <see cref="IVariableDeclarationOperation" />,
          even if the declaration group only declares 1 variable.
        </remarks>
      </Comments>
    </Property>
    <Property Name="Initializer" Type="IVariableInitializerOperation?">
      <Comments>
        <summary>Optional initializer of the variable.</summary>
        <remarks>In C#, this will always be null.</remarks>
      </Comments>
    </Property>
    <Property Name="IgnoredDimensions" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>
          Array dimensions supplied to an array declaration in error cases, ignored by the compiler. This is only used for the C# case of
          RankSpecifierSyntax nodes on an ArrayTypeSyntax.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IArgumentOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents an argument to a method invocation.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# argument to an invocation expression, object creation expression, etc.</description></item>
          <item><description>VB argument to an invocation expression, object creation expression, etc.</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="ArgumentKind" Type="ArgumentKind">
      <Comments>
        <summary>Kind of argument.</summary>
      </Comments>
    </Property>
    <Property Name="Parameter" Type="IParameterSymbol?">
      <Comments>
        <summary>Parameter the argument matches. This can be null for __arglist parameters.</summary>
      </Comments>
    </Property>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Value supplied for the argument.</summary>
      </Comments>
    </Property>
    <Property Name="InConversion" Type="CommonConversion">
      <Comments>
        <summary>Information of the conversion applied to the argument value passing it into the target method. Applicable only to VB Reference arguments.</summary>
      </Comments>
    </Property>
    <Property Name="OutConversion" Type="CommonConversion">
      <Comments>
        <summary>Information of the conversion applied to the argument value after the invocation. Applicable only to VB Reference arguments.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ICatchClauseOperation" Base="IOperation" ChildrenOrder="ExceptionDeclarationOrExpression,Filter,Handler">
    <Comments>
      <summary>
        Represents a catch clause.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# catch clause</description></item>
          <item><description>VB Catch clause</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="ExceptionDeclarationOrExpression" Type="IOperation?">
      <Comments>
        <summary>
          Optional source for exception. This could be any of the following operation:
          1. Declaration for the local catch variable bound to the caught exception (C# and VB) OR
          2. Null, indicating no declaration or expression (C# and VB)
          3. Reference to an existing local or parameter (VB) OR
          4. Other expression for error scenarios (VB)
        </summary>
      </Comments>
    </Property>
    <Property Name="ExceptionType" Type="ITypeSymbol">
      <Comments>
        <summary>Type of the exception handled by the catch clause.</summary>
      </Comments>
    </Property>
    <Property Name="Locals" Type="ImmutableArray&lt;ILocalSymbol&gt;">
      <Comments>
        <summary>
          Locals declared by the <see cref="ExceptionDeclarationOrExpression" /> and/or <see cref="Filter" /> clause.
        </summary>
      </Comments>
    </Property>
    <Property Name="Filter" Type="IOperation?">
      <Comments>
        <summary>Filter operation to be executed to determine whether to handle the exception.</summary>
      </Comments>
    </Property>
    <Property Name="Handler" Type="IBlockOperation">
      <Comments>
        <summary>Body of the exception handler.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ISwitchCaseOperation" Base="IOperation" ChildrenOrder="Clauses,Body">
    <Comments>
      <summary>
        Represents a switch case section with one or more case clauses to match and one or more operations to execute within the section.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# switch section for one or more case clause and set of statements to execute</description></item>
          <item><description>VB case block with a case statement for one or more case clause and set of statements to execute</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Clauses" Type="ImmutableArray&lt;ICaseClauseOperation&gt;">
      <Comments>
        <summary>Clauses of the case.</summary>
      </Comments>
    </Property>
    <Property Name="Body" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>One or more operations to execute within the switch section.</summary>
      </Comments>
    </Property>
    <Property Name="Locals" Type="ImmutableArray&lt;ILocalSymbol&gt;">
      <Comments>
        <summary>Locals declared within the switch case section scoped to the section.</summary>
      </Comments>
    </Property>
    <Property Name="Condition" Type="IOperation?" Internal="true">
      <Comments>
        <summary>
          Optional combined logical condition that accounts for all <see cref="Clauses"/>.
          An instance of <see cref="IPlaceholderOperation"/> with kind <see cref="PlaceholderKind.SwitchOperationExpression"/>
          is used to refer to the <see cref="ISwitchOperation.Value"/> in context of this expression.
          It is not part of <see cref="Children"/> list and likely contains duplicate nodes for
          nodes exposed by <see cref="Clauses"/>, like <see cref="ISingleValueCaseClauseOperation.Value"/>,
          etc.
          Never set for C# at the moment.
        </summary>
      </Comments>
    </Property>
  </Node>
  <AbstractNode Name="ICaseClauseOperation" Base="IOperation">
    <OperationKind Include="true" ExtraDescription="This is further differentiated by &lt;see cref=&quot;ICaseClauseOperation.CaseKind&quot;/&gt;." />
    <Comments>
      <summary>
        Represents a case clause.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# case clause</description></item>
          <item><description>VB Case clause</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="CaseKind" Type="CaseKind" MakeAbstract="true">
      <Comments>
        <summary>Kind of the clause.</summary>
      </Comments>
    </Property>
    <Property Name="Label" Type="ILabelSymbol?">
      <Comments>
        <summary>Label associated with the case clause, if any.</summary>
      </Comments>
    </Property>
  </AbstractNode>
  <Node Name="IDefaultCaseClauseOperation" Base="ICaseClauseOperation">
    <OperationKind Include="false" />
    <Comments>
      <summary>
        Represents a default case clause.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# default clause</description></item>
          <item><description>VB Case Else clause</description></item>
        </list>
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="IPatternCaseClauseOperation" Base="ICaseClauseOperation" ChildrenOrder="Pattern,Guard">
    <OperationKind Include="false" />
    <Comments>
      <summary>
        Represents a case clause with a pattern and an optional guard operation.
        <para>
        Current usage:
         (1) C# pattern case clause.
        </para>
      </summary>
    </Comments>
    <Property Name="Label" Type="ILabelSymbol" New="true">
      <Comments>
        <!-- It would be a binary breaking change to remove this -->
        <summary>
          Label associated with the case clause.
        </summary>
      </Comments>
    </Property>
    <Property Name="Pattern" Type="IPatternOperation">
      <Comments>
        <summary>Pattern associated with case clause.</summary>
      </Comments>
    </Property>
    <Property Name="Guard" Type="IOperation?">
      <Comments>
        <summary>Guard associated with the pattern case clause.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IRangeCaseClauseOperation" Base="ICaseClauseOperation" ChildrenOrder="MinimumValue,MaximumValue">
    <OperationKind Include="false" />
    <Comments>
      <summary>
        Represents a case clause with range of values for comparison.
        <para>
        Current usage:
        <list type="number">
          <item><description>VB range case clause of the form <c>Case x To y</c></description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="MinimumValue" Type="IOperation">
      <Comments>
        <summary>Minimum value of the case range.</summary>
      </Comments>
    </Property>
    <Property Name="MaximumValue" Type="IOperation">
      <Comments>
        <summary>Maximum value of the case range.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IRelationalCaseClauseOperation" Base="ICaseClauseOperation">
    <OperationKind Include="false" />
    <Comments>
      <summary>
        Represents a case clause with custom relational operator for comparison.
        <para>
        Current usage:
        <list type="number">
          <item><description>VB relational case clause of the form <c>Case Is op x</c></description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Case value.</summary>
      </Comments>
    </Property>
    <Property Name="Relation" Type="BinaryOperatorKind">
      <Comments>
        <summary>Relational operator used to compare the switch value with the case value.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ISingleValueCaseClauseOperation" Base="ICaseClauseOperation">
    <OperationKind Include="false" />
    <Comments>
      <summary>
        Represents a case clause with a single value for comparison.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# case clause of the form <c>case x</c></description></item>
          <item><description>VB case clause of the form <c>Case x</c></description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Case value.</summary>
      </Comments>
    </Property>
  </Node>
  <AbstractNode Name="IInterpolatedStringContentOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a constituent part of an interpolated string.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# interpolated string content</description></item>
          <item><description>VB interpolated string content</description></item>
        </list>
        </para>
      </summary>
    </Comments>
  </AbstractNode>
  <Node Name="IInterpolatedStringTextOperation" Base="IInterpolatedStringContentOperation">
    <Comments>
      <summary>
        Represents a constituent string literal part of an interpolated string operation.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# interpolated string text</description></item>
          <item><description>VB interpolated string text</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Text" Type="IOperation">
      <Comments>
        <summary>Text content.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IInterpolationOperation" Base="IInterpolatedStringContentOperation" ChildrenOrder="Expression,Alignment,FormatString">
    <Comments>
      <summary>
        Represents a constituent interpolation part of an interpolated string operation.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# interpolation part</description></item>
          <item><description>VB interpolation part</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Expression" Type="IOperation">
      <Comments>
        <summary>Expression of the interpolation.</summary>
      </Comments>
    </Property>
    <Property Name="Alignment" Type="IOperation?">
      <Comments>
        <summary>Optional alignment of the interpolation.</summary>
      </Comments>
    </Property>
    <Property Name="FormatString" Type="IOperation?">
      <Comments>
        <summary>Optional format string of the interpolation.</summary>
      </Comments>
    </Property>
  </Node>
  <AbstractNode Name="IPatternOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a pattern matching operation.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# pattern</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="InputType" Type="ITypeSymbol">
      <Comments>
        <summary>The input type to the pattern-matching operation.</summary>
      </Comments>
    </Property>
    <Property Name="NarrowedType" Type="ITypeSymbol">
      <Comments>
        <summary>The narrowed type of the pattern-matching operation.</summary>
      </Comments>
    </Property>
  </AbstractNode>
  <Node Name="IConstantPatternOperation" Base="IPatternOperation">
    <Comments>
      <summary>
        Represents a pattern with a constant value.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# constant pattern</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Constant value of the pattern operation.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IDeclarationPatternOperation" Base="IPatternOperation">
    <Comments>
      <summary>
        Represents a pattern that declares a symbol.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# declaration pattern</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="MatchedType" Type="ITypeSymbol?">
      <Comments>
        <summary>
          The type explicitly specified, or null if it was inferred (e.g. using <see langword="var" /> in C#).
        </summary>
      </Comments>
    </Property>
    <Property Name="MatchesNull" Type="bool">
      <Comments>
        <summary>
          True if the pattern is of a form that accepts null.
          For example, in C# the pattern `var x` will match a null input,
          while the pattern `string x` will not.
        </summary>
      </Comments>
    </Property>
    <Property Name="DeclaredSymbol" Type="ISymbol?">
      <Comments>
        <summary>Symbol declared by the pattern, if any.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ITupleBinaryOperation" Base="IOperation" VisitorName="VisitTupleBinaryOperator" ChildrenOrder="LeftOperand,RightOperand" HasType="true">
    <OperationKind>
      <Entry Name="TupleBinary" Value="0x57" />
      <Entry Name="TupleBinaryOperator" Value="0x57" EditorBrowsable="false" ExtraDescription="Use &lt;see cref=&quot;TupleBinary&quot;/&gt; instead." />
    </OperationKind>
    <Comments>
      <summary>
        Represents a comparison of two operands that returns a bool type.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# tuple binary operator expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="OperatorKind" Type="BinaryOperatorKind">
      <Comments>
        <summary>Kind of binary operation.</summary>
      </Comments>
    </Property>
    <Property Name="LeftOperand" Type="IOperation">
      <Comments>
        <summary>Left operand.</summary>
      </Comments>
    </Property>
    <Property Name="RightOperand" Type="IOperation">
      <Comments>
        <summary>Right operand.</summary>
      </Comments>
    </Property>
  </Node>
  <AbstractNode Name="IMethodBodyBaseOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents a method body operation.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# method body</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="BlockBody" Type="IBlockOperation?">
      <Comments>
        <summary>Method body corresponding to BaseMethodDeclarationSyntax.Body or AccessorDeclarationSyntax.Body</summary>
      </Comments>
    </Property>
    <Property Name="ExpressionBody" Type="IBlockOperation?">
      <Comments>
        <summary>Method body corresponding to BaseMethodDeclarationSyntax.ExpressionBody or AccessorDeclarationSyntax.ExpressionBody</summary>
      </Comments>
    </Property>
  </AbstractNode>
  <Node Name="IMethodBodyOperation" Base="IMethodBodyBaseOperation" VisitorName="VisitMethodBodyOperation" ChildrenOrder="BlockBody,ExpressionBody">
    <OperationKind>
      <Entry Name="MethodBody" Value="0x58" />
      <Entry Name="MethodBodyOperation" Value="0x58" EditorBrowsable="false" ExtraDescription="Use &lt;see cref=&quot;MethodBody&quot;/&gt; instead." />
    </OperationKind>
    <Comments>
      <summary>
        Represents a method body operation.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# method body for non-constructor</description></item>
        </list>
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="IConstructorBodyOperation" Base="IMethodBodyBaseOperation" VisitorName="VisitConstructorBodyOperation" ChildrenOrder="Initializer,BlockBody,ExpressionBody">
    <OperationKind>
      <Entry Name="ConstructorBody" Value="0x59" />
      <Entry Name="ConstructorBodyOperation" Value="0x59" EditorBrowsable="false" ExtraDescription="Use &lt;see cref=&quot;ConstructorBody&quot;/&gt; instead." />
    </OperationKind>
    <Comments>
      <summary>
        Represents a constructor method body operation.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# method body for constructor declaration</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Locals" Type="ImmutableArray&lt;ILocalSymbol&gt;">
      <Comments>
        <summary>Local declarations contained within the <see cref="Initializer" />.</summary>
      </Comments>
    </Property>
    <Property Name="Initializer" Type="IOperation?">
      <Comments>
        <summary>Constructor initializer, if any.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IDiscardOperation" Base="IOperation" VisitorName="VisitDiscardOperation" HasType="true">
    <Comments>
      <summary>
        Represents a discard operation.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# discard expressions</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="DiscardSymbol" Type="IDiscardSymbol">
      <Comments>
        <summary>The symbol of the discard operation.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IFlowCaptureOperation" Base="IOperation" Namespace="FlowAnalysis" SkipInCloner="true">
    <Comments>
      <summary>
        Represents that an intermediate result is being captured.
        This node is produced only as part of a <see cref="ControlFlowGraph" />.
      </summary>
    </Comments>
    <Property Name="Id" Type="CaptureId">
      <Comments>
        <summary>An id used to match references to the same intermediate result.</summary>
      </Comments>
    </Property>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Value to be captured.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IFlowCaptureReferenceOperation" Base="IOperation" Namespace="FlowAnalysis" HasType="true" HasConstantValue="true">
    <Comments>
      <summary>
        Represents a point of use of an intermediate result captured earlier.
        The fact of capturing the result is represented by <see cref="IFlowCaptureOperation" />.
        This node is produced only as part of a <see cref="ControlFlowGraph" />.
      </summary>
    </Comments>
    <Property Name="Id" Type="CaptureId">
      <Comments>
        <summary>An id used to match references to the same intermediate result.</summary>
      </Comments>
    </Property>
    <Property Name="IsInitialization" Type="bool">
      <Comments>
        <summary>True if this reference to the capture initializes the capture. Used when the capture is being initialized by being passed as an <see langword="out" /> parameter.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IIsNullOperation" Base="IOperation" Namespace="FlowAnalysis" SkipInCloner="true" HasType="true" HasConstantValue="true">
    <Comments>
      <summary>
        Represents result of checking whether the <see cref="Operand" /> is null.
        For reference types this checks if the <see cref="Operand" /> is a null reference,
        for nullable types this checks if the <see cref="Operand" /> doesn’t have a value.
        The node is produced as part of a flow graph during rewrite of <see cref="ICoalesceOperation" />
        and <see cref="IConditionalAccessOperation" /> nodes.
      </summary>
    </Comments>
    <Property Name="Operand" Type="IOperation">
      <Comments>
        <summary>Value to check.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ICaughtExceptionOperation" Base="IOperation" Namespace="FlowAnalysis" SkipInCloner="true" HasType="true">
    <Comments>
      <summary>
        Represents a exception instance passed by an execution environment to an exception filter or handler.
        This node is produced only as part of a <see cref="ControlFlowGraph" />.
      </summary>
    </Comments>
  </Node>
  <Node Name="IStaticLocalInitializationSemaphoreOperation" Base="IOperation" Namespace="FlowAnalysis" SkipInCloner="true" HasType="true">
    <Comments>
      <summary>
        Represents the check during initialization of a VB static local that is initialized on the first call of the function, and never again.
        If the semaphore operation returns true, the static local has not yet been initialized, and the initializer will be run. If it returns
        false, then the local has already been initialized, and the static local initializer region will be skipped.
        This node is produced only as part of a <see cref="ControlFlowGraph" />.
      </summary>
    </Comments>
    <Property Name="Local" Type="ILocalSymbol">
      <Comments>
        <summary>The static local variable that is possibly initialized.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IFlowAnonymousFunctionOperation" Base="IOperation" Namespace="FlowAnalysis" SkipClassGeneration="true">
    <Comments>
      <summary>
        Represents an anonymous function operation in context of a <see cref="ControlFlowGraph" />.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# lambda expression</description></item>
          <item><description>VB anonymous delegate expression</description></item>
        </list>
        </para>
        A <see cref="ControlFlowGraph" /> for the body of the anonymous function is available from
        the enclosing <see cref="ControlFlowGraph" />.
      </summary>
    </Comments>
    <Property Name="Symbol" Type="IMethodSymbol">
      <Comments>
        <summary>Symbol of the anonymous function.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ICoalesceAssignmentOperation" Base="IAssignmentOperation" ChildrenOrder="Target,Value" HasType="true">
    <Comments>
      <summary>
        Represents a coalesce assignment operation with a target and a conditionally-evaluated value:
        <list type="number">
          <item><description><see cref="IAssignmentOperation.Target" /> is evaluated for null. If it is null, <see cref="IAssignmentOperation.Value" /> is evaluated and assigned to target</description></item>
          <item><description><see cref="IAssignmentOperation.Value" /> is conditionally evaluated if <see cref="IAssignmentOperation.Target" /> is null, and the result is assigned into <see cref="IAssignmentOperation.Target" /></description></item>
        </list>
        The result of the entire expression is <see cref="IAssignmentOperation.Target" />, which is only evaluated once.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# null-coalescing assignment operation <c>Target ??= Value</c></description></item>
        </list>
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="IRangeOperation" Base="IOperation" VisitorName="VisitRangeOperation" ChildrenOrder="LeftOperand,RightOperand" HasType="true">
    <Comments>
      <summary>
        Represents a range operation.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# range expressions</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="LeftOperand" Type="IOperation?">
      <Comments>
        <summary>Left operand.</summary>
      </Comments>
    </Property>
    <Property Name="RightOperand" Type="IOperation?">
      <Comments>
        <summary>Right operand.</summary>
      </Comments>
    </Property>
    <Property Name="IsLifted" Type="bool">
      <Comments>
        <summary>
          <see langword="true" /> if this is a 'lifted' range operation.  When there is an
          operator that is defined to work on a value type, 'lifted' operators are
          created to work on the <see cref="System.Nullable{T}" /> versions of those
          value types.
        </summary>
      </Comments>
    </Property>
    <Property Name="Method" Type="IMethodSymbol?">
      <Comments>
        <summary>
          Factory method used to create this Range value. Can be null if appropriate
          symbol was not found.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IReDimOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents the ReDim operation to re-allocate storage space for array variables.
        <para>
        Current usage:
        <list type="number">
          <item><description>VB ReDim statement</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Clauses" Type="ImmutableArray&lt;IReDimClauseOperation&gt;">
      <Comments>
        <summary>Individual clauses of the ReDim operation.</summary>
      </Comments>
    </Property>
    <Property Name="Preserve" Type="bool">
      <Comments>
        <summary>Modifier used to preserve the data in the existing array when you change the size of only the last dimension.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IReDimClauseOperation" Base="IOperation" ChildrenOrder="Operand,DimensionSizes">
    <Comments>
      <summary>
        Represents an individual clause of an <see cref="IReDimOperation" /> to re-allocate storage space for a single array variable.
        <para>
        Current usage:
        <list type="number">
          <item><description>VB ReDim clause</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Operand" Type="IOperation">
      <Comments>
        <summary>Operand whose storage space needs to be re-allocated.</summary>
      </Comments>
    </Property>
    <Property Name="DimensionSizes" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>Sizes of the dimensions of the created array instance.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IRecursivePatternOperation" Base="IPatternOperation" ChildrenOrder="DeconstructionSubpatterns,PropertySubpatterns">
    <Comments>
      <summary>Represents a C# recursive pattern.</summary>
    </Comments>
    <Property Name="MatchedType" Type="ITypeSymbol">
      <Comments>
        <summary>The type accepted for the recursive pattern.</summary>
      </Comments>
    </Property>
    <Property Name="DeconstructSymbol" Type="ISymbol?">
      <Comments>
        <summary>
          The symbol, if any, used for the fetching values for subpatterns. This is either a <c>Deconstruct</c>
          method, the type <c>System.Runtime.CompilerServices.ITuple</c>, or null (for example, in
          error cases or when matching a tuple type).
        </summary>
      </Comments>
    </Property>
    <Property Name="DeconstructionSubpatterns" Type="ImmutableArray&lt;IPatternOperation&gt;">
      <Comments>
        <summary>This contains the patterns contained within a deconstruction or positional subpattern.</summary>
      </Comments>
    </Property>
    <Property Name="PropertySubpatterns" Type="ImmutableArray&lt;IPropertySubpatternOperation&gt;">
      <Comments>
        <summary>This contains the (symbol, property) pairs within a property subpattern.</summary>
      </Comments>
    </Property>
    <Property Name="DeclaredSymbol" Type="ISymbol?">
      <Comments>
        <summary>Symbol declared by the pattern.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IDiscardPatternOperation" Base="IPatternOperation">
    <Comments>
      <summary>
        Represents a discard pattern.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# discard pattern</description></item>
        </list>
        </para>
      </summary>
    </Comments>
  </Node>
  <Node Name="ISwitchExpressionOperation" Base="IOperation" ChildrenOrder="Value,Arms" HasType="true">
    <Comments>
      <summary>
        Represents a switch expression.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# switch expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Value to be switched upon.</summary>
      </Comments>
    </Property>
    <Property Name="Arms" Type="ImmutableArray&lt;ISwitchExpressionArmOperation&gt;">
      <Comments>
        <summary>Arms of the switch expression.</summary>
      </Comments>
    </Property>
    <Property Name="IsExhaustive" Type="bool">
        <Comments>
            <summary>True if the switch expressions arms cover every possible input value.</summary>
        </Comments>
    </Property>
  </Node>
  <Node Name="ISwitchExpressionArmOperation" Base="IOperation" ChildrenOrder="Pattern,Guard,Value">
    <Comments>
      <summary>Represents one arm of a switch expression.</summary>
    </Comments>
    <Property Name="Pattern" Type="IPatternOperation">
      <Comments>
        <summary>The pattern to match.</summary>
      </Comments>
    </Property>
    <Property Name="Guard" Type="IOperation?">
      <Comments>
        <summary>Guard (when clause expression) associated with the switch arm, if any.</summary>
      </Comments>
    </Property>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Result value of the enclosing switch expression when this arm matches.</summary>
      </Comments>
    </Property>
    <Property Name="Locals" Type="ImmutableArray&lt;ILocalSymbol&gt;">
      <Comments>
        <summary>Locals declared within the switch arm (e.g. pattern locals and locals declared in the guard) scoped to the arm.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IPropertySubpatternOperation" Base="IOperation" ChildrenOrder="Member,Pattern">
    <Comments>
      <summary>
        Represents an element of a property subpattern, which identifies a member to be matched and the
        pattern to match it against.
      </summary>
    </Comments>
    <Property Name="Member" Type="IOperation">
      <Comments>
        <summary>
          The member being matched in a property subpattern.  This can be a <see cref="IMemberReferenceOperation" />
          in non-error cases, or an <see cref="IInvalidOperation" /> in error cases.
        </summary>
      </Comments>
    </Property>
    <Property Name="Pattern" Type="IPatternOperation">
      <Comments>
        <summary>The pattern to which the member is matched in a property subpattern.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IAggregateQueryOperation" Base="IOperation" Internal="true" ChildrenOrder="Group,Aggregation" HasType="true">
    <Comments>
      <summary>Represents a standalone VB query Aggregate operation with more than one item in Into clause.</summary>
    </Comments>
    <Property Name="Group" Type="IOperation" />
    <Property Name="Aggregation" Type="IOperation" />
  </Node>
  <Node Name="IFixedOperation" Base="IOperation" Internal="true" SkipInVisitor="true" ChildrenOrder="Variables,Body">
    <!-- Making this public is tracked by https://github.com/dotnet/roslyn/issues/21281 -->
    <Comments>
      <summary>Represents a C# fixed statement.</summary>
    </Comments>
    <Property Name="Locals" Type="ImmutableArray&lt;ILocalSymbol&gt;">
      <Comments>
        <summary>Locals declared.</summary>
      </Comments>
    </Property>
    <Property Name="Variables" Type="IVariableDeclarationGroupOperation">
      <Comments>
        <summary>Variables to be fixed.</summary>
      </Comments>
    </Property>
    <Property Name="Body" Type="IOperation">
      <Comments>
        <summary>Body of the fixed, over which the variables are fixed.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="INoPiaObjectCreationOperation" Base="IOperation" Internal="true" HasType="true">
    <Comments>
      <summary>
        Represents a creation of an instance of a NoPia interface, i.e. new I(), where I is an embedded NoPia interface.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# NoPia interface instance creation expression</description></item>
          <item><description>VB NoPia interface instance creation expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Initializer" Type="IObjectOrCollectionInitializerOperation?">
      <Comments>
        <summary>Object or collection initializer, if any.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IPlaceholderOperation" Base="IOperation" Internal="true" HasType="true">
    <Comments>
      <summary>
        Represents a general placeholder when no more specific kind of placeholder is available.
        A placeholder is an expression whose meaning is inferred from context.
      </summary>
    </Comments>
    <Property Name="PlaceholderKind" Type="PlaceholderKind" />
  </Node>
  <Node Name="IPointerIndirectionReferenceOperation" Base="IOperation" SkipClassGeneration="true" Internal="true" HasType="true">
    <Comments>
      <summary>
        Represents a reference through a pointer.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# pointer indirection reference expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Pointer" Type="IOperation">
      <Comments>
        <summary>Pointer to be dereferenced.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IWithStatementOperation" Base="IOperation" Internal="true" ChildrenOrder="Value,Body">
    <Comments>
      <summary>
        Represents a <see cref="Body" /> of operations that are executed with implicit reference to the <see cref="Value" /> for member references.
        <para>
        Current usage:
        <list type="number">
          <item><description>VB With statement</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Body" Type="IOperation">
      <Comments>
        <summary>Body of the with.</summary>
      </Comments>
    </Property>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Value to whose members leading-dot-qualified references within the with body bind.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IUsingDeclarationOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents using variable declaration, with scope spanning across the parent <see cref="IBlockOperation"/>.
        <para>
        Current Usage:
        <list type="number">
          <item><description>C# using declaration</description></item>
          <item><description>C# asynchronous using declaration</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="DeclarationGroup" Type="IVariableDeclarationGroupOperation">
      <Comments>
        <summary>The variables declared by this using declaration.</summary>
      </Comments>
    </Property>
    <Property Name="IsAsynchronous" Type="bool">
      <Comments>
        <summary>True if this is an asynchronous using declaration.</summary>
      </Comments>
    </Property>
    <Property Name="DisposeInfo" Type="DisposeOperationInfo" Internal="true">
      <Comments>
        <summary>Information about the method that will be invoked to dispose the declared instances when pattern based disposal is used.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="INegatedPatternOperation" Base="IPatternOperation">
    <Comments>
      <summary>
        Represents a negated pattern.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# negated pattern</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Pattern" Type="IPatternOperation">
      <Comments>
        <summary>The negated pattern.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IBinaryPatternOperation" Base="IPatternOperation" ChildrenOrder="LeftPattern,RightPattern">
    <Comments>
      <summary>
        Represents a binary ("and" or "or") pattern.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# "and" and "or" patterns</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="OperatorKind" Type="BinaryOperatorKind">
      <Comments>
        <summary>Kind of binary pattern; either <see cref="BinaryOperatorKind.And"/> or <see cref="BinaryOperatorKind.Or"/>.</summary>
      </Comments>
    </Property>
    <Property Name="LeftPattern" Type="IPatternOperation">
      <Comments>
        <summary>The pattern on the left.</summary>
      </Comments>
    </Property>
    <Property Name="RightPattern" Type="IPatternOperation">
      <Comments>
        <summary>The pattern on the right.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ITypePatternOperation" Base="IPatternOperation">
    <Comments>
      <summary>
        Represents a pattern comparing the input with a given type.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# type pattern</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="MatchedType" Type="ITypeSymbol">
      <Comments>
        <summary>
          The type explicitly specified, or null if it was inferred (e.g. using <see langword="var" /> in C#).
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IRelationalPatternOperation" Base="IPatternOperation">
    <Comments>
      <summary>
        Represents a pattern comparing the input with a constant value using a relational operator.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# relational pattern</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="OperatorKind" Type="BinaryOperatorKind">
      <Comments>
        <summary>The kind of the relational operator.</summary>
      </Comments>
    </Property>
    <Property Name="Value" Type="IOperation">
      <Comments>
        <summary>Constant value of the pattern operation.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IWithOperation" Base="IOperation" ChildrenOrder="Operand,Initializer" HasType="true">
    <Comments>
      <summary>
        Represents cloning of an object instance.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# with expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Operand" Type="IOperation">
      <Comments>
        <summary>Operand to be cloned.</summary>
      </Comments>
    </Property>
    <Property Name="CloneMethod" Type="IMethodSymbol?">
      <Comments>
        <summary>Clone method to be invoked on the value. This can be null in error scenarios.</summary>
      </Comments>
    </Property>
    <Property Name="Initializer" Type="IObjectOrCollectionInitializerOperation">
      <Comments>
        <summary>With collection initializer.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IInterpolatedStringHandlerCreationOperation" Base="IOperation" ChildrenOrder="HandlerCreation,Content" HasType="true">
    <Comments>
      <summary>Represents an interpolated string converted to a custom interpolated string handler type.</summary>
    </Comments>
    <Property Name="HandlerCreation" Type="IOperation">
      <Comments>
        <summary>
          The construction of the interpolated string handler instance. This can be an <see cref="IObjectCreationOperation"/> for valid code, and
          <see cref="IDynamicObjectCreationOperation"/> or <see cref="IInvalidOperation"/> for invalid code.
        </summary>
      </Comments>
    </Property>
    <Property Name="HandlerCreationHasSuccessParameter" Type="bool">
      <Comments>
        <summary>
          True if the last parameter of <see cref="HandlerCreation"/> is an out <see langword="bool"/> parameter that will be checked before executing the code in
          <see cref="Content"/>. False otherwise.
        </summary>
      </Comments>
    </Property>
    <Property Name="HandlerAppendCallsReturnBool" Type="bool">
      <Comments>
        <summary>
          True if the AppendLiteral or AppendFormatted calls in nested <see cref="IInterpolatedStringOperation.Parts"/> return <see langword="bool"/>. When that is true, each part
          will be conditional on the return of the part before it, only being executed when the Append call returns true. False otherwise.
        </summary>
        <remarks>
          when this is true and <see cref="HandlerCreationHasSuccessParameter"/> is true, then the first part in nested <see cref="IInterpolatedStringOperation.Parts"/> is conditionally
          run. If this is true and <see cref="HandlerCreationHasSuccessParameter"/> is false, then the first part is unconditionally run.
          <br/>
          Just because this is true or false does not guarantee that all Append calls actually do return boolean values, as there could be dynamic calls or errors.
          It only governs what the compiler was expecting, based on the first calls it did see.
        </remarks>
      </Comments>
    </Property>
    <Property Name="Content" Type="IOperation">
      <Comments>
        <summary>
          The interpolated string expression or addition operation that makes up the content of this string. This is either an <see cref="IInterpolatedStringOperation"/>
          or an <see cref="IInterpolatedStringAdditionOperation"/> operation.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IInterpolatedStringAdditionOperation" Base="IOperation" ChildrenOrder="Left,Right">
    <Comments>
      <summary>
        Represents an addition of multiple interpolated string literals being converted to an interpolated string handler type.
      </summary>
    </Comments>
    <Property Name="Left" Type="IOperation">
      <Comments>
        <summary>
          The interpolated string expression or addition operation on the left side of the operator. This is either an <see cref="IInterpolatedStringOperation"/>
          or an <see cref="IInterpolatedStringAdditionOperation"/> operation.
        </summary>
      </Comments>
    </Property>
    <Property Name="Right" Type="IOperation">
      <Comments>
        <summary>
          The interpolated string expression or addition operation on the right side of the operator. This is either an <see cref="IInterpolatedStringOperation"/>
          or an <see cref="IInterpolatedStringAdditionOperation"/> operation.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IInterpolatedStringAppendOperation" Base="IInterpolatedStringContentOperation">
    <OperationKind>
      <Entry Name="InterpolatedStringAppendLiteral" Value="0x74" ExtraDescription="This append is of a literal component"/>
      <Entry Name="InterpolatedStringAppendFormatted" Value="0x75" ExtraDescription="This append is of an interpolation component"/>
      <Entry Name="InterpolatedStringAppendInvalid" Value="0x76" ExtraDescription="This append is invalid"/>
    </OperationKind>
    <Comments>
      <summary>Represents a call to either AppendLiteral or AppendFormatted as part of an interpolated string handler conversion.</summary>
    </Comments>
    <Property Name="AppendCall" Type="IOperation">
      <Comments>
        <summary>
          If this interpolated string is subject to an interpolated string handler conversion, the construction of the interpolated string handler instance.
          This can be an <see cref="IInvocationOperation"/>  or <see cref="IDynamicInvocationOperation"/> for valid code, and <see cref="IInvalidOperation"/> for invalid code.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IInterpolatedStringHandlerArgumentPlaceholderOperation" Base="IOperation">
    <Comments>
      <summary>Represents an argument from the method call, indexer access, or constructor invocation that is creating the containing <see cref="IInterpolatedStringHandlerCreationOperation"/></summary>
    </Comments>
    <Property Name="ArgumentIndex" Type="int">
      <Comments>
        <summary>
          The index of the argument of the method call, indexer, or object creation containing the interpolated string handler conversion this placeholder is referencing.
          -1 if <see cref="PlaceholderKind" /> is anything other than <see cref="InterpolatedStringArgumentPlaceholderKind.CallsiteArgument"/>.
        </summary>
      </Comments>
    </Property>
    <Property Name="PlaceholderKind" Type="InterpolatedStringArgumentPlaceholderKind">
      <Comments>
        <summary>
          The component this placeholder represents.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IFunctionPointerInvocationOperation" Base="IOperation" ChildrenOrder="Target,Arguments" HasType="true">
    <Comments>
      <summary>
        Represents an invocation of a function pointer.
      </summary>
    </Comments>
	<Property Name="Target" Type="IOperation">
      <Comments>
        <summary>Invoked pointer.</summary>
      </Comments>
    </Property>
    <Property Name="Arguments" Type="ImmutableArray&lt;IArgumentOperation&gt;">
      <Comments>
        <summary>Arguments of the invocation. Arguments are in evaluation order.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IListPatternOperation" Base="IPatternOperation">
    <Comments>
      <summary>Represents a C# list pattern.</summary>
    </Comments>
    <Property Name="LengthSymbol" Type="ISymbol?">
      <Comments>
        <summary>
          The <c>Length</c> or <c>Count</c> property that is used to fetch the length value.
          Returns <c>null</c> if no such property is found.
        </summary>
      </Comments>
    </Property>
    <Property Name="IndexerSymbol" Type="ISymbol?">
      <Comments>
        <summary>
          The indexer that is used to fetch elements.
          Returns <c>null</c> for an array input.
        </summary>
      </Comments>
    </Property>
    <Property Name="Patterns" Type="ImmutableArray&lt;IPatternOperation&gt;">
      <Comments>
        <summary>
          Returns subpatterns contained within the list pattern.
        </summary>
      </Comments>
    </Property>
    <Property Name="DeclaredSymbol" Type="ISymbol?">
      <Comments>
        <summary>Symbol declared by the pattern, if any.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ISlicePatternOperation" Base="IPatternOperation">
    <Comments>
      <summary>
        Represents a C# slice pattern.
      </summary>
    </Comments>
    <Property Name="SliceSymbol" Type="ISymbol?">
      <Comments>
        <summary>
          The range indexer or the <c>Slice</c> method used to fetch the slice value.
        </summary>
      </Comments>
    </Property>
    <Property Name="Pattern" Type="IPatternOperation?">
      <Comments>
        <summary>
          The pattern that the slice value is matched with, if any.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IImplicitIndexerReferenceOperation" Base="IOperation" ChildrenOrder="Instance,Argument" HasType="true">
    <Comments>
      <summary>
        Represents a reference to an implicit System.Index or System.Range indexer over a non-array type.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# implicit System.Index or System.Range indexer reference expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Instance" Type="IOperation">
      <Comments>
        <summary>Instance of the type to be indexed.</summary>
      </Comments>
    </Property>
    <Property Name="Argument" Type="IOperation">
      <Comments>
        <summary>System.Index or System.Range value.</summary>
      </Comments>
    </Property>
    <Property Name="LengthSymbol" Type="ISymbol">
      <Comments>
        <summary>
          The <c>Length</c> or <c>Count</c> property that might be used to fetch the length value.
        </summary>
      </Comments>
    </Property>
    <Property Name="IndexerSymbol" Type="ISymbol">
      <Comments>
        <summary>
          Symbol for the underlying indexer or a slice method that is used to implement the implicit indexer.
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IUtf8StringOperation" Base="IOperation" HasType="true" HasConstantValue="false">
    <Comments>
      <summary>
        Represents a UTF-8 encoded byte representation of a string.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# UTF-8 string literal expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Value" Type="string">
      <Comments>
        <summary>The underlying string value.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IAttributeOperation" Base="IOperation">
    <Comments>
      <summary>
        Represents the application of an attribute.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# attribute application</description></item>
          <item><description>VB attribute application</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Operation" Type="IOperation">
      <Comments>
        <summary>The operation representing the attribute. This can be a <see cref="IObjectCreationOperation" /> in non-error cases, or an <see cref="IInvalidOperation" /> in error cases.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="IInlineArrayAccessOperation" Base="IOperation" ChildrenOrder="Instance,Argument" HasType="true">
    <Comments>
      <summary>
        Represents an element reference or a slice operation over an inline array type.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# inline array access</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Instance" Type="IOperation">
      <Comments>
        <summary>Instance of the inline array type to be accessed.</summary>
      </Comments>
    </Property>
    <Property Name="Argument" Type="IOperation">
      <Comments>
        <summary>System.Int32, System.Index or System.Range value.</summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ICollectionExpressionOperation" Base="IOperation" HasType="true" ChildrenOrder="ConstructArguments,Elements">
    <Comments>
      <summary>
        Represents a collection expression.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# collection expression</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="ConstructMethod" Type="IMethodSymbol?">
      <Comments>
        <summary>
          Method used to construct the collection.
          <para/>
          <list type="number">
          <item>If the collection type is an array, span, or type parameter, the method is null.</item>
          <item>If the collection type has a [CollectionBuilder] attribute, the method is the builder method.</item>
          <item>If the collection type is a mutable array interface and the collection was initialized with arguments,
          the method is the constructor of <see cref="List{T}"/> that was used.  If this is read-only array interface,
          or no arguments were provided, the method is null</item>
          <item>Otherwise, the method is the collection type constructor.</item>
          </list>
        </summary>
      </Comments>
    </Property>
    <Property Name="ConstructArguments" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>
          Arguments passed to to <see cref="ConstructMethod"/>, if present. Arguments are in evaluation order. This can
          be an empty array. Will never be <c>default</c>.  If the arguments succe successfully bound, these will all be
          <see cref="IArgumentOperation"/>; otherwise, they can be any operation.
        </summary>
        <remarks>
          If the invocation is in its expanded form, then params/ParamArray arguments would be collected into arrays.
          Default values are supplied for optional arguments missing in source.
        </remarks>
      </Comments>
    </Property>
    <Property Name="Elements" Type="ImmutableArray&lt;IOperation&gt;">
      <Comments>
        <summary>
          Collection expression elements.
          <para>
            If the element is an expression, the entry is the expression, with a conversion to
            the target element type if necessary;
            otherwise, the entry is an ISpreadOperation.
          </para>
        </summary>
      </Comments>
    </Property>
  </Node>
  <Node Name="ISpreadOperation" Base="IOperation" HasType="false">
      <Comments>
      <summary>
        Represents a collection expression spread element.
        <para>
        Current usage:
        <list type="number">
          <item><description>C# spread element</description></item>
        </list>
        </para>
      </summary>
    </Comments>
    <Property Name="Operand" Type="IOperation">
      <Comments>
        <summary>Collection being spread.</summary>
      </Comments>
    </Property>
    <Property Name="ElementType" Type="ITypeSymbol?">
      <Comments>
        <summary>
          Type of the elements in the collection.
        </summary>
      </Comments>
    </Property>
    <Property Name="ElementConversion" Type="CommonConversion">
      <Comments>
        <summary>
          Conversion from the type of the collection element to the target element type
          of the containing collection expression.
        </summary>
      </Comments>
    </Property>
  </Node>
</Tree>
