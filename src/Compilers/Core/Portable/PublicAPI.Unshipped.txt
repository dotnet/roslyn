*REMOVED*override abstract Microsoft.CodeAnalysis.Diagnostic.Equals(object? obj) -> bool
const Metalama.Compiler.MetalamaCompilerAnnotations.GeneratedCodeAnnotationKind = "Metalama.Compiler.GeneratedCode" -> string!
Metalama.Compiler.MetalamaCompilerAnnotations
Metalama.Compiler.TransformerContext.AnalyzerConfigOptionsProvider.get -> Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptionsProvider!
Metalama.Compiler.TransformerContext.Options.get -> Metalama.Compiler.TransformerOptions!
Metalama.Compiler.TransformerOptions
Metalama.Compiler.TransformerOptions.RequiresCodeCoverageAnnotations.get -> bool
Microsoft.CodeAnalysis.Compilation.GetTypesByMetadataName(string! fullyQualifiedMetadataName) -> System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.INamedTypeSymbol!>
Microsoft.CodeAnalysis.IOperation.ChildOperations.get -> Microsoft.CodeAnalysis.IOperation.OperationList
Microsoft.CodeAnalysis.IOperation.OperationList
Microsoft.CodeAnalysis.IOperation.OperationList.Any() -> bool
Microsoft.CodeAnalysis.IOperation.OperationList.OperationList() -> void
Microsoft.CodeAnalysis.IOperation.OperationList.Count.get -> int
Microsoft.CodeAnalysis.IOperation.OperationList.First() -> Microsoft.CodeAnalysis.IOperation!
Microsoft.CodeAnalysis.IOperation.OperationList.GetEnumerator() -> Microsoft.CodeAnalysis.IOperation.OperationList.Enumerator
Microsoft.CodeAnalysis.IOperation.OperationList.Last() -> Microsoft.CodeAnalysis.IOperation!
Microsoft.CodeAnalysis.IOperation.OperationList.Reverse() -> Microsoft.CodeAnalysis.IOperation.OperationList.Reversed
Microsoft.CodeAnalysis.IOperation.OperationList.ToImmutableArray() -> System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IOperation!>
Microsoft.CodeAnalysis.IOperation.OperationList.Enumerator
Microsoft.CodeAnalysis.IOperation.OperationList.Enumerator.Current.get -> Microsoft.CodeAnalysis.IOperation!
Microsoft.CodeAnalysis.IOperation.OperationList.Enumerator.Enumerator() -> void
Microsoft.CodeAnalysis.IOperation.OperationList.Enumerator.MoveNext() -> bool
Microsoft.CodeAnalysis.IOperation.OperationList.Enumerator.Reset() -> void
Microsoft.CodeAnalysis.IOperation.OperationList.Reversed.Enumerator
Microsoft.CodeAnalysis.IOperation.OperationList.Reversed.Enumerator.Current.get -> Microsoft.CodeAnalysis.IOperation!
Microsoft.CodeAnalysis.IOperation.OperationList.Reversed.Enumerator.Enumerator() -> void
Microsoft.CodeAnalysis.IOperation.OperationList.Reversed.Enumerator.MoveNext() -> bool
Microsoft.CodeAnalysis.IOperation.OperationList.Reversed.Enumerator.Reset() -> void
Microsoft.CodeAnalysis.IOperation.OperationList.Reversed
Microsoft.CodeAnalysis.IOperation.OperationList.Reversed.Reversed() -> void
Microsoft.CodeAnalysis.IOperation.OperationList.Reversed.Count.get -> int
Microsoft.CodeAnalysis.IOperation.OperationList.Reversed.GetEnumerator() -> Microsoft.CodeAnalysis.IOperation.OperationList.Reversed.Enumerator
Microsoft.CodeAnalysis.IOperation.OperationList.Reversed.ToImmutableArray() -> System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IOperation!>
override sealed Microsoft.CodeAnalysis.Diagnostic.Equals(object? obj) -> bool
*REMOVED*static Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceSyntax<TRoot>(this TRoot! root, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode!>! nodes, System.Func<Microsoft.CodeAnalysis.SyntaxNode!, Microsoft.CodeAnalysis.SyntaxNode!, Microsoft.CodeAnalysis.SyntaxNode!>! computeReplacementNode, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken>! tokens, System.Func<Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxToken>! computeReplacementToken, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia>! trivia, System.Func<Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia>! computeReplacementTrivia) -> TRoot!
static Metalama.Compiler.MetalamaCompilerAnnotations.CreateGeneratedCodeAnnotation(string! origin) -> Microsoft.CodeAnalysis.SyntaxAnnotation!
static Metalama.Compiler.MetalamaCompilerAnnotations.SourceCodeAnnotation.get -> Microsoft.CodeAnalysis.SyntaxAnnotation!
static Metalama.Compiler.MetalamaCompilerAnnotations.TryGetCodeCoverageRedirectionFromAnnotation(this Microsoft.CodeAnalysis.SyntaxNode! syntaxNode, Microsoft.CodeAnalysis.Compilation! compilation, out Microsoft.CodeAnalysis.ISymbol? redirectedSymbol) -> bool
static Metalama.Compiler.MetalamaCompilerAnnotations.WithIgnoreCodeCoverageAnnotation<T>(this T! syntaxNode) -> T!
static Metalama.Compiler.MetalamaCompilerAnnotations.WithOriginalLocationAnnotationFrom(this Microsoft.CodeAnalysis.SyntaxToken token, Microsoft.CodeAnalysis.SyntaxToken originalToken) -> Microsoft.CodeAnalysis.SyntaxToken
static Metalama.Compiler.MetalamaCompilerAnnotations.WithOriginalLocationAnnotationFrom<T>(this T! node, Microsoft.CodeAnalysis.SyntaxNode! originalNode) -> T!
static Metalama.Compiler.MetalamaCompilerAnnotations.WithRedirectCodeCoverageAnnotation<T>(this T! syntaxNode, Microsoft.CodeAnalysis.ISymbol! originalSymbol) -> T!
static Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceSyntax<TRoot>(this TRoot! root, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode!>? nodes, System.Func<Microsoft.CodeAnalysis.SyntaxNode!, Microsoft.CodeAnalysis.SyntaxNode!, Microsoft.CodeAnalysis.SyntaxNode!>? computeReplacementNode, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken>? tokens, System.Func<Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxToken>? computeReplacementToken, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia>? trivia, System.Func<Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia>? computeReplacementTrivia) -> TRoot!
