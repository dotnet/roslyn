<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AllInOneCSharpCode" xml:space="preserve">
    <value>#error Error message
#warning Warning message
#pragma warning disable 414, 3021
#pragma warning restore 3021
#pragma checksum "file.txt" "{00000000-0000-0000-0000-000000000000}" "2453"
#define goo
#if goo
#else
#endif
#undef goo

extern alias Goo;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using M = System.Math;

#if DEBUG || TRACE
using System.Diagnostics;
#elif SILVERLIGHT &amp;&amp; WINDOWS_PHONE || DEBUG || goo == true || goo != false
using System.Diagnostics;
#else
using System.Diagnostics;
#endif

#region Region

#region more
using ConsoleApplication2.Test;
#endregion
using X = int1;
using Y = ABC.X&lt;int&gt;;

#endregion

[assembly: System.Copyright(@"(C)"" 

2009")]
[module: System.Copyright("\n\t\u0123(C) \"2009" + "\u0123")]

class TopLevelType : IDisposable
{
    void IDisposable.Dispose() { }
}

namespace My
{
    using A.B;

    interface CoContra&lt;out T, in K&gt; { }
    delegate void CoContra2&lt;[System.Obsolete()] out T, in K&gt; () where T : struct;

    public unsafe partial class A : C, I
    {
        [DllImport("kernel32", SetLastError = true)]
        static extern bool CreateDirectory(string name, SecurityAttribute sa);

        private const int global = int.MinValue - 1;

        static A() 
        {
            int x = default;
            string y = null!;
        }

        void Patterns(object o, object p)
        {
            var b = o is string s;
            var c = o switch { "a" => 1, "b" => 2, _ => 3 };
            switch (o, p)
            {
                case (2, 1): break;
                case (2, 2) q: break;
                case X(2, 3): break;
                case X(2, 4) q: break;
                case X { A: 2, B: 5 }: break;
                case X { A: 2, B: 6 } q: break;
                case X(2, 1) { A: 2, B: 7 }: break;
                case X(2, 4) { A: 2, B: 8 } q: break;
                case { A: 3, B: 9 }: break;
                case { A: 3, B: 10 } q: break;
                case [ 1, 2, 3, .. 4 ]: break;
                case [ 1, 2, 3, .. 4 ] v: break;
                case X q: break;
                case var (x, y) when x == y: break;
                case var (x, (y, z)) when x == y: break;
                case { x.y: p }: break;
                case _: break;
            }
        }

        public static bool IsAsciiLetter(char c) => c is (>= 'a' and &lt;= 'z') or (>= 'A' and &lt;= 'Z');
        public static bool NotInteger(object o) => o is not int;

        [method: Obsolete]
        public A([param: Obsolete] int goo) :
            base(1)
        {
        L:
            {
                int i = sizeof(int);
                ++i;
                var s1 = $"x {1 , -2 :d}";
                var s2 = $@"x {1 , -2 :d}";
            }

            int LocalFunction()
            {
            }

#if DEBUG
      Console.WriteLine(export.iefSupplied.command);
#endif
            const int? local = int.MaxValue;
            const Guid? local0 = new Guid(r.ToString());

            var привет = local;
            var мир = local;
            var local3 = 0, local4 = 1;
            local3 = local4 = 1;
            var local5 = null as Action ?? null;
            local5 ??= null;
            local5 = (local5 ??= null);
            var local6 = local5 is Action;

            var u = 1u;
            var U = 1U;
            long hex = 0xBADC0DE, Hex = 0XDEADBEEF, l = -1L, L = 1L, l2 = 2l;
            ulong ul = 1ul, Ul = 1Ul, uL = 1uL, UL = 1UL,
                lu = 1lu, Lu = 1Lu, lU = 1lU, LU = 1LU;
            int minInt32Value = -2147483648;
            int minInt64Value = -9223372036854775808L;

            scoped ref string stringRef;
            stringRef = ref System.String.Empty;

            ref string stringRef1 = ref System.String.Empty;

            bool @bool;
            byte @byte;
            char @char = 'c', \u0066 = '\u0066', hexchar = '\x0130', hexchar2 = (char)0xBAD;
            string \U00000065 = "\U00000065";
            decimal @decimal = 1.44M;
            @decimal = 1.2m;
            dynamic @dynamic;
            double @double = M.PI;
            @double = 1d;
            @double = 1D;
            @double = -1.2e3;
            float @float = 1.2f;
            @float = 1.44F;
            int @int = local ?? -1;
            long @long;
            object @object;
            sbyte @sbyte;
            short @short;
            string @string = @"""/*";
            var utf8String = @"""/*"u8;
            uint @uint;
            ulong @ulong;
            ushort @ushort;
            
            dynamic dynamic = local5;
            var add = 0;
            var ascending = 0;
            var descending = 0;
            var from = 0;
            var get = 0;
            var global = 0;
            var group = 0;
            var into = 0;
            var join = 0;
            var let = 0;
            var orderby = 0;
            var partial = 0;
            var remove = 0;
            var select = 0;
            var set = 0;
            var value = 0;
            var var = 0;
            var where = 0;
            var yield = 0;
            where = yield = 0;

            if (i &gt; 0)
            {
                return;
            }
            else if (i == 0)
            {
                throw new Exception();
            }
            var o1 = new MyObject();
            var o2 = new MyObject(var);
            var o3 = new MyObject { A = i };
            var o4 = new MyObject(@dynamic)
            {
                A = 0,
                B = 0,
                C = 0
            };
            var o5 = new { A = 0 };
            object o6 = new();
            var dictionaryInitializer = new Dictionary&lt;int, string&gt; 
            { 
                {1, ""}, 
                {2, "a"} 
            };
            float[] a = new float[] 
            {
                0f,
                1.1f
            };
            var (tuple, _) = (named: 1, 2);
            bool tupleEquality = (1, (2, 3)) == (1, (2, 3));
            bool tupleInequality = (1, (2, 3)) != (1, (2, 3));
            int[, ,] cube = { { { 111, 112, }, { 121, 122 } }, { { 211, 212 }, { 221, 222 } } };
            int[][] jagged = { { 111 }, { 121, 122 } };
            int[][,] arr = new int[5][,]; // as opposed to new int[][5,5]
            arr[0] = new int[5,5];  // as opposed to arr[0,0] = new int[5];
            arr[0][0,0] = 47;
            int[] arrayTypeInference = new[] { 0, 1, };
            switch (3) { }
            switch (i)
            {
                case 0:
                case 1:
                    {
                        goto case 2;
                    }
                case 2 + 3:
                    {
                        goto default;
                        break;
                    }
                case 4 when true:
                    break;
                case int i:
                    break;
                // case Type (int x, 3) { A: _, B: 7 } identifier:
                //     break;
                // case var (x, y, (z, w)):
                //     break;
                default:
                    {
                        return;
                    }
            }
            var z7 = 1 switch { 1 => 1 };
            while (i &lt; 10)
            {
                ++i;
                if (i is int q) continue;
                void LocalFcn() =&gt; throw null;
                break;
            }
            do
            {
                ++i;
                if (true) continue;
                break;
            }
            while (i &lt; 10);
            for (int j = 0; j &lt; 100; ++j)
            {
                for(;;) 
                {
                    for (int i = 0, j = 0; i &lt; length; i++, j++) { }
                    if (true) continue;
                    break;
                }
            }
            label:
            goto label;
            label2: ;
            foreach (var i in Items())
            {
                if (i == 7)
                    return;
                else
                    continue;
            }
            foreach (var (_, _) in new (int, int)[]{ (1, 2) })
            {
            }
            checked
            {
                checked(++i);
            }
            unchecked
            {
                unchecked(++i);
            }
            lock (sync)
                process();
            using (var v = BeginScope())
            using (A a = new A())
            using (A a = new A(), b = new A())
            using (BeginScope())
                return;
            yield return this.items[3];
            yield break;
            delegate*&lt;int, string, void&gt; fp1 = null;
            delegate* managed&lt;int, string, void&gt; fp2 = null;
            delegate* unmanaged&lt;int, string, void&gt; fp3 = null;
            delegate* unmanaged[Cdecl]&lt;int, string, void&gt; fp4 = null;
            fixed (int* p = stackalloc int[100], q = &amp;y)
            {
                *intref = 1;
            }
            fixed (int* p = stackalloc int[] { 100 }, q = stackalloc[] { 100 })
            {
                *intref = 1;
            }
            unsafe
            {
                int* p = null;
            }
            try
            {
                throw null;
            }
            catch (System.AccessViolationException av)
            {
                throw av;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                try { } catch { }
            }
            var anonymous = 
            {
                A = 1,
                B = 2,
                C = 3,
            };
            var query = from c in customers
                        let d = c
                        where d != null
                        join c1 in customers on c1.GetHashCode() equals c.GetHashCode()
                        join c1 in customers on c1.GetHashCode() equals c.GetHashCode() into e
                        group c by c.Country
                            into g
                            orderby g.Count() ascending
                            orderby g.Key descending
                            select new { Country = g.Key, CustCount = g.Count() };
            query = from c in customers
                    select c into d
                    select d;
        }
        ~A()
        {
        }
        private readonly int f1;
        [Obsolete]
        [NonExisting]
        [Goo::NonExisting(var, 5)]
        [CLSCompliant(false)]
        [Obsolete, System.NonSerialized, NonSerialized, CLSCompliant(true || false &amp; true)]
        private volatile int f2;
        [return: Obsolete]
        [method: Obsolete]
        public void Handler(object value)
        {
        }
        public int m&lt;T&gt;(T t)
          where T : class, new()
        {
            base.m(t);
            return 1;
        }
        public string P
        {
            get
            {
                return "A";
            }
            set;
        }
        public abstract string P
        {
            get;
        }
        public abstract int this[int index]
        {
            protected internal get;
            internal protected set;
        }
        [method: Obsolete]
        [field: Obsolete]
        [event: Obsolete]
        public readonly event Event E;
        [event: Test]
        public event Action E1
        {
            [Obsolete]
            add { value = value; }
            [Obsolete]
            [return: Obsolete]
            remove { E += Handler; E -= Handler; }
        }
        public static A operator +(A first, A second)
        {
            Delegate handler = new Delegate(Handler);
            return first.Add(second);
        }
        [method: Obsolete]
        [return: Obsolete]
        public static bool operator true(A a)
        {
            return true;
        }
        public static bool operator false(A a)
        {
            return false;
        }
        class C
        {
        }
    }
    public struct S : I
    {
        public S()
        {
        }
        private int f1;
        [Obsolete]
        private volatile int f2;
        public abstract int m&lt;T&gt;(T t)
          where T : struct, allows ref struct
        {
            return 1;
        }
        public string P
        {
            get
            {
                int value = 0;
                return "A";
            }
            set;
        }
        public abstract string P
        {
            get;
        }
        public abstract int this[int index]
        {
            get;
            internal protected set;
        }
        public event Event E;
        public static A operator +(A first, A second)
        {
            return first.Add(second);
        }
        fixed int field[10];
        class C
        {
        }
    }
    public interface I
    {
        void A(int value);
        string Value
        {
            get;
            set;
        }
    }
    [type: Flags]
    public enum E
    {
        A,
        B = A,
        C = 2 + A,

#if DEBUG
    D,
#endif

    }
    public explicit extension X1 for Underlying : R1, I { }
    public implicit extension X2 for Underlying : R1, I { }
    public delegate void Delegate(object P);
    namespace Test
    {
        using System;
        using System.Collections;
        public class Список
        {
            public static IEnumerable Power(int number, int exponent)
            {
                Список Список = new Список();
                Список.Main();
                int counter = (0 + 0);
                int אתר = 0;
                while (++counter++ &lt; --exponent--)
                {
                    result = result * number + +number+++++number;
                    yield return result;
                }
            }
            static void Main()
            {
                foreach (int i in Power(2, 8))
                {
                    Console.Write("{0} ", i);
                }
            }
            async void Wait()
            {
                await System.Threading.Tasks.Task.Delay(0);
            }
        }
    }
}

namespace ConsoleApplication1
{
    namespace RecursiveGenericBaseType
    {
        class A&lt;T&gt; : B&lt;A&lt;T&gt;, A&lt;T&gt;&gt; where T : A&lt;T&gt;
        {
            protected virtual A&lt;T&gt; M() { }
            protected abstract B&lt;A&lt;T&gt;, A&lt;T&gt;&gt; N() { }
            static B&lt;A&lt;T&gt;, A&lt;T&gt;&gt; O() { }
        }

        sealed class B&lt;T1, T2&gt; : A&lt;B&lt;T1, T2&gt;&gt;
        {
            protected override A&lt;T&gt; M() { }
            protected sealed override B&lt;A&lt;T&gt;, A&lt;T&gt;&gt; N() { }
            new static A&lt;T&gt; O() { }
        }
    }

    namespace Boo
    {
        public class Bar&lt;T&gt; where T : IComparable
        {
            public T f;
            public class Goo&lt;U&gt; : IEnumerable&lt;T&gt;
            {
                public void Method&lt;K, V&gt;(K k, T t, U u)
                    where K : IList&lt;V&gt;, IList&lt;T&gt;, IList&lt;U&gt;
                    where V : IList&lt;K&gt;
                {
                    A&lt;int&gt; a;
                    M(A&lt;B, C&gt;(5));
                }
            };
        };
    };

    class Test
    {
        void Bar3()
        {
            var x = new Boo.Bar&lt;int&gt;.Goo&lt;object&gt;();
            x.Method&lt;string, string&gt;(" ", 5, new object());

            var q = from i in new int[] { 1, 2, 3, 4 }
                    where i &gt; 5
                    select i;
        }

        public static implicit operator Test(string s)
        {
            return new ConsoleApplication1.Test();
        }
        public static explicit operator Test(string s)
        {
            return new Test();
        }

        public int goo = 5;
        void Bar2()
        {
            goo = 6;
            this.Goo = 5.GetType(); Test t = "sss";
        }

        public event EventHandler MyEvent = delegate { };

        void Blah()
        {
            int i = 5;
            int? j = 6;

            Expression&lt;Func&lt;int&gt;&gt; e = () =&gt; i;
            Expression&lt;Func&lt;bool, Action&gt;&gt; e2 = b =&gt; () =&gt; { return; };
            Func&lt;bool, bool&gt; f = delegate (bool a)
            {
                return !a;
            };
            Func&lt;int, int, int&gt; f2 = (a, b) =&gt; 0;
            f2 = (int a, int b) =&gt; 1;
            Action a = Blah;
            f2 = () =&gt; {};
            f2 = () =&gt; {;};
        }

        delegate Recursive Recursive(Recursive r);
        delegate Recursive Recursive&lt;A,R&gt;(Recursive&lt;A,R&gt; r);

        public Type Goo
        {
            [Obsolete("Name", error = false)]
            get
            {
                var result = typeof(IEnumerable&lt;int&gt;);
                var t = typeof(int?) == typeof(Nullable&lt;int&gt;);
                t = typeof(IEnumerable&lt;int?[][][]&gt;);
                return typeof(IEnumerable&lt;&gt;);
            }
            set
            {
                var t = typeof(System.Int32);
                t.ToString();
                t = value;
            }
        }

        public void Constants()
        {
            int i = 1 + 2 + 3 + 5;
            global::System.String s = "a" + (System.String)"a" + "a" + "a" + "a" + "A";
        }

        public void ConstructedType()
        {
            List&lt;int&gt; i = null;
            int c = i.Count;
        }
    }
}

namespace Comments.XmlComments.UndocumentedKeywords
{
    /// &lt;summary&gt;
    /// Whatever 
    /// &lt;/summary&gt;
    /// &lt;!-- c --&gt;
    /// &lt;![CDATA[c]]&gt; //
    /// &lt;c&gt;&lt;/c&gt; /* */
    /// &lt;code&gt;&lt;/code&gt;
    /// &lt;example&gt;&lt;/example&gt;
    /// &lt;exception cref="bla"&gt;&lt;/exception&gt;
    /// &lt;include file='' path='[@name=""]'/&gt;
    /// &lt;permission cref=" "&gt;&lt;/permission&gt;
    /// &lt;remarks&gt;&lt;/remarks&gt;
    /// &lt;see cref=""/&gt;
    /// &lt;seealso cref=" "/&gt;
    /// &lt;value&gt;&lt;/value&gt;
    /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
    class /*///*/C&lt;T&gt;
    {
        void M&lt;U&gt;(T t, U u)
        {
            // comment
            /* *** / */
            /* //
             */
            /*s*///comment
            // /***/
            /*s*/int /*s*/intValue = 0;
            intValue = intValue /*s*/+ 1;
            string strValue = /*s*/"hello";
            /*s*/MyClass c = new MyClass();
            string verbatimStr = /*s*/@"\\\\";
        }
    }

    //General Test F. Type a very long class name, verify colorization happens correctly only upto the correct size (118324)
    class TestClassXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX/*Scen8*/{ }

    class TestClassXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX22/*Scen9*/{ }

    class yield
    {
        void Goo&lt;U&gt;(__arglist)
        {
            C&lt;U&gt; c = null;
            c.M&lt;int&gt;(5, default(U));
            TypedReference tr = __makeref(c);
            Type t = __reftype(tr);
            int j = __refvalue(tr, int);
            Params(a: t, b: t);
            Params(ref c, out c);
        }
        void Params(ref dynamic a, out dynamic b, params dynamic[] c) {}
        void Params(out dynamic a = 2, ref dynamic c = default(dynamic), params dynamic[][] c) {}

        public override string ToString() { return base.ToString(); } 

        public partial void OnError();

        public partial void method()
        {
            int?[] a = new int?[5];/*[] bug*/ // YES []
            int[] var = { 1, 2, 3, 4, 5 };/*,;*/
            int i = a[i];/*[]*/
            Goo&lt;T&gt; f = new Goo&lt;int&gt;();/*&lt;&gt; ()*/
            f.method();/*().*/
            i = i + i - i * i / i % i &amp; i | i ^ i;/*+ - * / % &amp; | ^*/
            bool b = true &amp; false | true ^ false;/*&amp; | ^*/
            b = !b;/*!*/
            i = ~i;/*~i*/
            b = i &lt; i &amp;&amp; i &gt; i;/*&lt; &amp;&amp; &gt;*/
            int? ii = 5;/*? bug*/ // NO ?
            int f = true ? 1 : 0;/*? :*/   // YES :
            i++;/*++*/
            i--;/*--*/
            b = true &amp;&amp; false || true;/*&amp;&amp; ||*/
            i &lt;&lt; 5;/*&lt;&lt;*/
            i &gt;&gt; 5;/*&gt;&gt;*/
            i &gt;&gt;&gt; 5;/*&gt;&gt;&gt;*/
            b = i == i &amp;&amp; i != i &amp;&amp; i &lt;= i &amp;&amp; i &gt;= i;/*= == &amp;&amp; != &lt;= &gt;=*/
            i += 5.0;/*+=*/
            i -= i;/*-=*/
            i *= i;/**=*/
            i /= i;/*/=*/
            i %= i;/*%=*/
            i &amp;= i;/*&amp;=*/
            i |= i;/*|=*/
            i ^= i;/*^=*/
            i &lt;&lt;= i;/*&lt;&lt;=*/
            i &gt;&gt;= i;/*&gt;&gt;=*/
            i &gt;&gt;&gt;= i;/*&gt;&gt;&gt;=*/
            object s = x =&gt; x + 1;/*=&gt;*/
            var index = ^1;
            var range = 1..2;
            Point point;
            unsafe
            {
                Point* p = &amp;point;/** &amp;*/
                p-&gt;x = 10;/*-&gt;*/
            }
            IO::BinaryReader br = null;
        }

        struct Point { public int X; public int Y; public void ThisAccess() { this = this; } }
    }
}

class RawStringLiterals
{
    public const string SingleLine = """single line""";
    public const string MultiLine = """
                                    Multi line
                                    """;
}

#line 6
#line 2 "test.cs"
#line default
#line hidden
#line (1, 1) - (2, 2) 3 "test.cs"
</value>
  </data>
  <data name="AllInOneVisualBasicBaseline" xml:space="preserve">
    <value>Option Infer On
Option Explicit Off

Imports System
Imports System.Collections.Generic
Imports System.Linq
Imports System.Linq.Expressions
Imports System.Text
Imports M = System.Math
Imports System.Collections
Imports &lt;xmlns:ns="goo"&gt;
Imports &lt;xmlns="goo"&gt;
#Const line = 6
#Const goo = True
#If goo Then
#Else
#End If
' There is no equivalent to #undef in VB.NET:
'#undef goo
'#warning goo
'#error goo
' There is no equivalent to 'extern alias' in VB:
'extern alias Goo;
#If DEBUG OrElse TRACE Then
Imports System.Diagnostics
#ElseIf SILVERLIGHT Then
Imports System.Diagnostics
#Else
Imports System.Diagnostics
#End If
#Region "Region"
#Region "more"
Imports ConsoleApplication2.Test
#End Region
Imports X = int1
Imports X = ABC.X(Of Integer)
Imports A.B

#End Region
&lt;Assembly:System.Copyright("(C) 2009")&gt;
&lt;Module:System.Copyright(vbLf &amp; vbTab &amp; ChrW(&amp;H123).ToString() &amp; "(C) 2009" &amp; ChrW(&amp;H123).ToString())&gt;
Friend Interface CoContra(Of Out T, In K)
End Interface

Public Delegate Sub CoContra2()

Namespace My

    Friend Interface CoContra(Of Out T, In K)
    End Interface

    Friend Delegate Sub CoContra2(Of Out T, In K)()

    Partial Public Class A
        Inherits CSType1
        Implements I

        Shared Sub New()
        End Sub

        &lt;Obsolete()&gt;
        Public Sub New(&lt;Obsolete()&gt; ByVal goo As Integer)
            MyBase.New(1)
L:
            Dim i As Integer = Len(New Integer)
            i += 1
#If DEBUG Then
            Console.WriteLine(export.iefSupplied.command)
#End If
            Const local? As Integer = Integer.MaxValue
            Const local0? As Guid = New Guid(r.ToString())
            'Inserted Compiling code 
            Dim r As Integer
            Dim Varioblelocal? As Integer = Integer.MaxValue
            Dim Varioblelocal0? As Guid = New Guid(r.ToString())
            Dim привет = local
            Dim мир = local
            Dim local3 = 0, local4 = 1
            Dim local5 = If(TryCast(Nothing, Action), Nothing)
            Dim local6 = TypeOf local5 Is Action
            Dim u = 1UI
            Dim U_Renamed = 1UI
            Dim hex As Long = &amp;HBADC0DE, Hex_Renamed As Long = &amp;HDEADBEEFL, l As Long = -1L, L_Renamed As Long = 1L
            Dim ul As ULong = 1UL, Ul_Renamed As ULong = 1UL, uL_Renamed2 As ULong = 1UL, UL_Renamed3 As ULong = 1UL, lu As ULong = 1UL, Lu_Renamed1 As ULong = 1UL, lU_Renamed2 As ULong = 1UL, LU_Renamed3 As ULong = 1UL
            Dim bool As Boolean
            Dim [byte] As Byte
            'ChrW(&amp;H0130), hexchar2 = ChrW(&amp;HBAD)
            'ChrW(&amp;H0066), hexchar = ChrW(&amp;H0130), hexchar2
            '"c"c, \u0066 = ChrW(&amp;H0066), hexchar
            Dim [char] As Char = "c"c ', \u0066
            Dim [decimal] As Decimal = 1.44D
            Dim [dynamic] As Object
            Dim [double] As Double = m.PI
            Dim float As Single
            Dim int As Integer = If(local, -1)
            Dim [long] As Long
            Dim [object] As Object
            Dim [sbyte] As SByte
            Dim [short] As Short
            Dim [string] As String = """/*"
            Dim uint As UInteger
            Dim [ulong] As ULong
            Dim [ushort] As UShort
            Dim dynamic1 = local5
            Dim add = 0
            Dim ascending = 0
            Dim descending = 0
            Dim From = 0
            Dim [get] = 0
            Dim [global] = 0
            Dim group = 0
            Dim into = 0
            Dim join = 0
            Dim [let] = 0
            Dim orderby = 0
            Dim [partial] = 0
            Dim remove = 0
            Dim [select] = 0
            Dim [set] = 0
            Dim value = 0
            Dim var = 0
            Dim where = 0
            Dim yield = 0
            If i &gt; 0 Then
                Return
            ElseIf i = 0 Then
                Throw New Exception()
            End If

            Dim o1 = New MyObject()
            Dim o2 = New MyObject(var)
            Dim o3 = New MyObject With {.A = i}
            Dim o4 = New MyObject(dynamic) With {.A = 0, .B = 0, .C = 0}
            Dim o5 = New With {Key .A = 0}
            Dim a() As Integer = {0, 1, 2, 3, 4, 5}
            Dim a As(named As Integer, Integer) =(named:=1, 2)
            Select Case i
                Case 1
                    GoTo CaseLabel1
                Case 2
CaseLabel1:
                    GoTo CaseLabel2
                    Exit Select
                Case Else
CaseLabel2:
                    Return
            End Select

            Do While i &lt; 10
                i += 1
            Loop

            Do
                i += 1
            Loop While i &lt; 10

            Do
                i += 1
            Loop Until i &gt; 20

            Do
                Exit Do
            Loop

            For j As Integer = 0 To 99
                Console.WriteLine(j)
            Next j

            'Modified to include items
            Dim items = {1, 2, 3, 4, 5, 6, 7, 8}
            For Each i In items
                If i = 7 Then
                    Return
                Else
                    Continue For
                End If
            Next i

            ' There is no equivalent to a 'checked' block in VB.NET
            '			checked
            i += 1
            'Modified use of synclock functions for VB
            Dim sText As String
            Dim objLock As Object = New Object()
            SyncLock objLock
                sText = "Hello"
            End SyncLock

            Using v = BeginScope()
                Using a As New A()
                    Using BeginScope()
                        Return
                    End Using
                End Using
            End Using

            ' VB does not support iterators and has no equivalent to the C# 'yield' keyword:
            'yield Return Me.items(i)
            ' VB does not support iterators and has no equivalent to the C# 'yield' keyword:
            'yield(break)
            ' There is no equivalent to a 'fixed' block in VB.NET
            'Integer* p = Nothing
            Try
                Throw New Exception 'Nothing
            Catch av As System.AccessViolationException
                Throw av
            Catch e1 As Exception
                Throw
            Finally
            End Try

            Dim anonymous = New With {.a = 1, .B = 2, .c = 3}
            Dim qry = From i1 In {1, 2, 3, 4, 5, 6} Where i1 &lt; 5 Select New With {.id = i1}
            Dim query = From c In customers Let d = c Where d IsNot Nothing Join c1 In customers On c1.GetHashCode() Equals c.GetHashCode() Group Join c1 In customers On c1.GetHashCode() Equals c.GetHashCode() Into e() Order By g.Count() Ascending Order By g.Key Descending Select New With {.Country = g.Key, .CustCount = g.Count()}
            'XML Literals
            Dim x = &lt;xmlliteral&gt;&lt;test name="test"/&gt; &lt;test name="test2"&gt;&lt;/test&gt;&lt;/xmlliteral&gt;
            Console.WriteLine(NameOf(Finalize))
        End Sub

        Protected Overrides Sub Finalize()
        End Sub

        Private ReadOnly f1 As Integer

        ' There is no VB.NET equivalent to 'volatile':
        &lt;Obsolete(), NonExisting(), Goo.NonExisting(var, 5), Obsolete(), NonSerialized(), CLSCompliant(True OrElse False And True)&gt;
        Private f2 As Integer

        &lt;Obsolete()&gt;
        Public Sub Handler(ByVal value As Object)
        End Sub

        Public Function m(Of T As {Class, New})(ByVal t1 As T) As Integer
            MyBase.m(t1)
            Return 1
        End Function

        Public Property P() As String
            Get
                Return "A"
            End Get

            Set(ByVal value As String)
            End Set
        End Property

        Public ReadOnly Property p2 As String
            Get
            End Get
        End Property

        Public Property p3 As String

        Default Public Property item(ByVal index As Integer) As Integer
            Protected Get
            End Get

            Set(ByVal value As Integer)
            End Set
        End Property

        &lt;Obsolete(), Obsolete()&gt;
        Public Custom Event E1 As Action
            ' This code will be run when AddHandler MyEvent, D1 is called
            AddHandler(ByVal value As Action)
            End AddHandler

            ' This code will be run when RemoveHandler MyEvent, D1 is called
            RemoveHandler(ByVal value As Action)
            End RemoveHandler

            &lt;Obsolete()&gt;
            RaiseEvent()
            End RaiseEvent
        End Event

        Public Shared Operator +(ByVal first, ByVal second)
            Dim handler As System.Delegate = New [Delegate](AddressOf Me.Handler)
            Return first.Add(second)
        End Operator

        &lt;Obsolete()&gt;
        Public Shared Operator IsTrue(ByVal a As A) As Boolean
            Return True
        End Operator

        Public Shared Operator IsFalse(ByVal a As A) As Boolean
            Return False
        End Operator

        Class c
        End Class

        Public Sub A(ByVal value As Integer) Implements I.A
        End Sub

        Public Property Value As String Implements I.Value
            Get
            End Get

            Set(ByVal value As String)
            End Set
        End Property
    End Class

    Public Structure S
        Implements I

        Private f1 As Integer

        ' There is no VB.NET equivalent to 'volatile':
        ' private volatile int f2;
        &lt;Obsolete()&gt;
        Private f2 As Integer

        Public Function m(Of T As {Structure, New})(ByVal s As T) As Integer
            Return 1
        End Function

        Public Property P1() As String
            Get
                Dim value As Integer = 0
                Return "A"
            End Get

            Set(ByVal value As String)
            End Set
        End Property

        'VB.NET can't support abstract member variable
        Public ReadOnly Property P2() As String
            Get
            End Get
        End Property

        Public Property p3 As String '//Auto Property

        Default Public Property item(ByVal index As Integer) As Integer
            Get
            End Get

            Friend Set(ByVal value As Integer)
            End Set
        End Property

        Public Event E()

        Public Shared Operator +(ByVal first, ByVal second)
            Return first.Add(second)
        'fixed Integer field(10)
        End Operator

        Class c
        End Class

        Public Sub A(ByVal value As Integer) Implements I.A
        End Sub

        Public Property Value As String Implements I.Value
            Get
            End Get

            Set(ByVal value As String)
            End Set
        End Property
    End Structure

    Public Interface I

        Sub A(ByVal value As Integer)

        Property Value() As String

    End Interface

    &lt;Flags()&gt;
    Public Enum E
        A
        B = A
        C = 2 + A
#If DEBUG Then
        D
#End If
    End Enum

    Public Delegate Sub [Delegate](ByVal P As Object)

    Namespace Test

        Public Class Список

            Public Shared Function Power(ByVal number As Integer, ByVal exponent As Integer) As IEnumerable
                Dim Список As New Список()
                Список.Main()
                Dim counter As Integer =(0 + 0)
                Dim result As Integer = 0
            'Do While ++counter++ &lt; --exponent--
            '                         result = result * number + +number + ++++number
            '                ' VB does not support iterators and has no equivalent to the C# 'yield' keyword:
            '                'yield Return result
            '            Loop
            End Function

            Shared Sub Main()
                For Each i As Integer In Power(2, 8)
                    Console.Write("{0} ", i)
                Next i
            End Sub

            Async Sub Wait()
                Await System.Threading.Tasks.Task.Delay(0)
            End Sub
        End Class
    End Namespace
End Namespace

Namespace ConsoleApplication1
    Namespace RecursiveGenericBaseType

        MustInherit Class A(Of T)
            Inherits B(Of A(Of T), A(Of T))

            Protected Overridable Function M() As A(Of T)
            End Function

            Protected MustOverride Function N() As B(Of A(Of T), A(Of T))

            Shared Function O() As B(Of A(Of T), A(Of T))
            End Function
        End Class

        Class B(Of T1, T2)
            Inherits A(Of B(Of T1, T2))

            Protected Overrides Function M() As A(Of T)
            End Function

            Protected NotOverridable Overrides Function N() As B(Of A(Of T), A(Of T))
            End Function

            Shared Shadows Function O() As A(Of T)
            End Function
        End Class
    End Namespace
End Namespace

Namespace Boo

    Public Class Bar(Of T As IComparable)

        Public f As T

        Public Class Goo(Of U)
            Implements IEnumerator(Of T)

            Public Sub Method(Of K As {IList(Of V), IList(Of T), IList(Of U)}, V As IList(Of K))(ByVal k1 As K, ByVal t1 As T, ByVal u1 As U)
                Dim a As A(Of Integer)
            End Sub

            Public ReadOnly Property Current As T Implements System.Collections.Generic.IEnumerator(Of T).Current
                Get
                End Get
            End Property

            Public ReadOnly Property Current1 As Object Implements System.Collections.IEnumerator.Current
                Get
                End Get
            End Property

            Public Function MoveNext() As Boolean Implements System.Collections.IEnumerator.MoveNext
            End Function

            Public Sub Reset() Implements System.Collections.IEnumerator.Reset
            End Sub

#Region "IDisposable Support"
            Private disposedValue As Boolean ' To detect redundant calls

            ' IDisposable
            Protected Overridable Sub Dispose(ByVal disposing As Boolean)
                If Not Me.disposedValue Then
                    If disposing Then
                    End If
                End If

                Me.disposedValue = True
            End Sub

            Public Sub Dispose() Implements IDisposable.Dispose
                Dispose(True)
                GC.SuppressFinalize(Me)
            End Sub
#End Region
        End Class
    End Class
End Namespace

Friend Class Test2

    Private Sub Bar3()
        Dim x = New Boo.Bar(Of Integer).Goo(Of Object)()
        x.Method(Of String, String)(" ", 5, New Object())
        Dim q = From i In New Integer() {1, 2, 3, 4} Where i &gt; 5 Select i
    End Sub

    Public Shared Widening Operator CType(ByVal s As String) As Test2
        Return New Test2()
    End Operator

    Public Shared Narrowing Operator CType(ByVal s As Integer) As Test2
        Return New Test2()
    End Operator

    Public goo As Integer = 5

    Private Sub Bar2()
        goo = 6
        Me.goo = 5.GetType()
        Dim t As Test2 = "sss"
    End Sub

    Private Sub Blah()
        Dim i As Integer = 5
        Dim j? As Integer = 6
        Dim e As Expression(Of Func(Of Integer)) = Function() i
    End Sub

    Public Property FGoo() As Type
        Get
            Return GetType(System.Int32)
        End Get

        Set(ByVal value As Type)
            Dim t = GetType(System.Int32)
            t.ToString()
            t = value
        End Set
    End Property

    Public Sub Constants()
        Dim i As Integer = 1 + 2 + 3 + 5
        Dim s As Global.System.String = "a" &amp; CStr("a") &amp; "a" &amp; "a" &amp; "a" &amp; "A"
    End Sub

    Public Sub ConstructedType()
        Dim i As List(Of Integer) = Nothing
        Dim c As Integer = i.Count
    End Sub
End Class

Namespace Comments.XmlComments.UndocumentedKeywords

    ''' &lt;summary&gt;
    ''' Whatever 
    ''' &lt;/summary&gt;
    ''' &lt;!-- c --&gt; 
    ''' &lt;![CDATA[c]]&gt;  //
    ''' &lt;c&gt;&lt;/c&gt; /* */
    ''' &lt;code&gt;&lt;/code&gt;
    ''' &lt;example&gt;&lt;/example&gt;
    ''' &lt;exception cref="bla"&gt;&lt;/exception&gt;
    ''' &lt;include file=''path='[@name=""]'/&gt; 
    ''' &lt;permission cref=" "&gt;&lt;/permission&gt;
    ''' &lt;remarks&gt;&lt;/remarks&gt;
    ''' &lt;see cref=""/&gt; 
    ''' &lt;seealso cref=" "/&gt; 
    ''' &lt;value&gt;&lt;/value&gt;
    ''' &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
    Class c(Of T)

        Sub M(Of U)(ByVal T1 As T, ByVal U1 As U)
            Dim intValue As Integer = 0
            intValue = intValue + 1
            Dim strValue As String = "hello" 's
            Dim c As New [MyClass]()
            Dim verbatimStr As String = "@ \\\\" 's
        End Sub
    End Class
End Namespace

Friend Class TestClassXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 'Scen8
End Class

Friend Class TestClass1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX22 'Scen9
End Class

Friend Class yield

    ''INSTANT VB TODO TASK: There is no equivalent to the undocumented C# '__arglist' keyword in VB:
    'Private Sub Goo(Of U)(ByVal __arglist)
    '    Dim c1 As C(Of U) = Nothing
    '    c1.M(Of Integer)(5, Nothing)
    '    Dim tr As TypedReference = __makeref(c1)
    '    Dim t As Type = __reftype(tr)
    '    	Dim j As Integer = __refvalue(tr, Integer)
    '    Params(a:=t, b:=t)
    'End Sub
    Private Sub Params(ByRef a As Object, &lt;System.Runtime.InteropServices.Out()&gt; ByRef b As Object, ByVal ParamArray c() As Object)
    End Sub

    'Private Sub Params(Optional &lt;System.Runtime.InteropServices.Out()&gt; ByRef a As dynamic = 2, Optional ByRef c As dynamic = Nothing, ParamArray ByVal c()() As dynamic)
    'End Sub
    Public Overrides Function ToString() As String
        Return MyBase.ToString()
    End Function

    Public Sub method()
        Dim a?(4) As Integer '[] bug
        ' YES []
        Dim var() As Integer = {1, 2, 3, 4, 5} ',;
        Dim i As Integer = a(i) '[]
        Dim f As New Goo(Of T)() '&lt;&gt; ()
        f.method()
        i = i + i - i * i \ i Mod i And i Or i Xor i '+ - * / % &amp; | ^
        Dim b As Boolean = True And False Or True Xor False '&amp; | ^
        b = Not b '!
        i = Not i '~i
        b = i &lt; i AndAlso i &gt; i '&lt; &amp;&amp; &gt;
        Dim ii? As Integer = 5 '? bug
        ' NO ?
        Dim f1 As Integer = If(True, 1, 0) '? :
        ' YES :
        i += 1 '++
        i -= 1 '--
        b = True AndAlso False OrElse True '&amp;&amp; ||
        i = i &lt;&lt; 5 '&lt;&lt;
        i = i &gt;&gt; 5 '&gt;&gt;
        b = i = i AndAlso i &lt;&gt; i AndAlso i &lt;= i AndAlso i &gt;= i '= == &amp;&amp; != &lt;= &gt;=
        i += 5.0 '+=
        i -= i '-=
        i *= i '*=
        i \= i '/
        '=
        i = i Mod i '%=
        i = i And i '&amp;=
        i = i Or i '|=
        i = i Xor i '^=
        i &lt;&lt;= i '&lt;&lt;=
        i &gt;&gt;= i '&gt;&gt;=
        Dim s As Object = Function(x) x + 1 '=&gt;
        ' There is no equivalent to an 'unsafe' block in VB.NET
        '			unsafe
        '		Point* p = &amp;point '* &amp;
        '			p-&gt;x = 10 '-&gt;
        Dim p As Point
        p.X = 10
        p.Y = 12
        Dim p2 As New Point With {.X = 10, .Y = 12}
        Dim br As IO.BinaryReader = Nothing
    End Sub

    Friend Structure Point

        Public X As Integer

        Public Y As Integer
    End Structure
End Class

'Extension Method
Module Module1

    &lt;Runtime.CompilerServices.Extension()&gt;
    Function GooExtension(ByVal x As String) As String
        Return x &amp; "test"
    End Function

    &lt;Runtime.CompilerServices.Extension()&gt;
    Function GooExtension(ByVal x As String, ByVal y As Integer) As String
        'With Implicit Line Continuation
        Return x &amp; "test2"
    End Function

    Sub Goo()
        'Collections
        Dim i As New List(Of String) From {"test", "item"}
        Dim i1 As New Dictionary(Of Integer, String) From {{1, "test"}, {2, "item"}}
        'Arrays
        Dim ia1 = {1, 2, 3, 4, 5}
        Dim la2 = {1, 2L, 3, 4S, 5}
        Console.Write(GetXmlNamespace(ns))
        Dim ia3 As Integer() = {1, 2, 3, 4, 5}
        Dim ia4() As Integer = {1, 2, 3, 4, 5}
        Dim ia5 = New Integer() {1, 2, 3, 4, 5}
        Dim ia6 = {{1, 2}, {3, 4}, {5, 6}} '2d array
        Dim ia7 = {({1}), ({3, 4}), ({5, 6, 2})} 'jagged array
        'Standalone
        If {1, 2, 3}.Count = 2 Then
        ElseIf {1, 2, 3}.Count = 3 Then
        Else
        End If
    End Sub
End Module

#Region "Events"
Public Delegate Sub MyDelegate(ByVal message As String)

Class MyClass1

    Custom Event MyEvent As MyDelegate
        ' This code will be run when AddHandler MyEvent, D1
        ' is called
        AddHandler(ByVal value As MyDelegate)
            Console.WriteLine("Adding Handler for MyEvent")
            MyEventHandler = value
        End AddHandler

        ' This code will be run when RemoveHandler MyEvent, D1
        ' is called
        RemoveHandler(ByVal value As MyDelegate)
            Console.WriteLine("Removing Handler for MyEvent")
            MyEventHandler = Nothing
        End RemoveHandler

        ' This code will be run when RaiseEvent MyEvent(string)
        ' is called
        RaiseEvent(ByVal message As String)
            If Not MyEventHandler Is Nothing Then
                MyEventHandler.Invoke(message)
            Else
                Console.WriteLine("No Handler for Raised MyEvent")
            End If
        End RaiseEvent
    End Event

    Public MyEventHandler As MyDelegate

    Public Sub Raise_Event()
        RaiseEvent MyEvent("MyEvent Was Raised")
    End Sub
End Class

Module DelegateModule

    Dim Var1 As MyClass1

    Dim D1 As MyDelegate

    Sub EventsMain()
        Var1 = New MyClass1
        D1 = New MyDelegate(AddressOf MyHandler)
        AddHandler Var1.MyEvent, D1
        Var1.Raise_Event()
        RemoveHandler Var1.MyEvent, D1
    End Sub

    Sub MyHandler(ByVal message As String)
        Console.WriteLine("Event Handled: " &amp; message)
    End Sub
End Module

#End Region
#Region "Linq"
Module LINQQueries

    Sub Join()
        Dim categories() = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}
        Dim productList = {New With {.category = "Condiments", .name = "Ketchup"}, New With {.category = "Seafood", .name = "Code"}}
        Dim query = From c In categories Group Join p In productList On c Equals p.category Into Group From p In Group Select Category = c, p.name
        For Each v In query
            Console.WriteLine(v.name + ": " + v.Category)
        Next
    End Sub
End Module

#End Region
#Region "Lambda's"
Module Lambdas

    Dim l1 = Sub()
        Console.WriteLine("Sub Statement")
    End Sub

    Dim L2 = Sub() Console.WriteLine("Sub Statement 2")

    Dim L3 = Function(x As Integer) x Mod 2

    Dim L4 = Function(y As Integer) As Boolean
        If y * 2 &lt; 10 Then
            Return True
        Else
            Return False
        End If
    End Function
End Module

#End Region
#Region "Co Contra Variance"
Public Class Cheetah
End Class

Public Class Animals
End Class

Public Interface IVariance(Of In T)

    Sub Goo(ByVal a As T)

    Property InterProperty() As IVariance(Of Cheetah)

    Property InterProperty2() As IVariance(Of Animals)

End Interface

Delegate Sub Func(Of In T)(ByVal a As T)

Public Delegate Function Func2(Of Out T)() As T

Public Interface IVariance2(Of Out T)

    Function Goo() As T

End Interface

Public Class Variance2(Of T As New) : Implements IVariance2(Of T)

    Dim type As IVariance2(Of Animals)

    Private Function Goo() As T Implements IVariance2(Of T).Goo
        Return New T
    End Function

    Function Goo(ByVal arg As IVariance2(Of T)) As String
        Return arg.GetType.ToString
    End Function

    Function Goo(ByVal arg As Func2(Of T)) As String
        Return arg.Invoke().GetType.ToString
    End Function
End Class

#End Region
Module Mod1Orcas

    Dim AT1 = New With {Key .prop1 = 1}

    Dim AT2 = New With {.prop1 = 7}

    Dim b_false As Boolean = False

    Dim n_false = False

    Dim i = If(b_false And n_false, 1, 2)

    Dim s1 = &lt;xml_literal&gt;&lt;%= If(Nothing, Nothing) %&gt;&lt;/xml_literal&gt;

    Delegate Sub delfoo()

    Delegate Sub delfoo1(ByVal sender As Object, ByVal e As System.EventArgs)

    Sub Goo()
    End Sub

    Sub Method1(ByVal sender As Object, ByVal e As System.EventArgs)
    End Sub

    Sub Method1a()
    End Sub

    Sub AssignDelegate()
        Dim d As delfoo = AddressOf Goo
        d.Invoke()
        Dim d1_1 As delfoo1 = AddressOf Method1
        Dim d1_1a As delfoo1 = AddressOf Method1a 'Relaxed Delegate
        'Nullable
        Dim Value1a As Integer? = 10
        Dim Value1b As Integer = 1
        Dim Value1c? As Integer = 1
        Dim Value1c? As Integer? = 1
        Dim TestReturnValue = Value1a * Value1b
        If Value1a / Value1b &gt; 0 Then
        End If

        Dim sNone = "None"
        Dim SSystemOnly = "SystemOnly"
        Dim XMLLiteral = &lt;?xml version ="1.0"encoding ="utf-8"?&gt; &lt;Details&gt;&lt;FileImports&gt;&lt;FileImport name=&lt;%= sNone %&gt;&gt;&lt;/FileImport&gt;&lt;FileImport name=&lt;%= SSystemOnly %&gt;&gt;
        Imports System
      &lt;/FileImport&gt;&lt;FileImport name="Default"&gt;
        Imports System
        Imports System.Collections
      &lt;/FileImport&gt;&lt;/FileImports&gt;&lt;CodeConstructs&gt;&lt;!-- Type Constructs--&gt; &lt;Construct name="Module"allowcodeblock="false"allowOuter="true"group="Type"allownesting="true"isnestable="false"allowsoverload="false"&gt;&lt;Start&gt;public Module {Identifier}&lt;/Start&gt;&lt;End&gt;End Module &lt;/End&gt;&lt;DefaultIdent&gt;Module_&lt;/DefaultIdent&gt;&lt;/Construct&gt;&lt;Construct name="Class"allowcodeblock="false"allowOuter="true"group="Type"allownesting="true"isnestable="true"allowsoverload="false"&gt;&lt;Start&gt;public class {Identifier}&lt;/Start&gt;&lt;End&gt;End Class&lt;/End&gt;&lt;DefaultIdent&gt;Class_&lt;/DefaultIdent&gt;&lt;/Construct&gt;&lt;Construct name="Structure"allowcodeblock="false"allowOuter="true"group="Type"allownesting="true"isnestable="true"allowsoverload="false"&gt;&lt;Start&gt;public class {Identifier}&lt;/Start&gt;&lt;End&gt;End Class&lt;/End&gt;&lt;DefaultIdent&gt;Struct_&lt;/DefaultIdent&gt;&lt;/Construct&gt;&lt;/CodeConstructs&gt;&lt;CodeBlocks&gt;&lt;Block name="CodeBlock0.txt"statements="1"&gt;&lt;![CDATA[ Dim &lt;{x0}&gt; = Microsoft.VisualBasic.FileSystem.Dir(".") ]]&gt;&lt;/Block&gt;&lt;Block name="CodeBlock1.txt"statements="1"&gt;&lt;![CDATA[ Dim &lt;{x0}&gt; = 1 ]]&gt;&lt;/Block&gt;&lt;Block name="CodeBlock2.txt"statements="1"&gt;&lt;![CDATA[ Dim &lt;{x0}&gt; as string = "2" ]]&gt;&lt;/Block&gt;&lt;/CodeBlocks&gt;&lt;/Details&gt;
        Dim x = &lt;![CDATA[ Dim &lt;{x0}&gt; as string = "2" ]]&gt;
        Dim y = &lt;!-- --&gt; : Call &lt;?a ?&gt;() : Dim x = &lt;e/&gt;
    End Sub
End Module

Class Customer

    Public Property name As String = "Default"

    Public AGe As Integer

    Public Position As String

    Public Level As Integer = 0

    Public Property age2 As Integer
End Class

Class Goo

    Structure Bar

        Dim x As Integer

        Sub LoopingMethod()
            For i = 1 To 20 Step 1
            Next i

            For Each a In {1, 2, 3, 4}
            Next

            Dim icount As Integer
            Do While icount &lt;= 10
                icount += 1
            Loop

            icount = 0
            While icount &lt;= 100
                icount += 1
            End While

            icount = 0
            Do Until icount &gt;= 10
                icount += 2
            Loop
        End Sub
    End Structure
End Class

Class GooGen(Of t)

    Structure BarGen(Of u)

        Dim x As t

        Dim z As u

        Sub SelectionMethods()
            Dim icount As Integer = 1L
            If icount = 1 Then
            ElseIf icount &gt; 1 Then
            Else
            End If

            Select Case icount
                Case 1
                Case 2, 3
                Case Is &gt; 3
                Case Else
            End Select
        End Sub

        Sub Operators()
            Dim a As Boolean = True
            Dim b As Boolean = False
            If a And b Then
            End If

            If a Or b Then
            End If

            If Not a And b Then
            End If

            If a = b AndAlso b = True Then
            End If

            If a = b OrElse b = False Then
            End If

            If(a Or b) OrElse b = True Then
            End If
        End Sub

        Sub Method1()
            Dim x As New Customer With {.name = "Test", .AGe = 30, .Level = 1, .Position = "SDET"}
            Dim x2 As New Customer With {.name = "Test", .AGe = 30, .Level = 1, .Position = "SDET", .age2 =.AGe}
        End Sub
    End Structure
End Class

Public Class Bar
End Class

Public Class ClsPPMTest003

    Partial Private Sub Goo3()
    End Sub
End Class

Partial Public Class ClsPPMTest003

    Private Sub Goo3()
    End Sub

    Public Sub CallGooFromClass()
        Me.Goo3()
        Dim x1 As New Goo
        Dim y1 As New Bar
        If x1 Is y1 Then
        Else
            Console.WriteLine("Expected Result Occurred")
        End If

        If x1 IsNot y1 Then
        Else
            Console.WriteLine("Expected Result Occurred")
        End If
    End Sub

    Sub InterpolatedString()
        Dim s = $"The current date = {Date.Today,10:yyyy-MM-dd}."
    End Sub
End Class
</value>
  </data>
  <data name="AllInOneVisualBasicCode" xml:space="preserve">
    <value>Option Infer On
Option Explicit Off

Imports System
Imports System.Collections.Generic
Imports System.Linq
Imports System.Linq.Expressions
Imports System.Text
Imports M = System.Math
Imports System.Collections
Imports &lt;xmlns:ns="goo"&gt;
Imports &lt;xmlns="goo"&gt;

#Const line = 6
#Const goo = True
#If goo Then
#Else
#End If
' There is no equivalent to #undef in VB.NET:
'#undef goo
'#warning goo
'#error goo
' There is no equivalent to 'extern alias' in VB:
'extern alias Goo;

#If DEBUG OrElse TRACE Then
Imports System.Diagnostics
#ElseIf SILVERLIGHT Then
Imports System.Diagnostics
#Else
Imports System.Diagnostics
#End If

#Region "Region"
#Region "more"
Imports ConsoleApplication2.Test
#End Region
Imports X = int1
Imports X = ABC.X(Of Integer)
Imports A.B

#End Region
&lt;Assembly: System.Copyright("(C) 2009")&gt; 
&lt;Module: System.Copyright(vbLf &amp; vbTab &amp; ChrW(&amp;H123).ToString() &amp; "(C) 2009" &amp; ChrW(&amp;H123).ToString())&gt; 
Friend Interface CoContra(Of Out T, In K)
End Interface
Public Delegate Sub CoContra2()

Namespace My

    Friend Interface CoContra(Of Out T, In K)
    End Interface
    Friend Delegate Sub CoContra2(Of Out T, In K)()


    Partial Public Class A
        Inherits CSType1
        Implements I

        Shared Sub New()
        End Sub
      
        &lt;Obsolete()&gt;
        Public Sub New(&lt;Obsolete()&gt; ByVal goo As Integer)
            MyBase.New(1)
L:
            Dim i As Integer = Len(New Integer)
            i += 1

#If DEBUG Then
            Console.WriteLine(export.iefSupplied.command)
#End If
            Const local? As Integer = Integer.MaxValue
            Const local0? As Guid = New Guid(r.ToString())

            'Inserted Compiling code 
            Dim r As Integer
            Dim Varioblelocal? As Integer = Integer.MaxValue
            Dim Varioblelocal0? As Guid = New Guid(r.ToString())

            Dim привет = local
            Dim мир = local
            Dim local3 = 0, local4 = 1
            Dim local5 = If(TryCast(Nothing, Action), Nothing)
            Dim local6 = TypeOf local5 Is Action

            Dim u = 1UI

            Dim U_Renamed = 1UI

            Dim hex As Long = &amp;HBADC0DE, Hex_Renamed As Long = &amp;HDEADBEEFL, l As Long = -1L, L_Renamed As Long = 1L

            Dim ul As ULong = 1UL, Ul_Renamed As ULong = 1UL, uL_Renamed2 As ULong = 1UL, UL_Renamed3 As ULong = 1UL, lu As ULong = 1UL, Lu_Renamed1 As ULong = 1UL, lU_Renamed2 As ULong = 1UL, LU_Renamed3 As ULong = 1UL

            Dim bool As Boolean
            Dim [byte] As Byte
            'ChrW(&amp;H0130), hexchar2 = ChrW(&amp;HBAD)
            'ChrW(&amp;H0066), hexchar = ChrW(&amp;H0130), hexchar2
            '"c"c, \u0066 = ChrW(&amp;H0066), hexchar
            Dim [char] As Char = "c"c ', \u0066
            Dim [decimal] As Decimal = 1.44D

            Dim [dynamic] As Object
            Dim [double] As Double = m.PI
            Dim float As Single
            Dim int As Integer = If(local, -1)
            Dim [long] As Long
            Dim [object] As Object
            Dim [sbyte] As SByte
            Dim [short] As Short
            Dim [string] As String = """/*"
            Dim uint As UInteger
            Dim [ulong] As ULong
            Dim [ushort] As UShort


            Dim dynamic1 = local5
            Dim add = 0
            Dim ascending = 0
            Dim descending = 0
            Dim From = 0
            Dim [get] = 0
            Dim [global] = 0
            Dim group = 0
            Dim into = 0
            Dim join = 0
            Dim [let] = 0
            Dim orderby = 0
            Dim [partial] = 0
            Dim remove = 0
            Dim [select] = 0
            Dim [set] = 0
            Dim value = 0
            Dim var = 0
            Dim where = 0
            Dim yield = 0

            If i &gt; 0 Then
                Return
            ElseIf i = 0 Then
                Throw New Exception()
            End If
            Dim o1 = New MyObject()
            Dim o2 = New MyObject(var)
            Dim o3 = New MyObject With {.A = i}
            Dim o4 = New MyObject(dynamic) With {.A = 0, .B = 0, .C = 0}
            Dim o5 = New With {Key .A = 0}
            Dim a() As Integer = {0, 1, 2, 3, 4, 5}
            Dim a As(named As Integer, Integer) =(named:=1, 2)
            Select Case i
                Case 1
                    GoTo CaseLabel1
                Case 2
CaseLabel1:
                    GoTo CaseLabel2
                    Exit Select
                Case Else
CaseLabel2:
                    Return
            End Select
            Do While i &lt; 10
                i += 1
            Loop
            Do
                i += 1
            Loop While i &lt; 10
            
            Do
                i += 1
            Loop Until i &gt; 20

            Do
                Exit Do
            Loop

            For j As Integer = 0 To 99
                Console.WriteLine(j)
            Next j

            'Modified to include items
            Dim items = {1, 2, 3, 4, 5, 6, 7, 8}
            For Each i In items
                If i = 7 Then
                    Return
                Else
                    Continue For
                End If
            Next i

            ' There is no equivalent to a 'checked' block in VB.NET
            '			checked
            i += 1

            'Modified use of synclock functions for VB
            Dim sText As String
            Dim objLock As Object = New Object()
            SyncLock objLock
                sText = "Hello"
            End SyncLock

            Using v = BeginScope()
                Using a As New A()
                    Using BeginScope()
                        Return
                    End Using
                End Using
            End Using

            ' VB does not support iterators and has no equivalent to the C# 'yield' keyword:
            'yield Return Me.items(i)
            ' VB does not support iterators and has no equivalent to the C# 'yield' keyword:
            'yield(break)
            ' There is no equivalent to a 'fixed' block in VB.NET
            'Integer* p = Nothing

            Try
                Throw New Exception 'Nothing
            Catch av As System.AccessViolationException
                Throw av
            Catch e1 As Exception
                Throw
            Finally
            End Try

            Dim anonymous = New With {.a = 1, .B = 2, .c = 3}

            Dim qry = From i1 In {1, 2, 3, 4, 5, 6}
                      Where i1 &lt; 5
                      Select New With {.id = i1}


            Dim query = From c In customers _
                            Let d = c _
                            Where d IsNot Nothing _
                            Join c1 In customers On c1.GetHashCode() Equals c.GetHashCode() _
                            Group Join c1 In customers On c1.GetHashCode() Equals c.GetHashCode()
                            Into e() _
                            Order By g.Count() Ascending _
                            Order By g.Key Descending _
                            Select New With {.Country = g.Key, .CustCount = g.Count()}


            'XML Literals
            Dim x = &lt;xmlliteral&gt;
                        &lt;test name="test"/&gt;
                        &lt;test name="test2"&gt;&lt;/test&gt;
                    &lt;/xmlliteral&gt;
            Console.WriteLine(NameOf(Finalize))
        End Sub

        Protected Overrides Sub Finalize()
        End Sub
        Private ReadOnly f1 As Integer
        ' There is no VB.NET equivalent to 'volatile':

        &lt;Obsolete(), NonExisting(), Goo.NonExisting(var, 5), Obsolete(), NonSerialized(), CLSCompliant(True OrElse False And True)&gt;
        Private f2 As Integer

        &lt;Obsolete()&gt;
        Public Sub Handler(ByVal value As Object)
        End Sub

        Public Function m(Of T As {Class, New})(ByVal t1 As T) As Integer
            MyBase.m(t1)
            Return 1
        End Function
        Public Property P() As String
            Get
                Return "A"
            End Get
            Set(ByVal value As String)
            End Set
        End Property

        Public ReadOnly Property p2 As String
            Get
            End Get
        End Property

        Public Property p3 As String

        Default Public Property item(ByVal index As Integer) As Integer
            Protected Get
            End Get
            Set(ByVal value As Integer)
            End Set
        End Property

        &lt;Obsolete(), Obsolete()&gt;
        Public Custom Event E1 As Action
            ' This code will be run when AddHandler MyEvent, D1 is called
            AddHandler(ByVal value As Action)
            End AddHandler

            ' This code will be run when RemoveHandler MyEvent, D1 is called
            RemoveHandler(ByVal value As Action)
            End RemoveHandler

            &lt;Obsolete()&gt; RaiseEvent()
            End RaiseEvent
        End Event


        Public Shared Operator +(ByVal first, ByVal second)
            Dim handler As System.Delegate = New [Delegate](AddressOf Me.Handler)
            Return first.Add(second)
        End Operator

        &lt;Obsolete()&gt;
        Public Shared Operator IsTrue(ByVal a As A) As Boolean
            Return True
        End Operator
        Public Shared Operator IsFalse(ByVal a As A) As Boolean
            Return False
        End Operator

        Class c
        End Class

        Public Sub A(ByVal value As Integer) Implements I.A

        End Sub

        Public Property Value As String Implements I.Value
            Get

            End Get
            Set(ByVal value As String)

            End Set
        End Property
    End Class

    Public Structure S
        Implements I

        Private f1 As Integer
        ' There is no VB.NET equivalent to 'volatile':
        ' private volatile int f2;

        &lt;Obsolete()&gt; Private f2 As Integer

        Public Function m(Of T As {Structure, New})(ByVal s As T) As Integer
            Return 1
        End Function

        Public Property P1() As String
            Get
                Dim value As Integer = 0
                Return "A"
            End Get
            Set(ByVal value As String)
            End Set
        End Property

        'VB.NET can't support abstract member variable
        Public ReadOnly Property P2() As String
            Get
            End Get
        End Property

        Public Property p3 As String '//Auto Property

        Default Public Property item(ByVal index As Integer) As Integer
            Get
            End Get
            Friend Set(ByVal value As Integer)
            End Set
        End Property


        Public Event E()

        Public Shared Operator +(ByVal first, ByVal second)
            Return first.Add(second)
            'fixed Integer field(10)
        End Operator

        Class c
        End Class

        Public Sub A(ByVal value As Integer) Implements I.A

        End Sub

        Public Property Value As String Implements I.Value
            Get

            End Get
            Set(ByVal value As String)

            End Set
        End Property
    End Structure
    Public Interface I
        Sub A(ByVal value As Integer)
        Property Value() As String
    End Interface
    &lt;Flags()&gt;
    Public Enum E
        A
        B = A
        C = 2 + A

#If DEBUG Then
        D
#End If

    End Enum
    Public Delegate Sub [Delegate](ByVal P As Object)

    Namespace Test
        Public Class Список
            Public Shared Function Power(ByVal number As Integer, ByVal exponent As Integer) As IEnumerable
                Dim Список As New Список()
                Список.Main()
                Dim counter As Integer = (0 + 0)
                Dim result As Integer = 0

                'Do While ++counter++ &lt; --exponent--
                '                         result = result * number + +number + ++++number
                '                ' VB does not support iterators and has no equivalent to the C# 'yield' keyword:
                '                'yield Return result
                '            Loop
            End Function
            Shared Sub Main()
                For Each i As Integer In Power(2, 8)
                    Console.Write("{0} ", i)
                Next i
            End Sub
            Async Sub Wait()
                Await System.Threading.Tasks.Task.Delay(0)
            End Sub
        End Class
    End Namespace
End Namespace

Namespace ConsoleApplication1
    Namespace RecursiveGenericBaseType
        MustInherit Class A(Of T)
            Inherits B(Of A(Of T), A(Of T))

            Protected Overridable Function M() As A(Of T)
            End Function

            Protected MustOverride Function N() As B(Of A(Of T), A(Of T))

            Shared Function O() As B(Of A(Of T), A(Of T))
            End Function
        End Class

        Class B(Of T1, T2)
            Inherits A(Of B(Of T1, T2))

            Protected Overrides Function M() As A(Of T)
            End Function
            Protected NotOverridable Overrides Function N() As B(Of A(Of T), A(Of T))
            End Function
            Shared Shadows Function O() As A(Of T)
            End Function
        End Class
    End Namespace
End Namespace

Namespace Boo
    Public Class Bar(Of T As IComparable)
        Public f As T

        Public Class Goo(Of U)
            Implements IEnumerator(Of T)

            Public Sub Method(Of K As {IList(Of V), IList(Of T), IList(Of U)}, V As IList(Of K))(ByVal k1 As K, ByVal t1 As T, ByVal u1 As U)
                Dim a As A(Of Integer)
            End Sub

            Public ReadOnly Property Current As T Implements System.Collections.Generic.IEnumerator(Of T).Current
                Get

                End Get
            End Property

            Public ReadOnly Property Current1 As Object Implements System.Collections.IEnumerator.Current
                Get

                End Get
            End Property

            Public Function MoveNext() As Boolean Implements System.Collections.IEnumerator.MoveNext

            End Function

            Public Sub Reset() Implements System.Collections.IEnumerator.Reset

            End Sub

#Region "IDisposable Support"
            Private disposedValue As Boolean ' To detect redundant calls

            ' IDisposable
            Protected Overridable Sub Dispose(ByVal disposing As Boolean)
                If Not Me.disposedValue Then
                    If disposing Then

                    End If


                End If
                Me.disposedValue = True
            End Sub

            Public Sub Dispose() Implements IDisposable.Dispose
                Dispose(True)
                GC.SuppressFinalize(Me)
            End Sub
#End Region

        End Class
    End Class
End Namespace

Friend Class Test2
    Private Sub Bar3()
        Dim x = New Boo.Bar(Of Integer).Goo(Of Object)()
        x.Method(Of String, String)(" ", 5, New Object())

        Dim q = From i In New Integer() {1, 2, 3, 4}
                Where i &gt; 5
                Select i
    End Sub

    Public Shared Widening Operator CType(ByVal s As String) As Test2
        Return New Test2()
    End Operator

    Public Shared Narrowing Operator CType(ByVal s As Integer) As Test2
        Return New Test2()
    End Operator

    Public goo As Integer = 5
    Private Sub Bar2()
        goo = 6
        Me.goo = 5.GetType()
        Dim t As Test2 = "sss"
    End Sub
    Private Sub Blah()
        Dim i As Integer = 5
        Dim j? As Integer = 6

        Dim e As Expression(Of Func(Of Integer)) = Function() i
    End Sub

    Public Property FGoo() As Type
        Get
            Return GetType(System.Int32)
        End Get
        Set(ByVal value As Type)
            Dim t = GetType(System.Int32)
            t.ToString()
            t = value
        End Set
    End Property
    Public Sub Constants()
        Dim i As Integer = 1 + 2 + 3 + 5
        Dim s As Global.System.String = "a" &amp; CStr("a") &amp; "a" &amp; "a" &amp; "a" &amp; "A"
    End Sub

    Public Sub ConstructedType()
        Dim i As List(Of Integer) = Nothing
        Dim c As Integer = i.Count
    End Sub
End Class
Namespace Comments.XmlComments.UndocumentedKeywords
    ''' &lt;summary&gt;
    ''' Whatever 
    ''' &lt;/summary&gt;
    ''' &lt;!-- c --&gt;
    ''' &lt;![CDATA[c]]&gt; //
    ''' &lt;c&gt;&lt;/c&gt; /* */
    ''' &lt;code&gt;&lt;/code&gt;
    ''' &lt;example&gt;&lt;/example&gt;
    ''' &lt;exception cref="bla"&gt;&lt;/exception&gt;
    ''' &lt;include file='' path='[@name=""]'/&gt;
    ''' &lt;permission cref=" "&gt;&lt;/permission&gt;
    ''' &lt;remarks&gt;&lt;/remarks&gt;
    ''' &lt;see cref=""/&gt;
    ''' &lt;seealso cref=" "/&gt;
    ''' &lt;value&gt;&lt;/value&gt;
    ''' &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
    Class c(Of T)
        Sub M(Of U)(ByVal T1 As T, ByVal U1 As U)
            Dim intValue As Integer = 0
            intValue = intValue + 1
            Dim strValue As String = "hello" 's
            Dim c As New [MyClass]()
            Dim verbatimStr As String = "@ \\\\" 's
        End Sub
    End Class

End Namespace
Friend Class TestClassXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 'Scen8
End Class

Friend Class TestClass1XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX22 'Scen9
End Class

Friend Class yield
    ''INSTANT VB TODO TASK: There is no equivalent to the undocumented C# '__arglist' keyword in VB:
    'Private Sub Goo(Of U)(ByVal __arglist)
    '    Dim c1 As C(Of U) = Nothing
    '    c1.M(Of Integer)(5, Nothing)
    '    Dim tr As TypedReference = __makeref(c1)
    '    Dim t As Type = __reftype(tr)

    '    	Dim j As Integer = __refvalue(tr, Integer)

    '    Params(a:=t, b:=t)
    'End Sub
    Private Sub Params(ByRef a As Object, &lt;System.Runtime.InteropServices.Out()&gt; ByRef b As Object, ByVal ParamArray c() As Object)
    End Sub

    'Private Sub Params(Optional &lt;System.Runtime.InteropServices.Out()&gt; ByRef a As dynamic = 2, Optional ByRef c As dynamic = Nothing, ParamArray ByVal c()() As dynamic)
    'End Sub
    Public Overrides Function ToString() As String
        Return MyBase.ToString()
    End Function

    Public Sub method()
        Dim a?(4) As Integer '[] bug
        ' YES []
        Dim var() As Integer = {1, 2, 3, 4, 5} ',;
        Dim i As Integer = a(i) '[]
        Dim f As New Goo(Of T)() '&lt;&gt; ()
        f.method()
        i = i + i - i * i \ i Mod i And i Or i Xor i '+ - * / % &amp; | ^

        Dim b As Boolean = True And False Or True Xor False '&amp; | ^
        b = Not b '!
        i = Not i '~i
        b = i &lt; i AndAlso i &gt; i '&lt; &amp;&amp; &gt;

        Dim ii? As Integer = 5 '? bug
        ' NO ?
        Dim f1 As Integer = If(True, 1, 0) '? :
        ' YES :
        i += 1 '++
        i -= 1 '--
        b = True AndAlso False OrElse True '&amp;&amp; ||
        i = i &lt;&lt; 5 '&lt;&lt;
        i = i &gt;&gt; 5 '&gt;&gt;
        b = i = i AndAlso i &lt;&gt; i AndAlso i &lt;= i AndAlso i &gt;= i '= == &amp;&amp; != &lt;= &gt;=
        i += 5.0 '+=
        i -= i '-=
        i *= i '*=
        i \= i '/
        '=
        i = i Mod i '%=
        i = i And i '&amp;=
        i = i Or i '|=
        i = i Xor i '^=
        i &lt;&lt;= i '&lt;&lt;=
        i &gt;&gt;= i '&gt;&gt;=
        Dim s As Object = Function(x) x + 1 '=&gt;


        ' There is no equivalent to an 'unsafe' block in VB.NET
        '			unsafe
        '		Point* p = &amp;point '* &amp;
        '			p-&gt;x = 10 '-&gt;

        Dim p As Point
        p.X = 10
        p.Y = 12

        Dim p2 As New Point With {.X = 10, .Y = 12}


        Dim br As IO.BinaryReader = Nothing
    End Sub

    Friend Structure Point
        Public X As Integer
        Public Y As Integer
    End Structure
End Class

'Extension Method
Module Module1
    &lt;Runtime.CompilerServices.Extension()&gt; Function GooExtension(ByVal x As String) As String
        Return x &amp; "test"
    End Function

    &lt;Runtime.CompilerServices.Extension()&gt; Function GooExtension(ByVal x As String,
                                                                 ByVal y As Integer) As String
        'With Implicit Line Continuation
        Return x &amp; "test2"
    End Function

    Sub Goo()
        'Collections
        Dim i As New List(Of String) From {"test", "item"}
        Dim i1 As New Dictionary(Of Integer, String) From {{1, "test"}, {2, "item"}}

        'Arrays
        Dim ia1 = {1, 2, 3, 4, 5}
        Dim la2 = {1,
                   2L,
                   3,
                   4S,
                   5}
        Console.Write(GetXmlNamespace(ns))
        Dim ia3 As Integer() = {1,
                                2,
                                3, 4, 5}
        Dim ia4() As Integer = {1,
                                2, 3, 4,
                                5}

        Dim ia5 = New Integer() {1, 2, 3, 4, 5}


        Dim ia6 = {{1, 2}, {3, 4}, {5, 6}} '2d array
        Dim ia7 = {({1}), ({3, 4}), ({5, 6, 2})} 'jagged array

        'Standalone
        If {1, 2, 3}.Count = 2 Then
        ElseIf {1, 2, 3}.Count = 3 Then
        Else
        End If

    End Sub
End Module




#Region "Events"
Public Delegate Sub MyDelegate(ByVal message As String)

Class MyClass1

    Custom Event MyEvent As MyDelegate

        ' This code will be run when AddHandler MyEvent, D1
        ' is called
        AddHandler(ByVal value As MyDelegate)
            Console.WriteLine("Adding Handler for MyEvent")
            MyEventHandler = value
        End AddHandler

        ' This code will be run when RemoveHandler MyEvent, D1
        ' is called
        RemoveHandler(ByVal value As MyDelegate)
            Console.WriteLine("Removing Handler for MyEvent")
            MyEventHandler = Nothing
        End RemoveHandler

        ' This code will be run when RaiseEvent MyEvent(string)
        ' is called
        RaiseEvent(ByVal message As String)
            If Not MyEventHandler Is Nothing Then
                MyEventHandler.Invoke(message)
            Else
                Console.WriteLine("No Handler for Raised MyEvent")
            End If
        End RaiseEvent
    End Event

    Public MyEventHandler As MyDelegate

    Public Sub Raise_Event()
        RaiseEvent MyEvent("MyEvent Was Raised")
    End Sub
End Class

Module DelegateModule
    Dim Var1 As MyClass1
    Dim D1 As MyDelegate

    Sub EventsMain()
        Var1 = New MyClass1
        D1 = New MyDelegate(AddressOf MyHandler)
        AddHandler Var1.MyEvent, D1
        Var1.Raise_Event()
        RemoveHandler Var1.MyEvent, D1
    End Sub

    Sub MyHandler(ByVal message As String)
        Console.WriteLine("Event Handled: " &amp; message)
    End Sub
End Module

#End Region

#Region "Linq"
Module LINQQueries
    Sub Join()
        Dim categories() = {"Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"}

        Dim productList = {New With {.category = "Condiments", .name = "Ketchup"}, New With {.category = "Seafood", .name = "Code"}}

        Dim query = From c In categories _
                    Group Join p In productList On c Equals p.category Into Group _
                    From p In Group _
                    Select Category = c, p.name

        For Each v In query
            Console.WriteLine(v.name + ": " + v.Category)
        Next
    End Sub
End Module
#End Region


#Region "Lambda's"
Module Lambdas
    Dim l1 = Sub()
                 Console.WriteLine("Sub Statement")
             End Sub

    Dim L2 = Sub() Console.WriteLine("Sub Statement 2")

    Dim L3 = Function(x As Integer) x Mod 2

    Dim L4 = Function(y As Integer) As Boolean
                 If y * 2 &lt; 10 Then
                     Return True
                 Else
                     Return False
                 End If
             End Function
End Module
#End Region

#Region "Co Contra Variance"
Public Class Cheetah

End Class
Public Class Animals

End Class
Public Interface IVariance(Of In T)
    Sub Goo(ByVal a As T)
    Property InterProperty() As IVariance(Of Cheetah)
    Property InterProperty2() As IVariance(Of Animals)
End Interface

Delegate Sub Func(Of In T)(ByVal a As T)


Public Delegate Function Func2(Of Out T)() As T
Public Interface IVariance2(Of Out T)
    Function Goo() As T
End Interface

Public Class Variance2(Of T As New) : Implements IVariance2(Of T)

    Dim type As IVariance2(Of Animals)

    Private Function Goo() As T Implements IVariance2(Of T).Goo
        Return New T
    End Function

    Function Goo(ByVal arg As IVariance2(Of T)) As String
        Return arg.GetType.ToString
    End Function

    Function Goo(ByVal arg As Func2(Of T)) As String
        Return arg.Invoke().GetType.ToString
    End Function
End Class

#End Region

Module Mod1Orcas
    Dim AT1 = New With {Key .prop1 = 1}
    Dim AT2 = New With {.prop1 = 7}
    Dim b_false As Boolean = False
    Dim n_false = False
    Dim i = If(b_false And n_false, 1, 2)
    Dim s1 = &lt;xml_literal&gt;&lt;%= If(Nothing, Nothing) %&gt;&lt;/xml_literal&gt;

    Delegate Sub delfoo()
    Delegate Sub delfoo1(ByVal sender As Object, ByVal e As System.EventArgs)

    Sub Goo()
    End Sub

    Sub Method1(ByVal sender As Object, ByVal e As System.EventArgs)
    End Sub
    Sub Method1a()
    End Sub

    Sub AssignDelegate()
        Dim d As delfoo = AddressOf Goo
        d.Invoke()


        Dim d1_1 As delfoo1 = AddressOf Method1
        Dim d1_1a As delfoo1 = AddressOf Method1a 'Relaxed Delegate




        'Nullable
        Dim Value1a As Integer? = 10
        Dim Value1b As Integer = 1
        Dim Value1c? As Integer = 1
        Dim Value1c? As Integer? = 1
        Dim TestReturnValue = Value1a * Value1b
        If Value1a / Value1b &gt; 0 Then

        End If

        Dim sNone = "None"
        Dim SSystemOnly = "SystemOnly"

        Dim XMLLiteral = &lt;?xml version="1.0" encoding="utf-8"?&gt;

                         &lt;Details&gt;
                             &lt;FileImports&gt;
                                 &lt;FileImport name=&lt;%= sNone %&gt;&gt;
                                 &lt;/FileImport&gt;
                                 &lt;FileImport name=&lt;%= SSystemOnly %&gt;&gt;
        Imports System
      &lt;/FileImport&gt;
                                 &lt;FileImport name="Default"&gt;
        Imports System
        Imports System.Collections
      &lt;/FileImport&gt;
                             &lt;/FileImports&gt;

                             &lt;CodeConstructs&gt;
                                 &lt;!-- Type Constructs--&gt;
                                 &lt;Construct name="Module" allowcodeblock="false" allowOuter="true" group="Type" allownesting="true" isnestable="false" allowsoverload="false"&gt;
                                     &lt;Start&gt;public Module {Identifier}&lt;/Start&gt;
                                     &lt;End&gt;End Module &lt;/End&gt;
                                     &lt;DefaultIdent&gt;Module_&lt;/DefaultIdent&gt;
                                 &lt;/Construct&gt;
                                 &lt;Construct name="Class" allowcodeblock="false" allowOuter="true" group="Type" allownesting="true" isnestable="true" allowsoverload="false"&gt;
                                     &lt;Start&gt;public class {Identifier}&lt;/Start&gt;
                                     &lt;End&gt;End Class&lt;/End&gt;
                                     &lt;DefaultIdent&gt;Class_&lt;/DefaultIdent&gt;
                                 &lt;/Construct&gt;
                                 &lt;Construct name="Structure" allowcodeblock="false" allowOuter="true" group="Type" allownesting="true" isnestable="true" allowsoverload="false"&gt;
                                     &lt;Start&gt;public class {Identifier}&lt;/Start&gt;
                                     &lt;End&gt;End Class&lt;/End&gt;
                                     &lt;DefaultIdent&gt;Struct_&lt;/DefaultIdent&gt;
                                 &lt;/Construct&gt;
                             &lt;/CodeConstructs&gt;

                             &lt;CodeBlocks&gt;
                                 &lt;Block name="CodeBlock0.txt" statements="1"&gt;
                                     &lt;![CDATA[ Dim &lt;{x0}&gt; = Microsoft.VisualBasic.FileSystem.Dir(".") ]]&gt;
                                 &lt;/Block&gt;
                                 &lt;Block name="CodeBlock1.txt" statements="1"&gt;
                                     &lt;![CDATA[ Dim &lt;{x0}&gt; = 1 ]]&gt;
                                 &lt;/Block&gt;
                                 &lt;Block name="CodeBlock2.txt" statements="1"&gt;
                                     &lt;![CDATA[ Dim &lt;{x0}&gt; as string = "2" ]]&gt;
                                 &lt;/Block&gt;
                             &lt;/CodeBlocks&gt;
                         &lt;/Details&gt;
        Dim x = &lt;![CDATA[ Dim &lt;{x0}&gt; as string = "2" ]]&gt;
        Dim y = &lt;!-- --&gt; : Call &lt;?a?&gt;() : Dim x = &lt;e/&gt;
    End Sub
End Module

Class Customer
    Public Property name As String = "Default"
    Public AGe As Integer
    Public Position As String
    Public Level As Integer = 0
    Public Property age2 As Integer
End Class

Class Goo
    Structure Bar
        Dim x As Integer

        Sub LoopingMethod()
            For i = 1 To 20 Step 1
            Next i

            For Each a In {1, 2, 3, 4}
            Next

            Dim icount As Integer
            Do While icount &lt;= 10
                icount += 1
            Loop

            icount = 0
            While icount &lt;= 100
                icount += 1
            End While

            icount = 0
            Do Until icount &gt;= 10
                icount += 2
            Loop
        End Sub
    End Structure
End Class

Class GooGen(Of t)
    Structure BarGen(Of u)
        Dim x As t
        Dim z As u
        Sub SelectionMethods()

            Dim icount As Integer = 1L

            If icount = 1 Then
            ElseIf icount &gt; 1 Then
            Else
            End If

            Select Case icount
                Case 1
                Case 2, 3
                Case Is &gt; 3
                Case Else
            End Select
        End Sub

        Sub Operators()
            Dim a As Boolean = True
            Dim b As Boolean = False

            If a And
                b Then
            End If

            If a Or
                b Then
            End If

            If Not a And
                   b Then
            End If

            If a = b AndAlso
                   b = True Then
            End If

            If a =
                b OrElse
                b =
                False Then
            End If

            If (a Or
                b) OrElse b =
            True Then
            End If

        End Sub

        Sub Method1()

            Dim x As New Customer With {.name = "Test",
                                        .AGe = 30,
                                        .Level = 1, .Position = "SDET"}


            Dim x2 As New Customer With {.name = "Test",
                                        .AGe = 30,
                                        .Level = 1, .Position = "SDET",
                                         .age2 = .AGe}

        End Sub


    End Structure
End Class


Public Class Bar

End Class

Public Class ClsPPMTest003
    Partial Private Sub Goo3()
    End Sub
End Class

Partial Public Class ClsPPMTest003
    Private Sub Goo3()
    End Sub

    Public Sub CallGooFromClass()
        Me.Goo3()
        Dim x1 As New Goo
        Dim y1 As New Bar

        If x1 Is y1 Then
        Else
            Console.WriteLine("Expected Result Occurred")
        End If

        If x1 IsNot y1 Then
        Else
            Console.WriteLine("Expected Result Occurred")
        End If

    End Sub

    Sub InterpolatedString()
        Dim s = $"The current date = {Date.Today,10:yyyy-MM-dd}."
    End Sub

End Class</value>
  </data>
  <data name="HelloWorldVisualBasicCode" xml:space="preserve">
    <value>Imports System
Imports System.Collections.Generic
Imports System.Linq

''' &lt;summary&gt;
''' Sample Documentation
''' &lt;/summary&gt;
Module Program
    Sub Main(args As String())
        ' User Comments
        Console.WriteLine(5)
    End Sub
End Module</value>
  </data>
</root>
