// <auto-generated />

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Text;
using Roslyn.Compilers.Internal;
using Roslyn.Compilers.Collections;

namespace Roslyn.Compilers.CSharp
{
    internal enum BoundKind: byte
    {
        FieldInitializer,
        GlobalStatementInitializer,
        Dup,
        BadExpression,
        BadStatement,
        TypeExpression,
        TypeOrValueExpression,
        NamespaceExpression,
        UnaryOperator,
        IncrementOperator,
        AddressOfOperator,
        PointerIndirectionOperator,
        PointerElementAccess,
        RefTypeOperator,
        MakeRefOperator,
        RefValueOperator,
        BinaryOperator,
        CompoundAssignmentOperator,
        AssignmentOperator,
        NullCoalescingOperator,
        ConditionalOperator,
        ArrayAccess,
        ArrayLength,
        AwaitExpression,
        LoweredAwaitExpressionStackMark,
        TypeOfOperator,
        MethodInfo,
        FieldInfo,
        DefaultOperator,
        IsOperator,
        AsOperator,
        SizeOfOperator,
        Conversion,
        ArgList,
        ArgListOperator,
        FixedLocalCollectionInitializer,
        SequencePoint,
        SequencePointWithSpan,
        Block,
        IteratorScope,
        LocalDeclaration,
        MultipleLocalDeclarations,
        Sequence,
        NoOpStatement,
        ReturnStatement,
        YieldReturnStatement,
        YieldBreakStatement,
        ThrowStatement,
        ExpressionStatement,
        SwitchStatement,
        SwitchSection,
        SwitchLabel,
        BreakStatement,
        ContinueStatement,
        IfStatement,
        DoStatement,
        WhileStatement,
        ForStatement,
        ForEachStatement,
        UsingStatement,
        FixedStatement,
        LockStatement,
        TryStatement,
        CatchBlock,
        Literal,
        ThisReference,
        PreviousSubmissionReference,
        HostObjectMemberReference,
        BaseReference,
        Local,
        RangeVariable,
        Parameter,
        LabelStatement,
        GotoStatement,
        LabeledStatement,
        Label,
        StatementList,
        ConditionalGoto,
        DynamicMemberAccess,
        DynamicInvocation,
        MethodGroup,
        PropertyGroup,
        Call,
        EventAssignmentOperator,
        DelegateCall,
        Attribute,
        ObjectCreationExpression,
        DynamicObjectCreationExpression,
        ObjectInitializerExpression,
        ObjectInitializerMember,
        CollectionInitializerExpression,
        CollectionElementInitializer,
        DynamicCollectionElementInitializer,
        ImplicitReceiver,
        AnonymousObjectCreationExpression,
        AnonymousPropertyDeclaration,
        NewT,
        DelegateCreationExpression,
        ArrayCreation,
        ArrayInitialization,
        StackAllocArrayCreation,
        FieldAccess,
        PropertyAccess,
        EventAccess,
        IndexerAccess,
        DynamicIndexerAccess,
        Lambda,
        UnboundLambda,
        QueryClause,
    }







    internal abstract partial class BoundInitializer : BoundNode
    {
        protected BoundInitializer(BoundKind kind, SyntaxNode syntax, bool hasErrors)
            : base(kind, syntax, hasErrors)
        {
        }

        protected BoundInitializer(BoundKind kind, SyntaxNode syntax)
            : base(kind, syntax)
        {
        }

    }

    internal sealed partial class BoundFieldInitializer : BoundInitializer
    {
        public BoundFieldInitializer(SyntaxNode syntax, FieldSymbol field, BoundExpression initialValue, bool hasErrors = false)
            : base(BoundKind.FieldInitializer, syntax, hasErrors || initialValue.HasErrors())
        {

            Debug.Assert(field != null, "Field 'field' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(initialValue != null, "Field 'initialValue' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Field = field;
            this.InitialValue = initialValue;
        }


        public FieldSymbol Field { get; private set; }

        public BoundExpression InitialValue { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitFieldInitializer(this);
        }

        public BoundFieldInitializer Update(FieldSymbol field, BoundExpression initialValue)
        {
            if (field != this.Field || initialValue != this.InitialValue)
            {
                var result = new BoundFieldInitializer(this.Syntax, field, initialValue, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundGlobalStatementInitializer : BoundInitializer
    {
        public BoundGlobalStatementInitializer(SyntaxNode syntax, BoundStatement statement, bool hasErrors = false)
            : base(BoundKind.GlobalStatementInitializer, syntax, hasErrors || statement.HasErrors())
        {

            Debug.Assert(statement != null, "Field 'statement' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Statement = statement;
        }


        public BoundStatement Statement { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitGlobalStatementInitializer(this);
        }

        public BoundGlobalStatementInitializer Update(BoundStatement statement)
        {
            if (statement != this.Statement)
            {
                var result = new BoundGlobalStatementInitializer(this.Syntax, statement, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal abstract partial class BoundExpression : BoundNode
    {
        protected BoundExpression(BoundKind kind, SyntaxNode syntax, TypeSymbol type, bool hasErrors)
            : base(kind, syntax, hasErrors)
        {
            this.Type = type;
        }

        protected BoundExpression(BoundKind kind, SyntaxNode syntax, TypeSymbol type)
            : base(kind, syntax)
        {
            this.Type = type;
        }


        public TypeSymbol Type { get; private set; }
    }

    internal sealed partial class BoundDup : BoundExpression
    {
        public BoundDup(SyntaxNode syntax, RefKind refKind, TypeSymbol type, bool hasErrors)
            : base(BoundKind.Dup, syntax, type, hasErrors)
        {
            this.RefKind = refKind;
        }

        public BoundDup(SyntaxNode syntax, RefKind refKind, TypeSymbol type)
            : base(BoundKind.Dup, syntax, type)
        {
            this.RefKind = refKind;
        }


        public RefKind RefKind { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitDup(this);
        }

        public BoundDup Update(RefKind refKind, TypeSymbol type)
        {
            if (refKind != this.RefKind || type != this.Type)
            {
                var result = new BoundDup(this.Syntax, refKind, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundBadExpression : BoundExpression
    {
        public BoundBadExpression(SyntaxNode syntax, LookupResultKind resultKind, ReadOnlyArray<Symbol> symbols, ReadOnlyArray<BoundNode> childBoundNodes, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.BadExpression, syntax, type, hasErrors || childBoundNodes.HasErrors())
        {

            Debug.Assert(!symbols.IsNull, "Field 'symbols' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(!childBoundNodes.IsNull, "Field 'childBoundNodes' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this._ResultKind = resultKind;
            this.Symbols = symbols;
            this.ChildBoundNodes = childBoundNodes;
        }


        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }

        public ReadOnlyArray<Symbol> Symbols { get; private set; }

        public ReadOnlyArray<BoundNode> ChildBoundNodes { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitBadExpression(this);
        }

        public BoundBadExpression Update(LookupResultKind resultKind, ReadOnlyArray<Symbol> symbols, ReadOnlyArray<BoundNode> childBoundNodes, TypeSymbol type)
        {
            if (resultKind != this.ResultKind || symbols != this.Symbols || childBoundNodes != this.ChildBoundNodes || type != this.Type)
            {
                var result = new BoundBadExpression(this.Syntax, resultKind, symbols, childBoundNodes, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundBadStatement : BoundStatement
    {
        public BoundBadStatement(SyntaxNode syntax, ReadOnlyArray<BoundNode> childBoundNodes, bool hasErrors = false)
            : base(BoundKind.BadStatement, syntax, hasErrors || childBoundNodes.HasErrors())
        {

            Debug.Assert(!childBoundNodes.IsNull, "Field 'childBoundNodes' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.ChildBoundNodes = childBoundNodes;
        }


        public ReadOnlyArray<BoundNode> ChildBoundNodes { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitBadStatement(this);
        }

        public BoundBadStatement Update(ReadOnlyArray<BoundNode> childBoundNodes)
        {
            if (childBoundNodes != this.ChildBoundNodes)
            {
                var result = new BoundBadStatement(this.Syntax, childBoundNodes, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundTypeExpression : BoundExpression
    {
        public BoundTypeExpression(SyntaxNode syntax, AliasSymbol aliasOpt, bool inferredType, BoundTypeExpression boundContainingTypeOpt, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.TypeExpression, syntax, type, hasErrors || boundContainingTypeOpt.HasErrors())
        {

            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.AliasOpt = aliasOpt;
            this.InferredType = inferredType;
            this.BoundContainingTypeOpt = boundContainingTypeOpt;
        }


        public AliasSymbol AliasOpt { get; private set; }

        public bool InferredType { get; private set; }

        public BoundTypeExpression BoundContainingTypeOpt { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitTypeExpression(this);
        }

        public BoundTypeExpression Update(AliasSymbol aliasOpt, bool inferredType, BoundTypeExpression boundContainingTypeOpt, TypeSymbol type)
        {
            if (aliasOpt != this.AliasOpt || inferredType != this.InferredType || boundContainingTypeOpt != this.BoundContainingTypeOpt || type != this.Type)
            {
                var result = new BoundTypeExpression(this.Syntax, aliasOpt, inferredType, boundContainingTypeOpt, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundTypeOrValueExpression : BoundExpression
    {
        public BoundTypeOrValueExpression(SyntaxNode syntax, Symbol variable, Binder binder, TypeSymbol type, bool hasErrors)
            : base(BoundKind.TypeOrValueExpression, syntax, type, hasErrors)
        {

            Debug.Assert(variable != null, "Field 'variable' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(binder != null, "Field 'binder' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Variable = variable;
            this.Binder = binder;
        }

        public BoundTypeOrValueExpression(SyntaxNode syntax, Symbol variable, Binder binder, TypeSymbol type)
            : base(BoundKind.TypeOrValueExpression, syntax, type)
        {

            Debug.Assert(variable != null, "Field 'variable' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(binder != null, "Field 'binder' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Variable = variable;
            this.Binder = binder;
        }


        public Symbol Variable { get; private set; }

        public Binder Binder { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitTypeOrValueExpression(this);
        }

        public BoundTypeOrValueExpression Update(Symbol variable, Binder binder, TypeSymbol type)
        {
            if (variable != this.Variable || binder != this.Binder || type != this.Type)
            {
                var result = new BoundTypeOrValueExpression(this.Syntax, variable, binder, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundNamespaceExpression : BoundExpression
    {
        public BoundNamespaceExpression(SyntaxNode syntax, NamespaceSymbol namespaceSymbol, AliasSymbol aliasOpt, bool hasErrors)
            : base(BoundKind.NamespaceExpression, syntax, null, hasErrors)
        {

            Debug.Assert(namespaceSymbol != null, "Field 'namespaceSymbol' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.NamespaceSymbol = namespaceSymbol;
            this.AliasOpt = aliasOpt;
        }

        public BoundNamespaceExpression(SyntaxNode syntax, NamespaceSymbol namespaceSymbol, AliasSymbol aliasOpt)
            : base(BoundKind.NamespaceExpression, syntax, null)
        {

            Debug.Assert(namespaceSymbol != null, "Field 'namespaceSymbol' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.NamespaceSymbol = namespaceSymbol;
            this.AliasOpt = aliasOpt;
        }


        public NamespaceSymbol NamespaceSymbol { get; private set; }

        public AliasSymbol AliasOpt { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitNamespaceExpression(this);
        }

        public BoundNamespaceExpression Update(NamespaceSymbol namespaceSymbol, AliasSymbol aliasOpt)
        {
            if (namespaceSymbol != this.NamespaceSymbol || aliasOpt != this.AliasOpt)
            {
                var result = new BoundNamespaceExpression(this.Syntax, namespaceSymbol, aliasOpt, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundUnaryOperator : BoundExpression
    {
        public BoundUnaryOperator(SyntaxNode syntax, UnaryOperatorKind operatorKind, BoundExpression operand, ConstantValue constantValueOpt, MethodSymbol methodOpt, LookupResultKind resultKind, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.UnaryOperator, syntax, type, hasErrors || operand.HasErrors())
        {

            Debug.Assert(operand != null, "Field 'operand' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.OperatorKind = operatorKind;
            this.Operand = operand;
            this.ConstantValueOpt = constantValueOpt;
            this.MethodOpt = methodOpt;
            this._ResultKind = resultKind;
        }


        public UnaryOperatorKind OperatorKind { get; private set; }

        public BoundExpression Operand { get; private set; }

        public ConstantValue ConstantValueOpt { get; private set; }

        public MethodSymbol MethodOpt { get; private set; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitUnaryOperator(this);
        }

        public BoundUnaryOperator Update(UnaryOperatorKind operatorKind, BoundExpression operand, ConstantValue constantValueOpt, MethodSymbol methodOpt, LookupResultKind resultKind, TypeSymbol type)
        {
            if (operatorKind != this.OperatorKind || operand != this.Operand || constantValueOpt != this.ConstantValueOpt || methodOpt != this.MethodOpt || resultKind != this.ResultKind || type != this.Type)
            {
                var result = new BoundUnaryOperator(this.Syntax, operatorKind, operand, constantValueOpt, methodOpt, resultKind, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundIncrementOperator : BoundExpression
    {
        public BoundIncrementOperator(SyntaxNode syntax, UnaryOperatorKind operatorKind, BoundExpression operand, MethodSymbol methodOpt, Conversion operandConversion, Conversion resultConversion, LookupResultKind resultKind, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.IncrementOperator, syntax, type, hasErrors || operand.HasErrors())
        {

            Debug.Assert(operand != null, "Field 'operand' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.OperatorKind = operatorKind;
            this.Operand = operand;
            this.MethodOpt = methodOpt;
            this.OperandConversion = operandConversion;
            this.ResultConversion = resultConversion;
            this._ResultKind = resultKind;
        }


        public UnaryOperatorKind OperatorKind { get; private set; }

        public BoundExpression Operand { get; private set; }

        public MethodSymbol MethodOpt { get; private set; }

        public Conversion OperandConversion { get; private set; }

        public Conversion ResultConversion { get; private set; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitIncrementOperator(this);
        }

        public BoundIncrementOperator Update(UnaryOperatorKind operatorKind, BoundExpression operand, MethodSymbol methodOpt, Conversion operandConversion, Conversion resultConversion, LookupResultKind resultKind, TypeSymbol type)
        {
            if (operatorKind != this.OperatorKind || operand != this.Operand || methodOpt != this.MethodOpt || operandConversion != this.OperandConversion || resultConversion != this.ResultConversion || resultKind != this.ResultKind || type != this.Type)
            {
                var result = new BoundIncrementOperator(this.Syntax, operatorKind, operand, methodOpt, operandConversion, resultConversion, resultKind, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundAddressOfOperator : BoundExpression
    {
        public BoundAddressOfOperator(SyntaxNode syntax, BoundExpression operand, bool isFixedStatementAddressOf, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.AddressOfOperator, syntax, type, hasErrors || operand.HasErrors())
        {

            Debug.Assert(operand != null, "Field 'operand' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Operand = operand;
            this.IsFixedStatementAddressOf = isFixedStatementAddressOf;
        }


        public BoundExpression Operand { get; private set; }

        public bool IsFixedStatementAddressOf { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitAddressOfOperator(this);
        }

        public BoundAddressOfOperator Update(BoundExpression operand, bool isFixedStatementAddressOf, TypeSymbol type)
        {
            if (operand != this.Operand || isFixedStatementAddressOf != this.IsFixedStatementAddressOf || type != this.Type)
            {
                var result = new BoundAddressOfOperator(this.Syntax, operand, isFixedStatementAddressOf, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundPointerIndirectionOperator : BoundExpression
    {
        public BoundPointerIndirectionOperator(SyntaxNode syntax, BoundExpression operand, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.PointerIndirectionOperator, syntax, type, hasErrors || operand.HasErrors())
        {

            Debug.Assert(operand != null, "Field 'operand' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Operand = operand;
        }


        public BoundExpression Operand { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitPointerIndirectionOperator(this);
        }

        public BoundPointerIndirectionOperator Update(BoundExpression operand, TypeSymbol type)
        {
            if (operand != this.Operand || type != this.Type)
            {
                var result = new BoundPointerIndirectionOperator(this.Syntax, operand, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundPointerElementAccess : BoundExpression
    {
        public BoundPointerElementAccess(SyntaxNode syntax, BoundExpression expression, BoundExpression index, Boolean @checked, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.PointerElementAccess, syntax, type, hasErrors || expression.HasErrors() || index.HasErrors())
        {

            Debug.Assert(expression != null, "Field 'expression' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(index != null, "Field 'index' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Expression = expression;
            this.Index = index;
            this.Checked = @checked;
        }


        public BoundExpression Expression { get; private set; }

        public BoundExpression Index { get; private set; }

        public Boolean Checked { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitPointerElementAccess(this);
        }

        public BoundPointerElementAccess Update(BoundExpression expression, BoundExpression index, Boolean @checked, TypeSymbol type)
        {
            if (expression != this.Expression || index != this.Index || @checked != this.Checked || type != this.Type)
            {
                var result = new BoundPointerElementAccess(this.Syntax, expression, index, @checked, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundRefTypeOperator : BoundExpression
    {
        public BoundRefTypeOperator(SyntaxNode syntax, BoundExpression operand, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.RefTypeOperator, syntax, type, hasErrors || operand.HasErrors())
        {

            Debug.Assert(operand != null, "Field 'operand' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Operand = operand;
        }


        public BoundExpression Operand { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitRefTypeOperator(this);
        }

        public BoundRefTypeOperator Update(BoundExpression operand, TypeSymbol type)
        {
            if (operand != this.Operand || type != this.Type)
            {
                var result = new BoundRefTypeOperator(this.Syntax, operand, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundMakeRefOperator : BoundExpression
    {
        public BoundMakeRefOperator(SyntaxNode syntax, BoundExpression operand, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.MakeRefOperator, syntax, type, hasErrors || operand.HasErrors())
        {

            Debug.Assert(operand != null, "Field 'operand' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Operand = operand;
        }


        public BoundExpression Operand { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitMakeRefOperator(this);
        }

        public BoundMakeRefOperator Update(BoundExpression operand, TypeSymbol type)
        {
            if (operand != this.Operand || type != this.Type)
            {
                var result = new BoundMakeRefOperator(this.Syntax, operand, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundRefValueOperator : BoundExpression
    {
        public BoundRefValueOperator(SyntaxNode syntax, BoundExpression operand, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.RefValueOperator, syntax, type, hasErrors || operand.HasErrors())
        {

            Debug.Assert(operand != null, "Field 'operand' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Operand = operand;
        }


        public BoundExpression Operand { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitRefValueOperator(this);
        }

        public BoundRefValueOperator Update(BoundExpression operand, TypeSymbol type)
        {
            if (operand != this.Operand || type != this.Type)
            {
                var result = new BoundRefValueOperator(this.Syntax, operand, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundBinaryOperator : BoundExpression
    {
        public BoundBinaryOperator(SyntaxNode syntax, BinaryOperatorKind operatorKind, BoundExpression left, BoundExpression right, ConstantValue constantValueOpt, MethodSymbol methodOpt, LookupResultKind resultKind, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.BinaryOperator, syntax, type, hasErrors || left.HasErrors() || right.HasErrors())
        {

            Debug.Assert(left != null, "Field 'left' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(right != null, "Field 'right' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.OperatorKind = operatorKind;
            this.Left = left;
            this.Right = right;
            this.ConstantValueOpt = constantValueOpt;
            this.MethodOpt = methodOpt;
            this._ResultKind = resultKind;
        }


        public BinaryOperatorKind OperatorKind { get; private set; }

        public BoundExpression Left { get; private set; }

        public BoundExpression Right { get; private set; }

        public ConstantValue ConstantValueOpt { get; private set; }

        public MethodSymbol MethodOpt { get; private set; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitBinaryOperator(this);
        }

        public BoundBinaryOperator Update(BinaryOperatorKind operatorKind, BoundExpression left, BoundExpression right, ConstantValue constantValueOpt, MethodSymbol methodOpt, LookupResultKind resultKind, TypeSymbol type)
        {
            if (operatorKind != this.OperatorKind || left != this.Left || right != this.Right || constantValueOpt != this.ConstantValueOpt || methodOpt != this.MethodOpt || resultKind != this.ResultKind || type != this.Type)
            {
                var result = new BoundBinaryOperator(this.Syntax, operatorKind, left, right, constantValueOpt, methodOpt, resultKind, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundCompoundAssignmentOperator : BoundExpression
    {
        public BoundCompoundAssignmentOperator(SyntaxNode syntax, BinaryOperatorSignature @operator, BoundExpression left, BoundExpression right, Conversion leftConversion, Conversion finalConversion, LookupResultKind resultKind, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.CompoundAssignmentOperator, syntax, type, hasErrors || left.HasErrors() || right.HasErrors())
        {

            Debug.Assert(left != null, "Field 'left' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(right != null, "Field 'right' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Operator = @operator;
            this.Left = left;
            this.Right = right;
            this.LeftConversion = leftConversion;
            this.FinalConversion = finalConversion;
            this._ResultKind = resultKind;
        }


        public BinaryOperatorSignature Operator { get; private set; }

        public BoundExpression Left { get; private set; }

        public BoundExpression Right { get; private set; }

        public Conversion LeftConversion { get; private set; }

        public Conversion FinalConversion { get; private set; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitCompoundAssignmentOperator(this);
        }

        public BoundCompoundAssignmentOperator Update(BinaryOperatorSignature @operator, BoundExpression left, BoundExpression right, Conversion leftConversion, Conversion finalConversion, LookupResultKind resultKind, TypeSymbol type)
        {
            if (@operator != this.Operator || left != this.Left || right != this.Right || leftConversion != this.LeftConversion || finalConversion != this.FinalConversion || resultKind != this.ResultKind || type != this.Type)
            {
                var result = new BoundCompoundAssignmentOperator(this.Syntax, @operator, left, right, leftConversion, finalConversion, resultKind, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundAssignmentOperator : BoundExpression
    {
        public BoundAssignmentOperator(SyntaxNode syntax, BoundExpression left, BoundExpression right, RefKind refKind, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.AssignmentOperator, syntax, type, hasErrors || left.HasErrors() || right.HasErrors())
        {

            Debug.Assert(left != null, "Field 'left' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Left = left;
            this.Right = right;
            this.RefKind = refKind;
        }


        public BoundExpression Left { get; private set; }

        public BoundExpression Right { get; private set; }

        public RefKind RefKind { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitAssignmentOperator(this);
        }

        public BoundAssignmentOperator Update(BoundExpression left, BoundExpression right, RefKind refKind, TypeSymbol type)
        {
            if (left != this.Left || right != this.Right || refKind != this.RefKind || type != this.Type)
            {
                var result = new BoundAssignmentOperator(this.Syntax, left, right, refKind, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundNullCoalescingOperator : BoundExpression
    {
        public BoundNullCoalescingOperator(SyntaxNode syntax, BoundExpression leftOperand, BoundExpression rightOperand, Conversion leftConversion, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.NullCoalescingOperator, syntax, type, hasErrors || leftOperand.HasErrors() || rightOperand.HasErrors())
        {

            Debug.Assert(leftOperand != null, "Field 'leftOperand' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(rightOperand != null, "Field 'rightOperand' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.LeftOperand = leftOperand;
            this.RightOperand = rightOperand;
            this.LeftConversion = leftConversion;
        }


        public BoundExpression LeftOperand { get; private set; }

        public BoundExpression RightOperand { get; private set; }

        public Conversion LeftConversion { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitNullCoalescingOperator(this);
        }

        public BoundNullCoalescingOperator Update(BoundExpression leftOperand, BoundExpression rightOperand, Conversion leftConversion, TypeSymbol type)
        {
            if (leftOperand != this.LeftOperand || rightOperand != this.RightOperand || leftConversion != this.LeftConversion || type != this.Type)
            {
                var result = new BoundNullCoalescingOperator(this.Syntax, leftOperand, rightOperand, leftConversion, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundConditionalOperator : BoundExpression
    {
        public BoundConditionalOperator(SyntaxNode syntax, BoundExpression condition, BoundExpression consequence, BoundExpression alternative, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.ConditionalOperator, syntax, type, hasErrors || condition.HasErrors() || consequence.HasErrors() || alternative.HasErrors())
        {

            Debug.Assert(condition != null, "Field 'condition' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(consequence != null, "Field 'consequence' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(alternative != null, "Field 'alternative' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Condition = condition;
            this.Consequence = consequence;
            this.Alternative = alternative;
            this.ConstantValueOpt = constantValueOpt;
        }


        public BoundExpression Condition { get; private set; }

        public BoundExpression Consequence { get; private set; }

        public BoundExpression Alternative { get; private set; }

        public ConstantValue ConstantValueOpt { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitConditionalOperator(this);
        }

        public BoundConditionalOperator Update(BoundExpression condition, BoundExpression consequence, BoundExpression alternative, ConstantValue constantValueOpt, TypeSymbol type)
        {
            if (condition != this.Condition || consequence != this.Consequence || alternative != this.Alternative || constantValueOpt != this.ConstantValueOpt || type != this.Type)
            {
                var result = new BoundConditionalOperator(this.Syntax, condition, consequence, alternative, constantValueOpt, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundArrayAccess : BoundExpression
    {
        public BoundArrayAccess(SyntaxNode syntax, BoundExpression expression, ReadOnlyArray<BoundExpression> indices, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.ArrayAccess, syntax, type, hasErrors || expression.HasErrors() || indices.HasErrors())
        {

            Debug.Assert(expression != null, "Field 'expression' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(!indices.IsNull, "Field 'indices' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Expression = expression;
            this.Indices = indices;
        }


        public BoundExpression Expression { get; private set; }

        public ReadOnlyArray<BoundExpression> Indices { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitArrayAccess(this);
        }

        public BoundArrayAccess Update(BoundExpression expression, ReadOnlyArray<BoundExpression> indices, TypeSymbol type)
        {
            if (expression != this.Expression || indices != this.Indices || type != this.Type)
            {
                var result = new BoundArrayAccess(this.Syntax, expression, indices, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundArrayLength : BoundExpression
    {
        public BoundArrayLength(SyntaxNode syntax, BoundExpression expression, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.ArrayLength, syntax, type, hasErrors || expression.HasErrors())
        {

            Debug.Assert(expression != null, "Field 'expression' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Expression = expression;
        }


        public BoundExpression Expression { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitArrayLength(this);
        }

        public BoundArrayLength Update(BoundExpression expression, TypeSymbol type)
        {
            if (expression != this.Expression || type != this.Type)
            {
                var result = new BoundArrayLength(this.Syntax, expression, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundAwaitExpression : BoundExpression
    {
        public BoundAwaitExpression(SyntaxNode syntax, BoundExpression expression, MethodSymbol getAwaiter, PropertySymbol isCompleted, MethodSymbol getResult, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.AwaitExpression, syntax, type, hasErrors || expression.HasErrors())
        {

            Debug.Assert(expression != null, "Field 'expression' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Expression = expression;
            this.GetAwaiter = getAwaiter;
            this.IsCompleted = isCompleted;
            this.GetResult = getResult;
        }


        public BoundExpression Expression { get; private set; }

        public MethodSymbol GetAwaiter { get; private set; }

        public PropertySymbol IsCompleted { get; private set; }

        public MethodSymbol GetResult { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitAwaitExpression(this);
        }

        public BoundAwaitExpression Update(BoundExpression expression, MethodSymbol getAwaiter, PropertySymbol isCompleted, MethodSymbol getResult, TypeSymbol type)
        {
            if (expression != this.Expression || getAwaiter != this.GetAwaiter || isCompleted != this.IsCompleted || getResult != this.GetResult || type != this.Type)
            {
                var result = new BoundAwaitExpression(this.Syntax, expression, getAwaiter, isCompleted, getResult, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundLoweredAwaitExpressionStackMark : BoundStatement
    {
        public BoundLoweredAwaitExpressionStackMark(SyntaxNode syntax, bool hasErrors)
            : base(BoundKind.LoweredAwaitExpressionStackMark, syntax, hasErrors)
        {
        }

        public BoundLoweredAwaitExpressionStackMark(SyntaxNode syntax)
            : base(BoundKind.LoweredAwaitExpressionStackMark, syntax)
        {
        }


        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitLoweredAwaitExpressionStackMark(this);
        }
    }

    internal sealed partial class BoundTypeOfOperator : BoundExpression
    {
        public BoundTypeOfOperator(SyntaxNode syntax, BoundTypeExpression sourceType, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.TypeOfOperator, syntax, type, hasErrors || sourceType.HasErrors())
        {

            Debug.Assert(sourceType != null, "Field 'sourceType' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.SourceType = sourceType;
        }


        public BoundTypeExpression SourceType { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitTypeOfOperator(this);
        }

        public BoundTypeOfOperator Update(BoundTypeExpression sourceType, TypeSymbol type)
        {
            if (sourceType != this.SourceType || type != this.Type)
            {
                var result = new BoundTypeOfOperator(this.Syntax, sourceType, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundMethodInfo : BoundExpression
    {
        public BoundMethodInfo(SyntaxNode syntax, MethodSymbol method, TypeSymbol type, bool hasErrors)
            : base(BoundKind.MethodInfo, syntax, type, hasErrors)
        {

            Debug.Assert(method != null, "Field 'method' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Method = method;
        }

        public BoundMethodInfo(SyntaxNode syntax, MethodSymbol method, TypeSymbol type)
            : base(BoundKind.MethodInfo, syntax, type)
        {

            Debug.Assert(method != null, "Field 'method' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Method = method;
        }


        public MethodSymbol Method { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitMethodInfo(this);
        }

        public BoundMethodInfo Update(MethodSymbol method, TypeSymbol type)
        {
            if (method != this.Method || type != this.Type)
            {
                var result = new BoundMethodInfo(this.Syntax, method, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundFieldInfo : BoundExpression
    {
        public BoundFieldInfo(SyntaxNode syntax, FieldSymbol field, TypeSymbol type, bool hasErrors)
            : base(BoundKind.FieldInfo, syntax, type, hasErrors)
        {

            Debug.Assert(field != null, "Field 'field' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Field = field;
        }

        public BoundFieldInfo(SyntaxNode syntax, FieldSymbol field, TypeSymbol type)
            : base(BoundKind.FieldInfo, syntax, type)
        {

            Debug.Assert(field != null, "Field 'field' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Field = field;
        }


        public FieldSymbol Field { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitFieldInfo(this);
        }

        public BoundFieldInfo Update(FieldSymbol field, TypeSymbol type)
        {
            if (field != this.Field || type != this.Type)
            {
                var result = new BoundFieldInfo(this.Syntax, field, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundDefaultOperator : BoundExpression
    {
        public BoundDefaultOperator(SyntaxNode syntax, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors)
            : base(BoundKind.DefaultOperator, syntax, type, hasErrors)
        {
            this.ConstantValueOpt = constantValueOpt;
        }

        public BoundDefaultOperator(SyntaxNode syntax, ConstantValue constantValueOpt, TypeSymbol type)
            : base(BoundKind.DefaultOperator, syntax, type)
        {
            this.ConstantValueOpt = constantValueOpt;
        }


        public ConstantValue ConstantValueOpt { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitDefaultOperator(this);
        }

        public BoundDefaultOperator Update(ConstantValue constantValueOpt, TypeSymbol type)
        {
            if (constantValueOpt != this.ConstantValueOpt || type != this.Type)
            {
                var result = new BoundDefaultOperator(this.Syntax, constantValueOpt, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundIsOperator : BoundExpression
    {
        public BoundIsOperator(SyntaxNode syntax, BoundExpression operand, BoundTypeExpression targetType, Conversion conversion, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.IsOperator, syntax, type, hasErrors || operand.HasErrors() || targetType.HasErrors())
        {

            Debug.Assert(operand != null, "Field 'operand' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(targetType != null, "Field 'targetType' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Operand = operand;
            this.TargetType = targetType;
            this.Conversion = conversion;
        }


        public BoundExpression Operand { get; private set; }

        public BoundTypeExpression TargetType { get; private set; }

        public Conversion Conversion { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitIsOperator(this);
        }

        public BoundIsOperator Update(BoundExpression operand, BoundTypeExpression targetType, Conversion conversion, TypeSymbol type)
        {
            if (operand != this.Operand || targetType != this.TargetType || conversion != this.Conversion || type != this.Type)
            {
                var result = new BoundIsOperator(this.Syntax, operand, targetType, conversion, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundAsOperator : BoundExpression
    {
        public BoundAsOperator(SyntaxNode syntax, BoundExpression operand, BoundTypeExpression targetType, Conversion conversion, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.AsOperator, syntax, type, hasErrors || operand.HasErrors() || targetType.HasErrors())
        {

            Debug.Assert(operand != null, "Field 'operand' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(targetType != null, "Field 'targetType' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Operand = operand;
            this.TargetType = targetType;
            this.Conversion = conversion;
        }


        public BoundExpression Operand { get; private set; }

        public BoundTypeExpression TargetType { get; private set; }

        public Conversion Conversion { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitAsOperator(this);
        }

        public BoundAsOperator Update(BoundExpression operand, BoundTypeExpression targetType, Conversion conversion, TypeSymbol type)
        {
            if (operand != this.Operand || targetType != this.TargetType || conversion != this.Conversion || type != this.Type)
            {
                var result = new BoundAsOperator(this.Syntax, operand, targetType, conversion, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundSizeOfOperator : BoundExpression
    {
        public BoundSizeOfOperator(SyntaxNode syntax, BoundTypeExpression sourceType, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.SizeOfOperator, syntax, type, hasErrors || sourceType.HasErrors())
        {

            Debug.Assert(sourceType != null, "Field 'sourceType' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.SourceType = sourceType;
            this.ConstantValueOpt = constantValueOpt;
        }


        public BoundTypeExpression SourceType { get; private set; }

        public ConstantValue ConstantValueOpt { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitSizeOfOperator(this);
        }

        public BoundSizeOfOperator Update(BoundTypeExpression sourceType, ConstantValue constantValueOpt, TypeSymbol type)
        {
            if (sourceType != this.SourceType || constantValueOpt != this.ConstantValueOpt || type != this.Type)
            {
                var result = new BoundSizeOfOperator(this.Syntax, sourceType, constantValueOpt, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundConversion : BoundExpression
    {
        public BoundConversion(SyntaxNode syntax, BoundExpression operand, ConversionKind conversionKind, MethodSymbol symbolOpt, Boolean @checked, Boolean explicitCastInCode, Boolean isExtensionMethod, Boolean isArrayIndex, ConstantValue constantValueOpt, LookupResultKind resultKind, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.Conversion, syntax, type, hasErrors || operand.HasErrors())
        {

            Debug.Assert(operand != null, "Field 'operand' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Operand = operand;
            this.ConversionKind = conversionKind;
            this.SymbolOpt = symbolOpt;
            this.Checked = @checked;
            this.ExplicitCastInCode = explicitCastInCode;
            this.IsExtensionMethod = isExtensionMethod;
            this.IsArrayIndex = isArrayIndex;
            this.ConstantValueOpt = constantValueOpt;
            this._ResultKind = resultKind;
        }


        public BoundExpression Operand { get; private set; }

        public ConversionKind ConversionKind { get; private set; }

        public MethodSymbol SymbolOpt { get; private set; }

        public Boolean Checked { get; private set; }

        public Boolean ExplicitCastInCode { get; private set; }

        public Boolean IsExtensionMethod { get; private set; }

        public Boolean IsArrayIndex { get; private set; }

        public ConstantValue ConstantValueOpt { get; private set; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitConversion(this);
        }

        public BoundConversion Update(BoundExpression operand, ConversionKind conversionKind, MethodSymbol symbolOpt, Boolean @checked, Boolean explicitCastInCode, Boolean isExtensionMethod, Boolean isArrayIndex, ConstantValue constantValueOpt, LookupResultKind resultKind, TypeSymbol type)
        {
            if (operand != this.Operand || conversionKind != this.ConversionKind || symbolOpt != this.SymbolOpt || @checked != this.Checked || explicitCastInCode != this.ExplicitCastInCode || isExtensionMethod != this.IsExtensionMethod || isArrayIndex != this.IsArrayIndex || constantValueOpt != this.ConstantValueOpt || resultKind != this.ResultKind || type != this.Type)
            {
                var result = new BoundConversion(this.Syntax, operand, conversionKind, symbolOpt, @checked, explicitCastInCode, isExtensionMethod, isArrayIndex, constantValueOpt, resultKind, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundArgList : BoundExpression
    {
        public BoundArgList(SyntaxNode syntax, TypeSymbol type, bool hasErrors)
            : base(BoundKind.ArgList, syntax, type, hasErrors)
        {

            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

        }

        public BoundArgList(SyntaxNode syntax, TypeSymbol type)
            : base(BoundKind.ArgList, syntax, type)
        {

            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

        }


        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitArgList(this);
        }

        public BoundArgList Update(TypeSymbol type)
        {
            if (type != this.Type)
            {
                var result = new BoundArgList(this.Syntax, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundArgListOperator : BoundExpression
    {
        public BoundArgListOperator(SyntaxNode syntax, ReadOnlyArray<BoundExpression> arguments, ReadOnlyArray<RefKind> argumentRefKindsOpt, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.ArgListOperator, syntax, type, hasErrors || arguments.HasErrors())
        {

            Debug.Assert(!arguments.IsNull, "Field 'arguments' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Arguments = arguments;
            this.ArgumentRefKindsOpt = argumentRefKindsOpt;
        }


        public ReadOnlyArray<BoundExpression> Arguments { get; private set; }

        public ReadOnlyArray<RefKind> ArgumentRefKindsOpt { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitArgListOperator(this);
        }

        public BoundArgListOperator Update(ReadOnlyArray<BoundExpression> arguments, ReadOnlyArray<RefKind> argumentRefKindsOpt, TypeSymbol type)
        {
            if (arguments != this.Arguments || argumentRefKindsOpt != this.ArgumentRefKindsOpt || type != this.Type)
            {
                var result = new BoundArgListOperator(this.Syntax, arguments, argumentRefKindsOpt, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundFixedLocalCollectionInitializer : BoundExpression
    {
        public BoundFixedLocalCollectionInitializer(SyntaxNode syntax, TypeSymbol elementPointerType, Conversion elementPointerTypeConversion, MethodSymbol helperMethodOpt, BoundExpression expression, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.FixedLocalCollectionInitializer, syntax, type, hasErrors || expression.HasErrors())
        {

            Debug.Assert(elementPointerType != null, "Field 'elementPointerType' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(expression != null, "Field 'expression' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.ElementPointerType = elementPointerType;
            this.ElementPointerTypeConversion = elementPointerTypeConversion;
            this.HelperMethodOpt = helperMethodOpt;
            this.Expression = expression;
        }


        public TypeSymbol ElementPointerType { get; private set; }

        public Conversion ElementPointerTypeConversion { get; private set; }

        public MethodSymbol HelperMethodOpt { get; private set; }

        public BoundExpression Expression { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitFixedLocalCollectionInitializer(this);
        }

        public BoundFixedLocalCollectionInitializer Update(TypeSymbol elementPointerType, Conversion elementPointerTypeConversion, MethodSymbol helperMethodOpt, BoundExpression expression, TypeSymbol type)
        {
            if (elementPointerType != this.ElementPointerType || elementPointerTypeConversion != this.ElementPointerTypeConversion || helperMethodOpt != this.HelperMethodOpt || expression != this.Expression || type != this.Type)
            {
                var result = new BoundFixedLocalCollectionInitializer(this.Syntax, elementPointerType, elementPointerTypeConversion, helperMethodOpt, expression, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal abstract partial class BoundStatement : BoundNode
    {
        protected BoundStatement(BoundKind kind, SyntaxNode syntax, bool hasErrors)
            : base(kind, syntax, hasErrors)
        {
        }

        protected BoundStatement(BoundKind kind, SyntaxNode syntax)
            : base(kind, syntax)
        {
        }

    }

    internal sealed partial class BoundSequencePoint : BoundStatement
    {
        public BoundSequencePoint(SyntaxNode syntax, BoundStatement statementOpt, bool hasErrors = false)
            : base(BoundKind.SequencePoint, syntax, hasErrors || statementOpt.HasErrors())
        {
            this.StatementOpt = statementOpt;
        }


        public BoundStatement StatementOpt { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitSequencePoint(this);
        }

        public BoundSequencePoint Update(BoundStatement statementOpt)
        {
            if (statementOpt != this.StatementOpt)
            {
                var result = new BoundSequencePoint(this.Syntax, statementOpt, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundSequencePointWithSpan : BoundStatement
    {
        public BoundSequencePointWithSpan(SyntaxNode syntax, BoundStatement statementOpt, TextSpan span, bool hasErrors = false)
            : base(BoundKind.SequencePointWithSpan, syntax, hasErrors || statementOpt.HasErrors())
        {
            this.StatementOpt = statementOpt;
            this.Span = span;
        }


        public BoundStatement StatementOpt { get; private set; }

        public TextSpan Span { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitSequencePointWithSpan(this);
        }

        public BoundSequencePointWithSpan Update(BoundStatement statementOpt, TextSpan span)
        {
            if (statementOpt != this.StatementOpt || span != this.Span)
            {
                var result = new BoundSequencePointWithSpan(this.Syntax, statementOpt, span, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundBlock : BoundStatementList
    {
        public BoundBlock(SyntaxNode syntax, ReadOnlyArray<LocalSymbol> localsOpt, ReadOnlyArray<BoundStatement> statements, bool hasErrors = false)
            : base(BoundKind.Block, syntax, statements, hasErrors || statements.HasErrors())
        {

            Debug.Assert(!statements.IsNull, "Field 'statements' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.LocalsOpt = localsOpt;
        }


        public ReadOnlyArray<LocalSymbol> LocalsOpt { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitBlock(this);
        }

        public BoundBlock Update(ReadOnlyArray<LocalSymbol> localsOpt, ReadOnlyArray<BoundStatement> statements)
        {
            if (localsOpt != this.LocalsOpt || statements != this.Statements)
            {
                var result = new BoundBlock(this.Syntax, localsOpt, statements, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundIteratorScope : BoundStatement
    {
        public BoundIteratorScope(SyntaxNode syntax, ReadOnlyArray<FieldSymbol> fields, BoundStatement statement, bool hasErrors = false)
            : base(BoundKind.IteratorScope, syntax, hasErrors || statement.HasErrors())
        {

            Debug.Assert(!fields.IsNull, "Field 'fields' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(statement != null, "Field 'statement' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Fields = fields;
            this.Statement = statement;
        }


        public ReadOnlyArray<FieldSymbol> Fields { get; private set; }

        public BoundStatement Statement { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitIteratorScope(this);
        }

        public BoundIteratorScope Update(ReadOnlyArray<FieldSymbol> fields, BoundStatement statement)
        {
            if (fields != this.Fields || statement != this.Statement)
            {
                var result = new BoundIteratorScope(this.Syntax, fields, statement, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundLocalDeclaration : BoundStatement
    {
        public BoundLocalDeclaration(SyntaxNode syntax, LocalSymbol localSymbol, BoundTypeExpression declaredType, BoundExpression initializerOpt, ReadOnlyArray<BoundExpression> argumentsOpt, bool hasErrors = false)
            : base(BoundKind.LocalDeclaration, syntax, hasErrors || declaredType.HasErrors() || initializerOpt.HasErrors() || argumentsOpt.HasErrors())
        {

            Debug.Assert(localSymbol != null, "Field 'localSymbol' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(declaredType != null, "Field 'declaredType' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.LocalSymbol = localSymbol;
            this.DeclaredType = declaredType;
            this.InitializerOpt = initializerOpt;
            this.ArgumentsOpt = argumentsOpt;
        }


        public LocalSymbol LocalSymbol { get; private set; }

        public BoundTypeExpression DeclaredType { get; private set; }

        public BoundExpression InitializerOpt { get; private set; }

        public ReadOnlyArray<BoundExpression> ArgumentsOpt { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitLocalDeclaration(this);
        }

        public BoundLocalDeclaration Update(LocalSymbol localSymbol, BoundTypeExpression declaredType, BoundExpression initializerOpt, ReadOnlyArray<BoundExpression> argumentsOpt)
        {
            if (localSymbol != this.LocalSymbol || declaredType != this.DeclaredType || initializerOpt != this.InitializerOpt || argumentsOpt != this.ArgumentsOpt)
            {
                var result = new BoundLocalDeclaration(this.Syntax, localSymbol, declaredType, initializerOpt, argumentsOpt, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundMultipleLocalDeclarations : BoundStatement
    {
        public BoundMultipleLocalDeclarations(SyntaxNode syntax, ReadOnlyArray<BoundLocalDeclaration> localDeclarations, bool hasErrors = false)
            : base(BoundKind.MultipleLocalDeclarations, syntax, hasErrors || localDeclarations.HasErrors())
        {

            Debug.Assert(!localDeclarations.IsNull, "Field 'localDeclarations' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.LocalDeclarations = localDeclarations;
        }


        public ReadOnlyArray<BoundLocalDeclaration> LocalDeclarations { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitMultipleLocalDeclarations(this);
        }

        public BoundMultipleLocalDeclarations Update(ReadOnlyArray<BoundLocalDeclaration> localDeclarations)
        {
            if (localDeclarations != this.LocalDeclarations)
            {
                var result = new BoundMultipleLocalDeclarations(this.Syntax, localDeclarations, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundSequence : BoundExpression
    {
        public BoundSequence(SyntaxNode syntax, ReadOnlyArray<LocalSymbol> locals, ReadOnlyArray<BoundStatement> sideEffects, BoundExpression value, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.Sequence, syntax, type, hasErrors || sideEffects.HasErrors() || value.HasErrors())
        {

            Debug.Assert(!locals.IsNull, "Field 'locals' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(!sideEffects.IsNull, "Field 'sideEffects' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(value != null, "Field 'value' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Locals = locals;
            this.SideEffects = sideEffects;
            this.Value = value;
        }


        public ReadOnlyArray<LocalSymbol> Locals { get; private set; }

        public ReadOnlyArray<BoundStatement> SideEffects { get; private set; }

        public BoundExpression Value { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitSequence(this);
        }

        public BoundSequence Update(ReadOnlyArray<LocalSymbol> locals, ReadOnlyArray<BoundStatement> sideEffects, BoundExpression value, TypeSymbol type)
        {
            if (locals != this.Locals || sideEffects != this.SideEffects || value != this.Value || type != this.Type)
            {
                var result = new BoundSequence(this.Syntax, locals, sideEffects, value, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundNoOpStatement : BoundStatement
    {
        public BoundNoOpStatement(SyntaxNode syntax, bool hasErrors)
            : base(BoundKind.NoOpStatement, syntax, hasErrors)
        {
        }

        public BoundNoOpStatement(SyntaxNode syntax)
            : base(BoundKind.NoOpStatement, syntax)
        {
        }


        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitNoOpStatement(this);
        }
    }

    internal sealed partial class BoundReturnStatement : BoundStatement
    {
        public BoundReturnStatement(SyntaxNode syntax, BoundExpression expressionOpt, bool hasErrors = false)
            : base(BoundKind.ReturnStatement, syntax, hasErrors || expressionOpt.HasErrors())
        {
            this.ExpressionOpt = expressionOpt;
        }


        public BoundExpression ExpressionOpt { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitReturnStatement(this);
        }

        public BoundReturnStatement Update(BoundExpression expressionOpt)
        {
            if (expressionOpt != this.ExpressionOpt)
            {
                var result = new BoundReturnStatement(this.Syntax, expressionOpt, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundYieldReturnStatement : BoundStatement
    {
        public BoundYieldReturnStatement(SyntaxNode syntax, BoundExpression expression, bool hasErrors = false)
            : base(BoundKind.YieldReturnStatement, syntax, hasErrors || expression.HasErrors())
        {

            Debug.Assert(expression != null, "Field 'expression' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Expression = expression;
        }


        public BoundExpression Expression { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitYieldReturnStatement(this);
        }

        public BoundYieldReturnStatement Update(BoundExpression expression)
        {
            if (expression != this.Expression)
            {
                var result = new BoundYieldReturnStatement(this.Syntax, expression, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundYieldBreakStatement : BoundStatement
    {
        public BoundYieldBreakStatement(SyntaxNode syntax, bool hasErrors)
            : base(BoundKind.YieldBreakStatement, syntax, hasErrors)
        {
        }

        public BoundYieldBreakStatement(SyntaxNode syntax)
            : base(BoundKind.YieldBreakStatement, syntax)
        {
        }


        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitYieldBreakStatement(this);
        }
    }

    internal sealed partial class BoundThrowStatement : BoundStatement
    {
        public BoundThrowStatement(SyntaxNode syntax, BoundExpression expressionOpt, bool hasErrors = false)
            : base(BoundKind.ThrowStatement, syntax, hasErrors || expressionOpt.HasErrors())
        {
            this.ExpressionOpt = expressionOpt;
        }


        public BoundExpression ExpressionOpt { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitThrowStatement(this);
        }

        public BoundThrowStatement Update(BoundExpression expressionOpt)
        {
            if (expressionOpt != this.ExpressionOpt)
            {
                var result = new BoundThrowStatement(this.Syntax, expressionOpt, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundExpressionStatement : BoundStatement
    {
        public BoundExpressionStatement(SyntaxNode syntax, BoundExpression expression, bool hasErrors = false)
            : base(BoundKind.ExpressionStatement, syntax, hasErrors || expression.HasErrors())
        {

            Debug.Assert(expression != null, "Field 'expression' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Expression = expression;
        }


        public BoundExpression Expression { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitExpressionStatement(this);
        }

        public BoundExpressionStatement Update(BoundExpression expression)
        {
            if (expression != this.Expression)
            {
                var result = new BoundExpressionStatement(this.Syntax, expression, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundSwitchStatement : BoundStatement
    {
        public BoundSwitchStatement(SyntaxNode syntax, BoundExpression boundExpression, LabelSymbol constantTargetOpt, ReadOnlyArray<LocalSymbol> localsOpt, ReadOnlyArray<BoundSwitchSection> switchSections, GeneratedLabelSymbol breakLabel, bool hasErrors = false)
            : base(BoundKind.SwitchStatement, syntax, hasErrors || boundExpression.HasErrors() || switchSections.HasErrors())
        {

            Debug.Assert(boundExpression != null, "Field 'boundExpression' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(!switchSections.IsNull, "Field 'switchSections' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(breakLabel != null, "Field 'breakLabel' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.BoundExpression = boundExpression;
            this.ConstantTargetOpt = constantTargetOpt;
            this.LocalsOpt = localsOpt;
            this.SwitchSections = switchSections;
            this.BreakLabel = breakLabel;
        }


        public BoundExpression BoundExpression { get; private set; }

        public LabelSymbol ConstantTargetOpt { get; private set; }

        public ReadOnlyArray<LocalSymbol> LocalsOpt { get; private set; }

        public ReadOnlyArray<BoundSwitchSection> SwitchSections { get; private set; }

        public GeneratedLabelSymbol BreakLabel { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitSwitchStatement(this);
        }

        public BoundSwitchStatement Update(BoundExpression boundExpression, LabelSymbol constantTargetOpt, ReadOnlyArray<LocalSymbol> localsOpt, ReadOnlyArray<BoundSwitchSection> switchSections, GeneratedLabelSymbol breakLabel)
        {
            if (boundExpression != this.BoundExpression || constantTargetOpt != this.ConstantTargetOpt || localsOpt != this.LocalsOpt || switchSections != this.SwitchSections || breakLabel != this.BreakLabel)
            {
                var result = new BoundSwitchStatement(this.Syntax, boundExpression, constantTargetOpt, localsOpt, switchSections, breakLabel, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundSwitchSection : BoundStatementList
    {
        public BoundSwitchSection(SyntaxNode syntax, ReadOnlyArray<BoundSwitchLabel> boundSwitchLabels, ReadOnlyArray<BoundStatement> statements, bool hasErrors = false)
            : base(BoundKind.SwitchSection, syntax, statements, hasErrors || boundSwitchLabels.HasErrors() || statements.HasErrors())
        {

            Debug.Assert(!boundSwitchLabels.IsNull, "Field 'boundSwitchLabels' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(!statements.IsNull, "Field 'statements' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.BoundSwitchLabels = boundSwitchLabels;
        }


        public ReadOnlyArray<BoundSwitchLabel> BoundSwitchLabels { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitSwitchSection(this);
        }

        public BoundSwitchSection Update(ReadOnlyArray<BoundSwitchLabel> boundSwitchLabels, ReadOnlyArray<BoundStatement> statements)
        {
            if (boundSwitchLabels != this.BoundSwitchLabels || statements != this.Statements)
            {
                var result = new BoundSwitchSection(this.Syntax, boundSwitchLabels, statements, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundSwitchLabel : BoundNode
    {
        public BoundSwitchLabel(SyntaxNode syntax, LabelSymbol label, BoundExpression expressionOpt, bool hasErrors = false)
            : base(BoundKind.SwitchLabel, syntax, hasErrors || expressionOpt.HasErrors())
        {

            Debug.Assert(label != null, "Field 'label' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Label = label;
            this.ExpressionOpt = expressionOpt;
        }


        public LabelSymbol Label { get; private set; }

        public BoundExpression ExpressionOpt { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitSwitchLabel(this);
        }

        public BoundSwitchLabel Update(LabelSymbol label, BoundExpression expressionOpt)
        {
            if (label != this.Label || expressionOpt != this.ExpressionOpt)
            {
                var result = new BoundSwitchLabel(this.Syntax, label, expressionOpt, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundBreakStatement : BoundStatement
    {
        public BoundBreakStatement(SyntaxNode syntax, GeneratedLabelSymbol label, bool hasErrors)
            : base(BoundKind.BreakStatement, syntax, hasErrors)
        {

            Debug.Assert(label != null, "Field 'label' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Label = label;
        }

        public BoundBreakStatement(SyntaxNode syntax, GeneratedLabelSymbol label)
            : base(BoundKind.BreakStatement, syntax)
        {

            Debug.Assert(label != null, "Field 'label' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Label = label;
        }


        public GeneratedLabelSymbol Label { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitBreakStatement(this);
        }

        public BoundBreakStatement Update(GeneratedLabelSymbol label)
        {
            if (label != this.Label)
            {
                var result = new BoundBreakStatement(this.Syntax, label, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundContinueStatement : BoundStatement
    {
        public BoundContinueStatement(SyntaxNode syntax, GeneratedLabelSymbol label, bool hasErrors)
            : base(BoundKind.ContinueStatement, syntax, hasErrors)
        {

            Debug.Assert(label != null, "Field 'label' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Label = label;
        }

        public BoundContinueStatement(SyntaxNode syntax, GeneratedLabelSymbol label)
            : base(BoundKind.ContinueStatement, syntax)
        {

            Debug.Assert(label != null, "Field 'label' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Label = label;
        }


        public GeneratedLabelSymbol Label { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitContinueStatement(this);
        }

        public BoundContinueStatement Update(GeneratedLabelSymbol label)
        {
            if (label != this.Label)
            {
                var result = new BoundContinueStatement(this.Syntax, label, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundIfStatement : BoundStatement
    {
        public BoundIfStatement(SyntaxNode syntax, BoundExpression condition, BoundStatement consequence, BoundStatement alternativeOpt, bool hasErrors = false)
            : base(BoundKind.IfStatement, syntax, hasErrors || condition.HasErrors() || consequence.HasErrors() || alternativeOpt.HasErrors())
        {

            Debug.Assert(condition != null, "Field 'condition' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(consequence != null, "Field 'consequence' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Condition = condition;
            this.Consequence = consequence;
            this.AlternativeOpt = alternativeOpt;
        }


        public BoundExpression Condition { get; private set; }

        public BoundStatement Consequence { get; private set; }

        public BoundStatement AlternativeOpt { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitIfStatement(this);
        }

        public BoundIfStatement Update(BoundExpression condition, BoundStatement consequence, BoundStatement alternativeOpt)
        {
            if (condition != this.Condition || consequence != this.Consequence || alternativeOpt != this.AlternativeOpt)
            {
                var result = new BoundIfStatement(this.Syntax, condition, consequence, alternativeOpt, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal abstract partial class BoundLoopStatement : BoundStatement
    {
        protected BoundLoopStatement(BoundKind kind, SyntaxNode syntax, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel, bool hasErrors)
            : base(kind, syntax, hasErrors)
        {

            Debug.Assert(breakLabel != null, "Field 'breakLabel' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(continueLabel != null, "Field 'continueLabel' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.BreakLabel = breakLabel;
            this.ContinueLabel = continueLabel;
        }

        protected BoundLoopStatement(BoundKind kind, SyntaxNode syntax, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel)
            : base(kind, syntax)
        {

            Debug.Assert(breakLabel != null, "Field 'breakLabel' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(continueLabel != null, "Field 'continueLabel' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.BreakLabel = breakLabel;
            this.ContinueLabel = continueLabel;
        }


        public GeneratedLabelSymbol BreakLabel { get; private set; }

        public GeneratedLabelSymbol ContinueLabel { get; private set; }
    }

    internal sealed partial class BoundDoStatement : BoundLoopStatement
    {
        public BoundDoStatement(SyntaxNode syntax, BoundExpression condition, BoundStatement body, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel, bool hasErrors = false)
            : base(BoundKind.DoStatement, syntax, breakLabel, continueLabel, hasErrors || condition.HasErrors() || body.HasErrors())
        {

            Debug.Assert(condition != null, "Field 'condition' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(body != null, "Field 'body' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(breakLabel != null, "Field 'breakLabel' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(continueLabel != null, "Field 'continueLabel' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Condition = condition;
            this.Body = body;
        }


        public BoundExpression Condition { get; private set; }

        public BoundStatement Body { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitDoStatement(this);
        }

        public BoundDoStatement Update(BoundExpression condition, BoundStatement body, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel)
        {
            if (condition != this.Condition || body != this.Body || breakLabel != this.BreakLabel || continueLabel != this.ContinueLabel)
            {
                var result = new BoundDoStatement(this.Syntax, condition, body, breakLabel, continueLabel, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundWhileStatement : BoundLoopStatement
    {
        public BoundWhileStatement(SyntaxNode syntax, BoundExpression condition, BoundStatement body, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel, bool hasErrors = false)
            : base(BoundKind.WhileStatement, syntax, breakLabel, continueLabel, hasErrors || condition.HasErrors() || body.HasErrors())
        {

            Debug.Assert(condition != null, "Field 'condition' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(body != null, "Field 'body' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(breakLabel != null, "Field 'breakLabel' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(continueLabel != null, "Field 'continueLabel' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Condition = condition;
            this.Body = body;
        }


        public BoundExpression Condition { get; private set; }

        public BoundStatement Body { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitWhileStatement(this);
        }

        public BoundWhileStatement Update(BoundExpression condition, BoundStatement body, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel)
        {
            if (condition != this.Condition || body != this.Body || breakLabel != this.BreakLabel || continueLabel != this.ContinueLabel)
            {
                var result = new BoundWhileStatement(this.Syntax, condition, body, breakLabel, continueLabel, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundForStatement : BoundLoopStatement
    {
        public BoundForStatement(SyntaxNode syntax, ReadOnlyArray<LocalSymbol> locals, BoundStatement initializer, BoundExpression condition, BoundStatement increment, BoundStatement body, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel, bool hasErrors = false)
            : base(BoundKind.ForStatement, syntax, breakLabel, continueLabel, hasErrors || initializer.HasErrors() || condition.HasErrors() || increment.HasErrors() || body.HasErrors())
        {

            Debug.Assert(!locals.IsNull, "Field 'locals' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(body != null, "Field 'body' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(breakLabel != null, "Field 'breakLabel' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(continueLabel != null, "Field 'continueLabel' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Locals = locals;
            this.Initializer = initializer;
            this.Condition = condition;
            this.Increment = increment;
            this.Body = body;
        }


        public ReadOnlyArray<LocalSymbol> Locals { get; private set; }

        public BoundStatement Initializer { get; private set; }

        public BoundExpression Condition { get; private set; }

        public BoundStatement Increment { get; private set; }

        public BoundStatement Body { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitForStatement(this);
        }

        public BoundForStatement Update(ReadOnlyArray<LocalSymbol> locals, BoundStatement initializer, BoundExpression condition, BoundStatement increment, BoundStatement body, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel)
        {
            if (locals != this.Locals || initializer != this.Initializer || condition != this.Condition || increment != this.Increment || body != this.Body || breakLabel != this.BreakLabel || continueLabel != this.ContinueLabel)
            {
                var result = new BoundForStatement(this.Syntax, locals, initializer, condition, increment, body, breakLabel, continueLabel, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundForEachStatement : BoundLoopStatement
    {
        public BoundForEachStatement(SyntaxNode syntax, ForEachEnumeratorInfo enumeratorInfoOpt, Conversion elementConversion, BoundTypeExpression iterationVariableType, LocalSymbol iterationVariable, BoundExpression expression, BoundStatement body, Boolean @checked, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel, bool hasErrors = false)
            : base(BoundKind.ForEachStatement, syntax, breakLabel, continueLabel, hasErrors || iterationVariableType.HasErrors() || expression.HasErrors() || body.HasErrors())
        {

            Debug.Assert(iterationVariableType != null, "Field 'iterationVariableType' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(iterationVariable != null, "Field 'iterationVariable' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(expression != null, "Field 'expression' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(body != null, "Field 'body' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(breakLabel != null, "Field 'breakLabel' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(continueLabel != null, "Field 'continueLabel' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.EnumeratorInfoOpt = enumeratorInfoOpt;
            this.ElementConversion = elementConversion;
            this.IterationVariableType = iterationVariableType;
            this.IterationVariable = iterationVariable;
            this.Expression = expression;
            this.Body = body;
            this.Checked = @checked;
        }


        public ForEachEnumeratorInfo EnumeratorInfoOpt { get; private set; }

        public Conversion ElementConversion { get; private set; }

        public BoundTypeExpression IterationVariableType { get; private set; }

        public LocalSymbol IterationVariable { get; private set; }

        public BoundExpression Expression { get; private set; }

        public BoundStatement Body { get; private set; }

        public Boolean Checked { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitForEachStatement(this);
        }

        public BoundForEachStatement Update(ForEachEnumeratorInfo enumeratorInfoOpt, Conversion elementConversion, BoundTypeExpression iterationVariableType, LocalSymbol iterationVariable, BoundExpression expression, BoundStatement body, Boolean @checked, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel)
        {
            if (enumeratorInfoOpt != this.EnumeratorInfoOpt || elementConversion != this.ElementConversion || iterationVariableType != this.IterationVariableType || iterationVariable != this.IterationVariable || expression != this.Expression || body != this.Body || @checked != this.Checked || breakLabel != this.BreakLabel || continueLabel != this.ContinueLabel)
            {
                var result = new BoundForEachStatement(this.Syntax, enumeratorInfoOpt, elementConversion, iterationVariableType, iterationVariable, expression, body, @checked, breakLabel, continueLabel, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundUsingStatement : BoundStatement
    {
        public BoundUsingStatement(SyntaxNode syntax, ReadOnlyArray<LocalSymbol> localsOpt, BoundMultipleLocalDeclarations declarationsOpt, BoundExpression expressionOpt, Conversion iDisposableConversion, BoundStatement body, bool hasErrors = false)
            : base(BoundKind.UsingStatement, syntax, hasErrors || declarationsOpt.HasErrors() || expressionOpt.HasErrors() || body.HasErrors())
        {

            Debug.Assert(body != null, "Field 'body' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.LocalsOpt = localsOpt;
            this.DeclarationsOpt = declarationsOpt;
            this.ExpressionOpt = expressionOpt;
            this.IDisposableConversion = iDisposableConversion;
            this.Body = body;
        }


        public ReadOnlyArray<LocalSymbol> LocalsOpt { get; private set; }

        public BoundMultipleLocalDeclarations DeclarationsOpt { get; private set; }

        public BoundExpression ExpressionOpt { get; private set; }

        public Conversion IDisposableConversion { get; private set; }

        public BoundStatement Body { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitUsingStatement(this);
        }

        public BoundUsingStatement Update(ReadOnlyArray<LocalSymbol> localsOpt, BoundMultipleLocalDeclarations declarationsOpt, BoundExpression expressionOpt, Conversion iDisposableConversion, BoundStatement body)
        {
            if (localsOpt != this.LocalsOpt || declarationsOpt != this.DeclarationsOpt || expressionOpt != this.ExpressionOpt || iDisposableConversion != this.IDisposableConversion || body != this.Body)
            {
                var result = new BoundUsingStatement(this.Syntax, localsOpt, declarationsOpt, expressionOpt, iDisposableConversion, body, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundFixedStatement : BoundStatement
    {
        public BoundFixedStatement(SyntaxNode syntax, ReadOnlyArray<LocalSymbol> locals, BoundMultipleLocalDeclarations declarations, BoundStatement body, bool hasErrors = false)
            : base(BoundKind.FixedStatement, syntax, hasErrors || declarations.HasErrors() || body.HasErrors())
        {

            Debug.Assert(!locals.IsNull, "Field 'locals' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(declarations != null, "Field 'declarations' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(body != null, "Field 'body' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Locals = locals;
            this.Declarations = declarations;
            this.Body = body;
        }


        public ReadOnlyArray<LocalSymbol> Locals { get; private set; }

        public BoundMultipleLocalDeclarations Declarations { get; private set; }

        public BoundStatement Body { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitFixedStatement(this);
        }

        public BoundFixedStatement Update(ReadOnlyArray<LocalSymbol> locals, BoundMultipleLocalDeclarations declarations, BoundStatement body)
        {
            if (locals != this.Locals || declarations != this.Declarations || body != this.Body)
            {
                var result = new BoundFixedStatement(this.Syntax, locals, declarations, body, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundLockStatement : BoundStatement
    {
        public BoundLockStatement(SyntaxNode syntax, BoundExpression argument, BoundStatement body, MethodSymbol enterMethod, MethodSymbol exitMethod, bool hasErrors = false)
            : base(BoundKind.LockStatement, syntax, hasErrors || argument.HasErrors() || body.HasErrors())
        {

            Debug.Assert(argument != null, "Field 'argument' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(body != null, "Field 'body' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Argument = argument;
            this.Body = body;
            this.EnterMethod = enterMethod;
            this.ExitMethod = exitMethod;
        }


        public BoundExpression Argument { get; private set; }

        public BoundStatement Body { get; private set; }

        public MethodSymbol EnterMethod { get; private set; }

        public MethodSymbol ExitMethod { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitLockStatement(this);
        }

        public BoundLockStatement Update(BoundExpression argument, BoundStatement body, MethodSymbol enterMethod, MethodSymbol exitMethod)
        {
            if (argument != this.Argument || body != this.Body || enterMethod != this.EnterMethod || exitMethod != this.ExitMethod)
            {
                var result = new BoundLockStatement(this.Syntax, argument, body, enterMethod, exitMethod, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundTryStatement : BoundStatement
    {
        public BoundTryStatement(SyntaxNode syntax, BoundBlock tryBlock, ReadOnlyArray<BoundCatchBlock> catchBlocks, BoundBlock finallyBlockOpt, bool hasErrors = false)
            : base(BoundKind.TryStatement, syntax, hasErrors || tryBlock.HasErrors() || catchBlocks.HasErrors() || finallyBlockOpt.HasErrors())
        {

            Debug.Assert(tryBlock != null, "Field 'tryBlock' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(!catchBlocks.IsNull, "Field 'catchBlocks' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.TryBlock = tryBlock;
            this.CatchBlocks = catchBlocks;
            this.FinallyBlockOpt = finallyBlockOpt;
        }


        public BoundBlock TryBlock { get; private set; }

        public ReadOnlyArray<BoundCatchBlock> CatchBlocks { get; private set; }

        public BoundBlock FinallyBlockOpt { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitTryStatement(this);
        }

        public BoundTryStatement Update(BoundBlock tryBlock, ReadOnlyArray<BoundCatchBlock> catchBlocks, BoundBlock finallyBlockOpt)
        {
            if (tryBlock != this.TryBlock || catchBlocks != this.CatchBlocks || finallyBlockOpt != this.FinallyBlockOpt)
            {
                var result = new BoundTryStatement(this.Syntax, tryBlock, catchBlocks, finallyBlockOpt, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundCatchBlock : BoundNode
    {
        public BoundCatchBlock(SyntaxNode syntax, LocalSymbol localOpt, TypeSymbol exceptionTypeOpt, BoundBlock boundBlock, bool hasErrors = false)
            : base(BoundKind.CatchBlock, syntax, hasErrors || boundBlock.HasErrors())
        {

            Debug.Assert(boundBlock != null, "Field 'boundBlock' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.LocalOpt = localOpt;
            this.ExceptionTypeOpt = exceptionTypeOpt;
            this.BoundBlock = boundBlock;
        }


        public LocalSymbol LocalOpt { get; private set; }

        public TypeSymbol ExceptionTypeOpt { get; private set; }

        public BoundBlock BoundBlock { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitCatchBlock(this);
        }

        public BoundCatchBlock Update(LocalSymbol localOpt, TypeSymbol exceptionTypeOpt, BoundBlock boundBlock)
        {
            if (localOpt != this.LocalOpt || exceptionTypeOpt != this.ExceptionTypeOpt || boundBlock != this.BoundBlock)
            {
                var result = new BoundCatchBlock(this.Syntax, localOpt, exceptionTypeOpt, boundBlock, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundLiteral : BoundExpression
    {
        public BoundLiteral(SyntaxNode syntax, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors)
            : base(BoundKind.Literal, syntax, type, hasErrors)
        {
            this.ConstantValueOpt = constantValueOpt;
        }

        public BoundLiteral(SyntaxNode syntax, ConstantValue constantValueOpt, TypeSymbol type)
            : base(BoundKind.Literal, syntax, type)
        {
            this.ConstantValueOpt = constantValueOpt;
        }


        public ConstantValue ConstantValueOpt { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitLiteral(this);
        }

        public BoundLiteral Update(ConstantValue constantValueOpt, TypeSymbol type)
        {
            if (constantValueOpt != this.ConstantValueOpt || type != this.Type)
            {
                var result = new BoundLiteral(this.Syntax, constantValueOpt, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundThisReference : BoundExpression
    {
        public BoundThisReference(SyntaxNode syntax, ParameterSymbol thisSymbol, TypeSymbol type, bool hasErrors)
            : base(BoundKind.ThisReference, syntax, type, hasErrors)
        {

            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.ThisSymbol = thisSymbol;
        }

        public BoundThisReference(SyntaxNode syntax, ParameterSymbol thisSymbol, TypeSymbol type)
            : base(BoundKind.ThisReference, syntax, type)
        {

            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.ThisSymbol = thisSymbol;
        }


        public ParameterSymbol ThisSymbol { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitThisReference(this);
        }

        public BoundThisReference Update(ParameterSymbol thisSymbol, TypeSymbol type)
        {
            if (thisSymbol != this.ThisSymbol || type != this.Type)
            {
                var result = new BoundThisReference(this.Syntax, thisSymbol, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundPreviousSubmissionReference : BoundExpression
    {
        public BoundPreviousSubmissionReference(SyntaxNode syntax, NamedTypeSymbol sourceType, TypeSymbol type, bool hasErrors)
            : base(BoundKind.PreviousSubmissionReference, syntax, type, hasErrors)
        {

            Debug.Assert(sourceType != null, "Field 'sourceType' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.SourceType = sourceType;
        }

        public BoundPreviousSubmissionReference(SyntaxNode syntax, NamedTypeSymbol sourceType, TypeSymbol type)
            : base(BoundKind.PreviousSubmissionReference, syntax, type)
        {

            Debug.Assert(sourceType != null, "Field 'sourceType' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.SourceType = sourceType;
        }


        public NamedTypeSymbol SourceType { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitPreviousSubmissionReference(this);
        }

        public BoundPreviousSubmissionReference Update(NamedTypeSymbol sourceType, TypeSymbol type)
        {
            if (sourceType != this.SourceType || type != this.Type)
            {
                var result = new BoundPreviousSubmissionReference(this.Syntax, sourceType, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundHostObjectMemberReference : BoundExpression
    {
        public BoundHostObjectMemberReference(SyntaxNode syntax, TypeSymbol type, bool hasErrors)
            : base(BoundKind.HostObjectMemberReference, syntax, type, hasErrors)
        {

            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

        }

        public BoundHostObjectMemberReference(SyntaxNode syntax, TypeSymbol type)
            : base(BoundKind.HostObjectMemberReference, syntax, type)
        {

            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

        }


        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitHostObjectMemberReference(this);
        }

        public BoundHostObjectMemberReference Update(TypeSymbol type)
        {
            if (type != this.Type)
            {
                var result = new BoundHostObjectMemberReference(this.Syntax, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundBaseReference : BoundExpression
    {
        public BoundBaseReference(SyntaxNode syntax, ParameterSymbol thisSymbol, TypeSymbol type, bool hasErrors)
            : base(BoundKind.BaseReference, syntax, type, hasErrors)
        {
            this.ThisSymbol = thisSymbol;
        }

        public BoundBaseReference(SyntaxNode syntax, ParameterSymbol thisSymbol, TypeSymbol type)
            : base(BoundKind.BaseReference, syntax, type)
        {
            this.ThisSymbol = thisSymbol;
        }


        public ParameterSymbol ThisSymbol { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitBaseReference(this);
        }

        public BoundBaseReference Update(ParameterSymbol thisSymbol, TypeSymbol type)
        {
            if (thisSymbol != this.ThisSymbol || type != this.Type)
            {
                var result = new BoundBaseReference(this.Syntax, thisSymbol, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundLocal : BoundExpression
    {
        public BoundLocal(SyntaxNode syntax, LocalSymbol localSymbol, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors)
            : base(BoundKind.Local, syntax, type, hasErrors)
        {

            Debug.Assert(localSymbol != null, "Field 'localSymbol' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.LocalSymbol = localSymbol;
            this.ConstantValueOpt = constantValueOpt;
        }

        public BoundLocal(SyntaxNode syntax, LocalSymbol localSymbol, ConstantValue constantValueOpt, TypeSymbol type)
            : base(BoundKind.Local, syntax, type)
        {

            Debug.Assert(localSymbol != null, "Field 'localSymbol' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.LocalSymbol = localSymbol;
            this.ConstantValueOpt = constantValueOpt;
        }


        public LocalSymbol LocalSymbol { get; private set; }

        public ConstantValue ConstantValueOpt { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitLocal(this);
        }

        public BoundLocal Update(LocalSymbol localSymbol, ConstantValue constantValueOpt, TypeSymbol type)
        {
            if (localSymbol != this.LocalSymbol || constantValueOpt != this.ConstantValueOpt || type != this.Type)
            {
                var result = new BoundLocal(this.Syntax, localSymbol, constantValueOpt, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundRangeVariable : BoundExpression
    {
        public BoundRangeVariable(SyntaxNode syntax, RangeVariableSymbol rangeVariableSymbol, BoundExpression value, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.RangeVariable, syntax, type, hasErrors || value.HasErrors())
        {

            Debug.Assert(rangeVariableSymbol != null, "Field 'rangeVariableSymbol' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(value != null, "Field 'value' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.RangeVariableSymbol = rangeVariableSymbol;
            this.Value = value;
        }


        public RangeVariableSymbol RangeVariableSymbol { get; private set; }

        public BoundExpression Value { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitRangeVariable(this);
        }

        public BoundRangeVariable Update(RangeVariableSymbol rangeVariableSymbol, BoundExpression value, TypeSymbol type)
        {
            if (rangeVariableSymbol != this.RangeVariableSymbol || value != this.Value || type != this.Type)
            {
                var result = new BoundRangeVariable(this.Syntax, rangeVariableSymbol, value, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundParameter : BoundExpression
    {
        public BoundParameter(SyntaxNode syntax, ParameterSymbol parameterSymbol, TypeSymbol type, bool hasErrors)
            : base(BoundKind.Parameter, syntax, type, hasErrors)
        {

            Debug.Assert(parameterSymbol != null, "Field 'parameterSymbol' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.ParameterSymbol = parameterSymbol;
        }

        public BoundParameter(SyntaxNode syntax, ParameterSymbol parameterSymbol, TypeSymbol type)
            : base(BoundKind.Parameter, syntax, type)
        {

            Debug.Assert(parameterSymbol != null, "Field 'parameterSymbol' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.ParameterSymbol = parameterSymbol;
        }


        public ParameterSymbol ParameterSymbol { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitParameter(this);
        }

        public BoundParameter Update(ParameterSymbol parameterSymbol, TypeSymbol type)
        {
            if (parameterSymbol != this.ParameterSymbol || type != this.Type)
            {
                var result = new BoundParameter(this.Syntax, parameterSymbol, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundLabelStatement : BoundStatement
    {
        public BoundLabelStatement(SyntaxNode syntax, LabelSymbol label, bool hasErrors)
            : base(BoundKind.LabelStatement, syntax, hasErrors)
        {

            Debug.Assert(label != null, "Field 'label' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Label = label;
        }

        public BoundLabelStatement(SyntaxNode syntax, LabelSymbol label)
            : base(BoundKind.LabelStatement, syntax)
        {

            Debug.Assert(label != null, "Field 'label' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Label = label;
        }


        public LabelSymbol Label { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitLabelStatement(this);
        }

        public BoundLabelStatement Update(LabelSymbol label)
        {
            if (label != this.Label)
            {
                var result = new BoundLabelStatement(this.Syntax, label, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundGotoStatement : BoundStatement
    {
        public BoundGotoStatement(SyntaxNode syntax, LabelSymbol label, BoundExpression caseExpressionOpt, BoundLabel labelExpressionOpt, bool hasErrors = false)
            : base(BoundKind.GotoStatement, syntax, hasErrors || caseExpressionOpt.HasErrors() || labelExpressionOpt.HasErrors())
        {

            Debug.Assert(label != null, "Field 'label' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Label = label;
            this.CaseExpressionOpt = caseExpressionOpt;
            this.LabelExpressionOpt = labelExpressionOpt;
        }


        public LabelSymbol Label { get; private set; }

        public BoundExpression CaseExpressionOpt { get; private set; }

        public BoundLabel LabelExpressionOpt { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitGotoStatement(this);
        }

        public BoundGotoStatement Update(LabelSymbol label, BoundExpression caseExpressionOpt, BoundLabel labelExpressionOpt)
        {
            if (label != this.Label || caseExpressionOpt != this.CaseExpressionOpt || labelExpressionOpt != this.LabelExpressionOpt)
            {
                var result = new BoundGotoStatement(this.Syntax, label, caseExpressionOpt, labelExpressionOpt, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundLabeledStatement : BoundStatement
    {
        public BoundLabeledStatement(SyntaxNode syntax, LabelSymbol label, BoundStatement body, bool hasErrors = false)
            : base(BoundKind.LabeledStatement, syntax, hasErrors || body.HasErrors())
        {

            Debug.Assert(label != null, "Field 'label' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(body != null, "Field 'body' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Label = label;
            this.Body = body;
        }


        public LabelSymbol Label { get; private set; }

        public BoundStatement Body { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitLabeledStatement(this);
        }

        public BoundLabeledStatement Update(LabelSymbol label, BoundStatement body)
        {
            if (label != this.Label || body != this.Body)
            {
                var result = new BoundLabeledStatement(this.Syntax, label, body, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundLabel : BoundExpression
    {
        public BoundLabel(SyntaxNode syntax, LabelSymbol label, TypeSymbol type, bool hasErrors)
            : base(BoundKind.Label, syntax, type, hasErrors)
        {

            Debug.Assert(label != null, "Field 'label' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Label = label;
        }

        public BoundLabel(SyntaxNode syntax, LabelSymbol label, TypeSymbol type)
            : base(BoundKind.Label, syntax, type)
        {

            Debug.Assert(label != null, "Field 'label' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Label = label;
        }


        public LabelSymbol Label { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitLabel(this);
        }

        public BoundLabel Update(LabelSymbol label, TypeSymbol type)
        {
            if (label != this.Label || type != this.Type)
            {
                var result = new BoundLabel(this.Syntax, label, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal partial class BoundStatementList : BoundStatement
    {
        protected BoundStatementList(BoundKind kind, SyntaxNode syntax, ReadOnlyArray<BoundStatement> statements, bool hasErrors = false)
            : base(kind, syntax, hasErrors)
        {

            Debug.Assert(!statements.IsNull, "Field 'statements' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Statements = statements;
        }

        public BoundStatementList(SyntaxNode syntax, ReadOnlyArray<BoundStatement> statements, bool hasErrors = false)
            : base(BoundKind.StatementList, syntax, hasErrors || statements.HasErrors())
        {

            Debug.Assert(!statements.IsNull, "Field 'statements' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Statements = statements;
        }


        public ReadOnlyArray<BoundStatement> Statements { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitStatementList(this);
        }

        public BoundStatementList Update(ReadOnlyArray<BoundStatement> statements)
        {
            if (statements != this.Statements)
            {
                var result = new BoundStatementList(this.Syntax, statements, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundConditionalGoto : BoundStatement
    {
        public BoundConditionalGoto(SyntaxNode syntax, BoundExpression condition, bool jumpIfTrue, LabelSymbol label, bool hasErrors = false)
            : base(BoundKind.ConditionalGoto, syntax, hasErrors || condition.HasErrors())
        {

            Debug.Assert(condition != null, "Field 'condition' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(label != null, "Field 'label' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Condition = condition;
            this.JumpIfTrue = jumpIfTrue;
            this.Label = label;
        }


        public BoundExpression Condition { get; private set; }

        public bool JumpIfTrue { get; private set; }

        public LabelSymbol Label { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitConditionalGoto(this);
        }

        public BoundConditionalGoto Update(BoundExpression condition, bool jumpIfTrue, LabelSymbol label)
        {
            if (condition != this.Condition || jumpIfTrue != this.JumpIfTrue || label != this.Label)
            {
                var result = new BoundConditionalGoto(this.Syntax, condition, jumpIfTrue, label, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal abstract partial class BoundMethodOrPropertyGroup : BoundExpression
    {
        protected BoundMethodOrPropertyGroup(BoundKind kind, SyntaxNode syntax, BoundExpression receiverOpt, LookupResultKind resultKind, bool hasErrors = false)
            : base(kind, syntax, null, hasErrors)
        {
            this.ReceiverOpt = receiverOpt;
            this._ResultKind = resultKind;
        }


        public BoundExpression ReceiverOpt { get; private set; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }
    }

    internal sealed partial class BoundDynamicMemberAccess : BoundExpression
    {
        public BoundDynamicMemberAccess(SyntaxNode syntax, BoundExpression receiver, ReadOnlyArray<TypeSymbol> typeArgumentsOpt, string name, bool invoked, bool indexed, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.DynamicMemberAccess, syntax, type, hasErrors || receiver.HasErrors())
        {

            Debug.Assert(receiver != null, "Field 'receiver' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(name != null, "Field 'name' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Receiver = receiver;
            this.TypeArgumentsOpt = typeArgumentsOpt;
            this.Name = name;
            this.Invoked = invoked;
            this.Indexed = indexed;
        }


        public BoundExpression Receiver { get; private set; }

        public ReadOnlyArray<TypeSymbol> TypeArgumentsOpt { get; private set; }

        public string Name { get; private set; }

        public bool Invoked { get; private set; }

        public bool Indexed { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitDynamicMemberAccess(this);
        }

        public BoundDynamicMemberAccess Update(BoundExpression receiver, ReadOnlyArray<TypeSymbol> typeArgumentsOpt, string name, bool invoked, bool indexed, TypeSymbol type)
        {
            if (receiver != this.Receiver || typeArgumentsOpt != this.TypeArgumentsOpt || name != this.Name || invoked != this.Invoked || indexed != this.Indexed || type != this.Type)
            {
                var result = new BoundDynamicMemberAccess(this.Syntax, receiver, typeArgumentsOpt, name, invoked, indexed, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundDynamicInvocation : BoundExpression
    {
        public BoundDynamicInvocation(SyntaxNode syntax, BoundExpression expression, ReadOnlyArray<BoundExpression> arguments, ReadOnlyArray<string> argumentNamesOpt, ReadOnlyArray<RefKind> argumentRefKindsOpt, ReadOnlyArray<MethodSymbol> applicableMethods, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.DynamicInvocation, syntax, type, hasErrors || expression.HasErrors() || arguments.HasErrors())
        {

            Debug.Assert(expression != null, "Field 'expression' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(!arguments.IsNull, "Field 'arguments' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(!applicableMethods.IsNull, "Field 'applicableMethods' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Expression = expression;
            this.Arguments = arguments;
            this.ArgumentNamesOpt = argumentNamesOpt;
            this.ArgumentRefKindsOpt = argumentRefKindsOpt;
            this.ApplicableMethods = applicableMethods;
        }


        public BoundExpression Expression { get; private set; }

        public ReadOnlyArray<BoundExpression> Arguments { get; private set; }

        public ReadOnlyArray<string> ArgumentNamesOpt { get; private set; }

        public ReadOnlyArray<RefKind> ArgumentRefKindsOpt { get; private set; }

        public ReadOnlyArray<MethodSymbol> ApplicableMethods { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitDynamicInvocation(this);
        }

        public BoundDynamicInvocation Update(BoundExpression expression, ReadOnlyArray<BoundExpression> arguments, ReadOnlyArray<string> argumentNamesOpt, ReadOnlyArray<RefKind> argumentRefKindsOpt, ReadOnlyArray<MethodSymbol> applicableMethods, TypeSymbol type)
        {
            if (expression != this.Expression || arguments != this.Arguments || argumentNamesOpt != this.ArgumentNamesOpt || argumentRefKindsOpt != this.ArgumentRefKindsOpt || applicableMethods != this.ApplicableMethods || type != this.Type)
            {
                var result = new BoundDynamicInvocation(this.Syntax, expression, arguments, argumentNamesOpt, argumentRefKindsOpt, applicableMethods, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundMethodGroup : BoundMethodOrPropertyGroup
    {
        public BoundMethodGroup(SyntaxNode syntax, ReadOnlyArray<TypeSymbol> typeArgumentsOpt, string name, ReadOnlyArray<MethodSymbol> methods, Symbol lookupSymbolOpt, DiagnosticInfo lookupError, BoundMethodGroupFlags flags, BoundExpression receiverOpt, LookupResultKind resultKind, bool hasErrors = false)
            : base(BoundKind.MethodGroup, syntax, receiverOpt, resultKind, hasErrors || receiverOpt.HasErrors())
        {

            Debug.Assert(name != null, "Field 'name' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(!methods.IsNull, "Field 'methods' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.TypeArgumentsOpt = typeArgumentsOpt;
            this.Name = name;
            this.Methods = methods;
            this.LookupSymbolOpt = lookupSymbolOpt;
            this.LookupError = lookupError;
            this.Flags = flags;
        }


        public ReadOnlyArray<TypeSymbol> TypeArgumentsOpt { get; private set; }

        public string Name { get; private set; }

        public ReadOnlyArray<MethodSymbol> Methods { get; private set; }

        public Symbol LookupSymbolOpt { get; private set; }

        public DiagnosticInfo LookupError { get; private set; }

        public BoundMethodGroupFlags Flags { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitMethodGroup(this);
        }

        public BoundMethodGroup Update(ReadOnlyArray<TypeSymbol> typeArgumentsOpt, string name, ReadOnlyArray<MethodSymbol> methods, Symbol lookupSymbolOpt, DiagnosticInfo lookupError, BoundMethodGroupFlags flags, BoundExpression receiverOpt, LookupResultKind resultKind)
        {
            if (typeArgumentsOpt != this.TypeArgumentsOpt || name != this.Name || methods != this.Methods || lookupSymbolOpt != this.LookupSymbolOpt || lookupError != this.LookupError || flags != this.Flags || receiverOpt != this.ReceiverOpt || resultKind != this.ResultKind)
            {
                var result = new BoundMethodGroup(this.Syntax, typeArgumentsOpt, name, methods, lookupSymbolOpt, lookupError, flags, receiverOpt, resultKind, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundPropertyGroup : BoundMethodOrPropertyGroup
    {
        public BoundPropertyGroup(SyntaxNode syntax, ReadOnlyArray<PropertySymbol> properties, BoundExpression receiverOpt, LookupResultKind resultKind, bool hasErrors = false)
            : base(BoundKind.PropertyGroup, syntax, receiverOpt, resultKind, hasErrors || receiverOpt.HasErrors())
        {

            Debug.Assert(!properties.IsNull, "Field 'properties' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Properties = properties;
        }


        public ReadOnlyArray<PropertySymbol> Properties { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitPropertyGroup(this);
        }

        public BoundPropertyGroup Update(ReadOnlyArray<PropertySymbol> properties, BoundExpression receiverOpt, LookupResultKind resultKind)
        {
            if (properties != this.Properties || receiverOpt != this.ReceiverOpt || resultKind != this.ResultKind)
            {
                var result = new BoundPropertyGroup(this.Syntax, properties, receiverOpt, resultKind, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal partial class BoundCall : BoundExpression
    {
        protected BoundCall(BoundKind kind, SyntaxNode syntax, BoundExpression receiverOpt, MethodSymbol method, ReadOnlyArray<BoundExpression> arguments, ReadOnlyArray<string> argumentNamesOpt, ReadOnlyArray<RefKind> argumentRefKindsOpt, bool expanded, bool invokedAsExtensionMethod, ReadOnlyArray<int> argsToParamsOpt, LookupResultKind resultKind, TypeSymbol type, bool hasErrors = false)
            : base(kind, syntax, type, hasErrors)
        {

            Debug.Assert(method != null, "Field 'method' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(!arguments.IsNull, "Field 'arguments' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.ReceiverOpt = receiverOpt;
            this.Method = method;
            this.Arguments = arguments;
            this.ArgumentNamesOpt = argumentNamesOpt;
            this.ArgumentRefKindsOpt = argumentRefKindsOpt;
            this.Expanded = expanded;
            this.InvokedAsExtensionMethod = invokedAsExtensionMethod;
            this.ArgsToParamsOpt = argsToParamsOpt;
            this._ResultKind = resultKind;
        }

        public BoundCall(SyntaxNode syntax, BoundExpression receiverOpt, MethodSymbol method, ReadOnlyArray<BoundExpression> arguments, ReadOnlyArray<string> argumentNamesOpt, ReadOnlyArray<RefKind> argumentRefKindsOpt, bool expanded, bool invokedAsExtensionMethod, ReadOnlyArray<int> argsToParamsOpt, LookupResultKind resultKind, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.Call, syntax, type, hasErrors || receiverOpt.HasErrors() || arguments.HasErrors())
        {

            Debug.Assert(method != null, "Field 'method' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(!arguments.IsNull, "Field 'arguments' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.ReceiverOpt = receiverOpt;
            this.Method = method;
            this.Arguments = arguments;
            this.ArgumentNamesOpt = argumentNamesOpt;
            this.ArgumentRefKindsOpt = argumentRefKindsOpt;
            this.Expanded = expanded;
            this.InvokedAsExtensionMethod = invokedAsExtensionMethod;
            this.ArgsToParamsOpt = argsToParamsOpt;
            this._ResultKind = resultKind;
        }


        public BoundExpression ReceiverOpt { get; private set; }

        public MethodSymbol Method { get; private set; }

        public ReadOnlyArray<BoundExpression> Arguments { get; private set; }

        public ReadOnlyArray<string> ArgumentNamesOpt { get; private set; }

        public ReadOnlyArray<RefKind> ArgumentRefKindsOpt { get; private set; }

        public bool Expanded { get; private set; }

        public bool InvokedAsExtensionMethod { get; private set; }

        public ReadOnlyArray<int> ArgsToParamsOpt { get; private set; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitCall(this);
        }

        public BoundCall Update(BoundExpression receiverOpt, MethodSymbol method, ReadOnlyArray<BoundExpression> arguments, ReadOnlyArray<string> argumentNamesOpt, ReadOnlyArray<RefKind> argumentRefKindsOpt, bool expanded, bool invokedAsExtensionMethod, ReadOnlyArray<int> argsToParamsOpt, LookupResultKind resultKind, TypeSymbol type)
        {
            if (receiverOpt != this.ReceiverOpt || method != this.Method || arguments != this.Arguments || argumentNamesOpt != this.ArgumentNamesOpt || argumentRefKindsOpt != this.ArgumentRefKindsOpt || expanded != this.Expanded || invokedAsExtensionMethod != this.InvokedAsExtensionMethod || argsToParamsOpt != this.ArgsToParamsOpt || resultKind != this.ResultKind || type != this.Type)
            {
                var result = new BoundCall(this.Syntax, receiverOpt, method, arguments, argumentNamesOpt, argumentRefKindsOpt, expanded, invokedAsExtensionMethod, argsToParamsOpt, resultKind, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundEventAssignmentOperator : BoundExpression
    {
        public BoundEventAssignmentOperator(SyntaxNode syntax, EventSymbol @event, bool isAddition, bool isDynamic, BoundExpression receiverOpt, BoundExpression argument, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.EventAssignmentOperator, syntax, type, hasErrors || receiverOpt.HasErrors() || argument.HasErrors())
        {

            Debug.Assert(@event != null, "Field '@event' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(argument != null, "Field 'argument' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Event = @event;
            this.IsAddition = isAddition;
            this.IsDynamic = isDynamic;
            this.ReceiverOpt = receiverOpt;
            this.Argument = argument;
        }


        public EventSymbol Event { get; private set; }

        public bool IsAddition { get; private set; }

        public bool IsDynamic { get; private set; }

        public BoundExpression ReceiverOpt { get; private set; }

        public BoundExpression Argument { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitEventAssignmentOperator(this);
        }

        public BoundEventAssignmentOperator Update(EventSymbol @event, bool isAddition, bool isDynamic, BoundExpression receiverOpt, BoundExpression argument, TypeSymbol type)
        {
            if (@event != this.Event || isAddition != this.IsAddition || isDynamic != this.IsDynamic || receiverOpt != this.ReceiverOpt || argument != this.Argument || type != this.Type)
            {
                var result = new BoundEventAssignmentOperator(this.Syntax, @event, isAddition, isDynamic, receiverOpt, argument, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundDelegateCall : BoundCall
    {
        public BoundDelegateCall(SyntaxNode syntax, BoundExpression receiverOpt, MethodSymbol method, ReadOnlyArray<BoundExpression> arguments, ReadOnlyArray<string> argumentNamesOpt, ReadOnlyArray<RefKind> argumentRefKindsOpt, bool expanded, bool invokedAsExtensionMethod, ReadOnlyArray<int> argsToParamsOpt, LookupResultKind resultKind, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.DelegateCall, syntax, receiverOpt, method, arguments, argumentNamesOpt, argumentRefKindsOpt, expanded, invokedAsExtensionMethod, argsToParamsOpt, resultKind, type, hasErrors || receiverOpt.HasErrors() || arguments.HasErrors())
        {

            Debug.Assert(method != null, "Field 'method' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(!arguments.IsNull, "Field 'arguments' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

        }


        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitDelegateCall(this);
        }

        public new BoundDelegateCall Update(BoundExpression receiverOpt, MethodSymbol method, ReadOnlyArray<BoundExpression> arguments, ReadOnlyArray<string> argumentNamesOpt, ReadOnlyArray<RefKind> argumentRefKindsOpt, bool expanded, bool invokedAsExtensionMethod, ReadOnlyArray<int> argsToParamsOpt, LookupResultKind resultKind, TypeSymbol type)
        {
            if (receiverOpt != this.ReceiverOpt || method != this.Method || arguments != this.Arguments || argumentNamesOpt != this.ArgumentNamesOpt || argumentRefKindsOpt != this.ArgumentRefKindsOpt || expanded != this.Expanded || invokedAsExtensionMethod != this.InvokedAsExtensionMethod || argsToParamsOpt != this.ArgsToParamsOpt || resultKind != this.ResultKind || type != this.Type)
            {
                var result = new BoundDelegateCall(this.Syntax, receiverOpt, method, arguments, argumentNamesOpt, argumentRefKindsOpt, expanded, invokedAsExtensionMethod, argsToParamsOpt, resultKind, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundAttribute : BoundExpression
    {
        public BoundAttribute(SyntaxNode syntax, MethodSymbol constructor, ReadOnlyArray<BoundExpression> constructorArguments, ReadOnlyArray<string> constructorArgumentNamesOpt, ReadOnlyArray<BoundExpression> namedArguments, LookupResultKind resultKind, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.Attribute, syntax, type, hasErrors || constructorArguments.HasErrors() || namedArguments.HasErrors())
        {

            Debug.Assert(!constructorArguments.IsNull, "Field 'constructorArguments' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(!namedArguments.IsNull, "Field 'namedArguments' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Constructor = constructor;
            this.ConstructorArguments = constructorArguments;
            this.ConstructorArgumentNamesOpt = constructorArgumentNamesOpt;
            this.NamedArguments = namedArguments;
            this._ResultKind = resultKind;
        }


        public MethodSymbol Constructor { get; private set; }

        public ReadOnlyArray<BoundExpression> ConstructorArguments { get; private set; }

        public ReadOnlyArray<string> ConstructorArgumentNamesOpt { get; private set; }

        public ReadOnlyArray<BoundExpression> NamedArguments { get; private set; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitAttribute(this);
        }

        public BoundAttribute Update(MethodSymbol constructor, ReadOnlyArray<BoundExpression> constructorArguments, ReadOnlyArray<string> constructorArgumentNamesOpt, ReadOnlyArray<BoundExpression> namedArguments, LookupResultKind resultKind, TypeSymbol type)
        {
            if (constructor != this.Constructor || constructorArguments != this.ConstructorArguments || constructorArgumentNamesOpt != this.ConstructorArgumentNamesOpt || namedArguments != this.NamedArguments || resultKind != this.ResultKind || type != this.Type)
            {
                var result = new BoundAttribute(this.Syntax, constructor, constructorArguments, constructorArgumentNamesOpt, namedArguments, resultKind, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundObjectCreationExpression : BoundExpression
    {
        public BoundObjectCreationExpression(SyntaxNode syntax, MethodSymbol constructor, ReadOnlyArray<BoundExpression> arguments, ReadOnlyArray<string> argumentNamesOpt, ReadOnlyArray<RefKind> argumentRefKindsOpt, bool expanded, ReadOnlyArray<int> argsToParamsOpt, ConstantValue constantValueOpt, BoundExpression initializerExpressionOpt, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.ObjectCreationExpression, syntax, type, hasErrors || arguments.HasErrors() || initializerExpressionOpt.HasErrors())
        {

            Debug.Assert(constructor != null, "Field 'constructor' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(!arguments.IsNull, "Field 'arguments' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Constructor = constructor;
            this.Arguments = arguments;
            this.ArgumentNamesOpt = argumentNamesOpt;
            this.ArgumentRefKindsOpt = argumentRefKindsOpt;
            this.Expanded = expanded;
            this.ArgsToParamsOpt = argsToParamsOpt;
            this.ConstantValueOpt = constantValueOpt;
            this.InitializerExpressionOpt = initializerExpressionOpt;
        }


        public MethodSymbol Constructor { get; private set; }

        public ReadOnlyArray<BoundExpression> Arguments { get; private set; }

        public ReadOnlyArray<string> ArgumentNamesOpt { get; private set; }

        public ReadOnlyArray<RefKind> ArgumentRefKindsOpt { get; private set; }

        public bool Expanded { get; private set; }

        public ReadOnlyArray<int> ArgsToParamsOpt { get; private set; }

        public ConstantValue ConstantValueOpt { get; private set; }

        public BoundExpression InitializerExpressionOpt { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitObjectCreationExpression(this);
        }

        public BoundObjectCreationExpression Update(MethodSymbol constructor, ReadOnlyArray<BoundExpression> arguments, ReadOnlyArray<string> argumentNamesOpt, ReadOnlyArray<RefKind> argumentRefKindsOpt, bool expanded, ReadOnlyArray<int> argsToParamsOpt, ConstantValue constantValueOpt, BoundExpression initializerExpressionOpt, TypeSymbol type)
        {
            if (constructor != this.Constructor || arguments != this.Arguments || argumentNamesOpt != this.ArgumentNamesOpt || argumentRefKindsOpt != this.ArgumentRefKindsOpt || expanded != this.Expanded || argsToParamsOpt != this.ArgsToParamsOpt || constantValueOpt != this.ConstantValueOpt || initializerExpressionOpt != this.InitializerExpressionOpt || type != this.Type)
            {
                var result = new BoundObjectCreationExpression(this.Syntax, constructor, arguments, argumentNamesOpt, argumentRefKindsOpt, expanded, argsToParamsOpt, constantValueOpt, initializerExpressionOpt, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundDynamicObjectCreationExpression : BoundExpression
    {
        public BoundDynamicObjectCreationExpression(SyntaxNode syntax, ReadOnlyArray<BoundExpression> arguments, ReadOnlyArray<string> argumentNamesOpt, ReadOnlyArray<RefKind> argumentRefKindsOpt, BoundExpression initializerExpressionOpt, ReadOnlyArray<MethodSymbol> applicableMethods, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.DynamicObjectCreationExpression, syntax, type, hasErrors || arguments.HasErrors() || initializerExpressionOpt.HasErrors())
        {

            Debug.Assert(!arguments.IsNull, "Field 'arguments' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(!applicableMethods.IsNull, "Field 'applicableMethods' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Arguments = arguments;
            this.ArgumentNamesOpt = argumentNamesOpt;
            this.ArgumentRefKindsOpt = argumentRefKindsOpt;
            this.InitializerExpressionOpt = initializerExpressionOpt;
            this.ApplicableMethods = applicableMethods;
        }


        public ReadOnlyArray<BoundExpression> Arguments { get; private set; }

        public ReadOnlyArray<string> ArgumentNamesOpt { get; private set; }

        public ReadOnlyArray<RefKind> ArgumentRefKindsOpt { get; private set; }

        public BoundExpression InitializerExpressionOpt { get; private set; }

        public ReadOnlyArray<MethodSymbol> ApplicableMethods { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitDynamicObjectCreationExpression(this);
        }

        public BoundDynamicObjectCreationExpression Update(ReadOnlyArray<BoundExpression> arguments, ReadOnlyArray<string> argumentNamesOpt, ReadOnlyArray<RefKind> argumentRefKindsOpt, BoundExpression initializerExpressionOpt, ReadOnlyArray<MethodSymbol> applicableMethods, TypeSymbol type)
        {
            if (arguments != this.Arguments || argumentNamesOpt != this.ArgumentNamesOpt || argumentRefKindsOpt != this.ArgumentRefKindsOpt || initializerExpressionOpt != this.InitializerExpressionOpt || applicableMethods != this.ApplicableMethods || type != this.Type)
            {
                var result = new BoundDynamicObjectCreationExpression(this.Syntax, arguments, argumentNamesOpt, argumentRefKindsOpt, initializerExpressionOpt, applicableMethods, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundObjectInitializerExpression : BoundExpression
    {
        public BoundObjectInitializerExpression(SyntaxNode syntax, ReadOnlyArray<BoundExpression> initializers, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.ObjectInitializerExpression, syntax, type, hasErrors || initializers.HasErrors())
        {

            Debug.Assert(!initializers.IsNull, "Field 'initializers' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Initializers = initializers;
        }


        public ReadOnlyArray<BoundExpression> Initializers { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitObjectInitializerExpression(this);
        }

        public BoundObjectInitializerExpression Update(ReadOnlyArray<BoundExpression> initializers, TypeSymbol type)
        {
            if (initializers != this.Initializers || type != this.Type)
            {
                var result = new BoundObjectInitializerExpression(this.Syntax, initializers, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundObjectInitializerMember : BoundExpression
    {
        public BoundObjectInitializerMember(SyntaxNode syntax, Symbol memberSymbol, LookupResultKind resultKind, TypeSymbol type, bool hasErrors)
            : base(BoundKind.ObjectInitializerMember, syntax, type, hasErrors)
        {

            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.MemberSymbol = memberSymbol;
            this._ResultKind = resultKind;
        }

        public BoundObjectInitializerMember(SyntaxNode syntax, Symbol memberSymbol, LookupResultKind resultKind, TypeSymbol type)
            : base(BoundKind.ObjectInitializerMember, syntax, type)
        {

            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.MemberSymbol = memberSymbol;
            this._ResultKind = resultKind;
        }


        public Symbol MemberSymbol { get; private set; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitObjectInitializerMember(this);
        }

        public BoundObjectInitializerMember Update(Symbol memberSymbol, LookupResultKind resultKind, TypeSymbol type)
        {
            if (memberSymbol != this.MemberSymbol || resultKind != this.ResultKind || type != this.Type)
            {
                var result = new BoundObjectInitializerMember(this.Syntax, memberSymbol, resultKind, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundCollectionInitializerExpression : BoundExpression
    {
        public BoundCollectionInitializerExpression(SyntaxNode syntax, ReadOnlyArray<BoundExpression> initializers, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.CollectionInitializerExpression, syntax, type, hasErrors || initializers.HasErrors())
        {

            Debug.Assert(!initializers.IsNull, "Field 'initializers' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Initializers = initializers;
        }


        public ReadOnlyArray<BoundExpression> Initializers { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitCollectionInitializerExpression(this);
        }

        public BoundCollectionInitializerExpression Update(ReadOnlyArray<BoundExpression> initializers, TypeSymbol type)
        {
            if (initializers != this.Initializers || type != this.Type)
            {
                var result = new BoundCollectionInitializerExpression(this.Syntax, initializers, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundCollectionElementInitializer : BoundExpression
    {
        public BoundCollectionElementInitializer(SyntaxNode syntax, MethodSymbol addMethod, ReadOnlyArray<BoundExpression> arguments, bool expanded, ReadOnlyArray<int> argsToParamsOpt, bool invokedAsExtensionMethod, LookupResultKind resultKind, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.CollectionElementInitializer, syntax, type, hasErrors || arguments.HasErrors())
        {

            Debug.Assert(addMethod != null, "Field 'addMethod' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(!arguments.IsNull, "Field 'arguments' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.AddMethod = addMethod;
            this.Arguments = arguments;
            this.Expanded = expanded;
            this.ArgsToParamsOpt = argsToParamsOpt;
            this.InvokedAsExtensionMethod = invokedAsExtensionMethod;
            this._ResultKind = resultKind;
        }


        public MethodSymbol AddMethod { get; private set; }

        public ReadOnlyArray<BoundExpression> Arguments { get; private set; }

        public bool Expanded { get; private set; }

        public ReadOnlyArray<int> ArgsToParamsOpt { get; private set; }

        public bool InvokedAsExtensionMethod { get; private set; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitCollectionElementInitializer(this);
        }

        public BoundCollectionElementInitializer Update(MethodSymbol addMethod, ReadOnlyArray<BoundExpression> arguments, bool expanded, ReadOnlyArray<int> argsToParamsOpt, bool invokedAsExtensionMethod, LookupResultKind resultKind, TypeSymbol type)
        {
            if (addMethod != this.AddMethod || arguments != this.Arguments || expanded != this.Expanded || argsToParamsOpt != this.ArgsToParamsOpt || invokedAsExtensionMethod != this.InvokedAsExtensionMethod || resultKind != this.ResultKind || type != this.Type)
            {
                var result = new BoundCollectionElementInitializer(this.Syntax, addMethod, arguments, expanded, argsToParamsOpt, invokedAsExtensionMethod, resultKind, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundDynamicCollectionElementInitializer : BoundExpression
    {
        public BoundDynamicCollectionElementInitializer(SyntaxNode syntax, ReadOnlyArray<BoundExpression> arguments, ReadOnlyArray<string> argumentNamesOpt, ReadOnlyArray<RefKind> argumentRefKindsOpt, ReadOnlyArray<MethodSymbol> applicableMethods, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.DynamicCollectionElementInitializer, syntax, type, hasErrors || arguments.HasErrors())
        {

            Debug.Assert(!arguments.IsNull, "Field 'arguments' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(!applicableMethods.IsNull, "Field 'applicableMethods' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Arguments = arguments;
            this.ArgumentNamesOpt = argumentNamesOpt;
            this.ArgumentRefKindsOpt = argumentRefKindsOpt;
            this.ApplicableMethods = applicableMethods;
        }


        public ReadOnlyArray<BoundExpression> Arguments { get; private set; }

        public ReadOnlyArray<string> ArgumentNamesOpt { get; private set; }

        public ReadOnlyArray<RefKind> ArgumentRefKindsOpt { get; private set; }

        public ReadOnlyArray<MethodSymbol> ApplicableMethods { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitDynamicCollectionElementInitializer(this);
        }

        public BoundDynamicCollectionElementInitializer Update(ReadOnlyArray<BoundExpression> arguments, ReadOnlyArray<string> argumentNamesOpt, ReadOnlyArray<RefKind> argumentRefKindsOpt, ReadOnlyArray<MethodSymbol> applicableMethods, TypeSymbol type)
        {
            if (arguments != this.Arguments || argumentNamesOpt != this.ArgumentNamesOpt || argumentRefKindsOpt != this.ArgumentRefKindsOpt || applicableMethods != this.ApplicableMethods || type != this.Type)
            {
                var result = new BoundDynamicCollectionElementInitializer(this.Syntax, arguments, argumentNamesOpt, argumentRefKindsOpt, applicableMethods, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundImplicitReceiver : BoundExpression
    {
        public BoundImplicitReceiver(SyntaxNode syntax, TypeSymbol type, bool hasErrors)
            : base(BoundKind.ImplicitReceiver, syntax, type, hasErrors)
        {

            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

        }

        public BoundImplicitReceiver(SyntaxNode syntax, TypeSymbol type)
            : base(BoundKind.ImplicitReceiver, syntax, type)
        {

            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

        }


        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitImplicitReceiver(this);
        }

        public BoundImplicitReceiver Update(TypeSymbol type)
        {
            if (type != this.Type)
            {
                var result = new BoundImplicitReceiver(this.Syntax, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundAnonymousObjectCreationExpression : BoundExpression
    {
        public BoundAnonymousObjectCreationExpression(SyntaxNode syntax, MethodSymbol constructor, ReadOnlyArray<BoundExpression> arguments, ReadOnlyArray<BoundAnonymousPropertyDeclaration> declarations, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.AnonymousObjectCreationExpression, syntax, type, hasErrors || arguments.HasErrors() || declarations.HasErrors())
        {

            Debug.Assert(constructor != null, "Field 'constructor' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(!arguments.IsNull, "Field 'arguments' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(!declarations.IsNull, "Field 'declarations' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Constructor = constructor;
            this.Arguments = arguments;
            this.Declarations = declarations;
        }


        public MethodSymbol Constructor { get; private set; }

        public ReadOnlyArray<BoundExpression> Arguments { get; private set; }

        public ReadOnlyArray<BoundAnonymousPropertyDeclaration> Declarations { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitAnonymousObjectCreationExpression(this);
        }

        public BoundAnonymousObjectCreationExpression Update(MethodSymbol constructor, ReadOnlyArray<BoundExpression> arguments, ReadOnlyArray<BoundAnonymousPropertyDeclaration> declarations, TypeSymbol type)
        {
            if (constructor != this.Constructor || arguments != this.Arguments || declarations != this.Declarations || type != this.Type)
            {
                var result = new BoundAnonymousObjectCreationExpression(this.Syntax, constructor, arguments, declarations, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundAnonymousPropertyDeclaration : BoundExpression
    {
        public BoundAnonymousPropertyDeclaration(SyntaxNode syntax, PropertySymbol property, TypeSymbol type, bool hasErrors)
            : base(BoundKind.AnonymousPropertyDeclaration, syntax, type, hasErrors)
        {

            Debug.Assert(property != null, "Field 'property' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Property = property;
        }

        public BoundAnonymousPropertyDeclaration(SyntaxNode syntax, PropertySymbol property, TypeSymbol type)
            : base(BoundKind.AnonymousPropertyDeclaration, syntax, type)
        {

            Debug.Assert(property != null, "Field 'property' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Property = property;
        }


        public PropertySymbol Property { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitAnonymousPropertyDeclaration(this);
        }

        public BoundAnonymousPropertyDeclaration Update(PropertySymbol property, TypeSymbol type)
        {
            if (property != this.Property || type != this.Type)
            {
                var result = new BoundAnonymousPropertyDeclaration(this.Syntax, property, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundNewT : BoundExpression
    {
        public BoundNewT(SyntaxNode syntax, BoundExpression initializerExpressionOpt, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.NewT, syntax, type, hasErrors || initializerExpressionOpt.HasErrors())
        {

            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.InitializerExpressionOpt = initializerExpressionOpt;
        }


        public BoundExpression InitializerExpressionOpt { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitNewT(this);
        }

        public BoundNewT Update(BoundExpression initializerExpressionOpt, TypeSymbol type)
        {
            if (initializerExpressionOpt != this.InitializerExpressionOpt || type != this.Type)
            {
                var result = new BoundNewT(this.Syntax, initializerExpressionOpt, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundDelegateCreationExpression : BoundExpression
    {
        public BoundDelegateCreationExpression(SyntaxNode syntax, BoundExpression argument, MethodSymbol methodOpt, bool isExtensionMethod, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.DelegateCreationExpression, syntax, type, hasErrors || argument.HasErrors())
        {

            Debug.Assert(argument != null, "Field 'argument' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Argument = argument;
            this.MethodOpt = methodOpt;
            this.IsExtensionMethod = isExtensionMethod;
        }


        public BoundExpression Argument { get; private set; }

        public MethodSymbol MethodOpt { get; private set; }

        public bool IsExtensionMethod { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitDelegateCreationExpression(this);
        }

        public BoundDelegateCreationExpression Update(BoundExpression argument, MethodSymbol methodOpt, bool isExtensionMethod, TypeSymbol type)
        {
            if (argument != this.Argument || methodOpt != this.MethodOpt || isExtensionMethod != this.IsExtensionMethod || type != this.Type)
            {
                var result = new BoundDelegateCreationExpression(this.Syntax, argument, methodOpt, isExtensionMethod, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundArrayCreation : BoundExpression
    {
        public BoundArrayCreation(SyntaxNode syntax, ReadOnlyArray<BoundExpression> bounds, BoundArrayInitialization initializerOpt, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.ArrayCreation, syntax, type, hasErrors || bounds.HasErrors() || initializerOpt.HasErrors())
        {

            Debug.Assert(!bounds.IsNull, "Field 'bounds' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Bounds = bounds;
            this.InitializerOpt = initializerOpt;
        }


        public ReadOnlyArray<BoundExpression> Bounds { get; private set; }

        public BoundArrayInitialization InitializerOpt { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitArrayCreation(this);
        }

        public BoundArrayCreation Update(ReadOnlyArray<BoundExpression> bounds, BoundArrayInitialization initializerOpt, TypeSymbol type)
        {
            if (bounds != this.Bounds || initializerOpt != this.InitializerOpt || type != this.Type)
            {
                var result = new BoundArrayCreation(this.Syntax, bounds, initializerOpt, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundArrayInitialization : BoundExpression
    {
        public BoundArrayInitialization(SyntaxNode syntax, ReadOnlyArray<BoundExpression> initializers, bool hasErrors = false)
            : base(BoundKind.ArrayInitialization, syntax, null, hasErrors || initializers.HasErrors())
        {

            Debug.Assert(!initializers.IsNull, "Field 'initializers' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Initializers = initializers;
        }


        public ReadOnlyArray<BoundExpression> Initializers { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitArrayInitialization(this);
        }

        public BoundArrayInitialization Update(ReadOnlyArray<BoundExpression> initializers)
        {
            if (initializers != this.Initializers)
            {
                var result = new BoundArrayInitialization(this.Syntax, initializers, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundStackAllocArrayCreation : BoundExpression
    {
        public BoundStackAllocArrayCreation(SyntaxNode syntax, BoundExpression count, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.StackAllocArrayCreation, syntax, type, hasErrors || count.HasErrors())
        {

            Debug.Assert(count != null, "Field 'count' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Count = count;
        }


        public BoundExpression Count { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitStackAllocArrayCreation(this);
        }

        public BoundStackAllocArrayCreation Update(BoundExpression count, TypeSymbol type)
        {
            if (count != this.Count || type != this.Type)
            {
                var result = new BoundStackAllocArrayCreation(this.Syntax, count, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundFieldAccess : BoundExpression
    {
        public BoundFieldAccess(SyntaxNode syntax, BoundExpression receiverOpt, FieldSymbol fieldSymbol, ConstantValue constantValueOpt, LookupResultKind resultKind, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.FieldAccess, syntax, type, hasErrors || receiverOpt.HasErrors())
        {

            Debug.Assert(fieldSymbol != null, "Field 'fieldSymbol' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.ReceiverOpt = receiverOpt;
            this.FieldSymbol = fieldSymbol;
            this.ConstantValueOpt = constantValueOpt;
            this._ResultKind = resultKind;
        }


        public BoundExpression ReceiverOpt { get; private set; }

        public FieldSymbol FieldSymbol { get; private set; }

        public ConstantValue ConstantValueOpt { get; private set; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitFieldAccess(this);
        }

        public BoundFieldAccess Update(BoundExpression receiverOpt, FieldSymbol fieldSymbol, ConstantValue constantValueOpt, LookupResultKind resultKind, TypeSymbol type)
        {
            if (receiverOpt != this.ReceiverOpt || fieldSymbol != this.FieldSymbol || constantValueOpt != this.ConstantValueOpt || resultKind != this.ResultKind || type != this.Type)
            {
                var result = new BoundFieldAccess(this.Syntax, receiverOpt, fieldSymbol, constantValueOpt, resultKind, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundPropertyAccess : BoundExpression
    {
        public BoundPropertyAccess(SyntaxNode syntax, BoundExpression receiverOpt, PropertySymbol propertySymbol, LookupResultKind resultKind, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.PropertyAccess, syntax, type, hasErrors || receiverOpt.HasErrors())
        {

            Debug.Assert(propertySymbol != null, "Field 'propertySymbol' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.ReceiverOpt = receiverOpt;
            this.PropertySymbol = propertySymbol;
            this._ResultKind = resultKind;
        }


        public BoundExpression ReceiverOpt { get; private set; }

        public PropertySymbol PropertySymbol { get; private set; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitPropertyAccess(this);
        }

        public BoundPropertyAccess Update(BoundExpression receiverOpt, PropertySymbol propertySymbol, LookupResultKind resultKind, TypeSymbol type)
        {
            if (receiverOpt != this.ReceiverOpt || propertySymbol != this.PropertySymbol || resultKind != this.ResultKind || type != this.Type)
            {
                var result = new BoundPropertyAccess(this.Syntax, receiverOpt, propertySymbol, resultKind, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundEventAccess : BoundExpression
    {
        public BoundEventAccess(SyntaxNode syntax, BoundExpression receiverOpt, EventSymbol eventSymbol, bool isUsableAsField, LookupResultKind resultKind, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.EventAccess, syntax, type, hasErrors || receiverOpt.HasErrors())
        {

            Debug.Assert(eventSymbol != null, "Field 'eventSymbol' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.ReceiverOpt = receiverOpt;
            this.EventSymbol = eventSymbol;
            this.IsUsableAsField = isUsableAsField;
            this._ResultKind = resultKind;
        }


        public BoundExpression ReceiverOpt { get; private set; }

        public EventSymbol EventSymbol { get; private set; }

        public bool IsUsableAsField { get; private set; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitEventAccess(this);
        }

        public BoundEventAccess Update(BoundExpression receiverOpt, EventSymbol eventSymbol, bool isUsableAsField, LookupResultKind resultKind, TypeSymbol type)
        {
            if (receiverOpt != this.ReceiverOpt || eventSymbol != this.EventSymbol || isUsableAsField != this.IsUsableAsField || resultKind != this.ResultKind || type != this.Type)
            {
                var result = new BoundEventAccess(this.Syntax, receiverOpt, eventSymbol, isUsableAsField, resultKind, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundIndexerAccess : BoundExpression
    {
        public BoundIndexerAccess(SyntaxNode syntax, BoundExpression receiverOpt, PropertySymbol indexer, ReadOnlyArray<BoundExpression> arguments, ReadOnlyArray<string> argumentNamesOpt, ReadOnlyArray<RefKind> argumentRefKindsOpt, bool expanded, ReadOnlyArray<int> argsToParamsOpt, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.IndexerAccess, syntax, type, hasErrors || receiverOpt.HasErrors() || arguments.HasErrors())
        {

            Debug.Assert(indexer != null, "Field 'indexer' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(!arguments.IsNull, "Field 'arguments' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.ReceiverOpt = receiverOpt;
            this.Indexer = indexer;
            this.Arguments = arguments;
            this.ArgumentNamesOpt = argumentNamesOpt;
            this.ArgumentRefKindsOpt = argumentRefKindsOpt;
            this.Expanded = expanded;
            this.ArgsToParamsOpt = argsToParamsOpt;
        }


        public BoundExpression ReceiverOpt { get; private set; }

        public PropertySymbol Indexer { get; private set; }

        public ReadOnlyArray<BoundExpression> Arguments { get; private set; }

        public ReadOnlyArray<string> ArgumentNamesOpt { get; private set; }

        public ReadOnlyArray<RefKind> ArgumentRefKindsOpt { get; private set; }

        public bool Expanded { get; private set; }

        public ReadOnlyArray<int> ArgsToParamsOpt { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitIndexerAccess(this);
        }

        public BoundIndexerAccess Update(BoundExpression receiverOpt, PropertySymbol indexer, ReadOnlyArray<BoundExpression> arguments, ReadOnlyArray<string> argumentNamesOpt, ReadOnlyArray<RefKind> argumentRefKindsOpt, bool expanded, ReadOnlyArray<int> argsToParamsOpt, TypeSymbol type)
        {
            if (receiverOpt != this.ReceiverOpt || indexer != this.Indexer || arguments != this.Arguments || argumentNamesOpt != this.ArgumentNamesOpt || argumentRefKindsOpt != this.ArgumentRefKindsOpt || expanded != this.Expanded || argsToParamsOpt != this.ArgsToParamsOpt || type != this.Type)
            {
                var result = new BoundIndexerAccess(this.Syntax, receiverOpt, indexer, arguments, argumentNamesOpt, argumentRefKindsOpt, expanded, argsToParamsOpt, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundDynamicIndexerAccess : BoundExpression
    {
        public BoundDynamicIndexerAccess(SyntaxNode syntax, BoundExpression receiverOpt, ReadOnlyArray<BoundExpression> arguments, ReadOnlyArray<string> argumentNamesOpt, ReadOnlyArray<RefKind> argumentRefKindsOpt, ReadOnlyArray<PropertySymbol> applicableIndexers, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.DynamicIndexerAccess, syntax, type, hasErrors || receiverOpt.HasErrors() || arguments.HasErrors())
        {

            Debug.Assert(!arguments.IsNull, "Field 'arguments' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(!applicableIndexers.IsNull, "Field 'applicableIndexers' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.ReceiverOpt = receiverOpt;
            this.Arguments = arguments;
            this.ArgumentNamesOpt = argumentNamesOpt;
            this.ArgumentRefKindsOpt = argumentRefKindsOpt;
            this.ApplicableIndexers = applicableIndexers;
        }


        public BoundExpression ReceiverOpt { get; private set; }

        public ReadOnlyArray<BoundExpression> Arguments { get; private set; }

        public ReadOnlyArray<string> ArgumentNamesOpt { get; private set; }

        public ReadOnlyArray<RefKind> ArgumentRefKindsOpt { get; private set; }

        public ReadOnlyArray<PropertySymbol> ApplicableIndexers { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitDynamicIndexerAccess(this);
        }

        public BoundDynamicIndexerAccess Update(BoundExpression receiverOpt, ReadOnlyArray<BoundExpression> arguments, ReadOnlyArray<string> argumentNamesOpt, ReadOnlyArray<RefKind> argumentRefKindsOpt, ReadOnlyArray<PropertySymbol> applicableIndexers, TypeSymbol type)
        {
            if (receiverOpt != this.ReceiverOpt || arguments != this.Arguments || argumentNamesOpt != this.ArgumentNamesOpt || argumentRefKindsOpt != this.ArgumentRefKindsOpt || applicableIndexers != this.ApplicableIndexers || type != this.Type)
            {
                var result = new BoundDynamicIndexerAccess(this.Syntax, receiverOpt, arguments, argumentNamesOpt, argumentRefKindsOpt, applicableIndexers, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundLambda : BoundExpression
    {
        public BoundLambda(SyntaxNode syntax, BoundBlock body, DiagnosticBag diagnostics, ExecutableCodeBinder binder, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.Lambda, syntax, type, hasErrors || body.HasErrors())
        {

            Debug.Assert(body != null, "Field 'body' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(diagnostics != null, "Field 'diagnostics' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(binder != null, "Field 'binder' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Body = body;
            this.Diagnostics = diagnostics;
            this.Binder = binder;
        }


        public BoundBlock Body { get; private set; }

        public DiagnosticBag Diagnostics { get; private set; }

        public ExecutableCodeBinder Binder { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitLambda(this);
        }

        public BoundLambda Update(BoundBlock body, DiagnosticBag diagnostics, ExecutableCodeBinder binder, TypeSymbol type)
        {
            if (body != this.Body || diagnostics != this.Diagnostics || binder != this.Binder || type != this.Type)
            {
                var result = new BoundLambda(this.Syntax, body, diagnostics, binder, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class UnboundLambda : BoundExpression
    {
        public UnboundLambda(SyntaxNode syntax, UnboundLambdaState data, bool hasErrors)
            : base(BoundKind.UnboundLambda, syntax, null, hasErrors)
        {

            Debug.Assert(data != null, "Field 'data' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Data = data;
        }

        public UnboundLambda(SyntaxNode syntax, UnboundLambdaState data)
            : base(BoundKind.UnboundLambda, syntax, null)
        {

            Debug.Assert(data != null, "Field 'data' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Data = data;
        }


        public UnboundLambdaState Data { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitUnboundLambda(this);
        }

        public UnboundLambda Update(UnboundLambdaState data)
        {
            if (data != this.Data)
            {
                var result = new UnboundLambda(this.Syntax, data, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal sealed partial class BoundQueryClause : BoundExpression
    {
        public BoundQueryClause(SyntaxNode syntax, BoundExpression value, RangeVariableSymbol definedSymbol, Binder binder, TypeSymbol type, bool hasErrors = false)
            : base(BoundKind.QueryClause, syntax, type, hasErrors || value.HasErrors())
        {

            Debug.Assert(value != null, "Field 'value' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(binder != null, "Field 'binder' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");
            Debug.Assert(type != null, "Field 'type' cannot be null (use Null=\"allow\" in BoundNodes.xml to remove this check)");

            this.Value = value;
            this.DefinedSymbol = definedSymbol;
            this.Binder = binder;
        }


        public BoundExpression Value { get; private set; }

        public RangeVariableSymbol DefinedSymbol { get; private set; }

        public Binder Binder { get; private set; }

        public override BoundNode Accept(BoundTreeVisitor visitor)
        {
            return visitor.VisitQueryClause(this);
        }

        public BoundQueryClause Update(BoundExpression value, RangeVariableSymbol definedSymbol, Binder binder, TypeSymbol type)
        {
            if (value != this.Value || definedSymbol != this.DefinedSymbol || binder != this.Binder || type != this.Type)
            {
                var result = new BoundQueryClause(this.Syntax, value, definedSymbol, binder, type, this.HasErrors);
                result.WasCompilerGenerated = this.WasCompilerGenerated;
                return result;
            }
            return this;
        }
    }

    internal abstract partial class BoundTreeVisitor<A,R>
    {

        [MethodImpl(MethodImplOptions.NoInlining)]
        internal R VisitInternal(BoundNode node, A arg)
        {
            switch (node.Kind)
            {
                case BoundKind.FieldInitializer: 
                    return VisitFieldInitializer(node as BoundFieldInitializer, arg);
                case BoundKind.GlobalStatementInitializer: 
                    return VisitGlobalStatementInitializer(node as BoundGlobalStatementInitializer, arg);
                case BoundKind.Dup: 
                    return VisitDup(node as BoundDup, arg);
                case BoundKind.BadExpression: 
                    return VisitBadExpression(node as BoundBadExpression, arg);
                case BoundKind.BadStatement: 
                    return VisitBadStatement(node as BoundBadStatement, arg);
                case BoundKind.TypeExpression: 
                    return VisitTypeExpression(node as BoundTypeExpression, arg);
                case BoundKind.TypeOrValueExpression: 
                    return VisitTypeOrValueExpression(node as BoundTypeOrValueExpression, arg);
                case BoundKind.NamespaceExpression: 
                    return VisitNamespaceExpression(node as BoundNamespaceExpression, arg);
                case BoundKind.UnaryOperator: 
                    return VisitUnaryOperator(node as BoundUnaryOperator, arg);
                case BoundKind.IncrementOperator: 
                    return VisitIncrementOperator(node as BoundIncrementOperator, arg);
                case BoundKind.AddressOfOperator: 
                    return VisitAddressOfOperator(node as BoundAddressOfOperator, arg);
                case BoundKind.PointerIndirectionOperator: 
                    return VisitPointerIndirectionOperator(node as BoundPointerIndirectionOperator, arg);
                case BoundKind.PointerElementAccess: 
                    return VisitPointerElementAccess(node as BoundPointerElementAccess, arg);
                case BoundKind.RefTypeOperator: 
                    return VisitRefTypeOperator(node as BoundRefTypeOperator, arg);
                case BoundKind.MakeRefOperator: 
                    return VisitMakeRefOperator(node as BoundMakeRefOperator, arg);
                case BoundKind.RefValueOperator: 
                    return VisitRefValueOperator(node as BoundRefValueOperator, arg);
                case BoundKind.BinaryOperator: 
                    return VisitBinaryOperator(node as BoundBinaryOperator, arg);
                case BoundKind.CompoundAssignmentOperator: 
                    return VisitCompoundAssignmentOperator(node as BoundCompoundAssignmentOperator, arg);
                case BoundKind.AssignmentOperator: 
                    return VisitAssignmentOperator(node as BoundAssignmentOperator, arg);
                case BoundKind.NullCoalescingOperator: 
                    return VisitNullCoalescingOperator(node as BoundNullCoalescingOperator, arg);
                case BoundKind.ConditionalOperator: 
                    return VisitConditionalOperator(node as BoundConditionalOperator, arg);
                case BoundKind.ArrayAccess: 
                    return VisitArrayAccess(node as BoundArrayAccess, arg);
                case BoundKind.ArrayLength: 
                    return VisitArrayLength(node as BoundArrayLength, arg);
                case BoundKind.AwaitExpression: 
                    return VisitAwaitExpression(node as BoundAwaitExpression, arg);
                case BoundKind.LoweredAwaitExpressionStackMark: 
                    return VisitLoweredAwaitExpressionStackMark(node as BoundLoweredAwaitExpressionStackMark, arg);
                case BoundKind.TypeOfOperator: 
                    return VisitTypeOfOperator(node as BoundTypeOfOperator, arg);
                case BoundKind.MethodInfo: 
                    return VisitMethodInfo(node as BoundMethodInfo, arg);
                case BoundKind.FieldInfo: 
                    return VisitFieldInfo(node as BoundFieldInfo, arg);
                case BoundKind.DefaultOperator: 
                    return VisitDefaultOperator(node as BoundDefaultOperator, arg);
                case BoundKind.IsOperator: 
                    return VisitIsOperator(node as BoundIsOperator, arg);
                case BoundKind.AsOperator: 
                    return VisitAsOperator(node as BoundAsOperator, arg);
                case BoundKind.SizeOfOperator: 
                    return VisitSizeOfOperator(node as BoundSizeOfOperator, arg);
                case BoundKind.Conversion: 
                    return VisitConversion(node as BoundConversion, arg);
                case BoundKind.ArgList: 
                    return VisitArgList(node as BoundArgList, arg);
                case BoundKind.ArgListOperator: 
                    return VisitArgListOperator(node as BoundArgListOperator, arg);
                case BoundKind.FixedLocalCollectionInitializer: 
                    return VisitFixedLocalCollectionInitializer(node as BoundFixedLocalCollectionInitializer, arg);
                case BoundKind.SequencePoint: 
                    return VisitSequencePoint(node as BoundSequencePoint, arg);
                case BoundKind.SequencePointWithSpan: 
                    return VisitSequencePointWithSpan(node as BoundSequencePointWithSpan, arg);
                case BoundKind.Block: 
                    return VisitBlock(node as BoundBlock, arg);
                case BoundKind.IteratorScope: 
                    return VisitIteratorScope(node as BoundIteratorScope, arg);
                case BoundKind.LocalDeclaration: 
                    return VisitLocalDeclaration(node as BoundLocalDeclaration, arg);
                case BoundKind.MultipleLocalDeclarations: 
                    return VisitMultipleLocalDeclarations(node as BoundMultipleLocalDeclarations, arg);
                case BoundKind.Sequence: 
                    return VisitSequence(node as BoundSequence, arg);
                case BoundKind.NoOpStatement: 
                    return VisitNoOpStatement(node as BoundNoOpStatement, arg);
                case BoundKind.ReturnStatement: 
                    return VisitReturnStatement(node as BoundReturnStatement, arg);
                case BoundKind.YieldReturnStatement: 
                    return VisitYieldReturnStatement(node as BoundYieldReturnStatement, arg);
                case BoundKind.YieldBreakStatement: 
                    return VisitYieldBreakStatement(node as BoundYieldBreakStatement, arg);
                case BoundKind.ThrowStatement: 
                    return VisitThrowStatement(node as BoundThrowStatement, arg);
                case BoundKind.ExpressionStatement: 
                    return VisitExpressionStatement(node as BoundExpressionStatement, arg);
                case BoundKind.SwitchStatement: 
                    return VisitSwitchStatement(node as BoundSwitchStatement, arg);
                case BoundKind.SwitchSection: 
                    return VisitSwitchSection(node as BoundSwitchSection, arg);
                case BoundKind.SwitchLabel: 
                    return VisitSwitchLabel(node as BoundSwitchLabel, arg);
                case BoundKind.BreakStatement: 
                    return VisitBreakStatement(node as BoundBreakStatement, arg);
                case BoundKind.ContinueStatement: 
                    return VisitContinueStatement(node as BoundContinueStatement, arg);
                case BoundKind.IfStatement: 
                    return VisitIfStatement(node as BoundIfStatement, arg);
                case BoundKind.DoStatement: 
                    return VisitDoStatement(node as BoundDoStatement, arg);
                case BoundKind.WhileStatement: 
                    return VisitWhileStatement(node as BoundWhileStatement, arg);
                case BoundKind.ForStatement: 
                    return VisitForStatement(node as BoundForStatement, arg);
                case BoundKind.ForEachStatement: 
                    return VisitForEachStatement(node as BoundForEachStatement, arg);
                case BoundKind.UsingStatement: 
                    return VisitUsingStatement(node as BoundUsingStatement, arg);
                case BoundKind.FixedStatement: 
                    return VisitFixedStatement(node as BoundFixedStatement, arg);
                case BoundKind.LockStatement: 
                    return VisitLockStatement(node as BoundLockStatement, arg);
                case BoundKind.TryStatement: 
                    return VisitTryStatement(node as BoundTryStatement, arg);
                case BoundKind.CatchBlock: 
                    return VisitCatchBlock(node as BoundCatchBlock, arg);
                case BoundKind.Literal: 
                    return VisitLiteral(node as BoundLiteral, arg);
                case BoundKind.ThisReference: 
                    return VisitThisReference(node as BoundThisReference, arg);
                case BoundKind.PreviousSubmissionReference: 
                    return VisitPreviousSubmissionReference(node as BoundPreviousSubmissionReference, arg);
                case BoundKind.HostObjectMemberReference: 
                    return VisitHostObjectMemberReference(node as BoundHostObjectMemberReference, arg);
                case BoundKind.BaseReference: 
                    return VisitBaseReference(node as BoundBaseReference, arg);
                case BoundKind.Local: 
                    return VisitLocal(node as BoundLocal, arg);
                case BoundKind.RangeVariable: 
                    return VisitRangeVariable(node as BoundRangeVariable, arg);
                case BoundKind.Parameter: 
                    return VisitParameter(node as BoundParameter, arg);
                case BoundKind.LabelStatement: 
                    return VisitLabelStatement(node as BoundLabelStatement, arg);
                case BoundKind.GotoStatement: 
                    return VisitGotoStatement(node as BoundGotoStatement, arg);
                case BoundKind.LabeledStatement: 
                    return VisitLabeledStatement(node as BoundLabeledStatement, arg);
                case BoundKind.Label: 
                    return VisitLabel(node as BoundLabel, arg);
                case BoundKind.StatementList: 
                    return VisitStatementList(node as BoundStatementList, arg);
                case BoundKind.ConditionalGoto: 
                    return VisitConditionalGoto(node as BoundConditionalGoto, arg);
                case BoundKind.DynamicMemberAccess: 
                    return VisitDynamicMemberAccess(node as BoundDynamicMemberAccess, arg);
                case BoundKind.DynamicInvocation: 
                    return VisitDynamicInvocation(node as BoundDynamicInvocation, arg);
                case BoundKind.MethodGroup: 
                    return VisitMethodGroup(node as BoundMethodGroup, arg);
                case BoundKind.PropertyGroup: 
                    return VisitPropertyGroup(node as BoundPropertyGroup, arg);
                case BoundKind.Call: 
                    return VisitCall(node as BoundCall, arg);
                case BoundKind.EventAssignmentOperator: 
                    return VisitEventAssignmentOperator(node as BoundEventAssignmentOperator, arg);
                case BoundKind.DelegateCall: 
                    return VisitDelegateCall(node as BoundDelegateCall, arg);
                case BoundKind.Attribute: 
                    return VisitAttribute(node as BoundAttribute, arg);
                case BoundKind.ObjectCreationExpression: 
                    return VisitObjectCreationExpression(node as BoundObjectCreationExpression, arg);
                case BoundKind.DynamicObjectCreationExpression: 
                    return VisitDynamicObjectCreationExpression(node as BoundDynamicObjectCreationExpression, arg);
                case BoundKind.ObjectInitializerExpression: 
                    return VisitObjectInitializerExpression(node as BoundObjectInitializerExpression, arg);
                case BoundKind.ObjectInitializerMember: 
                    return VisitObjectInitializerMember(node as BoundObjectInitializerMember, arg);
                case BoundKind.CollectionInitializerExpression: 
                    return VisitCollectionInitializerExpression(node as BoundCollectionInitializerExpression, arg);
                case BoundKind.CollectionElementInitializer: 
                    return VisitCollectionElementInitializer(node as BoundCollectionElementInitializer, arg);
                case BoundKind.DynamicCollectionElementInitializer: 
                    return VisitDynamicCollectionElementInitializer(node as BoundDynamicCollectionElementInitializer, arg);
                case BoundKind.ImplicitReceiver: 
                    return VisitImplicitReceiver(node as BoundImplicitReceiver, arg);
                case BoundKind.AnonymousObjectCreationExpression: 
                    return VisitAnonymousObjectCreationExpression(node as BoundAnonymousObjectCreationExpression, arg);
                case BoundKind.AnonymousPropertyDeclaration: 
                    return VisitAnonymousPropertyDeclaration(node as BoundAnonymousPropertyDeclaration, arg);
                case BoundKind.NewT: 
                    return VisitNewT(node as BoundNewT, arg);
                case BoundKind.DelegateCreationExpression: 
                    return VisitDelegateCreationExpression(node as BoundDelegateCreationExpression, arg);
                case BoundKind.ArrayCreation: 
                    return VisitArrayCreation(node as BoundArrayCreation, arg);
                case BoundKind.ArrayInitialization: 
                    return VisitArrayInitialization(node as BoundArrayInitialization, arg);
                case BoundKind.StackAllocArrayCreation: 
                    return VisitStackAllocArrayCreation(node as BoundStackAllocArrayCreation, arg);
                case BoundKind.FieldAccess: 
                    return VisitFieldAccess(node as BoundFieldAccess, arg);
                case BoundKind.PropertyAccess: 
                    return VisitPropertyAccess(node as BoundPropertyAccess, arg);
                case BoundKind.EventAccess: 
                    return VisitEventAccess(node as BoundEventAccess, arg);
                case BoundKind.IndexerAccess: 
                    return VisitIndexerAccess(node as BoundIndexerAccess, arg);
                case BoundKind.DynamicIndexerAccess: 
                    return VisitDynamicIndexerAccess(node as BoundDynamicIndexerAccess, arg);
                case BoundKind.Lambda: 
                    return VisitLambda(node as BoundLambda, arg);
                case BoundKind.UnboundLambda: 
                    return VisitUnboundLambda(node as UnboundLambda, arg);
                case BoundKind.QueryClause: 
                    return VisitQueryClause(node as BoundQueryClause, arg);
            }

            return default(R);
        }
    }

    internal abstract partial class BoundTreeVisitor<A,R>
    {
        public virtual R VisitFieldInitializer(BoundFieldInitializer node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitGlobalStatementInitializer(BoundGlobalStatementInitializer node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitDup(BoundDup node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitBadExpression(BoundBadExpression node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitBadStatement(BoundBadStatement node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitTypeExpression(BoundTypeExpression node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitTypeOrValueExpression(BoundTypeOrValueExpression node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitNamespaceExpression(BoundNamespaceExpression node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitUnaryOperator(BoundUnaryOperator node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitIncrementOperator(BoundIncrementOperator node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitAddressOfOperator(BoundAddressOfOperator node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitPointerIndirectionOperator(BoundPointerIndirectionOperator node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitPointerElementAccess(BoundPointerElementAccess node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitRefTypeOperator(BoundRefTypeOperator node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitMakeRefOperator(BoundMakeRefOperator node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitRefValueOperator(BoundRefValueOperator node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitBinaryOperator(BoundBinaryOperator node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitCompoundAssignmentOperator(BoundCompoundAssignmentOperator node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitAssignmentOperator(BoundAssignmentOperator node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitNullCoalescingOperator(BoundNullCoalescingOperator node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitConditionalOperator(BoundConditionalOperator node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitArrayAccess(BoundArrayAccess node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitArrayLength(BoundArrayLength node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitAwaitExpression(BoundAwaitExpression node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitLoweredAwaitExpressionStackMark(BoundLoweredAwaitExpressionStackMark node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitTypeOfOperator(BoundTypeOfOperator node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitMethodInfo(BoundMethodInfo node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitFieldInfo(BoundFieldInfo node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitDefaultOperator(BoundDefaultOperator node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitIsOperator(BoundIsOperator node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitAsOperator(BoundAsOperator node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitSizeOfOperator(BoundSizeOfOperator node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitConversion(BoundConversion node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitArgList(BoundArgList node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitArgListOperator(BoundArgListOperator node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitFixedLocalCollectionInitializer(BoundFixedLocalCollectionInitializer node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitSequencePoint(BoundSequencePoint node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitSequencePointWithSpan(BoundSequencePointWithSpan node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitBlock(BoundBlock node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitIteratorScope(BoundIteratorScope node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitLocalDeclaration(BoundLocalDeclaration node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitMultipleLocalDeclarations(BoundMultipleLocalDeclarations node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitSequence(BoundSequence node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitNoOpStatement(BoundNoOpStatement node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitReturnStatement(BoundReturnStatement node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitYieldReturnStatement(BoundYieldReturnStatement node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitYieldBreakStatement(BoundYieldBreakStatement node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitThrowStatement(BoundThrowStatement node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitExpressionStatement(BoundExpressionStatement node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitSwitchStatement(BoundSwitchStatement node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitSwitchSection(BoundSwitchSection node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitSwitchLabel(BoundSwitchLabel node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitBreakStatement(BoundBreakStatement node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitContinueStatement(BoundContinueStatement node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitIfStatement(BoundIfStatement node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitDoStatement(BoundDoStatement node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitWhileStatement(BoundWhileStatement node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitForStatement(BoundForStatement node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitForEachStatement(BoundForEachStatement node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitUsingStatement(BoundUsingStatement node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitFixedStatement(BoundFixedStatement node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitLockStatement(BoundLockStatement node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitTryStatement(BoundTryStatement node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitCatchBlock(BoundCatchBlock node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitLiteral(BoundLiteral node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitThisReference(BoundThisReference node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitPreviousSubmissionReference(BoundPreviousSubmissionReference node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitHostObjectMemberReference(BoundHostObjectMemberReference node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitBaseReference(BoundBaseReference node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitLocal(BoundLocal node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitRangeVariable(BoundRangeVariable node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitParameter(BoundParameter node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitLabelStatement(BoundLabelStatement node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitGotoStatement(BoundGotoStatement node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitLabeledStatement(BoundLabeledStatement node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitLabel(BoundLabel node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitStatementList(BoundStatementList node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitConditionalGoto(BoundConditionalGoto node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitDynamicMemberAccess(BoundDynamicMemberAccess node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitDynamicInvocation(BoundDynamicInvocation node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitMethodGroup(BoundMethodGroup node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitPropertyGroup(BoundPropertyGroup node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitCall(BoundCall node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitEventAssignmentOperator(BoundEventAssignmentOperator node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitDelegateCall(BoundDelegateCall node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitAttribute(BoundAttribute node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitObjectCreationExpression(BoundObjectCreationExpression node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitDynamicObjectCreationExpression(BoundDynamicObjectCreationExpression node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitObjectInitializerExpression(BoundObjectInitializerExpression node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitObjectInitializerMember(BoundObjectInitializerMember node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitCollectionInitializerExpression(BoundCollectionInitializerExpression node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitCollectionElementInitializer(BoundCollectionElementInitializer node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitDynamicCollectionElementInitializer(BoundDynamicCollectionElementInitializer node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitImplicitReceiver(BoundImplicitReceiver node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitAnonymousObjectCreationExpression(BoundAnonymousObjectCreationExpression node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitAnonymousPropertyDeclaration(BoundAnonymousPropertyDeclaration node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitNewT(BoundNewT node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitDelegateCreationExpression(BoundDelegateCreationExpression node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitArrayCreation(BoundArrayCreation node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitArrayInitialization(BoundArrayInitialization node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitStackAllocArrayCreation(BoundStackAllocArrayCreation node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitFieldAccess(BoundFieldAccess node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitPropertyAccess(BoundPropertyAccess node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitEventAccess(BoundEventAccess node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitIndexerAccess(BoundIndexerAccess node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitDynamicIndexerAccess(BoundDynamicIndexerAccess node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitLambda(BoundLambda node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitUnboundLambda(UnboundLambda node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
        public virtual R VisitQueryClause(BoundQueryClause node, A arg)
        {
            return this.DefaultVisit(node, arg);
        }
    }

    internal abstract partial class BoundTreeVisitor
    {
        public virtual BoundNode VisitFieldInitializer(BoundFieldInitializer node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitGlobalStatementInitializer(BoundGlobalStatementInitializer node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitDup(BoundDup node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitBadExpression(BoundBadExpression node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitBadStatement(BoundBadStatement node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitTypeExpression(BoundTypeExpression node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitTypeOrValueExpression(BoundTypeOrValueExpression node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitNamespaceExpression(BoundNamespaceExpression node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitUnaryOperator(BoundUnaryOperator node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitIncrementOperator(BoundIncrementOperator node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitAddressOfOperator(BoundAddressOfOperator node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitPointerIndirectionOperator(BoundPointerIndirectionOperator node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitPointerElementAccess(BoundPointerElementAccess node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitRefTypeOperator(BoundRefTypeOperator node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitMakeRefOperator(BoundMakeRefOperator node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitRefValueOperator(BoundRefValueOperator node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitBinaryOperator(BoundBinaryOperator node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitCompoundAssignmentOperator(BoundCompoundAssignmentOperator node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitAssignmentOperator(BoundAssignmentOperator node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitNullCoalescingOperator(BoundNullCoalescingOperator node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitConditionalOperator(BoundConditionalOperator node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitArrayAccess(BoundArrayAccess node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitArrayLength(BoundArrayLength node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitAwaitExpression(BoundAwaitExpression node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitLoweredAwaitExpressionStackMark(BoundLoweredAwaitExpressionStackMark node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitTypeOfOperator(BoundTypeOfOperator node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitMethodInfo(BoundMethodInfo node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitFieldInfo(BoundFieldInfo node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitDefaultOperator(BoundDefaultOperator node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitIsOperator(BoundIsOperator node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitAsOperator(BoundAsOperator node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitSizeOfOperator(BoundSizeOfOperator node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitConversion(BoundConversion node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitArgList(BoundArgList node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitArgListOperator(BoundArgListOperator node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitFixedLocalCollectionInitializer(BoundFixedLocalCollectionInitializer node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitSequencePoint(BoundSequencePoint node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitSequencePointWithSpan(BoundSequencePointWithSpan node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitBlock(BoundBlock node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitIteratorScope(BoundIteratorScope node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitLocalDeclaration(BoundLocalDeclaration node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitMultipleLocalDeclarations(BoundMultipleLocalDeclarations node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitSequence(BoundSequence node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitNoOpStatement(BoundNoOpStatement node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitReturnStatement(BoundReturnStatement node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitYieldReturnStatement(BoundYieldReturnStatement node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitYieldBreakStatement(BoundYieldBreakStatement node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitThrowStatement(BoundThrowStatement node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitExpressionStatement(BoundExpressionStatement node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitSwitchStatement(BoundSwitchStatement node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitSwitchSection(BoundSwitchSection node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitSwitchLabel(BoundSwitchLabel node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitBreakStatement(BoundBreakStatement node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitContinueStatement(BoundContinueStatement node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitIfStatement(BoundIfStatement node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitDoStatement(BoundDoStatement node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitWhileStatement(BoundWhileStatement node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitForStatement(BoundForStatement node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitForEachStatement(BoundForEachStatement node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitUsingStatement(BoundUsingStatement node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitFixedStatement(BoundFixedStatement node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitLockStatement(BoundLockStatement node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitTryStatement(BoundTryStatement node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitCatchBlock(BoundCatchBlock node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitLiteral(BoundLiteral node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitThisReference(BoundThisReference node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitPreviousSubmissionReference(BoundPreviousSubmissionReference node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitHostObjectMemberReference(BoundHostObjectMemberReference node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitBaseReference(BoundBaseReference node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitLocal(BoundLocal node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitRangeVariable(BoundRangeVariable node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitParameter(BoundParameter node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitLabelStatement(BoundLabelStatement node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitGotoStatement(BoundGotoStatement node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitLabeledStatement(BoundLabeledStatement node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitLabel(BoundLabel node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitStatementList(BoundStatementList node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitConditionalGoto(BoundConditionalGoto node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitDynamicMemberAccess(BoundDynamicMemberAccess node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitDynamicInvocation(BoundDynamicInvocation node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitMethodGroup(BoundMethodGroup node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitPropertyGroup(BoundPropertyGroup node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitCall(BoundCall node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitEventAssignmentOperator(BoundEventAssignmentOperator node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitDelegateCall(BoundDelegateCall node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitAttribute(BoundAttribute node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitObjectCreationExpression(BoundObjectCreationExpression node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitDynamicObjectCreationExpression(BoundDynamicObjectCreationExpression node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitObjectInitializerExpression(BoundObjectInitializerExpression node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitObjectInitializerMember(BoundObjectInitializerMember node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitCollectionInitializerExpression(BoundCollectionInitializerExpression node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitCollectionElementInitializer(BoundCollectionElementInitializer node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitDynamicCollectionElementInitializer(BoundDynamicCollectionElementInitializer node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitImplicitReceiver(BoundImplicitReceiver node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitAnonymousObjectCreationExpression(BoundAnonymousObjectCreationExpression node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitAnonymousPropertyDeclaration(BoundAnonymousPropertyDeclaration node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitNewT(BoundNewT node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitDelegateCreationExpression(BoundDelegateCreationExpression node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitArrayCreation(BoundArrayCreation node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitArrayInitialization(BoundArrayInitialization node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitStackAllocArrayCreation(BoundStackAllocArrayCreation node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitFieldAccess(BoundFieldAccess node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitPropertyAccess(BoundPropertyAccess node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitEventAccess(BoundEventAccess node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitIndexerAccess(BoundIndexerAccess node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitDynamicIndexerAccess(BoundDynamicIndexerAccess node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitLambda(BoundLambda node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitUnboundLambda(UnboundLambda node)
        {
            return this.DefaultVisit(node);
        }
        public virtual BoundNode VisitQueryClause(BoundQueryClause node)
        {
            return this.DefaultVisit(node);
        }
    }

    internal abstract partial class BoundTreeWalker: BoundTreeVisitor
    {
        public override BoundNode VisitFieldInitializer(BoundFieldInitializer node)
        {
            this.Visit(node.InitialValue);
            return null;
        }
        public override BoundNode VisitGlobalStatementInitializer(BoundGlobalStatementInitializer node)
        {
            this.Visit(node.Statement);
            return null;
        }
        public override BoundNode VisitDup(BoundDup node)
        {
            return null;
        }
        public override BoundNode VisitBadExpression(BoundBadExpression node)
        {
            this.VisitList(node.ChildBoundNodes);
            return null;
        }
        public override BoundNode VisitBadStatement(BoundBadStatement node)
        {
            this.VisitList(node.ChildBoundNodes);
            return null;
        }
        public override BoundNode VisitTypeExpression(BoundTypeExpression node)
        {
            this.Visit(node.BoundContainingTypeOpt);
            return null;
        }
        public override BoundNode VisitTypeOrValueExpression(BoundTypeOrValueExpression node)
        {
            return null;
        }
        public override BoundNode VisitNamespaceExpression(BoundNamespaceExpression node)
        {
            return null;
        }
        public override BoundNode VisitUnaryOperator(BoundUnaryOperator node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override BoundNode VisitIncrementOperator(BoundIncrementOperator node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override BoundNode VisitAddressOfOperator(BoundAddressOfOperator node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override BoundNode VisitPointerIndirectionOperator(BoundPointerIndirectionOperator node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override BoundNode VisitPointerElementAccess(BoundPointerElementAccess node)
        {
            this.Visit(node.Expression);
            this.Visit(node.Index);
            return null;
        }
        public override BoundNode VisitRefTypeOperator(BoundRefTypeOperator node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override BoundNode VisitMakeRefOperator(BoundMakeRefOperator node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override BoundNode VisitRefValueOperator(BoundRefValueOperator node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override BoundNode VisitBinaryOperator(BoundBinaryOperator node)
        {
            this.Visit(node.Left);
            this.Visit(node.Right);
            return null;
        }
        public override BoundNode VisitCompoundAssignmentOperator(BoundCompoundAssignmentOperator node)
        {
            this.Visit(node.Left);
            this.Visit(node.Right);
            return null;
        }
        public override BoundNode VisitAssignmentOperator(BoundAssignmentOperator node)
        {
            this.Visit(node.Left);
            this.Visit(node.Right);
            return null;
        }
        public override BoundNode VisitNullCoalescingOperator(BoundNullCoalescingOperator node)
        {
            this.Visit(node.LeftOperand);
            this.Visit(node.RightOperand);
            return null;
        }
        public override BoundNode VisitConditionalOperator(BoundConditionalOperator node)
        {
            this.Visit(node.Condition);
            this.Visit(node.Consequence);
            this.Visit(node.Alternative);
            return null;
        }
        public override BoundNode VisitArrayAccess(BoundArrayAccess node)
        {
            this.Visit(node.Expression);
            this.VisitList(node.Indices);
            return null;
        }
        public override BoundNode VisitArrayLength(BoundArrayLength node)
        {
            this.Visit(node.Expression);
            return null;
        }
        public override BoundNode VisitAwaitExpression(BoundAwaitExpression node)
        {
            this.Visit(node.Expression);
            return null;
        }
        public override BoundNode VisitLoweredAwaitExpressionStackMark(BoundLoweredAwaitExpressionStackMark node)
        {
            return null;
        }
        public override BoundNode VisitTypeOfOperator(BoundTypeOfOperator node)
        {
            this.Visit(node.SourceType);
            return null;
        }
        public override BoundNode VisitMethodInfo(BoundMethodInfo node)
        {
            return null;
        }
        public override BoundNode VisitFieldInfo(BoundFieldInfo node)
        {
            return null;
        }
        public override BoundNode VisitDefaultOperator(BoundDefaultOperator node)
        {
            return null;
        }
        public override BoundNode VisitIsOperator(BoundIsOperator node)
        {
            this.Visit(node.Operand);
            this.Visit(node.TargetType);
            return null;
        }
        public override BoundNode VisitAsOperator(BoundAsOperator node)
        {
            this.Visit(node.Operand);
            this.Visit(node.TargetType);
            return null;
        }
        public override BoundNode VisitSizeOfOperator(BoundSizeOfOperator node)
        {
            this.Visit(node.SourceType);
            return null;
        }
        public override BoundNode VisitConversion(BoundConversion node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override BoundNode VisitArgList(BoundArgList node)
        {
            return null;
        }
        public override BoundNode VisitArgListOperator(BoundArgListOperator node)
        {
            this.VisitList(node.Arguments);
            return null;
        }
        public override BoundNode VisitFixedLocalCollectionInitializer(BoundFixedLocalCollectionInitializer node)
        {
            this.Visit(node.Expression);
            return null;
        }
        public override BoundNode VisitSequencePoint(BoundSequencePoint node)
        {
            this.Visit(node.StatementOpt);
            return null;
        }
        public override BoundNode VisitSequencePointWithSpan(BoundSequencePointWithSpan node)
        {
            this.Visit(node.StatementOpt);
            return null;
        }
        public override BoundNode VisitBlock(BoundBlock node)
        {
            this.VisitList(node.Statements);
            return null;
        }
        public override BoundNode VisitIteratorScope(BoundIteratorScope node)
        {
            this.Visit(node.Statement);
            return null;
        }
        public override BoundNode VisitLocalDeclaration(BoundLocalDeclaration node)
        {
            this.Visit(node.DeclaredType);
            this.Visit(node.InitializerOpt);
            this.VisitList(node.ArgumentsOpt);
            return null;
        }
        public override BoundNode VisitMultipleLocalDeclarations(BoundMultipleLocalDeclarations node)
        {
            this.VisitList(node.LocalDeclarations);
            return null;
        }
        public override BoundNode VisitSequence(BoundSequence node)
        {
            this.VisitList(node.SideEffects);
            this.Visit(node.Value);
            return null;
        }
        public override BoundNode VisitNoOpStatement(BoundNoOpStatement node)
        {
            return null;
        }
        public override BoundNode VisitReturnStatement(BoundReturnStatement node)
        {
            this.Visit(node.ExpressionOpt);
            return null;
        }
        public override BoundNode VisitYieldReturnStatement(BoundYieldReturnStatement node)
        {
            this.Visit(node.Expression);
            return null;
        }
        public override BoundNode VisitYieldBreakStatement(BoundYieldBreakStatement node)
        {
            return null;
        }
        public override BoundNode VisitThrowStatement(BoundThrowStatement node)
        {
            this.Visit(node.ExpressionOpt);
            return null;
        }
        public override BoundNode VisitExpressionStatement(BoundExpressionStatement node)
        {
            this.Visit(node.Expression);
            return null;
        }
        public override BoundNode VisitSwitchStatement(BoundSwitchStatement node)
        {
            this.Visit(node.BoundExpression);
            this.VisitList(node.SwitchSections);
            return null;
        }
        public override BoundNode VisitSwitchSection(BoundSwitchSection node)
        {
            this.VisitList(node.BoundSwitchLabels);
            this.VisitList(node.Statements);
            return null;
        }
        public override BoundNode VisitSwitchLabel(BoundSwitchLabel node)
        {
            this.Visit(node.ExpressionOpt);
            return null;
        }
        public override BoundNode VisitBreakStatement(BoundBreakStatement node)
        {
            return null;
        }
        public override BoundNode VisitContinueStatement(BoundContinueStatement node)
        {
            return null;
        }
        public override BoundNode VisitIfStatement(BoundIfStatement node)
        {
            this.Visit(node.Condition);
            this.Visit(node.Consequence);
            this.Visit(node.AlternativeOpt);
            return null;
        }
        public override BoundNode VisitDoStatement(BoundDoStatement node)
        {
            this.Visit(node.Condition);
            this.Visit(node.Body);
            return null;
        }
        public override BoundNode VisitWhileStatement(BoundWhileStatement node)
        {
            this.Visit(node.Condition);
            this.Visit(node.Body);
            return null;
        }
        public override BoundNode VisitForStatement(BoundForStatement node)
        {
            this.Visit(node.Initializer);
            this.Visit(node.Condition);
            this.Visit(node.Increment);
            this.Visit(node.Body);
            return null;
        }
        public override BoundNode VisitForEachStatement(BoundForEachStatement node)
        {
            this.Visit(node.IterationVariableType);
            this.Visit(node.Expression);
            this.Visit(node.Body);
            return null;
        }
        public override BoundNode VisitUsingStatement(BoundUsingStatement node)
        {
            this.Visit(node.DeclarationsOpt);
            this.Visit(node.ExpressionOpt);
            this.Visit(node.Body);
            return null;
        }
        public override BoundNode VisitFixedStatement(BoundFixedStatement node)
        {
            this.Visit(node.Declarations);
            this.Visit(node.Body);
            return null;
        }
        public override BoundNode VisitLockStatement(BoundLockStatement node)
        {
            this.Visit(node.Argument);
            this.Visit(node.Body);
            return null;
        }
        public override BoundNode VisitTryStatement(BoundTryStatement node)
        {
            this.Visit(node.TryBlock);
            this.VisitList(node.CatchBlocks);
            this.Visit(node.FinallyBlockOpt);
            return null;
        }
        public override BoundNode VisitCatchBlock(BoundCatchBlock node)
        {
            this.Visit(node.BoundBlock);
            return null;
        }
        public override BoundNode VisitLiteral(BoundLiteral node)
        {
            return null;
        }
        public override BoundNode VisitThisReference(BoundThisReference node)
        {
            return null;
        }
        public override BoundNode VisitPreviousSubmissionReference(BoundPreviousSubmissionReference node)
        {
            return null;
        }
        public override BoundNode VisitHostObjectMemberReference(BoundHostObjectMemberReference node)
        {
            return null;
        }
        public override BoundNode VisitBaseReference(BoundBaseReference node)
        {
            return null;
        }
        public override BoundNode VisitLocal(BoundLocal node)
        {
            return null;
        }
        public override BoundNode VisitRangeVariable(BoundRangeVariable node)
        {
            this.Visit(node.Value);
            return null;
        }
        public override BoundNode VisitParameter(BoundParameter node)
        {
            return null;
        }
        public override BoundNode VisitLabelStatement(BoundLabelStatement node)
        {
            return null;
        }
        public override BoundNode VisitGotoStatement(BoundGotoStatement node)
        {
            this.Visit(node.CaseExpressionOpt);
            this.Visit(node.LabelExpressionOpt);
            return null;
        }
        public override BoundNode VisitLabeledStatement(BoundLabeledStatement node)
        {
            this.Visit(node.Body);
            return null;
        }
        public override BoundNode VisitLabel(BoundLabel node)
        {
            return null;
        }
        public override BoundNode VisitStatementList(BoundStatementList node)
        {
            this.VisitList(node.Statements);
            return null;
        }
        public override BoundNode VisitConditionalGoto(BoundConditionalGoto node)
        {
            this.Visit(node.Condition);
            return null;
        }
        public override BoundNode VisitDynamicMemberAccess(BoundDynamicMemberAccess node)
        {
            this.Visit(node.Receiver);
            return null;
        }
        public override BoundNode VisitDynamicInvocation(BoundDynamicInvocation node)
        {
            this.Visit(node.Expression);
            this.VisitList(node.Arguments);
            return null;
        }
        public override BoundNode VisitMethodGroup(BoundMethodGroup node)
        {
            this.Visit(node.ReceiverOpt);
            return null;
        }
        public override BoundNode VisitPropertyGroup(BoundPropertyGroup node)
        {
            this.Visit(node.ReceiverOpt);
            return null;
        }
        public override BoundNode VisitCall(BoundCall node)
        {
            this.Visit(node.ReceiverOpt);
            this.VisitList(node.Arguments);
            return null;
        }
        public override BoundNode VisitEventAssignmentOperator(BoundEventAssignmentOperator node)
        {
            this.Visit(node.ReceiverOpt);
            this.Visit(node.Argument);
            return null;
        }
        public override BoundNode VisitDelegateCall(BoundDelegateCall node)
        {
            this.Visit(node.ReceiverOpt);
            this.VisitList(node.Arguments);
            return null;
        }
        public override BoundNode VisitAttribute(BoundAttribute node)
        {
            this.VisitList(node.ConstructorArguments);
            this.VisitList(node.NamedArguments);
            return null;
        }
        public override BoundNode VisitObjectCreationExpression(BoundObjectCreationExpression node)
        {
            this.VisitList(node.Arguments);
            this.Visit(node.InitializerExpressionOpt);
            return null;
        }
        public override BoundNode VisitDynamicObjectCreationExpression(BoundDynamicObjectCreationExpression node)
        {
            this.VisitList(node.Arguments);
            this.Visit(node.InitializerExpressionOpt);
            return null;
        }
        public override BoundNode VisitObjectInitializerExpression(BoundObjectInitializerExpression node)
        {
            this.VisitList(node.Initializers);
            return null;
        }
        public override BoundNode VisitObjectInitializerMember(BoundObjectInitializerMember node)
        {
            return null;
        }
        public override BoundNode VisitCollectionInitializerExpression(BoundCollectionInitializerExpression node)
        {
            this.VisitList(node.Initializers);
            return null;
        }
        public override BoundNode VisitCollectionElementInitializer(BoundCollectionElementInitializer node)
        {
            this.VisitList(node.Arguments);
            return null;
        }
        public override BoundNode VisitDynamicCollectionElementInitializer(BoundDynamicCollectionElementInitializer node)
        {
            this.VisitList(node.Arguments);
            return null;
        }
        public override BoundNode VisitImplicitReceiver(BoundImplicitReceiver node)
        {
            return null;
        }
        public override BoundNode VisitAnonymousObjectCreationExpression(BoundAnonymousObjectCreationExpression node)
        {
            this.VisitList(node.Arguments);
            this.VisitList(node.Declarations);
            return null;
        }
        public override BoundNode VisitAnonymousPropertyDeclaration(BoundAnonymousPropertyDeclaration node)
        {
            return null;
        }
        public override BoundNode VisitNewT(BoundNewT node)
        {
            this.Visit(node.InitializerExpressionOpt);
            return null;
        }
        public override BoundNode VisitDelegateCreationExpression(BoundDelegateCreationExpression node)
        {
            this.Visit(node.Argument);
            return null;
        }
        public override BoundNode VisitArrayCreation(BoundArrayCreation node)
        {
            this.VisitList(node.Bounds);
            this.Visit(node.InitializerOpt);
            return null;
        }
        public override BoundNode VisitArrayInitialization(BoundArrayInitialization node)
        {
            this.VisitList(node.Initializers);
            return null;
        }
        public override BoundNode VisitStackAllocArrayCreation(BoundStackAllocArrayCreation node)
        {
            this.Visit(node.Count);
            return null;
        }
        public override BoundNode VisitFieldAccess(BoundFieldAccess node)
        {
            this.Visit(node.ReceiverOpt);
            return null;
        }
        public override BoundNode VisitPropertyAccess(BoundPropertyAccess node)
        {
            this.Visit(node.ReceiverOpt);
            return null;
        }
        public override BoundNode VisitEventAccess(BoundEventAccess node)
        {
            this.Visit(node.ReceiverOpt);
            return null;
        }
        public override BoundNode VisitIndexerAccess(BoundIndexerAccess node)
        {
            this.Visit(node.ReceiverOpt);
            this.VisitList(node.Arguments);
            return null;
        }
        public override BoundNode VisitDynamicIndexerAccess(BoundDynamicIndexerAccess node)
        {
            this.Visit(node.ReceiverOpt);
            this.VisitList(node.Arguments);
            return null;
        }
        public override BoundNode VisitLambda(BoundLambda node)
        {
            this.Visit(node.Body);
            return null;
        }
        public override BoundNode VisitUnboundLambda(UnboundLambda node)
        {
            return null;
        }
        public override BoundNode VisitQueryClause(BoundQueryClause node)
        {
            this.Visit(node.Value);
            return null;
        }
    }

    internal abstract partial class BoundTreeReverseWalker: BoundTreeVisitor
    {
        public override BoundNode VisitFieldInitializer(BoundFieldInitializer node)
        {
            this.Visit(node.InitialValue);
            return null;
        }
        public override BoundNode VisitGlobalStatementInitializer(BoundGlobalStatementInitializer node)
        {
            this.Visit(node.Statement);
            return null;
        }
        public override BoundNode VisitDup(BoundDup node)
        {
            return null;
        }
        public override BoundNode VisitBadExpression(BoundBadExpression node)
        {
            this.VisitListReverse(node.ChildBoundNodes);
            return null;
        }
        public override BoundNode VisitBadStatement(BoundBadStatement node)
        {
            this.VisitListReverse(node.ChildBoundNodes);
            return null;
        }
        public override BoundNode VisitTypeExpression(BoundTypeExpression node)
        {
            this.Visit(node.BoundContainingTypeOpt);
            return null;
        }
        public override BoundNode VisitTypeOrValueExpression(BoundTypeOrValueExpression node)
        {
            return null;
        }
        public override BoundNode VisitNamespaceExpression(BoundNamespaceExpression node)
        {
            return null;
        }
        public override BoundNode VisitUnaryOperator(BoundUnaryOperator node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override BoundNode VisitIncrementOperator(BoundIncrementOperator node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override BoundNode VisitAddressOfOperator(BoundAddressOfOperator node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override BoundNode VisitPointerIndirectionOperator(BoundPointerIndirectionOperator node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override BoundNode VisitPointerElementAccess(BoundPointerElementAccess node)
        {
            this.Visit(node.Index);
            this.Visit(node.Expression);
            return null;
        }
        public override BoundNode VisitRefTypeOperator(BoundRefTypeOperator node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override BoundNode VisitMakeRefOperator(BoundMakeRefOperator node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override BoundNode VisitRefValueOperator(BoundRefValueOperator node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override BoundNode VisitBinaryOperator(BoundBinaryOperator node)
        {
            this.Visit(node.Right);
            this.Visit(node.Left);
            return null;
        }
        public override BoundNode VisitCompoundAssignmentOperator(BoundCompoundAssignmentOperator node)
        {
            this.Visit(node.Right);
            this.Visit(node.Left);
            return null;
        }
        public override BoundNode VisitAssignmentOperator(BoundAssignmentOperator node)
        {
            this.Visit(node.Right);
            this.Visit(node.Left);
            return null;
        }
        public override BoundNode VisitNullCoalescingOperator(BoundNullCoalescingOperator node)
        {
            this.Visit(node.RightOperand);
            this.Visit(node.LeftOperand);
            return null;
        }
        public override BoundNode VisitConditionalOperator(BoundConditionalOperator node)
        {
            this.Visit(node.Alternative);
            this.Visit(node.Consequence);
            this.Visit(node.Condition);
            return null;
        }
        public override BoundNode VisitArrayAccess(BoundArrayAccess node)
        {
            this.VisitListReverse(node.Indices);
            this.Visit(node.Expression);
            return null;
        }
        public override BoundNode VisitArrayLength(BoundArrayLength node)
        {
            this.Visit(node.Expression);
            return null;
        }
        public override BoundNode VisitAwaitExpression(BoundAwaitExpression node)
        {
            this.Visit(node.Expression);
            return null;
        }
        public override BoundNode VisitLoweredAwaitExpressionStackMark(BoundLoweredAwaitExpressionStackMark node)
        {
            return null;
        }
        public override BoundNode VisitTypeOfOperator(BoundTypeOfOperator node)
        {
            this.Visit(node.SourceType);
            return null;
        }
        public override BoundNode VisitMethodInfo(BoundMethodInfo node)
        {
            return null;
        }
        public override BoundNode VisitFieldInfo(BoundFieldInfo node)
        {
            return null;
        }
        public override BoundNode VisitDefaultOperator(BoundDefaultOperator node)
        {
            return null;
        }
        public override BoundNode VisitIsOperator(BoundIsOperator node)
        {
            this.Visit(node.TargetType);
            this.Visit(node.Operand);
            return null;
        }
        public override BoundNode VisitAsOperator(BoundAsOperator node)
        {
            this.Visit(node.TargetType);
            this.Visit(node.Operand);
            return null;
        }
        public override BoundNode VisitSizeOfOperator(BoundSizeOfOperator node)
        {
            this.Visit(node.SourceType);
            return null;
        }
        public override BoundNode VisitConversion(BoundConversion node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override BoundNode VisitArgList(BoundArgList node)
        {
            return null;
        }
        public override BoundNode VisitArgListOperator(BoundArgListOperator node)
        {
            this.VisitListReverse(node.Arguments);
            return null;
        }
        public override BoundNode VisitFixedLocalCollectionInitializer(BoundFixedLocalCollectionInitializer node)
        {
            this.Visit(node.Expression);
            return null;
        }
        public override BoundNode VisitSequencePoint(BoundSequencePoint node)
        {
            this.Visit(node.StatementOpt);
            return null;
        }
        public override BoundNode VisitSequencePointWithSpan(BoundSequencePointWithSpan node)
        {
            this.Visit(node.StatementOpt);
            return null;
        }
        public override BoundNode VisitBlock(BoundBlock node)
        {
            this.VisitListReverse(node.Statements);
            return null;
        }
        public override BoundNode VisitIteratorScope(BoundIteratorScope node)
        {
            this.Visit(node.Statement);
            return null;
        }
        public override BoundNode VisitLocalDeclaration(BoundLocalDeclaration node)
        {
            this.VisitListReverse(node.ArgumentsOpt);
            this.Visit(node.InitializerOpt);
            this.Visit(node.DeclaredType);
            return null;
        }
        public override BoundNode VisitMultipleLocalDeclarations(BoundMultipleLocalDeclarations node)
        {
            this.VisitListReverse(node.LocalDeclarations);
            return null;
        }
        public override BoundNode VisitSequence(BoundSequence node)
        {
            this.Visit(node.Value);
            this.VisitListReverse(node.SideEffects);
            return null;
        }
        public override BoundNode VisitNoOpStatement(BoundNoOpStatement node)
        {
            return null;
        }
        public override BoundNode VisitReturnStatement(BoundReturnStatement node)
        {
            this.Visit(node.ExpressionOpt);
            return null;
        }
        public override BoundNode VisitYieldReturnStatement(BoundYieldReturnStatement node)
        {
            this.Visit(node.Expression);
            return null;
        }
        public override BoundNode VisitYieldBreakStatement(BoundYieldBreakStatement node)
        {
            return null;
        }
        public override BoundNode VisitThrowStatement(BoundThrowStatement node)
        {
            this.Visit(node.ExpressionOpt);
            return null;
        }
        public override BoundNode VisitExpressionStatement(BoundExpressionStatement node)
        {
            this.Visit(node.Expression);
            return null;
        }
        public override BoundNode VisitSwitchStatement(BoundSwitchStatement node)
        {
            this.VisitListReverse(node.SwitchSections);
            this.Visit(node.BoundExpression);
            return null;
        }
        public override BoundNode VisitSwitchSection(BoundSwitchSection node)
        {
            this.VisitListReverse(node.Statements);
            this.VisitListReverse(node.BoundSwitchLabels);
            return null;
        }
        public override BoundNode VisitSwitchLabel(BoundSwitchLabel node)
        {
            this.Visit(node.ExpressionOpt);
            return null;
        }
        public override BoundNode VisitBreakStatement(BoundBreakStatement node)
        {
            return null;
        }
        public override BoundNode VisitContinueStatement(BoundContinueStatement node)
        {
            return null;
        }
        public override BoundNode VisitIfStatement(BoundIfStatement node)
        {
            this.Visit(node.AlternativeOpt);
            this.Visit(node.Consequence);
            this.Visit(node.Condition);
            return null;
        }
        public override BoundNode VisitDoStatement(BoundDoStatement node)
        {
            this.Visit(node.Body);
            this.Visit(node.Condition);
            return null;
        }
        public override BoundNode VisitWhileStatement(BoundWhileStatement node)
        {
            this.Visit(node.Body);
            this.Visit(node.Condition);
            return null;
        }
        public override BoundNode VisitForStatement(BoundForStatement node)
        {
            this.Visit(node.Body);
            this.Visit(node.Increment);
            this.Visit(node.Condition);
            this.Visit(node.Initializer);
            return null;
        }
        public override BoundNode VisitForEachStatement(BoundForEachStatement node)
        {
            this.Visit(node.Body);
            this.Visit(node.Expression);
            this.Visit(node.IterationVariableType);
            return null;
        }
        public override BoundNode VisitUsingStatement(BoundUsingStatement node)
        {
            this.Visit(node.Body);
            this.Visit(node.ExpressionOpt);
            this.Visit(node.DeclarationsOpt);
            return null;
        }
        public override BoundNode VisitFixedStatement(BoundFixedStatement node)
        {
            this.Visit(node.Body);
            this.Visit(node.Declarations);
            return null;
        }
        public override BoundNode VisitLockStatement(BoundLockStatement node)
        {
            this.Visit(node.Body);
            this.Visit(node.Argument);
            return null;
        }
        public override BoundNode VisitTryStatement(BoundTryStatement node)
        {
            this.Visit(node.FinallyBlockOpt);
            this.VisitListReverse(node.CatchBlocks);
            this.Visit(node.TryBlock);
            return null;
        }
        public override BoundNode VisitCatchBlock(BoundCatchBlock node)
        {
            this.Visit(node.BoundBlock);
            return null;
        }
        public override BoundNode VisitLiteral(BoundLiteral node)
        {
            return null;
        }
        public override BoundNode VisitThisReference(BoundThisReference node)
        {
            return null;
        }
        public override BoundNode VisitPreviousSubmissionReference(BoundPreviousSubmissionReference node)
        {
            return null;
        }
        public override BoundNode VisitHostObjectMemberReference(BoundHostObjectMemberReference node)
        {
            return null;
        }
        public override BoundNode VisitBaseReference(BoundBaseReference node)
        {
            return null;
        }
        public override BoundNode VisitLocal(BoundLocal node)
        {
            return null;
        }
        public override BoundNode VisitRangeVariable(BoundRangeVariable node)
        {
            this.Visit(node.Value);
            return null;
        }
        public override BoundNode VisitParameter(BoundParameter node)
        {
            return null;
        }
        public override BoundNode VisitLabelStatement(BoundLabelStatement node)
        {
            return null;
        }
        public override BoundNode VisitGotoStatement(BoundGotoStatement node)
        {
            this.Visit(node.LabelExpressionOpt);
            this.Visit(node.CaseExpressionOpt);
            return null;
        }
        public override BoundNode VisitLabeledStatement(BoundLabeledStatement node)
        {
            this.Visit(node.Body);
            return null;
        }
        public override BoundNode VisitLabel(BoundLabel node)
        {
            return null;
        }
        public override BoundNode VisitStatementList(BoundStatementList node)
        {
            this.VisitListReverse(node.Statements);
            return null;
        }
        public override BoundNode VisitConditionalGoto(BoundConditionalGoto node)
        {
            this.Visit(node.Condition);
            return null;
        }
        public override BoundNode VisitDynamicMemberAccess(BoundDynamicMemberAccess node)
        {
            this.Visit(node.Receiver);
            return null;
        }
        public override BoundNode VisitDynamicInvocation(BoundDynamicInvocation node)
        {
            this.VisitListReverse(node.Arguments);
            this.Visit(node.Expression);
            return null;
        }
        public override BoundNode VisitMethodGroup(BoundMethodGroup node)
        {
            this.Visit(node.ReceiverOpt);
            return null;
        }
        public override BoundNode VisitPropertyGroup(BoundPropertyGroup node)
        {
            this.Visit(node.ReceiverOpt);
            return null;
        }
        public override BoundNode VisitCall(BoundCall node)
        {
            this.VisitListReverse(node.Arguments);
            this.Visit(node.ReceiverOpt);
            return null;
        }
        public override BoundNode VisitEventAssignmentOperator(BoundEventAssignmentOperator node)
        {
            this.Visit(node.Argument);
            this.Visit(node.ReceiverOpt);
            return null;
        }
        public override BoundNode VisitDelegateCall(BoundDelegateCall node)
        {
            this.VisitListReverse(node.Arguments);
            this.Visit(node.ReceiverOpt);
            return null;
        }
        public override BoundNode VisitAttribute(BoundAttribute node)
        {
            this.VisitListReverse(node.NamedArguments);
            this.VisitListReverse(node.ConstructorArguments);
            return null;
        }
        public override BoundNode VisitObjectCreationExpression(BoundObjectCreationExpression node)
        {
            this.Visit(node.InitializerExpressionOpt);
            this.VisitListReverse(node.Arguments);
            return null;
        }
        public override BoundNode VisitDynamicObjectCreationExpression(BoundDynamicObjectCreationExpression node)
        {
            this.Visit(node.InitializerExpressionOpt);
            this.VisitListReverse(node.Arguments);
            return null;
        }
        public override BoundNode VisitObjectInitializerExpression(BoundObjectInitializerExpression node)
        {
            this.VisitListReverse(node.Initializers);
            return null;
        }
        public override BoundNode VisitObjectInitializerMember(BoundObjectInitializerMember node)
        {
            return null;
        }
        public override BoundNode VisitCollectionInitializerExpression(BoundCollectionInitializerExpression node)
        {
            this.VisitListReverse(node.Initializers);
            return null;
        }
        public override BoundNode VisitCollectionElementInitializer(BoundCollectionElementInitializer node)
        {
            this.VisitListReverse(node.Arguments);
            return null;
        }
        public override BoundNode VisitDynamicCollectionElementInitializer(BoundDynamicCollectionElementInitializer node)
        {
            this.VisitListReverse(node.Arguments);
            return null;
        }
        public override BoundNode VisitImplicitReceiver(BoundImplicitReceiver node)
        {
            return null;
        }
        public override BoundNode VisitAnonymousObjectCreationExpression(BoundAnonymousObjectCreationExpression node)
        {
            this.VisitListReverse(node.Declarations);
            this.VisitListReverse(node.Arguments);
            return null;
        }
        public override BoundNode VisitAnonymousPropertyDeclaration(BoundAnonymousPropertyDeclaration node)
        {
            return null;
        }
        public override BoundNode VisitNewT(BoundNewT node)
        {
            this.Visit(node.InitializerExpressionOpt);
            return null;
        }
        public override BoundNode VisitDelegateCreationExpression(BoundDelegateCreationExpression node)
        {
            this.Visit(node.Argument);
            return null;
        }
        public override BoundNode VisitArrayCreation(BoundArrayCreation node)
        {
            this.Visit(node.InitializerOpt);
            this.VisitListReverse(node.Bounds);
            return null;
        }
        public override BoundNode VisitArrayInitialization(BoundArrayInitialization node)
        {
            this.VisitListReverse(node.Initializers);
            return null;
        }
        public override BoundNode VisitStackAllocArrayCreation(BoundStackAllocArrayCreation node)
        {
            this.Visit(node.Count);
            return null;
        }
        public override BoundNode VisitFieldAccess(BoundFieldAccess node)
        {
            this.Visit(node.ReceiverOpt);
            return null;
        }
        public override BoundNode VisitPropertyAccess(BoundPropertyAccess node)
        {
            this.Visit(node.ReceiverOpt);
            return null;
        }
        public override BoundNode VisitEventAccess(BoundEventAccess node)
        {
            this.Visit(node.ReceiverOpt);
            return null;
        }
        public override BoundNode VisitIndexerAccess(BoundIndexerAccess node)
        {
            this.VisitListReverse(node.Arguments);
            this.Visit(node.ReceiverOpt);
            return null;
        }
        public override BoundNode VisitDynamicIndexerAccess(BoundDynamicIndexerAccess node)
        {
            this.VisitListReverse(node.Arguments);
            this.Visit(node.ReceiverOpt);
            return null;
        }
        public override BoundNode VisitLambda(BoundLambda node)
        {
            this.Visit(node.Body);
            return null;
        }
        public override BoundNode VisitUnboundLambda(UnboundLambda node)
        {
            return null;
        }
        public override BoundNode VisitQueryClause(BoundQueryClause node)
        {
            this.Visit(node.Value);
            return null;
        }
    }

    internal abstract partial class BoundTreeRewriter : BoundTreeVisitor
    {
        public override BoundNode VisitFieldInitializer(BoundFieldInitializer node)
        {
            BoundExpression initialValue = (BoundExpression)this.Visit(node.InitialValue);
            return node.Update(node.Field, initialValue);
        }
        public override BoundNode VisitGlobalStatementInitializer(BoundGlobalStatementInitializer node)
        {
            BoundStatement statement = (BoundStatement)this.Visit(node.Statement);
            return node.Update(statement);
        }
        public override BoundNode VisitDup(BoundDup node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.RefKind, type);
        }
        public override BoundNode VisitBadExpression(BoundBadExpression node)
        {
            ReadOnlyArray<BoundNode> childBoundNodes = (ReadOnlyArray<BoundNode>)this.VisitList(node.ChildBoundNodes);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.ResultKind, node.Symbols, childBoundNodes, type);
        }
        public override BoundNode VisitBadStatement(BoundBadStatement node)
        {
            ReadOnlyArray<BoundNode> childBoundNodes = (ReadOnlyArray<BoundNode>)this.VisitList(node.ChildBoundNodes);
            return node.Update(childBoundNodes);
        }
        public override BoundNode VisitTypeExpression(BoundTypeExpression node)
        {
            BoundTypeExpression boundContainingTypeOpt = (BoundTypeExpression)this.Visit(node.BoundContainingTypeOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.AliasOpt, node.InferredType, boundContainingTypeOpt, type);
        }
        public override BoundNode VisitTypeOrValueExpression(BoundTypeOrValueExpression node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Variable, node.Binder, type);
        }
        public override BoundNode VisitNamespaceExpression(BoundNamespaceExpression node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.NamespaceSymbol, node.AliasOpt);
        }
        public override BoundNode VisitUnaryOperator(BoundUnaryOperator node)
        {
            BoundExpression operand = (BoundExpression)this.Visit(node.Operand);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.OperatorKind, operand, node.ConstantValueOpt, node.MethodOpt, node.ResultKind, type);
        }
        public override BoundNode VisitIncrementOperator(BoundIncrementOperator node)
        {
            BoundExpression operand = (BoundExpression)this.Visit(node.Operand);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.OperatorKind, operand, node.MethodOpt, node.OperandConversion, node.ResultConversion, node.ResultKind, type);
        }
        public override BoundNode VisitAddressOfOperator(BoundAddressOfOperator node)
        {
            BoundExpression operand = (BoundExpression)this.Visit(node.Operand);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(operand, node.IsFixedStatementAddressOf, type);
        }
        public override BoundNode VisitPointerIndirectionOperator(BoundPointerIndirectionOperator node)
        {
            BoundExpression operand = (BoundExpression)this.Visit(node.Operand);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(operand, type);
        }
        public override BoundNode VisitPointerElementAccess(BoundPointerElementAccess node)
        {
            BoundExpression expression = (BoundExpression)this.Visit(node.Expression);
            BoundExpression index = (BoundExpression)this.Visit(node.Index);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(expression, index, node.Checked, type);
        }
        public override BoundNode VisitRefTypeOperator(BoundRefTypeOperator node)
        {
            BoundExpression operand = (BoundExpression)this.Visit(node.Operand);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(operand, type);
        }
        public override BoundNode VisitMakeRefOperator(BoundMakeRefOperator node)
        {
            BoundExpression operand = (BoundExpression)this.Visit(node.Operand);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(operand, type);
        }
        public override BoundNode VisitRefValueOperator(BoundRefValueOperator node)
        {
            BoundExpression operand = (BoundExpression)this.Visit(node.Operand);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(operand, type);
        }
        public override BoundNode VisitBinaryOperator(BoundBinaryOperator node)
        {
            BoundExpression left = (BoundExpression)this.Visit(node.Left);
            BoundExpression right = (BoundExpression)this.Visit(node.Right);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.OperatorKind, left, right, node.ConstantValueOpt, node.MethodOpt, node.ResultKind, type);
        }
        public override BoundNode VisitCompoundAssignmentOperator(BoundCompoundAssignmentOperator node)
        {
            BoundExpression left = (BoundExpression)this.Visit(node.Left);
            BoundExpression right = (BoundExpression)this.Visit(node.Right);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Operator, left, right, node.LeftConversion, node.FinalConversion, node.ResultKind, type);
        }
        public override BoundNode VisitAssignmentOperator(BoundAssignmentOperator node)
        {
            BoundExpression left = (BoundExpression)this.Visit(node.Left);
            BoundExpression right = (BoundExpression)this.Visit(node.Right);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(left, right, node.RefKind, type);
        }
        public override BoundNode VisitNullCoalescingOperator(BoundNullCoalescingOperator node)
        {
            BoundExpression leftOperand = (BoundExpression)this.Visit(node.LeftOperand);
            BoundExpression rightOperand = (BoundExpression)this.Visit(node.RightOperand);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(leftOperand, rightOperand, node.LeftConversion, type);
        }
        public override BoundNode VisitConditionalOperator(BoundConditionalOperator node)
        {
            BoundExpression condition = (BoundExpression)this.Visit(node.Condition);
            BoundExpression consequence = (BoundExpression)this.Visit(node.Consequence);
            BoundExpression alternative = (BoundExpression)this.Visit(node.Alternative);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(condition, consequence, alternative, node.ConstantValueOpt, type);
        }
        public override BoundNode VisitArrayAccess(BoundArrayAccess node)
        {
            BoundExpression expression = (BoundExpression)this.Visit(node.Expression);
            ReadOnlyArray<BoundExpression> indices = (ReadOnlyArray<BoundExpression>)this.VisitList(node.Indices);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(expression, indices, type);
        }
        public override BoundNode VisitArrayLength(BoundArrayLength node)
        {
            BoundExpression expression = (BoundExpression)this.Visit(node.Expression);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(expression, type);
        }
        public override BoundNode VisitAwaitExpression(BoundAwaitExpression node)
        {
            BoundExpression expression = (BoundExpression)this.Visit(node.Expression);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(expression, node.GetAwaiter, node.IsCompleted, node.GetResult, type);
        }
        public override BoundNode VisitLoweredAwaitExpressionStackMark(BoundLoweredAwaitExpressionStackMark node)
        {
            return node;
        }
        public override BoundNode VisitTypeOfOperator(BoundTypeOfOperator node)
        {
            BoundTypeExpression sourceType = (BoundTypeExpression)this.Visit(node.SourceType);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(sourceType, type);
        }
        public override BoundNode VisitMethodInfo(BoundMethodInfo node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Method, type);
        }
        public override BoundNode VisitFieldInfo(BoundFieldInfo node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Field, type);
        }
        public override BoundNode VisitDefaultOperator(BoundDefaultOperator node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.ConstantValueOpt, type);
        }
        public override BoundNode VisitIsOperator(BoundIsOperator node)
        {
            BoundExpression operand = (BoundExpression)this.Visit(node.Operand);
            BoundTypeExpression targetType = (BoundTypeExpression)this.Visit(node.TargetType);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(operand, targetType, node.Conversion, type);
        }
        public override BoundNode VisitAsOperator(BoundAsOperator node)
        {
            BoundExpression operand = (BoundExpression)this.Visit(node.Operand);
            BoundTypeExpression targetType = (BoundTypeExpression)this.Visit(node.TargetType);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(operand, targetType, node.Conversion, type);
        }
        public override BoundNode VisitSizeOfOperator(BoundSizeOfOperator node)
        {
            BoundTypeExpression sourceType = (BoundTypeExpression)this.Visit(node.SourceType);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(sourceType, node.ConstantValueOpt, type);
        }
        public override BoundNode VisitConversion(BoundConversion node)
        {
            BoundExpression operand = (BoundExpression)this.Visit(node.Operand);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(operand, node.ConversionKind, node.SymbolOpt, node.Checked, node.ExplicitCastInCode, node.IsExtensionMethod, node.IsArrayIndex, node.ConstantValueOpt, node.ResultKind, type);
        }
        public override BoundNode VisitArgList(BoundArgList node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(type);
        }
        public override BoundNode VisitArgListOperator(BoundArgListOperator node)
        {
            ReadOnlyArray<BoundExpression> arguments = (ReadOnlyArray<BoundExpression>)this.VisitList(node.Arguments);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(arguments, node.ArgumentRefKindsOpt, type);
        }
        public override BoundNode VisitFixedLocalCollectionInitializer(BoundFixedLocalCollectionInitializer node)
        {
            BoundExpression expression = (BoundExpression)this.Visit(node.Expression);
            TypeSymbol elementPointerType = this.VisitType(node.ElementPointerType);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(elementPointerType, node.ElementPointerTypeConversion, node.HelperMethodOpt, expression, type);
        }
        public override BoundNode VisitSequencePoint(BoundSequencePoint node)
        {
            BoundStatement statementOpt = (BoundStatement)this.Visit(node.StatementOpt);
            return node.Update(statementOpt);
        }
        public override BoundNode VisitSequencePointWithSpan(BoundSequencePointWithSpan node)
        {
            BoundStatement statementOpt = (BoundStatement)this.Visit(node.StatementOpt);
            return node.Update(statementOpt, node.Span);
        }
        public override BoundNode VisitBlock(BoundBlock node)
        {
            ReadOnlyArray<BoundStatement> statements = (ReadOnlyArray<BoundStatement>)this.VisitList(node.Statements);
            return node.Update(node.LocalsOpt, statements);
        }
        public override BoundNode VisitIteratorScope(BoundIteratorScope node)
        {
            BoundStatement statement = (BoundStatement)this.Visit(node.Statement);
            return node.Update(node.Fields, statement);
        }
        public override BoundNode VisitLocalDeclaration(BoundLocalDeclaration node)
        {
            BoundTypeExpression declaredType = (BoundTypeExpression)this.Visit(node.DeclaredType);
            BoundExpression initializerOpt = (BoundExpression)this.Visit(node.InitializerOpt);
            ReadOnlyArray<BoundExpression> argumentsOpt = (ReadOnlyArray<BoundExpression>)this.VisitList(node.ArgumentsOpt);
            return node.Update(node.LocalSymbol, declaredType, initializerOpt, argumentsOpt);
        }
        public override BoundNode VisitMultipleLocalDeclarations(BoundMultipleLocalDeclarations node)
        {
            ReadOnlyArray<BoundLocalDeclaration> localDeclarations = (ReadOnlyArray<BoundLocalDeclaration>)this.VisitList(node.LocalDeclarations);
            return node.Update(localDeclarations);
        }
        public override BoundNode VisitSequence(BoundSequence node)
        {
            ReadOnlyArray<BoundStatement> sideEffects = (ReadOnlyArray<BoundStatement>)this.VisitList(node.SideEffects);
            BoundExpression value = (BoundExpression)this.Visit(node.Value);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Locals, sideEffects, value, type);
        }
        public override BoundNode VisitNoOpStatement(BoundNoOpStatement node)
        {
            return node;
        }
        public override BoundNode VisitReturnStatement(BoundReturnStatement node)
        {
            BoundExpression expressionOpt = (BoundExpression)this.Visit(node.ExpressionOpt);
            return node.Update(expressionOpt);
        }
        public override BoundNode VisitYieldReturnStatement(BoundYieldReturnStatement node)
        {
            BoundExpression expression = (BoundExpression)this.Visit(node.Expression);
            return node.Update(expression);
        }
        public override BoundNode VisitYieldBreakStatement(BoundYieldBreakStatement node)
        {
            return node;
        }
        public override BoundNode VisitThrowStatement(BoundThrowStatement node)
        {
            BoundExpression expressionOpt = (BoundExpression)this.Visit(node.ExpressionOpt);
            return node.Update(expressionOpt);
        }
        public override BoundNode VisitExpressionStatement(BoundExpressionStatement node)
        {
            BoundExpression expression = (BoundExpression)this.Visit(node.Expression);
            return node.Update(expression);
        }
        public override BoundNode VisitSwitchStatement(BoundSwitchStatement node)
        {
            BoundExpression boundExpression = (BoundExpression)this.Visit(node.BoundExpression);
            ReadOnlyArray<BoundSwitchSection> switchSections = (ReadOnlyArray<BoundSwitchSection>)this.VisitList(node.SwitchSections);
            return node.Update(boundExpression, node.ConstantTargetOpt, node.LocalsOpt, switchSections, node.BreakLabel);
        }
        public override BoundNode VisitSwitchSection(BoundSwitchSection node)
        {
            ReadOnlyArray<BoundSwitchLabel> boundSwitchLabels = (ReadOnlyArray<BoundSwitchLabel>)this.VisitList(node.BoundSwitchLabels);
            ReadOnlyArray<BoundStatement> statements = (ReadOnlyArray<BoundStatement>)this.VisitList(node.Statements);
            return node.Update(boundSwitchLabels, statements);
        }
        public override BoundNode VisitSwitchLabel(BoundSwitchLabel node)
        {
            BoundExpression expressionOpt = (BoundExpression)this.Visit(node.ExpressionOpt);
            return node.Update(node.Label, expressionOpt);
        }
        public override BoundNode VisitBreakStatement(BoundBreakStatement node)
        {
            return node;
        }
        public override BoundNode VisitContinueStatement(BoundContinueStatement node)
        {
            return node;
        }
        public override BoundNode VisitIfStatement(BoundIfStatement node)
        {
            BoundExpression condition = (BoundExpression)this.Visit(node.Condition);
            BoundStatement consequence = (BoundStatement)this.Visit(node.Consequence);
            BoundStatement alternativeOpt = (BoundStatement)this.Visit(node.AlternativeOpt);
            return node.Update(condition, consequence, alternativeOpt);
        }
        public override BoundNode VisitDoStatement(BoundDoStatement node)
        {
            BoundExpression condition = (BoundExpression)this.Visit(node.Condition);
            BoundStatement body = (BoundStatement)this.Visit(node.Body);
            return node.Update(condition, body, node.BreakLabel, node.ContinueLabel);
        }
        public override BoundNode VisitWhileStatement(BoundWhileStatement node)
        {
            BoundExpression condition = (BoundExpression)this.Visit(node.Condition);
            BoundStatement body = (BoundStatement)this.Visit(node.Body);
            return node.Update(condition, body, node.BreakLabel, node.ContinueLabel);
        }
        public override BoundNode VisitForStatement(BoundForStatement node)
        {
            BoundStatement initializer = (BoundStatement)this.Visit(node.Initializer);
            BoundExpression condition = (BoundExpression)this.Visit(node.Condition);
            BoundStatement increment = (BoundStatement)this.Visit(node.Increment);
            BoundStatement body = (BoundStatement)this.Visit(node.Body);
            return node.Update(node.Locals, initializer, condition, increment, body, node.BreakLabel, node.ContinueLabel);
        }
        public override BoundNode VisitForEachStatement(BoundForEachStatement node)
        {
            BoundTypeExpression iterationVariableType = (BoundTypeExpression)this.Visit(node.IterationVariableType);
            BoundExpression expression = (BoundExpression)this.Visit(node.Expression);
            BoundStatement body = (BoundStatement)this.Visit(node.Body);
            return node.Update(node.EnumeratorInfoOpt, node.ElementConversion, iterationVariableType, node.IterationVariable, expression, body, node.Checked, node.BreakLabel, node.ContinueLabel);
        }
        public override BoundNode VisitUsingStatement(BoundUsingStatement node)
        {
            BoundMultipleLocalDeclarations declarationsOpt = (BoundMultipleLocalDeclarations)this.Visit(node.DeclarationsOpt);
            BoundExpression expressionOpt = (BoundExpression)this.Visit(node.ExpressionOpt);
            BoundStatement body = (BoundStatement)this.Visit(node.Body);
            return node.Update(node.LocalsOpt, declarationsOpt, expressionOpt, node.IDisposableConversion, body);
        }
        public override BoundNode VisitFixedStatement(BoundFixedStatement node)
        {
            BoundMultipleLocalDeclarations declarations = (BoundMultipleLocalDeclarations)this.Visit(node.Declarations);
            BoundStatement body = (BoundStatement)this.Visit(node.Body);
            return node.Update(node.Locals, declarations, body);
        }
        public override BoundNode VisitLockStatement(BoundLockStatement node)
        {
            BoundExpression argument = (BoundExpression)this.Visit(node.Argument);
            BoundStatement body = (BoundStatement)this.Visit(node.Body);
            return node.Update(argument, body, node.EnterMethod, node.ExitMethod);
        }
        public override BoundNode VisitTryStatement(BoundTryStatement node)
        {
            BoundBlock tryBlock = (BoundBlock)this.Visit(node.TryBlock);
            ReadOnlyArray<BoundCatchBlock> catchBlocks = (ReadOnlyArray<BoundCatchBlock>)this.VisitList(node.CatchBlocks);
            BoundBlock finallyBlockOpt = (BoundBlock)this.Visit(node.FinallyBlockOpt);
            return node.Update(tryBlock, catchBlocks, finallyBlockOpt);
        }
        public override BoundNode VisitCatchBlock(BoundCatchBlock node)
        {
            BoundBlock boundBlock = (BoundBlock)this.Visit(node.BoundBlock);
            TypeSymbol exceptionTypeOpt = this.VisitType(node.ExceptionTypeOpt);
            return node.Update(node.LocalOpt, exceptionTypeOpt, boundBlock);
        }
        public override BoundNode VisitLiteral(BoundLiteral node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.ConstantValueOpt, type);
        }
        public override BoundNode VisitThisReference(BoundThisReference node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.ThisSymbol, type);
        }
        public override BoundNode VisitPreviousSubmissionReference(BoundPreviousSubmissionReference node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.SourceType, type);
        }
        public override BoundNode VisitHostObjectMemberReference(BoundHostObjectMemberReference node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(type);
        }
        public override BoundNode VisitBaseReference(BoundBaseReference node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.ThisSymbol, type);
        }
        public override BoundNode VisitLocal(BoundLocal node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.LocalSymbol, node.ConstantValueOpt, type);
        }
        public override BoundNode VisitRangeVariable(BoundRangeVariable node)
        {
            BoundExpression value = (BoundExpression)this.Visit(node.Value);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.RangeVariableSymbol, value, type);
        }
        public override BoundNode VisitParameter(BoundParameter node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.ParameterSymbol, type);
        }
        public override BoundNode VisitLabelStatement(BoundLabelStatement node)
        {
            return node;
        }
        public override BoundNode VisitGotoStatement(BoundGotoStatement node)
        {
            BoundExpression caseExpressionOpt = (BoundExpression)this.Visit(node.CaseExpressionOpt);
            BoundLabel labelExpressionOpt = (BoundLabel)this.Visit(node.LabelExpressionOpt);
            return node.Update(node.Label, caseExpressionOpt, labelExpressionOpt);
        }
        public override BoundNode VisitLabeledStatement(BoundLabeledStatement node)
        {
            BoundStatement body = (BoundStatement)this.Visit(node.Body);
            return node.Update(node.Label, body);
        }
        public override BoundNode VisitLabel(BoundLabel node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Label, type);
        }
        public override BoundNode VisitStatementList(BoundStatementList node)
        {
            ReadOnlyArray<BoundStatement> statements = (ReadOnlyArray<BoundStatement>)this.VisitList(node.Statements);
            return node.Update(statements);
        }
        public override BoundNode VisitConditionalGoto(BoundConditionalGoto node)
        {
            BoundExpression condition = (BoundExpression)this.Visit(node.Condition);
            return node.Update(condition, node.JumpIfTrue, node.Label);
        }
        public override BoundNode VisitDynamicMemberAccess(BoundDynamicMemberAccess node)
        {
            BoundExpression receiver = (BoundExpression)this.Visit(node.Receiver);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(receiver, node.TypeArgumentsOpt, node.Name, node.Invoked, node.Indexed, type);
        }
        public override BoundNode VisitDynamicInvocation(BoundDynamicInvocation node)
        {
            BoundExpression expression = (BoundExpression)this.Visit(node.Expression);
            ReadOnlyArray<BoundExpression> arguments = (ReadOnlyArray<BoundExpression>)this.VisitList(node.Arguments);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(expression, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, node.ApplicableMethods, type);
        }
        public override BoundNode VisitMethodGroup(BoundMethodGroup node)
        {
            BoundExpression receiverOpt = (BoundExpression)this.Visit(node.ReceiverOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.TypeArgumentsOpt, node.Name, node.Methods, node.LookupSymbolOpt, node.LookupError, node.Flags, receiverOpt, node.ResultKind);
        }
        public override BoundNode VisitPropertyGroup(BoundPropertyGroup node)
        {
            BoundExpression receiverOpt = (BoundExpression)this.Visit(node.ReceiverOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Properties, receiverOpt, node.ResultKind);
        }
        public override BoundNode VisitCall(BoundCall node)
        {
            BoundExpression receiverOpt = (BoundExpression)this.Visit(node.ReceiverOpt);
            ReadOnlyArray<BoundExpression> arguments = (ReadOnlyArray<BoundExpression>)this.VisitList(node.Arguments);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(receiverOpt, node.Method, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, node.Expanded, node.InvokedAsExtensionMethod, node.ArgsToParamsOpt, node.ResultKind, type);
        }
        public override BoundNode VisitEventAssignmentOperator(BoundEventAssignmentOperator node)
        {
            BoundExpression receiverOpt = (BoundExpression)this.Visit(node.ReceiverOpt);
            BoundExpression argument = (BoundExpression)this.Visit(node.Argument);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Event, node.IsAddition, node.IsDynamic, receiverOpt, argument, type);
        }
        public override BoundNode VisitDelegateCall(BoundDelegateCall node)
        {
            BoundExpression receiverOpt = (BoundExpression)this.Visit(node.ReceiverOpt);
            ReadOnlyArray<BoundExpression> arguments = (ReadOnlyArray<BoundExpression>)this.VisitList(node.Arguments);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(receiverOpt, node.Method, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, node.Expanded, node.InvokedAsExtensionMethod, node.ArgsToParamsOpt, node.ResultKind, type);
        }
        public override BoundNode VisitAttribute(BoundAttribute node)
        {
            ReadOnlyArray<BoundExpression> constructorArguments = (ReadOnlyArray<BoundExpression>)this.VisitList(node.ConstructorArguments);
            ReadOnlyArray<BoundExpression> namedArguments = (ReadOnlyArray<BoundExpression>)this.VisitList(node.NamedArguments);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Constructor, constructorArguments, node.ConstructorArgumentNamesOpt, namedArguments, node.ResultKind, type);
        }
        public override BoundNode VisitObjectCreationExpression(BoundObjectCreationExpression node)
        {
            ReadOnlyArray<BoundExpression> arguments = (ReadOnlyArray<BoundExpression>)this.VisitList(node.Arguments);
            BoundExpression initializerExpressionOpt = (BoundExpression)this.Visit(node.InitializerExpressionOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Constructor, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, node.Expanded, node.ArgsToParamsOpt, node.ConstantValueOpt, initializerExpressionOpt, type);
        }
        public override BoundNode VisitDynamicObjectCreationExpression(BoundDynamicObjectCreationExpression node)
        {
            ReadOnlyArray<BoundExpression> arguments = (ReadOnlyArray<BoundExpression>)this.VisitList(node.Arguments);
            BoundExpression initializerExpressionOpt = (BoundExpression)this.Visit(node.InitializerExpressionOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, initializerExpressionOpt, node.ApplicableMethods, type);
        }
        public override BoundNode VisitObjectInitializerExpression(BoundObjectInitializerExpression node)
        {
            ReadOnlyArray<BoundExpression> initializers = (ReadOnlyArray<BoundExpression>)this.VisitList(node.Initializers);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(initializers, type);
        }
        public override BoundNode VisitObjectInitializerMember(BoundObjectInitializerMember node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.MemberSymbol, node.ResultKind, type);
        }
        public override BoundNode VisitCollectionInitializerExpression(BoundCollectionInitializerExpression node)
        {
            ReadOnlyArray<BoundExpression> initializers = (ReadOnlyArray<BoundExpression>)this.VisitList(node.Initializers);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(initializers, type);
        }
        public override BoundNode VisitCollectionElementInitializer(BoundCollectionElementInitializer node)
        {
            ReadOnlyArray<BoundExpression> arguments = (ReadOnlyArray<BoundExpression>)this.VisitList(node.Arguments);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.AddMethod, arguments, node.Expanded, node.ArgsToParamsOpt, node.InvokedAsExtensionMethod, node.ResultKind, type);
        }
        public override BoundNode VisitDynamicCollectionElementInitializer(BoundDynamicCollectionElementInitializer node)
        {
            ReadOnlyArray<BoundExpression> arguments = (ReadOnlyArray<BoundExpression>)this.VisitList(node.Arguments);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, node.ApplicableMethods, type);
        }
        public override BoundNode VisitImplicitReceiver(BoundImplicitReceiver node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(type);
        }
        public override BoundNode VisitAnonymousObjectCreationExpression(BoundAnonymousObjectCreationExpression node)
        {
            ReadOnlyArray<BoundExpression> arguments = (ReadOnlyArray<BoundExpression>)this.VisitList(node.Arguments);
            ReadOnlyArray<BoundAnonymousPropertyDeclaration> declarations = (ReadOnlyArray<BoundAnonymousPropertyDeclaration>)this.VisitList(node.Declarations);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Constructor, arguments, declarations, type);
        }
        public override BoundNode VisitAnonymousPropertyDeclaration(BoundAnonymousPropertyDeclaration node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Property, type);
        }
        public override BoundNode VisitNewT(BoundNewT node)
        {
            BoundExpression initializerExpressionOpt = (BoundExpression)this.Visit(node.InitializerExpressionOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(initializerExpressionOpt, type);
        }
        public override BoundNode VisitDelegateCreationExpression(BoundDelegateCreationExpression node)
        {
            BoundExpression argument = (BoundExpression)this.Visit(node.Argument);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(argument, node.MethodOpt, node.IsExtensionMethod, type);
        }
        public override BoundNode VisitArrayCreation(BoundArrayCreation node)
        {
            ReadOnlyArray<BoundExpression> bounds = (ReadOnlyArray<BoundExpression>)this.VisitList(node.Bounds);
            BoundArrayInitialization initializerOpt = (BoundArrayInitialization)this.Visit(node.InitializerOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(bounds, initializerOpt, type);
        }
        public override BoundNode VisitArrayInitialization(BoundArrayInitialization node)
        {
            ReadOnlyArray<BoundExpression> initializers = (ReadOnlyArray<BoundExpression>)this.VisitList(node.Initializers);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(initializers);
        }
        public override BoundNode VisitStackAllocArrayCreation(BoundStackAllocArrayCreation node)
        {
            BoundExpression count = (BoundExpression)this.Visit(node.Count);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(count, type);
        }
        public override BoundNode VisitFieldAccess(BoundFieldAccess node)
        {
            BoundExpression receiverOpt = (BoundExpression)this.Visit(node.ReceiverOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(receiverOpt, node.FieldSymbol, node.ConstantValueOpt, node.ResultKind, type);
        }
        public override BoundNode VisitPropertyAccess(BoundPropertyAccess node)
        {
            BoundExpression receiverOpt = (BoundExpression)this.Visit(node.ReceiverOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(receiverOpt, node.PropertySymbol, node.ResultKind, type);
        }
        public override BoundNode VisitEventAccess(BoundEventAccess node)
        {
            BoundExpression receiverOpt = (BoundExpression)this.Visit(node.ReceiverOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(receiverOpt, node.EventSymbol, node.IsUsableAsField, node.ResultKind, type);
        }
        public override BoundNode VisitIndexerAccess(BoundIndexerAccess node)
        {
            BoundExpression receiverOpt = (BoundExpression)this.Visit(node.ReceiverOpt);
            ReadOnlyArray<BoundExpression> arguments = (ReadOnlyArray<BoundExpression>)this.VisitList(node.Arguments);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(receiverOpt, node.Indexer, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, node.Expanded, node.ArgsToParamsOpt, type);
        }
        public override BoundNode VisitDynamicIndexerAccess(BoundDynamicIndexerAccess node)
        {
            BoundExpression receiverOpt = (BoundExpression)this.Visit(node.ReceiverOpt);
            ReadOnlyArray<BoundExpression> arguments = (ReadOnlyArray<BoundExpression>)this.VisitList(node.Arguments);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(receiverOpt, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, node.ApplicableIndexers, type);
        }
        public override BoundNode VisitLambda(BoundLambda node)
        {
            BoundBlock body = (BoundBlock)this.Visit(node.Body);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(body, node.Diagnostics, node.Binder, type);
        }
        public override BoundNode VisitUnboundLambda(UnboundLambda node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Data);
        }
        public override BoundNode VisitQueryClause(BoundQueryClause node)
        {
            BoundExpression value = (BoundExpression)this.Visit(node.Value);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(value, node.DefinedSymbol, node.Binder, type);
        }
    }

    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class BoundTreeDumperNodeProducer : BoundTreeVisitor<object, TreeDumperNode>
    {
        private BoundTreeDumperNodeProducer()
        {
        }
        public static TreeDumperNode MakeTree(BoundNode node)
        {
            return (new BoundTreeDumperNodeProducer()).Visit(node, null);
        }
        public override TreeDumperNode VisitFieldInitializer(BoundFieldInitializer node, object arg)
        {
            return new TreeDumperNode("fieldInitializer", null, new TreeDumperNode[]
            {
                new TreeDumperNode("field", node.Field, null),
                new TreeDumperNode("initialValue", null, new TreeDumperNode[] { Visit(node.InitialValue, null) })
            }
            );
        }
        public override TreeDumperNode VisitGlobalStatementInitializer(BoundGlobalStatementInitializer node, object arg)
        {
            return new TreeDumperNode("globalStatementInitializer", null, new TreeDumperNode[]
            {
                new TreeDumperNode("statement", null, new TreeDumperNode[] { Visit(node.Statement, null) })
            }
            );
        }
        public override TreeDumperNode VisitDup(BoundDup node, object arg)
        {
            return new TreeDumperNode("dup", null, new TreeDumperNode[]
            {
                new TreeDumperNode("refKind", node.RefKind, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitBadExpression(BoundBadExpression node, object arg)
        {
            return new TreeDumperNode("badExpression", null, new TreeDumperNode[]
            {
                new TreeDumperNode("resultKind", node.ResultKind, null),
                new TreeDumperNode("symbols", node.Symbols, null),
                new TreeDumperNode("childBoundNodes", null, from x in node.ChildBoundNodes select Visit(x, null)),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitBadStatement(BoundBadStatement node, object arg)
        {
            return new TreeDumperNode("badStatement", null, new TreeDumperNode[]
            {
                new TreeDumperNode("childBoundNodes", null, from x in node.ChildBoundNodes select Visit(x, null))
            }
            );
        }
        public override TreeDumperNode VisitTypeExpression(BoundTypeExpression node, object arg)
        {
            return new TreeDumperNode("typeExpression", null, new TreeDumperNode[]
            {
                new TreeDumperNode("aliasOpt", node.AliasOpt, null),
                new TreeDumperNode("inferredType", node.InferredType, null),
                new TreeDumperNode("boundContainingTypeOpt", null, new TreeDumperNode[] { Visit(node.BoundContainingTypeOpt, null) }),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitTypeOrValueExpression(BoundTypeOrValueExpression node, object arg)
        {
            return new TreeDumperNode("typeOrValueExpression", null, new TreeDumperNode[]
            {
                new TreeDumperNode("variable", node.Variable, null),
                new TreeDumperNode("binder", node.Binder, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitNamespaceExpression(BoundNamespaceExpression node, object arg)
        {
            return new TreeDumperNode("namespaceExpression", null, new TreeDumperNode[]
            {
                new TreeDumperNode("namespaceSymbol", node.NamespaceSymbol, null),
                new TreeDumperNode("aliasOpt", node.AliasOpt, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitUnaryOperator(BoundUnaryOperator node, object arg)
        {
            return new TreeDumperNode("unaryOperator", null, new TreeDumperNode[]
            {
                new TreeDumperNode("operatorKind", node.OperatorKind, null),
                new TreeDumperNode("operand", null, new TreeDumperNode[] { Visit(node.Operand, null) }),
                new TreeDumperNode("constantValueOpt", node.ConstantValueOpt, null),
                new TreeDumperNode("methodOpt", node.MethodOpt, null),
                new TreeDumperNode("resultKind", node.ResultKind, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitIncrementOperator(BoundIncrementOperator node, object arg)
        {
            return new TreeDumperNode("incrementOperator", null, new TreeDumperNode[]
            {
                new TreeDumperNode("operatorKind", node.OperatorKind, null),
                new TreeDumperNode("operand", null, new TreeDumperNode[] { Visit(node.Operand, null) }),
                new TreeDumperNode("methodOpt", node.MethodOpt, null),
                new TreeDumperNode("operandConversion", node.OperandConversion, null),
                new TreeDumperNode("resultConversion", node.ResultConversion, null),
                new TreeDumperNode("resultKind", node.ResultKind, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitAddressOfOperator(BoundAddressOfOperator node, object arg)
        {
            return new TreeDumperNode("addressOfOperator", null, new TreeDumperNode[]
            {
                new TreeDumperNode("operand", null, new TreeDumperNode[] { Visit(node.Operand, null) }),
                new TreeDumperNode("isFixedStatementAddressOf", node.IsFixedStatementAddressOf, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitPointerIndirectionOperator(BoundPointerIndirectionOperator node, object arg)
        {
            return new TreeDumperNode("pointerIndirectionOperator", null, new TreeDumperNode[]
            {
                new TreeDumperNode("operand", null, new TreeDumperNode[] { Visit(node.Operand, null) }),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitPointerElementAccess(BoundPointerElementAccess node, object arg)
        {
            return new TreeDumperNode("pointerElementAccess", null, new TreeDumperNode[]
            {
                new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
                new TreeDumperNode("index", null, new TreeDumperNode[] { Visit(node.Index, null) }),
                new TreeDumperNode("@checked", node.Checked, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitRefTypeOperator(BoundRefTypeOperator node, object arg)
        {
            return new TreeDumperNode("refTypeOperator", null, new TreeDumperNode[]
            {
                new TreeDumperNode("operand", null, new TreeDumperNode[] { Visit(node.Operand, null) }),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitMakeRefOperator(BoundMakeRefOperator node, object arg)
        {
            return new TreeDumperNode("makeRefOperator", null, new TreeDumperNode[]
            {
                new TreeDumperNode("operand", null, new TreeDumperNode[] { Visit(node.Operand, null) }),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitRefValueOperator(BoundRefValueOperator node, object arg)
        {
            return new TreeDumperNode("refValueOperator", null, new TreeDumperNode[]
            {
                new TreeDumperNode("operand", null, new TreeDumperNode[] { Visit(node.Operand, null) }),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitBinaryOperator(BoundBinaryOperator node, object arg)
        {
            return new TreeDumperNode("binaryOperator", null, new TreeDumperNode[]
            {
                new TreeDumperNode("operatorKind", node.OperatorKind, null),
                new TreeDumperNode("left", null, new TreeDumperNode[] { Visit(node.Left, null) }),
                new TreeDumperNode("right", null, new TreeDumperNode[] { Visit(node.Right, null) }),
                new TreeDumperNode("constantValueOpt", node.ConstantValueOpt, null),
                new TreeDumperNode("methodOpt", node.MethodOpt, null),
                new TreeDumperNode("resultKind", node.ResultKind, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitCompoundAssignmentOperator(BoundCompoundAssignmentOperator node, object arg)
        {
            return new TreeDumperNode("compoundAssignmentOperator", null, new TreeDumperNode[]
            {
                new TreeDumperNode("@operator", node.Operator, null),
                new TreeDumperNode("left", null, new TreeDumperNode[] { Visit(node.Left, null) }),
                new TreeDumperNode("right", null, new TreeDumperNode[] { Visit(node.Right, null) }),
                new TreeDumperNode("leftConversion", node.LeftConversion, null),
                new TreeDumperNode("finalConversion", node.FinalConversion, null),
                new TreeDumperNode("resultKind", node.ResultKind, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitAssignmentOperator(BoundAssignmentOperator node, object arg)
        {
            return new TreeDumperNode("assignmentOperator", null, new TreeDumperNode[]
            {
                new TreeDumperNode("left", null, new TreeDumperNode[] { Visit(node.Left, null) }),
                new TreeDumperNode("right", null, new TreeDumperNode[] { Visit(node.Right, null) }),
                new TreeDumperNode("refKind", node.RefKind, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitNullCoalescingOperator(BoundNullCoalescingOperator node, object arg)
        {
            return new TreeDumperNode("nullCoalescingOperator", null, new TreeDumperNode[]
            {
                new TreeDumperNode("leftOperand", null, new TreeDumperNode[] { Visit(node.LeftOperand, null) }),
                new TreeDumperNode("rightOperand", null, new TreeDumperNode[] { Visit(node.RightOperand, null) }),
                new TreeDumperNode("leftConversion", node.LeftConversion, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitConditionalOperator(BoundConditionalOperator node, object arg)
        {
            return new TreeDumperNode("conditionalOperator", null, new TreeDumperNode[]
            {
                new TreeDumperNode("condition", null, new TreeDumperNode[] { Visit(node.Condition, null) }),
                new TreeDumperNode("consequence", null, new TreeDumperNode[] { Visit(node.Consequence, null) }),
                new TreeDumperNode("alternative", null, new TreeDumperNode[] { Visit(node.Alternative, null) }),
                new TreeDumperNode("constantValueOpt", node.ConstantValueOpt, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitArrayAccess(BoundArrayAccess node, object arg)
        {
            return new TreeDumperNode("arrayAccess", null, new TreeDumperNode[]
            {
                new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
                new TreeDumperNode("indices", null, from x in node.Indices select Visit(x, null)),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitArrayLength(BoundArrayLength node, object arg)
        {
            return new TreeDumperNode("arrayLength", null, new TreeDumperNode[]
            {
                new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitAwaitExpression(BoundAwaitExpression node, object arg)
        {
            return new TreeDumperNode("awaitExpression", null, new TreeDumperNode[]
            {
                new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
                new TreeDumperNode("getAwaiter", node.GetAwaiter, null),
                new TreeDumperNode("isCompleted", node.IsCompleted, null),
                new TreeDumperNode("getResult", node.GetResult, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitLoweredAwaitExpressionStackMark(BoundLoweredAwaitExpressionStackMark node, object arg)
        {
            return new TreeDumperNode("loweredAwaitExpressionStackMark", null, new TreeDumperNode[]
            {
            }
            );
        }
        public override TreeDumperNode VisitTypeOfOperator(BoundTypeOfOperator node, object arg)
        {
            return new TreeDumperNode("typeOfOperator", null, new TreeDumperNode[]
            {
                new TreeDumperNode("sourceType", null, new TreeDumperNode[] { Visit(node.SourceType, null) }),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitMethodInfo(BoundMethodInfo node, object arg)
        {
            return new TreeDumperNode("methodInfo", null, new TreeDumperNode[]
            {
                new TreeDumperNode("method", node.Method, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitFieldInfo(BoundFieldInfo node, object arg)
        {
            return new TreeDumperNode("fieldInfo", null, new TreeDumperNode[]
            {
                new TreeDumperNode("field", node.Field, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitDefaultOperator(BoundDefaultOperator node, object arg)
        {
            return new TreeDumperNode("defaultOperator", null, new TreeDumperNode[]
            {
                new TreeDumperNode("constantValueOpt", node.ConstantValueOpt, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitIsOperator(BoundIsOperator node, object arg)
        {
            return new TreeDumperNode("isOperator", null, new TreeDumperNode[]
            {
                new TreeDumperNode("operand", null, new TreeDumperNode[] { Visit(node.Operand, null) }),
                new TreeDumperNode("targetType", null, new TreeDumperNode[] { Visit(node.TargetType, null) }),
                new TreeDumperNode("conversion", node.Conversion, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitAsOperator(BoundAsOperator node, object arg)
        {
            return new TreeDumperNode("asOperator", null, new TreeDumperNode[]
            {
                new TreeDumperNode("operand", null, new TreeDumperNode[] { Visit(node.Operand, null) }),
                new TreeDumperNode("targetType", null, new TreeDumperNode[] { Visit(node.TargetType, null) }),
                new TreeDumperNode("conversion", node.Conversion, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitSizeOfOperator(BoundSizeOfOperator node, object arg)
        {
            return new TreeDumperNode("sizeOfOperator", null, new TreeDumperNode[]
            {
                new TreeDumperNode("sourceType", null, new TreeDumperNode[] { Visit(node.SourceType, null) }),
                new TreeDumperNode("constantValueOpt", node.ConstantValueOpt, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitConversion(BoundConversion node, object arg)
        {
            return new TreeDumperNode("conversion", null, new TreeDumperNode[]
            {
                new TreeDumperNode("operand", null, new TreeDumperNode[] { Visit(node.Operand, null) }),
                new TreeDumperNode("conversionKind", node.ConversionKind, null),
                new TreeDumperNode("symbolOpt", node.SymbolOpt, null),
                new TreeDumperNode("@checked", node.Checked, null),
                new TreeDumperNode("explicitCastInCode", node.ExplicitCastInCode, null),
                new TreeDumperNode("isExtensionMethod", node.IsExtensionMethod, null),
                new TreeDumperNode("isArrayIndex", node.IsArrayIndex, null),
                new TreeDumperNode("constantValueOpt", node.ConstantValueOpt, null),
                new TreeDumperNode("resultKind", node.ResultKind, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitArgList(BoundArgList node, object arg)
        {
            return new TreeDumperNode("argList", null, new TreeDumperNode[]
            {
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitArgListOperator(BoundArgListOperator node, object arg)
        {
            return new TreeDumperNode("argListOperator", null, new TreeDumperNode[]
            {
                new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
                new TreeDumperNode("argumentRefKindsOpt", node.ArgumentRefKindsOpt, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitFixedLocalCollectionInitializer(BoundFixedLocalCollectionInitializer node, object arg)
        {
            return new TreeDumperNode("fixedLocalCollectionInitializer", null, new TreeDumperNode[]
            {
                new TreeDumperNode("elementPointerType", node.ElementPointerType, null),
                new TreeDumperNode("elementPointerTypeConversion", node.ElementPointerTypeConversion, null),
                new TreeDumperNode("helperMethodOpt", node.HelperMethodOpt, null),
                new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitSequencePoint(BoundSequencePoint node, object arg)
        {
            return new TreeDumperNode("sequencePoint", null, new TreeDumperNode[]
            {
                new TreeDumperNode("statementOpt", null, new TreeDumperNode[] { Visit(node.StatementOpt, null) })
            }
            );
        }
        public override TreeDumperNode VisitSequencePointWithSpan(BoundSequencePointWithSpan node, object arg)
        {
            return new TreeDumperNode("sequencePointWithSpan", null, new TreeDumperNode[]
            {
                new TreeDumperNode("statementOpt", null, new TreeDumperNode[] { Visit(node.StatementOpt, null) }),
                new TreeDumperNode("span", node.Span, null)
            }
            );
        }
        public override TreeDumperNode VisitBlock(BoundBlock node, object arg)
        {
            return new TreeDumperNode("block", null, new TreeDumperNode[]
            {
                new TreeDumperNode("localsOpt", node.LocalsOpt, null),
                new TreeDumperNode("statements", null, from x in node.Statements select Visit(x, null))
            }
            );
        }
        public override TreeDumperNode VisitIteratorScope(BoundIteratorScope node, object arg)
        {
            return new TreeDumperNode("iteratorScope", null, new TreeDumperNode[]
            {
                new TreeDumperNode("fields", node.Fields, null),
                new TreeDumperNode("statement", null, new TreeDumperNode[] { Visit(node.Statement, null) })
            }
            );
        }
        public override TreeDumperNode VisitLocalDeclaration(BoundLocalDeclaration node, object arg)
        {
            return new TreeDumperNode("localDeclaration", null, new TreeDumperNode[]
            {
                new TreeDumperNode("localSymbol", node.LocalSymbol, null),
                new TreeDumperNode("declaredType", null, new TreeDumperNode[] { Visit(node.DeclaredType, null) }),
                new TreeDumperNode("initializerOpt", null, new TreeDumperNode[] { Visit(node.InitializerOpt, null) }),
                new TreeDumperNode("argumentsOpt", null, node.ArgumentsOpt.IsNull ? new TreeDumperNode[0] : from x in node.ArgumentsOpt select Visit(x, null))
            }
            );
        }
        public override TreeDumperNode VisitMultipleLocalDeclarations(BoundMultipleLocalDeclarations node, object arg)
        {
            return new TreeDumperNode("multipleLocalDeclarations", null, new TreeDumperNode[]
            {
                new TreeDumperNode("localDeclarations", null, from x in node.LocalDeclarations select Visit(x, null))
            }
            );
        }
        public override TreeDumperNode VisitSequence(BoundSequence node, object arg)
        {
            return new TreeDumperNode("sequence", null, new TreeDumperNode[]
            {
                new TreeDumperNode("locals", node.Locals, null),
                new TreeDumperNode("sideEffects", null, from x in node.SideEffects select Visit(x, null)),
                new TreeDumperNode("value", null, new TreeDumperNode[] { Visit(node.Value, null) }),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitNoOpStatement(BoundNoOpStatement node, object arg)
        {
            return new TreeDumperNode("noOpStatement", null, new TreeDumperNode[]
            {
            }
            );
        }
        public override TreeDumperNode VisitReturnStatement(BoundReturnStatement node, object arg)
        {
            return new TreeDumperNode("returnStatement", null, new TreeDumperNode[]
            {
                new TreeDumperNode("expressionOpt", null, new TreeDumperNode[] { Visit(node.ExpressionOpt, null) })
            }
            );
        }
        public override TreeDumperNode VisitYieldReturnStatement(BoundYieldReturnStatement node, object arg)
        {
            return new TreeDumperNode("yieldReturnStatement", null, new TreeDumperNode[]
            {
                new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) })
            }
            );
        }
        public override TreeDumperNode VisitYieldBreakStatement(BoundYieldBreakStatement node, object arg)
        {
            return new TreeDumperNode("yieldBreakStatement", null, new TreeDumperNode[]
            {
            }
            );
        }
        public override TreeDumperNode VisitThrowStatement(BoundThrowStatement node, object arg)
        {
            return new TreeDumperNode("throwStatement", null, new TreeDumperNode[]
            {
                new TreeDumperNode("expressionOpt", null, new TreeDumperNode[] { Visit(node.ExpressionOpt, null) })
            }
            );
        }
        public override TreeDumperNode VisitExpressionStatement(BoundExpressionStatement node, object arg)
        {
            return new TreeDumperNode("expressionStatement", null, new TreeDumperNode[]
            {
                new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) })
            }
            );
        }
        public override TreeDumperNode VisitSwitchStatement(BoundSwitchStatement node, object arg)
        {
            return new TreeDumperNode("switchStatement", null, new TreeDumperNode[]
            {
                new TreeDumperNode("boundExpression", null, new TreeDumperNode[] { Visit(node.BoundExpression, null) }),
                new TreeDumperNode("constantTargetOpt", node.ConstantTargetOpt, null),
                new TreeDumperNode("localsOpt", node.LocalsOpt, null),
                new TreeDumperNode("switchSections", null, from x in node.SwitchSections select Visit(x, null)),
                new TreeDumperNode("breakLabel", node.BreakLabel, null)
            }
            );
        }
        public override TreeDumperNode VisitSwitchSection(BoundSwitchSection node, object arg)
        {
            return new TreeDumperNode("switchSection", null, new TreeDumperNode[]
            {
                new TreeDumperNode("boundSwitchLabels", null, from x in node.BoundSwitchLabels select Visit(x, null)),
                new TreeDumperNode("statements", null, from x in node.Statements select Visit(x, null))
            }
            );
        }
        public override TreeDumperNode VisitSwitchLabel(BoundSwitchLabel node, object arg)
        {
            return new TreeDumperNode("switchLabel", null, new TreeDumperNode[]
            {
                new TreeDumperNode("label", node.Label, null),
                new TreeDumperNode("expressionOpt", null, new TreeDumperNode[] { Visit(node.ExpressionOpt, null) })
            }
            );
        }
        public override TreeDumperNode VisitBreakStatement(BoundBreakStatement node, object arg)
        {
            return new TreeDumperNode("breakStatement", null, new TreeDumperNode[]
            {
                new TreeDumperNode("label", node.Label, null)
            }
            );
        }
        public override TreeDumperNode VisitContinueStatement(BoundContinueStatement node, object arg)
        {
            return new TreeDumperNode("continueStatement", null, new TreeDumperNode[]
            {
                new TreeDumperNode("label", node.Label, null)
            }
            );
        }
        public override TreeDumperNode VisitIfStatement(BoundIfStatement node, object arg)
        {
            return new TreeDumperNode("ifStatement", null, new TreeDumperNode[]
            {
                new TreeDumperNode("condition", null, new TreeDumperNode[] { Visit(node.Condition, null) }),
                new TreeDumperNode("consequence", null, new TreeDumperNode[] { Visit(node.Consequence, null) }),
                new TreeDumperNode("alternativeOpt", null, new TreeDumperNode[] { Visit(node.AlternativeOpt, null) })
            }
            );
        }
        public override TreeDumperNode VisitDoStatement(BoundDoStatement node, object arg)
        {
            return new TreeDumperNode("doStatement", null, new TreeDumperNode[]
            {
                new TreeDumperNode("condition", null, new TreeDumperNode[] { Visit(node.Condition, null) }),
                new TreeDumperNode("body", null, new TreeDumperNode[] { Visit(node.Body, null) }),
                new TreeDumperNode("breakLabel", node.BreakLabel, null),
                new TreeDumperNode("continueLabel", node.ContinueLabel, null)
            }
            );
        }
        public override TreeDumperNode VisitWhileStatement(BoundWhileStatement node, object arg)
        {
            return new TreeDumperNode("whileStatement", null, new TreeDumperNode[]
            {
                new TreeDumperNode("condition", null, new TreeDumperNode[] { Visit(node.Condition, null) }),
                new TreeDumperNode("body", null, new TreeDumperNode[] { Visit(node.Body, null) }),
                new TreeDumperNode("breakLabel", node.BreakLabel, null),
                new TreeDumperNode("continueLabel", node.ContinueLabel, null)
            }
            );
        }
        public override TreeDumperNode VisitForStatement(BoundForStatement node, object arg)
        {
            return new TreeDumperNode("forStatement", null, new TreeDumperNode[]
            {
                new TreeDumperNode("locals", node.Locals, null),
                new TreeDumperNode("initializer", null, new TreeDumperNode[] { Visit(node.Initializer, null) }),
                new TreeDumperNode("condition", null, new TreeDumperNode[] { Visit(node.Condition, null) }),
                new TreeDumperNode("increment", null, new TreeDumperNode[] { Visit(node.Increment, null) }),
                new TreeDumperNode("body", null, new TreeDumperNode[] { Visit(node.Body, null) }),
                new TreeDumperNode("breakLabel", node.BreakLabel, null),
                new TreeDumperNode("continueLabel", node.ContinueLabel, null)
            }
            );
        }
        public override TreeDumperNode VisitForEachStatement(BoundForEachStatement node, object arg)
        {
            return new TreeDumperNode("forEachStatement", null, new TreeDumperNode[]
            {
                new TreeDumperNode("enumeratorInfoOpt", node.EnumeratorInfoOpt, null),
                new TreeDumperNode("elementConversion", node.ElementConversion, null),
                new TreeDumperNode("iterationVariableType", null, new TreeDumperNode[] { Visit(node.IterationVariableType, null) }),
                new TreeDumperNode("iterationVariable", node.IterationVariable, null),
                new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
                new TreeDumperNode("body", null, new TreeDumperNode[] { Visit(node.Body, null) }),
                new TreeDumperNode("@checked", node.Checked, null),
                new TreeDumperNode("breakLabel", node.BreakLabel, null),
                new TreeDumperNode("continueLabel", node.ContinueLabel, null)
            }
            );
        }
        public override TreeDumperNode VisitUsingStatement(BoundUsingStatement node, object arg)
        {
            return new TreeDumperNode("usingStatement", null, new TreeDumperNode[]
            {
                new TreeDumperNode("localsOpt", node.LocalsOpt, null),
                new TreeDumperNode("declarationsOpt", null, new TreeDumperNode[] { Visit(node.DeclarationsOpt, null) }),
                new TreeDumperNode("expressionOpt", null, new TreeDumperNode[] { Visit(node.ExpressionOpt, null) }),
                new TreeDumperNode("iDisposableConversion", node.IDisposableConversion, null),
                new TreeDumperNode("body", null, new TreeDumperNode[] { Visit(node.Body, null) })
            }
            );
        }
        public override TreeDumperNode VisitFixedStatement(BoundFixedStatement node, object arg)
        {
            return new TreeDumperNode("fixedStatement", null, new TreeDumperNode[]
            {
                new TreeDumperNode("locals", node.Locals, null),
                new TreeDumperNode("declarations", null, new TreeDumperNode[] { Visit(node.Declarations, null) }),
                new TreeDumperNode("body", null, new TreeDumperNode[] { Visit(node.Body, null) })
            }
            );
        }
        public override TreeDumperNode VisitLockStatement(BoundLockStatement node, object arg)
        {
            return new TreeDumperNode("lockStatement", null, new TreeDumperNode[]
            {
                new TreeDumperNode("argument", null, new TreeDumperNode[] { Visit(node.Argument, null) }),
                new TreeDumperNode("body", null, new TreeDumperNode[] { Visit(node.Body, null) }),
                new TreeDumperNode("enterMethod", node.EnterMethod, null),
                new TreeDumperNode("exitMethod", node.ExitMethod, null)
            }
            );
        }
        public override TreeDumperNode VisitTryStatement(BoundTryStatement node, object arg)
        {
            return new TreeDumperNode("tryStatement", null, new TreeDumperNode[]
            {
                new TreeDumperNode("tryBlock", null, new TreeDumperNode[] { Visit(node.TryBlock, null) }),
                new TreeDumperNode("catchBlocks", null, from x in node.CatchBlocks select Visit(x, null)),
                new TreeDumperNode("finallyBlockOpt", null, new TreeDumperNode[] { Visit(node.FinallyBlockOpt, null) })
            }
            );
        }
        public override TreeDumperNode VisitCatchBlock(BoundCatchBlock node, object arg)
        {
            return new TreeDumperNode("catchBlock", null, new TreeDumperNode[]
            {
                new TreeDumperNode("localOpt", node.LocalOpt, null),
                new TreeDumperNode("exceptionTypeOpt", node.ExceptionTypeOpt, null),
                new TreeDumperNode("boundBlock", null, new TreeDumperNode[] { Visit(node.BoundBlock, null) })
            }
            );
        }
        public override TreeDumperNode VisitLiteral(BoundLiteral node, object arg)
        {
            return new TreeDumperNode("literal", null, new TreeDumperNode[]
            {
                new TreeDumperNode("constantValueOpt", node.ConstantValueOpt, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitThisReference(BoundThisReference node, object arg)
        {
            return new TreeDumperNode("thisReference", null, new TreeDumperNode[]
            {
                new TreeDumperNode("thisSymbol", node.ThisSymbol, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitPreviousSubmissionReference(BoundPreviousSubmissionReference node, object arg)
        {
            return new TreeDumperNode("previousSubmissionReference", null, new TreeDumperNode[]
            {
                new TreeDumperNode("sourceType", node.SourceType, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitHostObjectMemberReference(BoundHostObjectMemberReference node, object arg)
        {
            return new TreeDumperNode("hostObjectMemberReference", null, new TreeDumperNode[]
            {
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitBaseReference(BoundBaseReference node, object arg)
        {
            return new TreeDumperNode("baseReference", null, new TreeDumperNode[]
            {
                new TreeDumperNode("thisSymbol", node.ThisSymbol, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitLocal(BoundLocal node, object arg)
        {
            return new TreeDumperNode("local", null, new TreeDumperNode[]
            {
                new TreeDumperNode("localSymbol", node.LocalSymbol, null),
                new TreeDumperNode("constantValueOpt", node.ConstantValueOpt, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitRangeVariable(BoundRangeVariable node, object arg)
        {
            return new TreeDumperNode("rangeVariable", null, new TreeDumperNode[]
            {
                new TreeDumperNode("rangeVariableSymbol", node.RangeVariableSymbol, null),
                new TreeDumperNode("value", null, new TreeDumperNode[] { Visit(node.Value, null) }),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitParameter(BoundParameter node, object arg)
        {
            return new TreeDumperNode("parameter", null, new TreeDumperNode[]
            {
                new TreeDumperNode("parameterSymbol", node.ParameterSymbol, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitLabelStatement(BoundLabelStatement node, object arg)
        {
            return new TreeDumperNode("labelStatement", null, new TreeDumperNode[]
            {
                new TreeDumperNode("label", node.Label, null)
            }
            );
        }
        public override TreeDumperNode VisitGotoStatement(BoundGotoStatement node, object arg)
        {
            return new TreeDumperNode("gotoStatement", null, new TreeDumperNode[]
            {
                new TreeDumperNode("label", node.Label, null),
                new TreeDumperNode("caseExpressionOpt", null, new TreeDumperNode[] { Visit(node.CaseExpressionOpt, null) }),
                new TreeDumperNode("labelExpressionOpt", null, new TreeDumperNode[] { Visit(node.LabelExpressionOpt, null) })
            }
            );
        }
        public override TreeDumperNode VisitLabeledStatement(BoundLabeledStatement node, object arg)
        {
            return new TreeDumperNode("labeledStatement", null, new TreeDumperNode[]
            {
                new TreeDumperNode("label", node.Label, null),
                new TreeDumperNode("body", null, new TreeDumperNode[] { Visit(node.Body, null) })
            }
            );
        }
        public override TreeDumperNode VisitLabel(BoundLabel node, object arg)
        {
            return new TreeDumperNode("label", null, new TreeDumperNode[]
            {
                new TreeDumperNode("label", node.Label, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitStatementList(BoundStatementList node, object arg)
        {
            return new TreeDumperNode("statementList", null, new TreeDumperNode[]
            {
                new TreeDumperNode("statements", null, from x in node.Statements select Visit(x, null))
            }
            );
        }
        public override TreeDumperNode VisitConditionalGoto(BoundConditionalGoto node, object arg)
        {
            return new TreeDumperNode("conditionalGoto", null, new TreeDumperNode[]
            {
                new TreeDumperNode("condition", null, new TreeDumperNode[] { Visit(node.Condition, null) }),
                new TreeDumperNode("jumpIfTrue", node.JumpIfTrue, null),
                new TreeDumperNode("label", node.Label, null)
            }
            );
        }
        public override TreeDumperNode VisitDynamicMemberAccess(BoundDynamicMemberAccess node, object arg)
        {
            return new TreeDumperNode("dynamicMemberAccess", null, new TreeDumperNode[]
            {
                new TreeDumperNode("receiver", null, new TreeDumperNode[] { Visit(node.Receiver, null) }),
                new TreeDumperNode("typeArgumentsOpt", node.TypeArgumentsOpt, null),
                new TreeDumperNode("name", node.Name, null),
                new TreeDumperNode("invoked", node.Invoked, null),
                new TreeDumperNode("indexed", node.Indexed, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitDynamicInvocation(BoundDynamicInvocation node, object arg)
        {
            return new TreeDumperNode("dynamicInvocation", null, new TreeDumperNode[]
            {
                new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
                new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
                new TreeDumperNode("argumentNamesOpt", node.ArgumentNamesOpt, null),
                new TreeDumperNode("argumentRefKindsOpt", node.ArgumentRefKindsOpt, null),
                new TreeDumperNode("applicableMethods", node.ApplicableMethods, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitMethodGroup(BoundMethodGroup node, object arg)
        {
            return new TreeDumperNode("methodGroup", null, new TreeDumperNode[]
            {
                new TreeDumperNode("typeArgumentsOpt", node.TypeArgumentsOpt, null),
                new TreeDumperNode("name", node.Name, null),
                new TreeDumperNode("methods", node.Methods, null),
                new TreeDumperNode("lookupSymbolOpt", node.LookupSymbolOpt, null),
                new TreeDumperNode("lookupError", node.LookupError, null),
                new TreeDumperNode("flags", node.Flags, null),
                new TreeDumperNode("receiverOpt", null, new TreeDumperNode[] { Visit(node.ReceiverOpt, null) }),
                new TreeDumperNode("resultKind", node.ResultKind, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitPropertyGroup(BoundPropertyGroup node, object arg)
        {
            return new TreeDumperNode("propertyGroup", null, new TreeDumperNode[]
            {
                new TreeDumperNode("properties", node.Properties, null),
                new TreeDumperNode("receiverOpt", null, new TreeDumperNode[] { Visit(node.ReceiverOpt, null) }),
                new TreeDumperNode("resultKind", node.ResultKind, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitCall(BoundCall node, object arg)
        {
            return new TreeDumperNode("call", null, new TreeDumperNode[]
            {
                new TreeDumperNode("receiverOpt", null, new TreeDumperNode[] { Visit(node.ReceiverOpt, null) }),
                new TreeDumperNode("method", node.Method, null),
                new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
                new TreeDumperNode("argumentNamesOpt", node.ArgumentNamesOpt, null),
                new TreeDumperNode("argumentRefKindsOpt", node.ArgumentRefKindsOpt, null),
                new TreeDumperNode("expanded", node.Expanded, null),
                new TreeDumperNode("invokedAsExtensionMethod", node.InvokedAsExtensionMethod, null),
                new TreeDumperNode("argsToParamsOpt", node.ArgsToParamsOpt, null),
                new TreeDumperNode("resultKind", node.ResultKind, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitEventAssignmentOperator(BoundEventAssignmentOperator node, object arg)
        {
            return new TreeDumperNode("eventAssignmentOperator", null, new TreeDumperNode[]
            {
                new TreeDumperNode("@event", node.Event, null),
                new TreeDumperNode("isAddition", node.IsAddition, null),
                new TreeDumperNode("isDynamic", node.IsDynamic, null),
                new TreeDumperNode("receiverOpt", null, new TreeDumperNode[] { Visit(node.ReceiverOpt, null) }),
                new TreeDumperNode("argument", null, new TreeDumperNode[] { Visit(node.Argument, null) }),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitDelegateCall(BoundDelegateCall node, object arg)
        {
            return new TreeDumperNode("delegateCall", null, new TreeDumperNode[]
            {
                new TreeDumperNode("receiverOpt", null, new TreeDumperNode[] { Visit(node.ReceiverOpt, null) }),
                new TreeDumperNode("method", node.Method, null),
                new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
                new TreeDumperNode("argumentNamesOpt", node.ArgumentNamesOpt, null),
                new TreeDumperNode("argumentRefKindsOpt", node.ArgumentRefKindsOpt, null),
                new TreeDumperNode("expanded", node.Expanded, null),
                new TreeDumperNode("invokedAsExtensionMethod", node.InvokedAsExtensionMethod, null),
                new TreeDumperNode("argsToParamsOpt", node.ArgsToParamsOpt, null),
                new TreeDumperNode("resultKind", node.ResultKind, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitAttribute(BoundAttribute node, object arg)
        {
            return new TreeDumperNode("attribute", null, new TreeDumperNode[]
            {
                new TreeDumperNode("constructor", node.Constructor, null),
                new TreeDumperNode("constructorArguments", null, from x in node.ConstructorArguments select Visit(x, null)),
                new TreeDumperNode("constructorArgumentNamesOpt", node.ConstructorArgumentNamesOpt, null),
                new TreeDumperNode("namedArguments", null, from x in node.NamedArguments select Visit(x, null)),
                new TreeDumperNode("resultKind", node.ResultKind, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitObjectCreationExpression(BoundObjectCreationExpression node, object arg)
        {
            return new TreeDumperNode("objectCreationExpression", null, new TreeDumperNode[]
            {
                new TreeDumperNode("constructor", node.Constructor, null),
                new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
                new TreeDumperNode("argumentNamesOpt", node.ArgumentNamesOpt, null),
                new TreeDumperNode("argumentRefKindsOpt", node.ArgumentRefKindsOpt, null),
                new TreeDumperNode("expanded", node.Expanded, null),
                new TreeDumperNode("argsToParamsOpt", node.ArgsToParamsOpt, null),
                new TreeDumperNode("constantValueOpt", node.ConstantValueOpt, null),
                new TreeDumperNode("initializerExpressionOpt", null, new TreeDumperNode[] { Visit(node.InitializerExpressionOpt, null) }),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitDynamicObjectCreationExpression(BoundDynamicObjectCreationExpression node, object arg)
        {
            return new TreeDumperNode("dynamicObjectCreationExpression", null, new TreeDumperNode[]
            {
                new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
                new TreeDumperNode("argumentNamesOpt", node.ArgumentNamesOpt, null),
                new TreeDumperNode("argumentRefKindsOpt", node.ArgumentRefKindsOpt, null),
                new TreeDumperNode("initializerExpressionOpt", null, new TreeDumperNode[] { Visit(node.InitializerExpressionOpt, null) }),
                new TreeDumperNode("applicableMethods", node.ApplicableMethods, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitObjectInitializerExpression(BoundObjectInitializerExpression node, object arg)
        {
            return new TreeDumperNode("objectInitializerExpression", null, new TreeDumperNode[]
            {
                new TreeDumperNode("initializers", null, from x in node.Initializers select Visit(x, null)),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitObjectInitializerMember(BoundObjectInitializerMember node, object arg)
        {
            return new TreeDumperNode("objectInitializerMember", null, new TreeDumperNode[]
            {
                new TreeDumperNode("memberSymbol", node.MemberSymbol, null),
                new TreeDumperNode("resultKind", node.ResultKind, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitCollectionInitializerExpression(BoundCollectionInitializerExpression node, object arg)
        {
            return new TreeDumperNode("collectionInitializerExpression", null, new TreeDumperNode[]
            {
                new TreeDumperNode("initializers", null, from x in node.Initializers select Visit(x, null)),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitCollectionElementInitializer(BoundCollectionElementInitializer node, object arg)
        {
            return new TreeDumperNode("collectionElementInitializer", null, new TreeDumperNode[]
            {
                new TreeDumperNode("addMethod", node.AddMethod, null),
                new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
                new TreeDumperNode("expanded", node.Expanded, null),
                new TreeDumperNode("argsToParamsOpt", node.ArgsToParamsOpt, null),
                new TreeDumperNode("invokedAsExtensionMethod", node.InvokedAsExtensionMethod, null),
                new TreeDumperNode("resultKind", node.ResultKind, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitDynamicCollectionElementInitializer(BoundDynamicCollectionElementInitializer node, object arg)
        {
            return new TreeDumperNode("dynamicCollectionElementInitializer", null, new TreeDumperNode[]
            {
                new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
                new TreeDumperNode("argumentNamesOpt", node.ArgumentNamesOpt, null),
                new TreeDumperNode("argumentRefKindsOpt", node.ArgumentRefKindsOpt, null),
                new TreeDumperNode("applicableMethods", node.ApplicableMethods, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitImplicitReceiver(BoundImplicitReceiver node, object arg)
        {
            return new TreeDumperNode("implicitReceiver", null, new TreeDumperNode[]
            {
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitAnonymousObjectCreationExpression(BoundAnonymousObjectCreationExpression node, object arg)
        {
            return new TreeDumperNode("anonymousObjectCreationExpression", null, new TreeDumperNode[]
            {
                new TreeDumperNode("constructor", node.Constructor, null),
                new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
                new TreeDumperNode("declarations", null, from x in node.Declarations select Visit(x, null)),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitAnonymousPropertyDeclaration(BoundAnonymousPropertyDeclaration node, object arg)
        {
            return new TreeDumperNode("anonymousPropertyDeclaration", null, new TreeDumperNode[]
            {
                new TreeDumperNode("property", node.Property, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitNewT(BoundNewT node, object arg)
        {
            return new TreeDumperNode("newT", null, new TreeDumperNode[]
            {
                new TreeDumperNode("initializerExpressionOpt", null, new TreeDumperNode[] { Visit(node.InitializerExpressionOpt, null) }),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitDelegateCreationExpression(BoundDelegateCreationExpression node, object arg)
        {
            return new TreeDumperNode("delegateCreationExpression", null, new TreeDumperNode[]
            {
                new TreeDumperNode("argument", null, new TreeDumperNode[] { Visit(node.Argument, null) }),
                new TreeDumperNode("methodOpt", node.MethodOpt, null),
                new TreeDumperNode("isExtensionMethod", node.IsExtensionMethod, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitArrayCreation(BoundArrayCreation node, object arg)
        {
            return new TreeDumperNode("arrayCreation", null, new TreeDumperNode[]
            {
                new TreeDumperNode("bounds", null, from x in node.Bounds select Visit(x, null)),
                new TreeDumperNode("initializerOpt", null, new TreeDumperNode[] { Visit(node.InitializerOpt, null) }),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitArrayInitialization(BoundArrayInitialization node, object arg)
        {
            return new TreeDumperNode("arrayInitialization", null, new TreeDumperNode[]
            {
                new TreeDumperNode("initializers", null, from x in node.Initializers select Visit(x, null)),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitStackAllocArrayCreation(BoundStackAllocArrayCreation node, object arg)
        {
            return new TreeDumperNode("stackAllocArrayCreation", null, new TreeDumperNode[]
            {
                new TreeDumperNode("count", null, new TreeDumperNode[] { Visit(node.Count, null) }),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitFieldAccess(BoundFieldAccess node, object arg)
        {
            return new TreeDumperNode("fieldAccess", null, new TreeDumperNode[]
            {
                new TreeDumperNode("receiverOpt", null, new TreeDumperNode[] { Visit(node.ReceiverOpt, null) }),
                new TreeDumperNode("fieldSymbol", node.FieldSymbol, null),
                new TreeDumperNode("constantValueOpt", node.ConstantValueOpt, null),
                new TreeDumperNode("resultKind", node.ResultKind, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitPropertyAccess(BoundPropertyAccess node, object arg)
        {
            return new TreeDumperNode("propertyAccess", null, new TreeDumperNode[]
            {
                new TreeDumperNode("receiverOpt", null, new TreeDumperNode[] { Visit(node.ReceiverOpt, null) }),
                new TreeDumperNode("propertySymbol", node.PropertySymbol, null),
                new TreeDumperNode("resultKind", node.ResultKind, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitEventAccess(BoundEventAccess node, object arg)
        {
            return new TreeDumperNode("eventAccess", null, new TreeDumperNode[]
            {
                new TreeDumperNode("receiverOpt", null, new TreeDumperNode[] { Visit(node.ReceiverOpt, null) }),
                new TreeDumperNode("eventSymbol", node.EventSymbol, null),
                new TreeDumperNode("isUsableAsField", node.IsUsableAsField, null),
                new TreeDumperNode("resultKind", node.ResultKind, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitIndexerAccess(BoundIndexerAccess node, object arg)
        {
            return new TreeDumperNode("indexerAccess", null, new TreeDumperNode[]
            {
                new TreeDumperNode("receiverOpt", null, new TreeDumperNode[] { Visit(node.ReceiverOpt, null) }),
                new TreeDumperNode("indexer", node.Indexer, null),
                new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
                new TreeDumperNode("argumentNamesOpt", node.ArgumentNamesOpt, null),
                new TreeDumperNode("argumentRefKindsOpt", node.ArgumentRefKindsOpt, null),
                new TreeDumperNode("expanded", node.Expanded, null),
                new TreeDumperNode("argsToParamsOpt", node.ArgsToParamsOpt, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitDynamicIndexerAccess(BoundDynamicIndexerAccess node, object arg)
        {
            return new TreeDumperNode("dynamicIndexerAccess", null, new TreeDumperNode[]
            {
                new TreeDumperNode("receiverOpt", null, new TreeDumperNode[] { Visit(node.ReceiverOpt, null) }),
                new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
                new TreeDumperNode("argumentNamesOpt", node.ArgumentNamesOpt, null),
                new TreeDumperNode("argumentRefKindsOpt", node.ArgumentRefKindsOpt, null),
                new TreeDumperNode("applicableIndexers", node.ApplicableIndexers, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitLambda(BoundLambda node, object arg)
        {
            return new TreeDumperNode("lambda", null, new TreeDumperNode[]
            {
                new TreeDumperNode("body", null, new TreeDumperNode[] { Visit(node.Body, null) }),
                new TreeDumperNode("diagnostics", node.Diagnostics, null),
                new TreeDumperNode("binder", node.Binder, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitUnboundLambda(UnboundLambda node, object arg)
        {
            return new TreeDumperNode("unboundLambda", null, new TreeDumperNode[]
            {
                new TreeDumperNode("data", node.Data, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
        public override TreeDumperNode VisitQueryClause(BoundQueryClause node, object arg)
        {
            return new TreeDumperNode("queryClause", null, new TreeDumperNode[]
            {
                new TreeDumperNode("value", null, new TreeDumperNode[] { Visit(node.Value, null) }),
                new TreeDumperNode("definedSymbol", node.DefinedSymbol, null),
                new TreeDumperNode("binder", node.Binder, null),
                new TreeDumperNode("type", node.Type, null)
            }
            );
        }
    }
}
