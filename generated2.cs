// <auto-generated />

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Roslyn.Utilities;

namespace Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax
{
  /// <summary>Provides the base class from which the classes that represent name syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class NameSyntax : TypeSyntax
  {
    internal NameSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal NameSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected NameSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>Provides the base class from which the classes that represent simple name syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class SimpleNameSyntax : NameSyntax
  {
    internal SimpleNameSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal SimpleNameSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected SimpleNameSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>SyntaxToken representing the identifier of the simple name.</summary>
    public abstract SyntaxToken Identifier { get; }
  }

  /// <summary>Class which represents the syntax node for identifier name.</summary>
  internal sealed partial class IdentifierNameSyntax : SimpleNameSyntax
  {
    internal readonly SyntaxToken identifier;

    internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }

    /// <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
    public override SyntaxToken Identifier { get { return this.identifier; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.IdentifierNameSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIdentifierName(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIdentifierName(this);
    }

    public IdentifierNameSyntax Update(SyntaxToken identifier)
    {
        if (identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.IdentifierName(identifier);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new IdentifierNameSyntax(this.Kind, this.identifier, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new IdentifierNameSyntax(this.Kind, this.identifier, GetDiagnostics(), annotations);
    }

    internal IdentifierNameSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new IdentifierNameSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for qualified name.</summary>
  internal sealed partial class QualifiedNameSyntax : NameSyntax
  {
    internal readonly NameSyntax left;
    internal readonly SyntaxToken dotToken;
    internal readonly SimpleNameSyntax right;

    internal QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }


    internal QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }


    internal QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }

    /// <summary>NameSyntax node representing the name on the left side of the dot token of the qualified name.</summary>
    public NameSyntax Left { get { return this.left; } }
    /// <summary>SyntaxToken representing the dot.</summary>
    public SyntaxToken DotToken { get { return this.dotToken; } }
    /// <summary>SimpleNameSyntax node representing the name on the right side of the dot token of the qualified name.</summary>
    public SimpleNameSyntax Right { get { return this.right; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.left;
            case 1: return this.dotToken;
            case 2: return this.right;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.QualifiedNameSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQualifiedName(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitQualifiedName(this);
    }

    public QualifiedNameSyntax Update(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
    {
        if (left != this.Left || dotToken != this.DotToken || right != this.Right)
        {
            var newNode = SyntaxFactory.QualifiedName(left, dotToken, right);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new QualifiedNameSyntax(this.Kind, this.left, this.dotToken, this.right, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new QualifiedNameSyntax(this.Kind, this.left, this.dotToken, this.right, GetDiagnostics(), annotations);
    }

    internal QualifiedNameSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var left = (NameSyntax)reader.ReadValue();
      if (left != null)
      {
         AdjustFlagsAndWidth(left);
         this.left = left;
      }
      var dotToken = (SyntaxToken)reader.ReadValue();
      if (dotToken != null)
      {
         AdjustFlagsAndWidth(dotToken);
         this.dotToken = dotToken;
      }
      var right = (SimpleNameSyntax)reader.ReadValue();
      if (right != null)
      {
         AdjustFlagsAndWidth(right);
         this.right = right;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.left);
      writer.WriteValue(this.dotToken);
      writer.WriteValue(this.right);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new QualifiedNameSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for generic name.</summary>
  internal sealed partial class GenericNameSyntax : SimpleNameSyntax
  {
    internal readonly SyntaxToken identifier;
    internal readonly TypeArgumentListSyntax typeArgumentList;

    internal GenericNameSyntax(SyntaxKind kind, SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(typeArgumentList);
        this.typeArgumentList = typeArgumentList;
    }


    internal GenericNameSyntax(SyntaxKind kind, SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(typeArgumentList);
        this.typeArgumentList = typeArgumentList;
    }


    internal GenericNameSyntax(SyntaxKind kind, SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(typeArgumentList);
        this.typeArgumentList = typeArgumentList;
    }

    /// <summary>SyntaxToken representing the name of the identifier of the generic name.</summary>
    public override SyntaxToken Identifier { get { return this.identifier; } }
    /// <summary>TypeArgumentListSyntax node representing the list of type arguments of the generic name.</summary>
    public TypeArgumentListSyntax TypeArgumentList { get { return this.typeArgumentList; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            case 1: return this.typeArgumentList;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.GenericNameSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGenericName(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitGenericName(this);
    }

    public GenericNameSyntax Update(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
    {
        if (identifier != this.Identifier || typeArgumentList != this.TypeArgumentList)
        {
            var newNode = SyntaxFactory.GenericName(identifier, typeArgumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new GenericNameSyntax(this.Kind, this.identifier, this.typeArgumentList, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new GenericNameSyntax(this.Kind, this.identifier, this.typeArgumentList, GetDiagnostics(), annotations);
    }

    internal GenericNameSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var typeArgumentList = (TypeArgumentListSyntax)reader.ReadValue();
      if (typeArgumentList != null)
      {
         AdjustFlagsAndWidth(typeArgumentList);
         this.typeArgumentList = typeArgumentList;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeArgumentList);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new GenericNameSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for type argument list.</summary>
  internal sealed partial class TypeArgumentListSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken lessThanToken;
    internal readonly CSharpSyntaxNode arguments;
    internal readonly SyntaxToken greaterThanToken;

    internal TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, CSharpSyntaxNode arguments, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, CSharpSyntaxNode arguments, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, CSharpSyntaxNode arguments, SyntaxToken greaterThanToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }

    /// <summary>SyntaxToken representing less than.</summary>
    public SyntaxToken LessThanToken { get { return this.lessThanToken; } }
    /// <summary>SeparatedSyntaxList of TypeSyntax node representing the type arguments.</summary>
    public SeparatedSyntaxList<TypeSyntax> Arguments { get { return new SeparatedSyntaxList<TypeSyntax>(new SyntaxList<CSharpSyntaxNode>(this.arguments)); } }
    /// <summary>SyntaxToken representing greater than.</summary>
    public SyntaxToken GreaterThanToken { get { return this.greaterThanToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanToken;
            case 1: return this.arguments;
            case 2: return this.greaterThanToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.TypeArgumentListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeArgumentList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeArgumentList(this);
    }

    public TypeArgumentListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || arguments != this.Arguments || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = SyntaxFactory.TypeArgumentList(lessThanToken, arguments, greaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TypeArgumentListSyntax(this.Kind, this.lessThanToken, this.arguments, this.greaterThanToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TypeArgumentListSyntax(this.Kind, this.lessThanToken, this.arguments, this.greaterThanToken, GetDiagnostics(), annotations);
    }

    internal TypeArgumentListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var lessThanToken = (SyntaxToken)reader.ReadValue();
      if (lessThanToken != null)
      {
         AdjustFlagsAndWidth(lessThanToken);
         this.lessThanToken = lessThanToken;
      }
      var arguments = (CSharpSyntaxNode)reader.ReadValue();
      if (arguments != null)
      {
         AdjustFlagsAndWidth(arguments);
         this.arguments = arguments;
      }
      var greaterThanToken = (SyntaxToken)reader.ReadValue();
      if (greaterThanToken != null)
      {
         AdjustFlagsAndWidth(greaterThanToken);
         this.greaterThanToken = greaterThanToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanToken);
      writer.WriteValue(this.arguments);
      writer.WriteValue(this.greaterThanToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new TypeArgumentListSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for alias qualified name.</summary>
  internal sealed partial class AliasQualifiedNameSyntax : NameSyntax
  {
    internal readonly IdentifierNameSyntax alias;
    internal readonly SyntaxToken colonColonToken;
    internal readonly SimpleNameSyntax name;

    internal AliasQualifiedNameSyntax(SyntaxKind kind, IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(alias);
        this.alias = alias;
        this.AdjustFlagsAndWidth(colonColonToken);
        this.colonColonToken = colonColonToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }


    internal AliasQualifiedNameSyntax(SyntaxKind kind, IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(alias);
        this.alias = alias;
        this.AdjustFlagsAndWidth(colonColonToken);
        this.colonColonToken = colonColonToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }


    internal AliasQualifiedNameSyntax(SyntaxKind kind, IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(alias);
        this.alias = alias;
        this.AdjustFlagsAndWidth(colonColonToken);
        this.colonColonToken = colonColonToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }

    /// <summary>IdentifierNameSyntax node representing the name of the alias</summary>
    public IdentifierNameSyntax Alias { get { return this.alias; } }
    /// <summary>SyntaxToken representing colon colon.</summary>
    public SyntaxToken ColonColonToken { get { return this.colonColonToken; } }
    /// <summary>SimpleNameSyntax node representing the name that is being alias qualified.</summary>
    public SimpleNameSyntax Name { get { return this.name; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.alias;
            case 1: return this.colonColonToken;
            case 2: return this.name;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AliasQualifiedNameSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAliasQualifiedName(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAliasQualifiedName(this);
    }

    public AliasQualifiedNameSyntax Update(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
    {
        if (alias != this.Alias || colonColonToken != this.ColonColonToken || name != this.Name)
        {
            var newNode = SyntaxFactory.AliasQualifiedName(alias, colonColonToken, name);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AliasQualifiedNameSyntax(this.Kind, this.alias, this.colonColonToken, this.name, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AliasQualifiedNameSyntax(this.Kind, this.alias, this.colonColonToken, this.name, GetDiagnostics(), annotations);
    }

    internal AliasQualifiedNameSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var alias = (IdentifierNameSyntax)reader.ReadValue();
      if (alias != null)
      {
         AdjustFlagsAndWidth(alias);
         this.alias = alias;
      }
      var colonColonToken = (SyntaxToken)reader.ReadValue();
      if (colonColonToken != null)
      {
         AdjustFlagsAndWidth(colonColonToken);
         this.colonColonToken = colonColonToken;
      }
      var name = (SimpleNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.alias);
      writer.WriteValue(this.colonColonToken);
      writer.WriteValue(this.name);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new AliasQualifiedNameSyntax(r);
    }
  }

  /// <summary>Provides the base class from which the classes that represent type syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class TypeSyntax : ExpressionSyntax
  {
    internal TypeSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal TypeSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected TypeSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>Class which represents the syntax node for predefined types.</summary>
  internal sealed partial class PredefinedTypeSyntax : TypeSyntax
  {
    internal readonly SyntaxToken keyword;

    internal PredefinedTypeSyntax(SyntaxKind kind, SyntaxToken keyword, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
    }


    internal PredefinedTypeSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
    }


    internal PredefinedTypeSyntax(SyntaxKind kind, SyntaxToken keyword)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
    }

    /// <summary>SyntaxToken which represents the keyword corresponding to the predefined type.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.PredefinedTypeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPredefinedType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPredefinedType(this);
    }

    public PredefinedTypeSyntax Update(SyntaxToken keyword)
    {
        if (keyword != this.Keyword)
        {
            var newNode = SyntaxFactory.PredefinedType(keyword);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new PredefinedTypeSyntax(this.Kind, this.keyword, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new PredefinedTypeSyntax(this.Kind, this.keyword, GetDiagnostics(), annotations);
    }

    internal PredefinedTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new PredefinedTypeSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for the array type.</summary>
  internal sealed partial class ArrayTypeSyntax : TypeSyntax
  {
    internal readonly TypeSyntax elementType;
    internal readonly CSharpSyntaxNode rankSpecifiers;

    internal ArrayTypeSyntax(SyntaxKind kind, TypeSyntax elementType, CSharpSyntaxNode rankSpecifiers, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        if (rankSpecifiers != null)
        {
            this.AdjustFlagsAndWidth(rankSpecifiers);
            this.rankSpecifiers = rankSpecifiers;
        }
    }


    internal ArrayTypeSyntax(SyntaxKind kind, TypeSyntax elementType, CSharpSyntaxNode rankSpecifiers, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        if (rankSpecifiers != null)
        {
            this.AdjustFlagsAndWidth(rankSpecifiers);
            this.rankSpecifiers = rankSpecifiers;
        }
    }


    internal ArrayTypeSyntax(SyntaxKind kind, TypeSyntax elementType, CSharpSyntaxNode rankSpecifiers)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        if (rankSpecifiers != null)
        {
            this.AdjustFlagsAndWidth(rankSpecifiers);
            this.rankSpecifiers = rankSpecifiers;
        }
    }

    /// <summary>TypeSyntax node representing the type of the element of the array.</summary>
    public TypeSyntax ElementType { get { return this.elementType; } }
    /// <summary>SyntaxList of ArrayRankSpecifierSyntax nodes representing the list of rank specifiers for the array.</summary>
    public SyntaxList<ArrayRankSpecifierSyntax> RankSpecifiers { get { return new SyntaxList<ArrayRankSpecifierSyntax>(this.rankSpecifiers); } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.elementType;
            case 1: return this.rankSpecifiers;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ArrayTypeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArrayType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArrayType(this);
    }

    public ArrayTypeSyntax Update(TypeSyntax elementType, SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
    {
        if (elementType != this.ElementType || rankSpecifiers != this.RankSpecifiers)
        {
            var newNode = SyntaxFactory.ArrayType(elementType, rankSpecifiers);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ArrayTypeSyntax(this.Kind, this.elementType, this.rankSpecifiers, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ArrayTypeSyntax(this.Kind, this.elementType, this.rankSpecifiers, GetDiagnostics(), annotations);
    }

    internal ArrayTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var elementType = (TypeSyntax)reader.ReadValue();
      if (elementType != null)
      {
         AdjustFlagsAndWidth(elementType);
         this.elementType = elementType;
      }
      var rankSpecifiers = (CSharpSyntaxNode)reader.ReadValue();
      if (rankSpecifiers != null)
      {
         AdjustFlagsAndWidth(rankSpecifiers);
         this.rankSpecifiers = rankSpecifiers;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.elementType);
      writer.WriteValue(this.rankSpecifiers);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ArrayTypeSyntax(r);
    }
  }

  internal sealed partial class ArrayRankSpecifierSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken openBracketToken;
    internal readonly CSharpSyntaxNode sizes;
    internal readonly SyntaxToken closeBracketToken;

    internal ArrayRankSpecifierSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode sizes, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (sizes != null)
        {
            this.AdjustFlagsAndWidth(sizes);
            this.sizes = sizes;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal ArrayRankSpecifierSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode sizes, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (sizes != null)
        {
            this.AdjustFlagsAndWidth(sizes);
            this.sizes = sizes;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal ArrayRankSpecifierSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode sizes, SyntaxToken closeBracketToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (sizes != null)
        {
            this.AdjustFlagsAndWidth(sizes);
            this.sizes = sizes;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }

    public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
    public SeparatedSyntaxList<ExpressionSyntax> Sizes { get { return new SeparatedSyntaxList<ExpressionSyntax>(new SyntaxList<CSharpSyntaxNode>(this.sizes)); } }
    public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBracketToken;
            case 1: return this.sizes;
            case 2: return this.closeBracketToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ArrayRankSpecifierSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArrayRankSpecifier(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArrayRankSpecifier(this);
    }

    public ArrayRankSpecifierSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || sizes != this.Sizes || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.ArrayRankSpecifier(openBracketToken, sizes, closeBracketToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ArrayRankSpecifierSyntax(this.Kind, this.openBracketToken, this.sizes, this.closeBracketToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ArrayRankSpecifierSyntax(this.Kind, this.openBracketToken, this.sizes, this.closeBracketToken, GetDiagnostics(), annotations);
    }

    internal ArrayRankSpecifierSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openBracketToken = (SyntaxToken)reader.ReadValue();
      if (openBracketToken != null)
      {
         AdjustFlagsAndWidth(openBracketToken);
         this.openBracketToken = openBracketToken;
      }
      var sizes = (CSharpSyntaxNode)reader.ReadValue();
      if (sizes != null)
      {
         AdjustFlagsAndWidth(sizes);
         this.sizes = sizes;
      }
      var closeBracketToken = (SyntaxToken)reader.ReadValue();
      if (closeBracketToken != null)
      {
         AdjustFlagsAndWidth(closeBracketToken);
         this.closeBracketToken = closeBracketToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.sizes);
      writer.WriteValue(this.closeBracketToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ArrayRankSpecifierSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for pointer type.</summary>
  internal sealed partial class PointerTypeSyntax : TypeSyntax
  {
    internal readonly TypeSyntax elementType;
    internal readonly SyntaxToken asteriskToken;

    internal PointerTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken asteriskToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(asteriskToken);
        this.asteriskToken = asteriskToken;
    }


    internal PointerTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken asteriskToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(asteriskToken);
        this.asteriskToken = asteriskToken;
    }


    internal PointerTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken asteriskToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(asteriskToken);
        this.asteriskToken = asteriskToken;
    }

    /// <summary>TypeSyntax node that represents the element type of the pointer.</summary>
    public TypeSyntax ElementType { get { return this.elementType; } }
    /// <summary>SyntaxToken representing the asterisk.</summary>
    public SyntaxToken AsteriskToken { get { return this.asteriskToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.elementType;
            case 1: return this.asteriskToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.PointerTypeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPointerType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPointerType(this);
    }

    public PointerTypeSyntax Update(TypeSyntax elementType, SyntaxToken asteriskToken)
    {
        if (elementType != this.ElementType || asteriskToken != this.AsteriskToken)
        {
            var newNode = SyntaxFactory.PointerType(elementType, asteriskToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new PointerTypeSyntax(this.Kind, this.elementType, this.asteriskToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new PointerTypeSyntax(this.Kind, this.elementType, this.asteriskToken, GetDiagnostics(), annotations);
    }

    internal PointerTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var elementType = (TypeSyntax)reader.ReadValue();
      if (elementType != null)
      {
         AdjustFlagsAndWidth(elementType);
         this.elementType = elementType;
      }
      var asteriskToken = (SyntaxToken)reader.ReadValue();
      if (asteriskToken != null)
      {
         AdjustFlagsAndWidth(asteriskToken);
         this.asteriskToken = asteriskToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.elementType);
      writer.WriteValue(this.asteriskToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new PointerTypeSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for a nullable type.</summary>
  internal sealed partial class NullableTypeSyntax : TypeSyntax
  {
    internal readonly TypeSyntax elementType;
    internal readonly SyntaxToken questionToken;

    internal NullableTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken questionToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(questionToken);
        this.questionToken = questionToken;
    }


    internal NullableTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken questionToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(questionToken);
        this.questionToken = questionToken;
    }


    internal NullableTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken questionToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(questionToken);
        this.questionToken = questionToken;
    }

    /// <summary>TypeSyntax node representing the type of the element.</summary>
    public TypeSyntax ElementType { get { return this.elementType; } }
    /// <summary>SyntaxToken representing the question mark.</summary>
    public SyntaxToken QuestionToken { get { return this.questionToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.elementType;
            case 1: return this.questionToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.NullableTypeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNullableType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitNullableType(this);
    }

    public NullableTypeSyntax Update(TypeSyntax elementType, SyntaxToken questionToken)
    {
        if (elementType != this.ElementType || questionToken != this.QuestionToken)
        {
            var newNode = SyntaxFactory.NullableType(elementType, questionToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new NullableTypeSyntax(this.Kind, this.elementType, this.questionToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new NullableTypeSyntax(this.Kind, this.elementType, this.questionToken, GetDiagnostics(), annotations);
    }

    internal NullableTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var elementType = (TypeSyntax)reader.ReadValue();
      if (elementType != null)
      {
         AdjustFlagsAndWidth(elementType);
         this.elementType = elementType;
      }
      var questionToken = (SyntaxToken)reader.ReadValue();
      if (questionToken != null)
      {
         AdjustFlagsAndWidth(questionToken);
         this.questionToken = questionToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.elementType);
      writer.WriteValue(this.questionToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new NullableTypeSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for tuple type.</summary>
  internal sealed partial class TupleTypeSyntax : TypeSyntax
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly CSharpSyntaxNode elements;
    internal readonly SyntaxToken closeParenToken;

    internal TupleTypeSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode elements, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (elements != null)
        {
            this.AdjustFlagsAndWidth(elements);
            this.elements = elements;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal TupleTypeSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode elements, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (elements != null)
        {
            this.AdjustFlagsAndWidth(elements);
            this.elements = elements;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal TupleTypeSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode elements, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (elements != null)
        {
            this.AdjustFlagsAndWidth(elements);
            this.elements = elements;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public SeparatedSyntaxList<TupleElementSyntax> Elements { get { return new SeparatedSyntaxList<TupleElementSyntax>(new SyntaxList<CSharpSyntaxNode>(this.elements)); } }
    /// <summary>SyntaxToken representing the close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.elements;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.TupleTypeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTupleType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTupleType(this);
    }

    public TupleTypeSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<TupleElementSyntax> elements, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || elements != this.Elements || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.TupleType(openParenToken, elements, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TupleTypeSyntax(this.Kind, this.openParenToken, this.elements, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TupleTypeSyntax(this.Kind, this.openParenToken, this.elements, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal TupleTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var elements = (CSharpSyntaxNode)reader.ReadValue();
      if (elements != null)
      {
         AdjustFlagsAndWidth(elements);
         this.elements = elements;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.elements);
      writer.WriteValue(this.closeParenToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new TupleTypeSyntax(r);
    }
  }

  /// <summary>Tuple type element.</summary>
  internal sealed partial class TupleElementSyntax : CSharpSyntaxNode
  {
    internal readonly TypeSyntax type;
    internal readonly IdentifierNameSyntax name;

    internal TupleElementSyntax(SyntaxKind kind, TypeSyntax type, IdentifierNameSyntax name, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (name != null)
        {
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }
    }


    internal TupleElementSyntax(SyntaxKind kind, TypeSyntax type, IdentifierNameSyntax name, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (name != null)
        {
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }
    }


    internal TupleElementSyntax(SyntaxKind kind, TypeSyntax type, IdentifierNameSyntax name)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (name != null)
        {
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }
    }

    /// <summary>Gets the type of the tuple element.</summary>
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>Gets the name of the tuple element.</summary>
    public IdentifierNameSyntax Name { get { return this.name; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            case 1: return this.name;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.TupleElementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTupleElement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTupleElement(this);
    }

    public TupleElementSyntax Update(TypeSyntax type, IdentifierNameSyntax name)
    {
        if (type != this.Type || name != this.Name)
        {
            var newNode = SyntaxFactory.TupleElement(type, name);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TupleElementSyntax(this.Kind, this.type, this.name, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TupleElementSyntax(this.Kind, this.type, this.name, GetDiagnostics(), annotations);
    }

    internal TupleElementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var name = (IdentifierNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.type);
      writer.WriteValue(this.name);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new TupleElementSyntax(r);
    }
  }

  /// <summary>Class which represents a placeholder in the type argument list of an unbound generic type.</summary>
  internal sealed partial class OmittedTypeArgumentSyntax : TypeSyntax
  {
    internal readonly SyntaxToken omittedTypeArgumentToken;

    internal OmittedTypeArgumentSyntax(SyntaxKind kind, SyntaxToken omittedTypeArgumentToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(omittedTypeArgumentToken);
        this.omittedTypeArgumentToken = omittedTypeArgumentToken;
    }


    internal OmittedTypeArgumentSyntax(SyntaxKind kind, SyntaxToken omittedTypeArgumentToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(omittedTypeArgumentToken);
        this.omittedTypeArgumentToken = omittedTypeArgumentToken;
    }


    internal OmittedTypeArgumentSyntax(SyntaxKind kind, SyntaxToken omittedTypeArgumentToken)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(omittedTypeArgumentToken);
        this.omittedTypeArgumentToken = omittedTypeArgumentToken;
    }

    /// <summary>SyntaxToken representing the omitted type argument.</summary>
    public SyntaxToken OmittedTypeArgumentToken { get { return this.omittedTypeArgumentToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.omittedTypeArgumentToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.OmittedTypeArgumentSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOmittedTypeArgument(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOmittedTypeArgument(this);
    }

    public OmittedTypeArgumentSyntax Update(SyntaxToken omittedTypeArgumentToken)
    {
        if (omittedTypeArgumentToken != this.OmittedTypeArgumentToken)
        {
            var newNode = SyntaxFactory.OmittedTypeArgument(omittedTypeArgumentToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new OmittedTypeArgumentSyntax(this.Kind, this.omittedTypeArgumentToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new OmittedTypeArgumentSyntax(this.Kind, this.omittedTypeArgumentToken, GetDiagnostics(), annotations);
    }

    internal OmittedTypeArgumentSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var omittedTypeArgumentToken = (SyntaxToken)reader.ReadValue();
      if (omittedTypeArgumentToken != null)
      {
         AdjustFlagsAndWidth(omittedTypeArgumentToken);
         this.omittedTypeArgumentToken = omittedTypeArgumentToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.omittedTypeArgumentToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new OmittedTypeArgumentSyntax(r);
    }
  }

  /// <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class ExpressionSyntax : CSharpSyntaxNode
  {
    internal ExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal ExpressionSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected ExpressionSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>Class which represents the syntax node for parenthesized expression.</summary>
  internal sealed partial class ParenthesizedExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;

    internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>SyntaxToken representing the close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.expression;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ParenthesizedExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParenthesizedExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitParenthesizedExpression(this);
    }

    public ParenthesizedExpressionSyntax Update(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.ParenthesizedExpression(openParenToken, expression, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ParenthesizedExpressionSyntax(this.Kind, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ParenthesizedExpressionSyntax(this.Kind, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal ParenthesizedExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ParenthesizedExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for tuple expression.</summary>
  internal sealed partial class TupleExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly CSharpSyntaxNode arguments;
    internal readonly SyntaxToken closeParenToken;

    internal TupleExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode arguments, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal TupleExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode arguments, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal TupleExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode arguments, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
    public SeparatedSyntaxList<ArgumentSyntax> Arguments { get { return new SeparatedSyntaxList<ArgumentSyntax>(new SyntaxList<CSharpSyntaxNode>(this.arguments)); } }
    /// <summary>SyntaxToken representing the close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.arguments;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.TupleExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTupleExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTupleExpression(this);
    }

    public TupleExpressionSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.TupleExpression(openParenToken, arguments, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TupleExpressionSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TupleExpressionSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal TupleExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var arguments = (CSharpSyntaxNode)reader.ReadValue();
      if (arguments != null)
      {
         AdjustFlagsAndWidth(arguments);
         this.arguments = arguments;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.arguments);
      writer.WriteValue(this.closeParenToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new TupleExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for prefix unary expression.</summary>
  internal sealed partial class PrefixUnaryExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken operatorToken;
    internal readonly ExpressionSyntax operand;

    internal PrefixUnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(operand);
        this.operand = operand;
    }


    internal PrefixUnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(operand);
        this.operand = operand;
    }


    internal PrefixUnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(operand);
        this.operand = operand;
    }

    /// <summary>SyntaxToken representing the kind of the operator of the prefix unary expression.</summary>
    public SyntaxToken OperatorToken { get { return this.operatorToken; } }
    /// <summary>ExpressionSyntax representing the operand of the prefix unary expression.</summary>
    public ExpressionSyntax Operand { get { return this.operand; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.operatorToken;
            case 1: return this.operand;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.PrefixUnaryExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPrefixUnaryExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPrefixUnaryExpression(this);
    }

    public PrefixUnaryExpressionSyntax Update(SyntaxToken operatorToken, ExpressionSyntax operand)
    {
        if (operatorToken != this.OperatorToken || operand != this.Operand)
        {
            var newNode = SyntaxFactory.PrefixUnaryExpression(this.Kind, operatorToken, operand);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new PrefixUnaryExpressionSyntax(this.Kind, this.operatorToken, this.operand, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new PrefixUnaryExpressionSyntax(this.Kind, this.operatorToken, this.operand, GetDiagnostics(), annotations);
    }

    internal PrefixUnaryExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var operand = (ExpressionSyntax)reader.ReadValue();
      if (operand != null)
      {
         AdjustFlagsAndWidth(operand);
         this.operand = operand;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.operand);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new PrefixUnaryExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for an "await" expression.</summary>
  internal sealed partial class AwaitExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken awaitKeyword;
    internal readonly ExpressionSyntax expression;

    internal AwaitExpressionSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(awaitKeyword);
        this.awaitKeyword = awaitKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal AwaitExpressionSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(awaitKeyword);
        this.awaitKeyword = awaitKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal AwaitExpressionSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(awaitKeyword);
        this.awaitKeyword = awaitKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    /// <summary>SyntaxToken representing the kind "await" keyword.</summary>
    public SyntaxToken AwaitKeyword { get { return this.awaitKeyword; } }
    /// <summary>ExpressionSyntax representing the operand of the "await" operator.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.awaitKeyword;
            case 1: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AwaitExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAwaitExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAwaitExpression(this);
    }

    public AwaitExpressionSyntax Update(SyntaxToken awaitKeyword, ExpressionSyntax expression)
    {
        if (awaitKeyword != this.AwaitKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.AwaitExpression(awaitKeyword, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AwaitExpressionSyntax(this.Kind, this.awaitKeyword, this.expression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AwaitExpressionSyntax(this.Kind, this.awaitKeyword, this.expression, GetDiagnostics(), annotations);
    }

    internal AwaitExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var awaitKeyword = (SyntaxToken)reader.ReadValue();
      if (awaitKeyword != null)
      {
         AdjustFlagsAndWidth(awaitKeyword);
         this.awaitKeyword = awaitKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.awaitKeyword);
      writer.WriteValue(this.expression);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new AwaitExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for postfix unary expression.</summary>
  internal sealed partial class PostfixUnaryExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax operand;
    internal readonly SyntaxToken operatorToken;

    internal PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operand);
        this.operand = operand;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
    }


    internal PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operand);
        this.operand = operand;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
    }


    internal PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operand);
        this.operand = operand;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
    }

    /// <summary>ExpressionSyntax representing the operand of the postfix unary expression.</summary>
    public ExpressionSyntax Operand { get { return this.operand; } }
    /// <summary>SyntaxToken representing the kind of the operator of the postfix unary expression.</summary>
    public SyntaxToken OperatorToken { get { return this.operatorToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.operand;
            case 1: return this.operatorToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.PostfixUnaryExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPostfixUnaryExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPostfixUnaryExpression(this);
    }

    public PostfixUnaryExpressionSyntax Update(ExpressionSyntax operand, SyntaxToken operatorToken)
    {
        if (operand != this.Operand || operatorToken != this.OperatorToken)
        {
            var newNode = SyntaxFactory.PostfixUnaryExpression(this.Kind, operand, operatorToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new PostfixUnaryExpressionSyntax(this.Kind, this.operand, this.operatorToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new PostfixUnaryExpressionSyntax(this.Kind, this.operand, this.operatorToken, GetDiagnostics(), annotations);
    }

    internal PostfixUnaryExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var operand = (ExpressionSyntax)reader.ReadValue();
      if (operand != null)
      {
         AdjustFlagsAndWidth(operand);
         this.operand = operand;
      }
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.operand);
      writer.WriteValue(this.operatorToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new PostfixUnaryExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for member access expression.</summary>
  internal sealed partial class MemberAccessExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken operatorToken;
    internal readonly SimpleNameSyntax name;

    internal MemberAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }


    internal MemberAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }


    internal MemberAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }

    /// <summary>ExpressionSyntax node representing the object that the member belongs to.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>SyntaxToken representing the kind of the operator in the member access expression.</summary>
    public SyntaxToken OperatorToken { get { return this.operatorToken; } }
    /// <summary>SimpleNameSyntax node representing the member being accessed.</summary>
    public SimpleNameSyntax Name { get { return this.name; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.operatorToken;
            case 2: return this.name;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.MemberAccessExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitMemberAccessExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitMemberAccessExpression(this);
    }

    public MemberAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
    {
        if (expression != this.Expression || operatorToken != this.OperatorToken || name != this.Name)
        {
            var newNode = SyntaxFactory.MemberAccessExpression(this.Kind, expression, operatorToken, name);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new MemberAccessExpressionSyntax(this.Kind, this.expression, this.operatorToken, this.name, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new MemberAccessExpressionSyntax(this.Kind, this.expression, this.operatorToken, this.name, GetDiagnostics(), annotations);
    }

    internal MemberAccessExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var name = (SimpleNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.name);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new MemberAccessExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for conditional access expression.</summary>
  internal sealed partial class ConditionalAccessExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken operatorToken;
    internal readonly ExpressionSyntax whenNotNull;

    internal ConditionalAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(whenNotNull);
        this.whenNotNull = whenNotNull;
    }


    internal ConditionalAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(whenNotNull);
        this.whenNotNull = whenNotNull;
    }


    internal ConditionalAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(whenNotNull);
        this.whenNotNull = whenNotNull;
    }

    /// <summary>ExpressionSyntax node representing the object conditionally accessed.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>SyntaxToken representing the question mark.</summary>
    public SyntaxToken OperatorToken { get { return this.operatorToken; } }
    /// <summary>ExpressionSyntax node representing the access expression to be executed when the object is not null.</summary>
    public ExpressionSyntax WhenNotNull { get { return this.whenNotNull; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.operatorToken;
            case 2: return this.whenNotNull;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ConditionalAccessExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConditionalAccessExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConditionalAccessExpression(this);
    }

    public ConditionalAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)
    {
        if (expression != this.Expression || operatorToken != this.OperatorToken || whenNotNull != this.WhenNotNull)
        {
            var newNode = SyntaxFactory.ConditionalAccessExpression(expression, operatorToken, whenNotNull);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ConditionalAccessExpressionSyntax(this.Kind, this.expression, this.operatorToken, this.whenNotNull, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ConditionalAccessExpressionSyntax(this.Kind, this.expression, this.operatorToken, this.whenNotNull, GetDiagnostics(), annotations);
    }

    internal ConditionalAccessExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var whenNotNull = (ExpressionSyntax)reader.ReadValue();
      if (whenNotNull != null)
      {
         AdjustFlagsAndWidth(whenNotNull);
         this.whenNotNull = whenNotNull;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.whenNotNull);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ConditionalAccessExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for member binding expression.</summary>
  internal sealed partial class MemberBindingExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken operatorToken;
    internal readonly SimpleNameSyntax name;

    internal MemberBindingExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, SimpleNameSyntax name, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }


    internal MemberBindingExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, SimpleNameSyntax name, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }


    internal MemberBindingExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, SimpleNameSyntax name)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }

    /// <summary>SyntaxToken representing dot.</summary>
    public SyntaxToken OperatorToken { get { return this.operatorToken; } }
    /// <summary>SimpleNameSyntax node representing the member being bound to.</summary>
    public SimpleNameSyntax Name { get { return this.name; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.operatorToken;
            case 1: return this.name;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.MemberBindingExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitMemberBindingExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitMemberBindingExpression(this);
    }

    public MemberBindingExpressionSyntax Update(SyntaxToken operatorToken, SimpleNameSyntax name)
    {
        if (operatorToken != this.OperatorToken || name != this.Name)
        {
            var newNode = SyntaxFactory.MemberBindingExpression(operatorToken, name);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new MemberBindingExpressionSyntax(this.Kind, this.operatorToken, this.name, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new MemberBindingExpressionSyntax(this.Kind, this.operatorToken, this.name, GetDiagnostics(), annotations);
    }

    internal MemberBindingExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var name = (SimpleNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.name);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new MemberBindingExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for element binding expression.</summary>
  internal sealed partial class ElementBindingExpressionSyntax : ExpressionSyntax
  {
    internal readonly BracketedArgumentListSyntax argumentList;

    internal ElementBindingExpressionSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ElementBindingExpressionSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ElementBindingExpressionSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }

    /// <summary>BracketedArgumentListSyntax node representing the list of arguments of the element binding expression.</summary>
    public BracketedArgumentListSyntax ArgumentList { get { return this.argumentList; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.argumentList;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ElementBindingExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElementBindingExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitElementBindingExpression(this);
    }

    public ElementBindingExpressionSyntax Update(BracketedArgumentListSyntax argumentList)
    {
        if (argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.ElementBindingExpression(argumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ElementBindingExpressionSyntax(this.Kind, this.argumentList, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ElementBindingExpressionSyntax(this.Kind, this.argumentList, GetDiagnostics(), annotations);
    }

    internal ElementBindingExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var argumentList = (BracketedArgumentListSyntax)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.argumentList);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ElementBindingExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for implicit element access expression.</summary>
  internal sealed partial class ImplicitElementAccessSyntax : ExpressionSyntax
  {
    internal readonly BracketedArgumentListSyntax argumentList;

    internal ImplicitElementAccessSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ImplicitElementAccessSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ImplicitElementAccessSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }

    /// <summary>BracketedArgumentListSyntax node representing the list of arguments of the implicit element access expression.</summary>
    public BracketedArgumentListSyntax ArgumentList { get { return this.argumentList; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.argumentList;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ImplicitElementAccessSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitImplicitElementAccess(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitImplicitElementAccess(this);
    }

    public ImplicitElementAccessSyntax Update(BracketedArgumentListSyntax argumentList)
    {
        if (argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.ImplicitElementAccess(argumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ImplicitElementAccessSyntax(this.Kind, this.argumentList, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ImplicitElementAccessSyntax(this.Kind, this.argumentList, GetDiagnostics(), annotations);
    }

    internal ImplicitElementAccessSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var argumentList = (BracketedArgumentListSyntax)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.argumentList);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ImplicitElementAccessSyntax(r);
    }
  }

  /// <summary>Class which represents an expression that has a binary operator.</summary>
  internal sealed partial class BinaryExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax left;
    internal readonly SyntaxToken operatorToken;
    internal readonly ExpressionSyntax right;

    internal BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }


    internal BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }


    internal BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }

    /// <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
    public ExpressionSyntax Left { get { return this.left; } }
    /// <summary>SyntaxToken representing the operator of the binary expression.</summary>
    public SyntaxToken OperatorToken { get { return this.operatorToken; } }
    /// <summary>ExpressionSyntax node representing the expression on the right of the binary operator.</summary>
    public ExpressionSyntax Right { get { return this.right; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.left;
            case 1: return this.operatorToken;
            case 2: return this.right;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.BinaryExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBinaryExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBinaryExpression(this);
    }

    public BinaryExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
        if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
        {
            var newNode = SyntaxFactory.BinaryExpression(this.Kind, left, operatorToken, right);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BinaryExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BinaryExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, GetDiagnostics(), annotations);
    }

    internal BinaryExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var left = (ExpressionSyntax)reader.ReadValue();
      if (left != null)
      {
         AdjustFlagsAndWidth(left);
         this.left = left;
      }
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var right = (ExpressionSyntax)reader.ReadValue();
      if (right != null)
      {
         AdjustFlagsAndWidth(right);
         this.right = right;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.left);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.right);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new BinaryExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents an expression that has an assignment operator.</summary>
  internal sealed partial class AssignmentExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax left;
    internal readonly SyntaxToken operatorToken;
    internal readonly ExpressionSyntax right;

    internal AssignmentExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }


    internal AssignmentExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }


    internal AssignmentExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }

    /// <summary>ExpressionSyntax node representing the expression on the left of the assignment operator.</summary>
    public ExpressionSyntax Left { get { return this.left; } }
    /// <summary>SyntaxToken representing the operator of the assignment expression.</summary>
    public SyntaxToken OperatorToken { get { return this.operatorToken; } }
    /// <summary>ExpressionSyntax node representing the expression on the right of the assignment operator.</summary>
    public ExpressionSyntax Right { get { return this.right; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.left;
            case 1: return this.operatorToken;
            case 2: return this.right;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AssignmentExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAssignmentExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAssignmentExpression(this);
    }

    public AssignmentExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
        if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
        {
            var newNode = SyntaxFactory.AssignmentExpression(this.Kind, left, operatorToken, right);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AssignmentExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AssignmentExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, GetDiagnostics(), annotations);
    }

    internal AssignmentExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var left = (ExpressionSyntax)reader.ReadValue();
      if (left != null)
      {
         AdjustFlagsAndWidth(left);
         this.left = left;
      }
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var right = (ExpressionSyntax)reader.ReadValue();
      if (right != null)
      {
         AdjustFlagsAndWidth(right);
         this.right = right;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.left);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.right);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new AssignmentExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for conditional expression.</summary>
  internal sealed partial class ConditionalExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax condition;
    internal readonly SyntaxToken questionToken;
    internal readonly ExpressionSyntax whenTrue;
    internal readonly SyntaxToken colonToken;
    internal readonly ExpressionSyntax whenFalse;

    internal ConditionalExpressionSyntax(SyntaxKind kind, ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(questionToken);
        this.questionToken = questionToken;
        this.AdjustFlagsAndWidth(whenTrue);
        this.whenTrue = whenTrue;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(whenFalse);
        this.whenFalse = whenFalse;
    }


    internal ConditionalExpressionSyntax(SyntaxKind kind, ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(questionToken);
        this.questionToken = questionToken;
        this.AdjustFlagsAndWidth(whenTrue);
        this.whenTrue = whenTrue;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(whenFalse);
        this.whenFalse = whenFalse;
    }


    internal ConditionalExpressionSyntax(SyntaxKind kind, ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(questionToken);
        this.questionToken = questionToken;
        this.AdjustFlagsAndWidth(whenTrue);
        this.whenTrue = whenTrue;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(whenFalse);
        this.whenFalse = whenFalse;
    }

    /// <summary>ExpressionSyntax node representing the condition of the conditional expression.</summary>
    public ExpressionSyntax Condition { get { return this.condition; } }
    /// <summary>SyntaxToken representing the question mark.</summary>
    public SyntaxToken QuestionToken { get { return this.questionToken; } }
    /// <summary>ExpressionSyntax node representing the expression to be executed when the condition is true.</summary>
    public ExpressionSyntax WhenTrue { get { return this.whenTrue; } }
    /// <summary>SyntaxToken representing the colon.</summary>
    public SyntaxToken ColonToken { get { return this.colonToken; } }
    /// <summary>ExpressionSyntax node representing the expression to be executed when the condition is false.</summary>
    public ExpressionSyntax WhenFalse { get { return this.whenFalse; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.condition;
            case 1: return this.questionToken;
            case 2: return this.whenTrue;
            case 3: return this.colonToken;
            case 4: return this.whenFalse;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ConditionalExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConditionalExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConditionalExpression(this);
    }

    public ConditionalExpressionSyntax Update(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
    {
        if (condition != this.Condition || questionToken != this.QuestionToken || whenTrue != this.WhenTrue || colonToken != this.ColonToken || whenFalse != this.WhenFalse)
        {
            var newNode = SyntaxFactory.ConditionalExpression(condition, questionToken, whenTrue, colonToken, whenFalse);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ConditionalExpressionSyntax(this.Kind, this.condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ConditionalExpressionSyntax(this.Kind, this.condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse, GetDiagnostics(), annotations);
    }

    internal ConditionalExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
      var questionToken = (SyntaxToken)reader.ReadValue();
      if (questionToken != null)
      {
         AdjustFlagsAndWidth(questionToken);
         this.questionToken = questionToken;
      }
      var whenTrue = (ExpressionSyntax)reader.ReadValue();
      if (whenTrue != null)
      {
         AdjustFlagsAndWidth(whenTrue);
         this.whenTrue = whenTrue;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
      var whenFalse = (ExpressionSyntax)reader.ReadValue();
      if (whenFalse != null)
      {
         AdjustFlagsAndWidth(whenFalse);
         this.whenFalse = whenFalse;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.questionToken);
      writer.WriteValue(this.whenTrue);
      writer.WriteValue(this.colonToken);
      writer.WriteValue(this.whenFalse);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ConditionalExpressionSyntax(r);
    }
  }

  /// <summary>Provides the base class from which the classes that represent instance expression syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class InstanceExpressionSyntax : ExpressionSyntax
  {
    internal InstanceExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal InstanceExpressionSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected InstanceExpressionSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>Class which represents the syntax node for a this expression.</summary>
  internal sealed partial class ThisExpressionSyntax : InstanceExpressionSyntax
  {
    internal readonly SyntaxToken token;

    internal ThisExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }


    internal ThisExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }


    internal ThisExpressionSyntax(SyntaxKind kind, SyntaxToken token)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }

    /// <summary>SyntaxToken representing the this keyword.</summary>
    public SyntaxToken Token { get { return this.token; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.token;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ThisExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitThisExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitThisExpression(this);
    }

    public ThisExpressionSyntax Update(SyntaxToken token)
    {
        if (token != this.Token)
        {
            var newNode = SyntaxFactory.ThisExpression(token);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ThisExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ThisExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);
    }

    internal ThisExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var token = (SyntaxToken)reader.ReadValue();
      if (token != null)
      {
         AdjustFlagsAndWidth(token);
         this.token = token;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.token);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ThisExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for a base expression.</summary>
  internal sealed partial class BaseExpressionSyntax : InstanceExpressionSyntax
  {
    internal readonly SyntaxToken token;

    internal BaseExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }


    internal BaseExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }


    internal BaseExpressionSyntax(SyntaxKind kind, SyntaxToken token)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }

    /// <summary>SyntaxToken representing the base keyword.</summary>
    public SyntaxToken Token { get { return this.token; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.token;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.BaseExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBaseExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBaseExpression(this);
    }

    public BaseExpressionSyntax Update(SyntaxToken token)
    {
        if (token != this.Token)
        {
            var newNode = SyntaxFactory.BaseExpression(token);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BaseExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BaseExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);
    }

    internal BaseExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var token = (SyntaxToken)reader.ReadValue();
      if (token != null)
      {
         AdjustFlagsAndWidth(token);
         this.token = token;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.token);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new BaseExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for an original expression.</summary>
  internal sealed partial class OriginalExpressionSyntax : InstanceExpressionSyntax
  {
    internal readonly SyntaxToken token;

    internal OriginalExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }


    internal OriginalExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }


    internal OriginalExpressionSyntax(SyntaxKind kind, SyntaxToken token)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }

    /// <summary>SyntaxToken representing the original keyword.</summary>
    public SyntaxToken Token { get { return this.token; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.token;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.OriginalExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOriginalExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOriginalExpression(this);
    }

    public OriginalExpressionSyntax Update(SyntaxToken token)
    {
        if (token != this.Token)
        {
            var newNode = SyntaxFactory.OriginalExpression(token);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new OriginalExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new OriginalExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);
    }

    internal OriginalExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var token = (SyntaxToken)reader.ReadValue();
      if (token != null)
      {
         AdjustFlagsAndWidth(token);
         this.token = token;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.token);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new OriginalExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for a literal expression.</summary>
  internal sealed partial class LiteralExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken token;

    internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }


    internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }


    internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }

    /// <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
    public SyntaxToken Token { get { return this.token; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.token;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.LiteralExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLiteralExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLiteralExpression(this);
    }

    public LiteralExpressionSyntax Update(SyntaxToken token)
    {
        if (token != this.Token)
        {
            var newNode = SyntaxFactory.LiteralExpression(this.Kind, token);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new LiteralExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new LiteralExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);
    }

    internal LiteralExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var token = (SyntaxToken)reader.ReadValue();
      if (token != null)
      {
         AdjustFlagsAndWidth(token);
         this.token = token;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.token);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new LiteralExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for MakeRef expression.</summary>
  internal sealed partial class MakeRefExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;

    internal MakeRefExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal MakeRefExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal MakeRefExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the MakeRefKeyword.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Argument of the primary function.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.MakeRefExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitMakeRefExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitMakeRefExpression(this);
    }

    public MakeRefExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.MakeRefExpression(keyword, openParenToken, expression, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new MakeRefExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new MakeRefExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal MakeRefExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new MakeRefExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for RefType expression.</summary>
  internal sealed partial class RefTypeExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;

    internal RefTypeExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal RefTypeExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal RefTypeExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the RefTypeKeyword.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Argument of the primary function.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.RefTypeExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRefTypeExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitRefTypeExpression(this);
    }

    public RefTypeExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.RefTypeExpression(keyword, openParenToken, expression, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new RefTypeExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new RefTypeExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal RefTypeExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new RefTypeExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for RefValue expression.</summary>
  internal sealed partial class RefValueExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken comma;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken closeParenToken;

    internal RefValueExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(comma);
        this.comma = comma;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal RefValueExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(comma);
        this.comma = comma;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal RefValueExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(comma);
        this.comma = comma;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the RefValueKeyword.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Typed reference expression.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>Comma separating the arguments.</summary>
    public SyntaxToken Comma { get { return this.comma; } }
    /// <summary>The type of the value.</summary>
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.comma;
            case 4: return this.type;
            case 5: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.RefValueExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRefValueExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitRefValueExpression(this);
    }

    public RefValueExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || comma != this.Comma || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.RefValueExpression(keyword, openParenToken, expression, comma, type, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new RefValueExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.comma, this.type, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new RefValueExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.comma, this.type, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal RefValueExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 6;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var comma = (SyntaxToken)reader.ReadValue();
      if (comma != null)
      {
         AdjustFlagsAndWidth(comma);
         this.comma = comma;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.comma);
      writer.WriteValue(this.type);
      writer.WriteValue(this.closeParenToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new RefValueExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for Checked or Unchecked expression.</summary>
  internal sealed partial class CheckedExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;

    internal CheckedExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CheckedExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CheckedExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the checked or unchecked keyword.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Argument of the primary function.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CheckedExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCheckedExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCheckedExpression(this);
    }

    public CheckedExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.CheckedExpression(this.Kind, keyword, openParenToken, expression, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CheckedExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CheckedExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal CheckedExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new CheckedExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for Default expression.</summary>
  internal sealed partial class DefaultExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken closeParenToken;

    internal DefaultExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal DefaultExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal DefaultExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the DefaultKeyword.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Argument of the primary function.</summary>
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.type;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.DefaultExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDefaultExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDefaultExpression(this);
    }

    public DefaultExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.DefaultExpression(keyword, openParenToken, type, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DefaultExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DefaultExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal DefaultExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.closeParenToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new DefaultExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for TypeOf expression.</summary>
  internal sealed partial class TypeOfExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken closeParenToken;

    internal TypeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal TypeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal TypeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the TypeOfKeyword.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>The expression to return type of.</summary>
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.type;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.TypeOfExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeOfExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeOfExpression(this);
    }

    public TypeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.TypeOfExpression(keyword, openParenToken, type, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TypeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TypeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal TypeOfExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.closeParenToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new TypeOfExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for SizeOf expression.</summary>
  internal sealed partial class SizeOfExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken closeParenToken;

    internal SizeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal SizeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal SizeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the SizeOfKeyword.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Argument of the primary function.</summary>
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.type;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.SizeOfExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSizeOfExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSizeOfExpression(this);
    }

    public SizeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.SizeOfExpression(keyword, openParenToken, type, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new SizeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new SizeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal SizeOfExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.closeParenToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new SizeOfExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for invocation expression.</summary>
  internal sealed partial class InvocationExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax expression;
    internal readonly ArgumentListSyntax argumentList;

    internal InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, ArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, ArgumentListSyntax argumentList, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, ArgumentListSyntax argumentList)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }

    /// <summary>ExpressionSyntax node representing the expression part of the invocation.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>ArgumentListSyntax node representing the list of arguments of the invocation expression.</summary>
    public ArgumentListSyntax ArgumentList { get { return this.argumentList; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.argumentList;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.InvocationExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInvocationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInvocationExpression(this);
    }

    public InvocationExpressionSyntax Update(ExpressionSyntax expression, ArgumentListSyntax argumentList)
    {
        if (expression != this.Expression || argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.InvocationExpression(expression, argumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new InvocationExpressionSyntax(this.Kind, this.expression, this.argumentList, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new InvocationExpressionSyntax(this.Kind, this.expression, this.argumentList, GetDiagnostics(), annotations);
    }

    internal InvocationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var argumentList = (ArgumentListSyntax)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.argumentList);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new InvocationExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for element access expression.</summary>
  internal sealed partial class ElementAccessExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax expression;
    internal readonly BracketedArgumentListSyntax argumentList;

    internal ElementAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, BracketedArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ElementAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, BracketedArgumentListSyntax argumentList, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ElementAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }

    /// <summary>ExpressionSyntax node representing the expression which is accessing the element.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>BracketedArgumentListSyntax node representing the list of arguments of the element access expression.</summary>
    public BracketedArgumentListSyntax ArgumentList { get { return this.argumentList; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.argumentList;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ElementAccessExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElementAccessExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitElementAccessExpression(this);
    }

    public ElementAccessExpressionSyntax Update(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
    {
        if (expression != this.Expression || argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.ElementAccessExpression(expression, argumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ElementAccessExpressionSyntax(this.Kind, this.expression, this.argumentList, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ElementAccessExpressionSyntax(this.Kind, this.expression, this.argumentList, GetDiagnostics(), annotations);
    }

    internal ElementAccessExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var argumentList = (BracketedArgumentListSyntax)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.argumentList);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ElementAccessExpressionSyntax(r);
    }
  }

  /// <summary>Provides the base class from which the classes that represent argument list syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class BaseArgumentListSyntax : CSharpSyntaxNode
  {
    internal BaseArgumentListSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseArgumentListSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseArgumentListSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>SeparatedSyntaxList of ArgumentSyntax nodes representing the list of arguments.</summary>
    public abstract SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }
  }

  /// <summary>Class which represents the syntax node for the list of arguments.</summary>
  internal sealed partial class ArgumentListSyntax : BaseArgumentListSyntax
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly CSharpSyntaxNode arguments;
    internal readonly SyntaxToken closeParenToken;

    internal ArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode arguments, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode arguments, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode arguments, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
    public override SeparatedSyntaxList<ArgumentSyntax> Arguments { get { return new SeparatedSyntaxList<ArgumentSyntax>(new SyntaxList<CSharpSyntaxNode>(this.arguments)); } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.arguments;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ArgumentListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArgumentList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArgumentList(this);
    }

    public ArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.ArgumentList(openParenToken, arguments, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal ArgumentListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var arguments = (CSharpSyntaxNode)reader.ReadValue();
      if (arguments != null)
      {
         AdjustFlagsAndWidth(arguments);
         this.arguments = arguments;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.arguments);
      writer.WriteValue(this.closeParenToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ArgumentListSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for bracketed argument list.</summary>
  internal sealed partial class BracketedArgumentListSyntax : BaseArgumentListSyntax
  {
    internal readonly SyntaxToken openBracketToken;
    internal readonly CSharpSyntaxNode arguments;
    internal readonly SyntaxToken closeBracketToken;

    internal BracketedArgumentListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode arguments, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal BracketedArgumentListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode arguments, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal BracketedArgumentListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode arguments, SyntaxToken closeBracketToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }

    /// <summary>SyntaxToken representing open bracket.</summary>
    public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
    /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
    public override SeparatedSyntaxList<ArgumentSyntax> Arguments { get { return new SeparatedSyntaxList<ArgumentSyntax>(new SyntaxList<CSharpSyntaxNode>(this.arguments)); } }
    /// <summary>SyntaxToken representing close bracket.</summary>
    public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBracketToken;
            case 1: return this.arguments;
            case 2: return this.closeBracketToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.BracketedArgumentListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBracketedArgumentList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBracketedArgumentList(this);
    }

    public BracketedArgumentListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || arguments != this.Arguments || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.BracketedArgumentList(openBracketToken, arguments, closeBracketToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BracketedArgumentListSyntax(this.Kind, this.openBracketToken, this.arguments, this.closeBracketToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BracketedArgumentListSyntax(this.Kind, this.openBracketToken, this.arguments, this.closeBracketToken, GetDiagnostics(), annotations);
    }

    internal BracketedArgumentListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openBracketToken = (SyntaxToken)reader.ReadValue();
      if (openBracketToken != null)
      {
         AdjustFlagsAndWidth(openBracketToken);
         this.openBracketToken = openBracketToken;
      }
      var arguments = (CSharpSyntaxNode)reader.ReadValue();
      if (arguments != null)
      {
         AdjustFlagsAndWidth(arguments);
         this.arguments = arguments;
      }
      var closeBracketToken = (SyntaxToken)reader.ReadValue();
      if (closeBracketToken != null)
      {
         AdjustFlagsAndWidth(closeBracketToken);
         this.closeBracketToken = closeBracketToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.arguments);
      writer.WriteValue(this.closeBracketToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new BracketedArgumentListSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for argument.</summary>
  internal sealed partial class ArgumentSyntax : CSharpSyntaxNode
  {
    internal readonly NameColonSyntax nameColon;
    internal readonly SyntaxToken refOrOutKeyword;
    internal readonly ExpressionSyntax expression;

    internal ArgumentSyntax(SyntaxKind kind, NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        if (nameColon != null)
        {
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
        }
        if (refOrOutKeyword != null)
        {
            this.AdjustFlagsAndWidth(refOrOutKeyword);
            this.refOrOutKeyword = refOrOutKeyword;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal ArgumentSyntax(SyntaxKind kind, NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        if (nameColon != null)
        {
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
        }
        if (refOrOutKeyword != null)
        {
            this.AdjustFlagsAndWidth(refOrOutKeyword);
            this.refOrOutKeyword = refOrOutKeyword;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal ArgumentSyntax(SyntaxKind kind, NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 3;
        if (nameColon != null)
        {
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
        }
        if (refOrOutKeyword != null)
        {
            this.AdjustFlagsAndWidth(refOrOutKeyword);
            this.refOrOutKeyword = refOrOutKeyword;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    /// <summary>NameColonSyntax node representing the optional name arguments.</summary>
    public NameColonSyntax NameColon { get { return this.nameColon; } }
    /// <summary>SyntaxToken representing the optional ref or out keyword.</summary>
    public SyntaxToken RefOrOutKeyword { get { return this.refOrOutKeyword; } }
    /// <summary>ExpressionSyntax node representing the argument.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nameColon;
            case 1: return this.refOrOutKeyword;
            case 2: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ArgumentSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArgument(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArgument(this);
    }

    public ArgumentSyntax Update(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression)
    {
        if (nameColon != this.NameColon || refOrOutKeyword != this.RefOrOutKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.Argument(nameColon, refOrOutKeyword, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ArgumentSyntax(this.Kind, this.nameColon, this.refOrOutKeyword, this.expression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ArgumentSyntax(this.Kind, this.nameColon, this.refOrOutKeyword, this.expression, GetDiagnostics(), annotations);
    }

    internal ArgumentSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var nameColon = (NameColonSyntax)reader.ReadValue();
      if (nameColon != null)
      {
         AdjustFlagsAndWidth(nameColon);
         this.nameColon = nameColon;
      }
      var refOrOutKeyword = (SyntaxToken)reader.ReadValue();
      if (refOrOutKeyword != null)
      {
         AdjustFlagsAndWidth(refOrOutKeyword);
         this.refOrOutKeyword = refOrOutKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.nameColon);
      writer.WriteValue(this.refOrOutKeyword);
      writer.WriteValue(this.expression);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ArgumentSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for name colon syntax.</summary>
  internal sealed partial class NameColonSyntax : CSharpSyntaxNode
  {
    internal readonly IdentifierNameSyntax name;
    internal readonly SyntaxToken colonToken;

    internal NameColonSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal NameColonSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken colonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal NameColonSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken colonToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }

    /// <summary>IdentifierNameSyntax representing the identifier name.</summary>
    public IdentifierNameSyntax Name { get { return this.name; } }
    /// <summary>SyntaxToken representing colon.</summary>
    public SyntaxToken ColonToken { get { return this.colonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.colonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.NameColonSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNameColon(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitNameColon(this);
    }

    public NameColonSyntax Update(IdentifierNameSyntax name, SyntaxToken colonToken)
    {
        if (name != this.Name || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.NameColon(name, colonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new NameColonSyntax(this.Kind, this.name, this.colonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new NameColonSyntax(this.Kind, this.name, this.colonToken, GetDiagnostics(), annotations);
    }

    internal NameColonSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var name = (IdentifierNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.colonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new NameColonSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for cast expression.</summary>
  internal sealed partial class CastExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken closeParenToken;
    internal readonly ExpressionSyntax expression;

    internal CastExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal CastExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal CastExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    /// <summary>SyntaxToken representing the open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>TypeSyntax node representing the type the expression is being casted to.</summary>
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>SyntaxToken representing the close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    /// <summary>ExpressionSyntax node representing the expression that is being casted.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.type;
            case 2: return this.closeParenToken;
            case 3: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CastExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCastExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCastExpression(this);
    }

    public CastExpressionSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
    {
        if (openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken || expression != this.Expression)
        {
            var newNode = SyntaxFactory.CastExpression(openParenToken, type, closeParenToken, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CastExpressionSyntax(this.Kind, this.openParenToken, this.type, this.closeParenToken, this.expression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CastExpressionSyntax(this.Kind, this.openParenToken, this.type, this.closeParenToken, this.expression, GetDiagnostics(), annotations);
    }

    internal CastExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.expression);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new CastExpressionSyntax(r);
    }
  }

  /// <summary>Provides the base class from which the classes that represent anonymous function expressions are derived.</summary>
  internal abstract partial class AnonymousFunctionExpressionSyntax : ExpressionSyntax
  {
    internal AnonymousFunctionExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal AnonymousFunctionExpressionSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected AnonymousFunctionExpressionSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the "async" token.</summary>
    public abstract SyntaxToken AsyncKeyword { get; }

    /// <summary>ExpressionSyntax or BlockSyntax representing the body of the lambda expression.</summary>
    public abstract CSharpSyntaxNode Body { get; }
  }

  /// <summary>Class which represents the syntax node for anonymous method expression.</summary>
  internal sealed partial class AnonymousMethodExpressionSyntax : AnonymousFunctionExpressionSyntax
  {
    internal readonly SyntaxToken asyncKeyword;
    internal readonly SyntaxToken delegateKeyword;
    internal readonly ParameterListSyntax parameterList;
    internal readonly CSharpSyntaxNode body;

    internal AnonymousMethodExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(delegateKeyword);
        this.delegateKeyword = delegateKeyword;
        if (parameterList != null)
        {
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
        }
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal AnonymousMethodExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(delegateKeyword);
        this.delegateKeyword = delegateKeyword;
        if (parameterList != null)
        {
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
        }
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal AnonymousMethodExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body)
        : base(kind)
    {
        this.SlotCount = 4;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(delegateKeyword);
        this.delegateKeyword = delegateKeyword;
        if (parameterList != null)
        {
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
        }
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }

    /// <summary>Gets the "async" token.</summary>
    public override SyntaxToken AsyncKeyword { get { return this.asyncKeyword; } }
    /// <summary>SyntaxToken representing the delegate keyword.</summary>
    public SyntaxToken DelegateKeyword { get { return this.delegateKeyword; } }
    /// <summary>List of parameters of the anonymous method expression, or null if there no parameters are specified.</summary>
    public ParameterListSyntax ParameterList { get { return this.parameterList; } }
    /// <summary>BlockSyntax node representing the body of the anonymous method.</summary>
    public override CSharpSyntaxNode Body { get { return this.body; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.asyncKeyword;
            case 1: return this.delegateKeyword;
            case 2: return this.parameterList;
            case 3: return this.body;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AnonymousMethodExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAnonymousMethodExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAnonymousMethodExpression(this);
    }

    public AnonymousMethodExpressionSyntax Update(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body)
    {
        if (asyncKeyword != this.AsyncKeyword || delegateKeyword != this.DelegateKeyword || parameterList != this.ParameterList || body != this.Body)
        {
            var newNode = SyntaxFactory.AnonymousMethodExpression(asyncKeyword, delegateKeyword, parameterList, body);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AnonymousMethodExpressionSyntax(this.Kind, this.asyncKeyword, this.delegateKeyword, this.parameterList, this.body, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AnonymousMethodExpressionSyntax(this.Kind, this.asyncKeyword, this.delegateKeyword, this.parameterList, this.body, GetDiagnostics(), annotations);
    }

    internal AnonymousMethodExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var asyncKeyword = (SyntaxToken)reader.ReadValue();
      if (asyncKeyword != null)
      {
         AdjustFlagsAndWidth(asyncKeyword);
         this.asyncKeyword = asyncKeyword;
      }
      var delegateKeyword = (SyntaxToken)reader.ReadValue();
      if (delegateKeyword != null)
      {
         AdjustFlagsAndWidth(delegateKeyword);
         this.delegateKeyword = delegateKeyword;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var body = (CSharpSyntaxNode)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.asyncKeyword);
      writer.WriteValue(this.delegateKeyword);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.body);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new AnonymousMethodExpressionSyntax(r);
    }
  }

  /// <summary>Provides the base class from which the classes that represent lambda expressions are derived.</summary>
  internal abstract partial class LambdaExpressionSyntax : AnonymousFunctionExpressionSyntax
  {
    internal LambdaExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal LambdaExpressionSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected LambdaExpressionSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>SyntaxToken representing equals greater than.</summary>
    public abstract SyntaxToken ArrowToken { get; }
  }

  /// <summary>Class which represents the syntax node for a simple lambda expression.</summary>
  internal sealed partial class SimpleLambdaExpressionSyntax : LambdaExpressionSyntax
  {
    internal readonly SyntaxToken asyncKeyword;
    internal readonly ParameterSyntax parameter;
    internal readonly SyntaxToken arrowToken;
    internal readonly SyntaxToken refKeyword;
    internal readonly CSharpSyntaxNode body;

    internal SimpleLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, SyntaxToken refKeyword, CSharpSyntaxNode body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(parameter);
        this.parameter = parameter;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal SimpleLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, SyntaxToken refKeyword, CSharpSyntaxNode body, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(parameter);
        this.parameter = parameter;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal SimpleLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, SyntaxToken refKeyword, CSharpSyntaxNode body)
        : base(kind)
    {
        this.SlotCount = 5;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(parameter);
        this.parameter = parameter;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }

    /// <summary>Gets the "async" token.</summary>
    public override SyntaxToken AsyncKeyword { get { return this.asyncKeyword; } }
    /// <summary>ParameterSyntax node representing the parameter of the lambda expression.</summary>
    public ParameterSyntax Parameter { get { return this.parameter; } }
    /// <summary>SyntaxToken representing equals greater than.</summary>
    public override SyntaxToken ArrowToken { get { return this.arrowToken; } }
    /// <summary>SyntaxToken representing the "ref" keyword if present.</summary>
    public SyntaxToken RefKeyword { get { return this.refKeyword; } }
    /// <summary>SyntaxNode representing the body of the lambda expression.</summary>
    public override CSharpSyntaxNode Body { get { return this.body; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.asyncKeyword;
            case 1: return this.parameter;
            case 2: return this.arrowToken;
            case 3: return this.refKeyword;
            case 4: return this.body;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.SimpleLambdaExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSimpleLambdaExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSimpleLambdaExpression(this);
    }

    public SimpleLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, SyntaxToken refKeyword, CSharpSyntaxNode body)
    {
        if (asyncKeyword != this.AsyncKeyword || parameter != this.Parameter || arrowToken != this.ArrowToken || refKeyword != this.RefKeyword || body != this.Body)
        {
            var newNode = SyntaxFactory.SimpleLambdaExpression(asyncKeyword, parameter, arrowToken, refKeyword, body);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new SimpleLambdaExpressionSyntax(this.Kind, this.asyncKeyword, this.parameter, this.arrowToken, this.refKeyword, this.body, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new SimpleLambdaExpressionSyntax(this.Kind, this.asyncKeyword, this.parameter, this.arrowToken, this.refKeyword, this.body, GetDiagnostics(), annotations);
    }

    internal SimpleLambdaExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var asyncKeyword = (SyntaxToken)reader.ReadValue();
      if (asyncKeyword != null)
      {
         AdjustFlagsAndWidth(asyncKeyword);
         this.asyncKeyword = asyncKeyword;
      }
      var parameter = (ParameterSyntax)reader.ReadValue();
      if (parameter != null)
      {
         AdjustFlagsAndWidth(parameter);
         this.parameter = parameter;
      }
      var arrowToken = (SyntaxToken)reader.ReadValue();
      if (arrowToken != null)
      {
         AdjustFlagsAndWidth(arrowToken);
         this.arrowToken = arrowToken;
      }
      var refKeyword = (SyntaxToken)reader.ReadValue();
      if (refKeyword != null)
      {
         AdjustFlagsAndWidth(refKeyword);
         this.refKeyword = refKeyword;
      }
      var body = (CSharpSyntaxNode)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.asyncKeyword);
      writer.WriteValue(this.parameter);
      writer.WriteValue(this.arrowToken);
      writer.WriteValue(this.refKeyword);
      writer.WriteValue(this.body);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new SimpleLambdaExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for parenthesized lambda expression.</summary>
  internal sealed partial class ParenthesizedLambdaExpressionSyntax : LambdaExpressionSyntax
  {
    internal readonly SyntaxToken asyncKeyword;
    internal readonly ParameterListSyntax parameterList;
    internal readonly SyntaxToken arrowToken;
    internal readonly SyntaxToken refKeyword;
    internal readonly CSharpSyntaxNode body;

    internal ParenthesizedLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, SyntaxToken refKeyword, CSharpSyntaxNode body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal ParenthesizedLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, SyntaxToken refKeyword, CSharpSyntaxNode body, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal ParenthesizedLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, SyntaxToken refKeyword, CSharpSyntaxNode body)
        : base(kind)
    {
        this.SlotCount = 5;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }

    /// <summary>Gets the "async" token.</summary>
    public override SyntaxToken AsyncKeyword { get { return this.asyncKeyword; } }
    /// <summary>ParameterListSyntax node representing the list of parameters for the lambda expression.</summary>
    public ParameterListSyntax ParameterList { get { return this.parameterList; } }
    /// <summary>SyntaxToken representing equals greater than.</summary>
    public override SyntaxToken ArrowToken { get { return this.arrowToken; } }
    /// <summary>SyntaxToken representing the "ref" keyword if present.</summary>
    public SyntaxToken RefKeyword { get { return this.refKeyword; } }
    /// <summary>SyntaxNode representing the body of the lambda expression.</summary>
    public override CSharpSyntaxNode Body { get { return this.body; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.asyncKeyword;
            case 1: return this.parameterList;
            case 2: return this.arrowToken;
            case 3: return this.refKeyword;
            case 4: return this.body;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ParenthesizedLambdaExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParenthesizedLambdaExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitParenthesizedLambdaExpression(this);
    }

    public ParenthesizedLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, SyntaxToken refKeyword, CSharpSyntaxNode body)
    {
        if (asyncKeyword != this.AsyncKeyword || parameterList != this.ParameterList || arrowToken != this.ArrowToken || refKeyword != this.RefKeyword || body != this.Body)
        {
            var newNode = SyntaxFactory.ParenthesizedLambdaExpression(asyncKeyword, parameterList, arrowToken, refKeyword, body);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ParenthesizedLambdaExpressionSyntax(this.Kind, this.asyncKeyword, this.parameterList, this.arrowToken, this.refKeyword, this.body, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ParenthesizedLambdaExpressionSyntax(this.Kind, this.asyncKeyword, this.parameterList, this.arrowToken, this.refKeyword, this.body, GetDiagnostics(), annotations);
    }

    internal ParenthesizedLambdaExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var asyncKeyword = (SyntaxToken)reader.ReadValue();
      if (asyncKeyword != null)
      {
         AdjustFlagsAndWidth(asyncKeyword);
         this.asyncKeyword = asyncKeyword;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var arrowToken = (SyntaxToken)reader.ReadValue();
      if (arrowToken != null)
      {
         AdjustFlagsAndWidth(arrowToken);
         this.arrowToken = arrowToken;
      }
      var refKeyword = (SyntaxToken)reader.ReadValue();
      if (refKeyword != null)
      {
         AdjustFlagsAndWidth(refKeyword);
         this.refKeyword = refKeyword;
      }
      var body = (CSharpSyntaxNode)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.asyncKeyword);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.arrowToken);
      writer.WriteValue(this.refKeyword);
      writer.WriteValue(this.body);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ParenthesizedLambdaExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for initializer expression.</summary>
  internal sealed partial class InitializerExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken openBraceToken;
    internal readonly CSharpSyntaxNode expressions;
    internal readonly SyntaxToken closeBraceToken;

    internal InitializerExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, CSharpSyntaxNode expressions, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (expressions != null)
        {
            this.AdjustFlagsAndWidth(expressions);
            this.expressions = expressions;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal InitializerExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, CSharpSyntaxNode expressions, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (expressions != null)
        {
            this.AdjustFlagsAndWidth(expressions);
            this.expressions = expressions;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal InitializerExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, CSharpSyntaxNode expressions, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (expressions != null)
        {
            this.AdjustFlagsAndWidth(expressions);
            this.expressions = expressions;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }

    /// <summary>SyntaxToken representing the open brace.</summary>
    public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    /// <summary>SeparatedSyntaxList of ExpressionSyntax representing the list of expressions in the initializer expression.</summary>
    public SeparatedSyntaxList<ExpressionSyntax> Expressions { get { return new SeparatedSyntaxList<ExpressionSyntax>(new SyntaxList<CSharpSyntaxNode>(this.expressions)); } }
    /// <summary>SyntaxToken representing the close brace.</summary>
    public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBraceToken;
            case 1: return this.expressions;
            case 2: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.InitializerExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInitializerExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInitializerExpression(this);
    }

    public InitializerExpressionSyntax Update(SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || expressions != this.Expressions || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.InitializerExpression(this.Kind, openBraceToken, expressions, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new InitializerExpressionSyntax(this.Kind, this.openBraceToken, this.expressions, this.closeBraceToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new InitializerExpressionSyntax(this.Kind, this.openBraceToken, this.expressions, this.closeBraceToken, GetDiagnostics(), annotations);
    }

    internal InitializerExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var expressions = (CSharpSyntaxNode)reader.ReadValue();
      if (expressions != null)
      {
         AdjustFlagsAndWidth(expressions);
         this.expressions = expressions;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.expressions);
      writer.WriteValue(this.closeBraceToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new InitializerExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for object creation expression.</summary>
  internal sealed partial class ObjectCreationExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken newKeyword;
    internal readonly TypeSyntax type;
    internal readonly ArgumentListSyntax argumentList;
    internal readonly InitializerExpressionSyntax initializer;

    internal ObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }


    internal ObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }


    internal ObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword { get { return this.newKeyword; } }
    /// <summary>TypeSyntax representing the type of the object being created.</summary>
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
    public ArgumentListSyntax ArgumentList { get { return this.argumentList; } }
    /// <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
    public InitializerExpressionSyntax Initializer { get { return this.initializer; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.newKeyword;
            case 1: return this.type;
            case 2: return this.argumentList;
            case 3: return this.initializer;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ObjectCreationExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitObjectCreationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitObjectCreationExpression(this);
    }

    public ObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
    {
        if (newKeyword != this.NewKeyword || type != this.Type || argumentList != this.ArgumentList || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.ObjectCreationExpression(newKeyword, type, argumentList, initializer);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.argumentList, this.initializer, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.argumentList, this.initializer, GetDiagnostics(), annotations);
    }

    internal ObjectCreationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var newKeyword = (SyntaxToken)reader.ReadValue();
      if (newKeyword != null)
      {
         AdjustFlagsAndWidth(newKeyword);
         this.newKeyword = newKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var argumentList = (ArgumentListSyntax)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
      var initializer = (InitializerExpressionSyntax)reader.ReadValue();
      if (initializer != null)
      {
         AdjustFlagsAndWidth(initializer);
         this.initializer = initializer;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.newKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.argumentList);
      writer.WriteValue(this.initializer);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ObjectCreationExpressionSyntax(r);
    }
  }

  internal sealed partial class AnonymousObjectMemberDeclaratorSyntax : CSharpSyntaxNode
  {
    internal readonly NameEqualsSyntax nameEquals;
    internal readonly ExpressionSyntax expression;

    internal AnonymousObjectMemberDeclaratorSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        if (nameEquals != null)
        {
            this.AdjustFlagsAndWidth(nameEquals);
            this.nameEquals = nameEquals;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal AnonymousObjectMemberDeclaratorSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        if (nameEquals != null)
        {
            this.AdjustFlagsAndWidth(nameEquals);
            this.nameEquals = nameEquals;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal AnonymousObjectMemberDeclaratorSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 2;
        if (nameEquals != null)
        {
            this.AdjustFlagsAndWidth(nameEquals);
            this.nameEquals = nameEquals;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    /// <summary>NameEqualsSyntax representing the optional name of the member being initialized.</summary>
    public NameEqualsSyntax NameEquals { get { return this.nameEquals; } }
    /// <summary>ExpressionSyntax representing the value the member is initialized with.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nameEquals;
            case 1: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAnonymousObjectMemberDeclarator(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAnonymousObjectMemberDeclarator(this);
    }

    public AnonymousObjectMemberDeclaratorSyntax Update(NameEqualsSyntax nameEquals, ExpressionSyntax expression)
    {
        if (nameEquals != this.NameEquals || expression != this.Expression)
        {
            var newNode = SyntaxFactory.AnonymousObjectMemberDeclarator(nameEquals, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AnonymousObjectMemberDeclaratorSyntax(this.Kind, this.nameEquals, this.expression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AnonymousObjectMemberDeclaratorSyntax(this.Kind, this.nameEquals, this.expression, GetDiagnostics(), annotations);
    }

    internal AnonymousObjectMemberDeclaratorSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var nameEquals = (NameEqualsSyntax)reader.ReadValue();
      if (nameEquals != null)
      {
         AdjustFlagsAndWidth(nameEquals);
         this.nameEquals = nameEquals;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.nameEquals);
      writer.WriteValue(this.expression);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new AnonymousObjectMemberDeclaratorSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for anonymous object creation expression.</summary>
  internal sealed partial class AnonymousObjectCreationExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken newKeyword;
    internal readonly SyntaxToken openBraceToken;
    internal readonly CSharpSyntaxNode initializers;
    internal readonly SyntaxToken closeBraceToken;

    internal AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBraceToken, CSharpSyntaxNode initializers, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (initializers != null)
        {
            this.AdjustFlagsAndWidth(initializers);
            this.initializers = initializers;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBraceToken, CSharpSyntaxNode initializers, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (initializers != null)
        {
            this.AdjustFlagsAndWidth(initializers);
            this.initializers = initializers;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBraceToken, CSharpSyntaxNode initializers, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (initializers != null)
        {
            this.AdjustFlagsAndWidth(initializers);
            this.initializers = initializers;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword { get { return this.newKeyword; } }
    /// <summary>SyntaxToken representing the open brace.</summary>
    public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    /// <summary>SeparatedSyntaxList of AnonymousObjectMemberDeclaratorSyntax representing the list of object member initializers.</summary>
    public SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> Initializers { get { return new SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax>(new SyntaxList<CSharpSyntaxNode>(this.initializers)); } }
    /// <summary>SyntaxToken representing the close brace.</summary>
    public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.newKeyword;
            case 1: return this.openBraceToken;
            case 2: return this.initializers;
            case 3: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AnonymousObjectCreationExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAnonymousObjectCreationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAnonymousObjectCreationExpression(this);
    }

    public AnonymousObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)
    {
        if (newKeyword != this.NewKeyword || openBraceToken != this.OpenBraceToken || initializers != this.Initializers || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.AnonymousObjectCreationExpression(newKeyword, openBraceToken, initializers, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AnonymousObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBraceToken, this.initializers, this.closeBraceToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AnonymousObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBraceToken, this.initializers, this.closeBraceToken, GetDiagnostics(), annotations);
    }

    internal AnonymousObjectCreationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var newKeyword = (SyntaxToken)reader.ReadValue();
      if (newKeyword != null)
      {
         AdjustFlagsAndWidth(newKeyword);
         this.newKeyword = newKeyword;
      }
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var initializers = (CSharpSyntaxNode)reader.ReadValue();
      if (initializers != null)
      {
         AdjustFlagsAndWidth(initializers);
         this.initializers = initializers;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.newKeyword);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.initializers);
      writer.WriteValue(this.closeBraceToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new AnonymousObjectCreationExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for array creation expression.</summary>
  internal sealed partial class ArrayCreationExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken newKeyword;
    internal readonly ArrayTypeSyntax type;
    internal readonly InitializerExpressionSyntax initializer;

    internal ArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }


    internal ArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }


    internal ArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword { get { return this.newKeyword; } }
    /// <summary>ArrayTypeSyntax node representing the type of the array.</summary>
    public ArrayTypeSyntax Type { get { return this.type; } }
    /// <summary>InitializerExpressionSyntax node representing the initializer of the array creation expression.</summary>
    public InitializerExpressionSyntax Initializer { get { return this.initializer; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.newKeyword;
            case 1: return this.type;
            case 2: return this.initializer;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ArrayCreationExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArrayCreationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArrayCreationExpression(this);
    }

    public ArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
    {
        if (newKeyword != this.NewKeyword || type != this.Type || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.ArrayCreationExpression(newKeyword, type, initializer);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.initializer, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.initializer, GetDiagnostics(), annotations);
    }

    internal ArrayCreationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var newKeyword = (SyntaxToken)reader.ReadValue();
      if (newKeyword != null)
      {
         AdjustFlagsAndWidth(newKeyword);
         this.newKeyword = newKeyword;
      }
      var type = (ArrayTypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var initializer = (InitializerExpressionSyntax)reader.ReadValue();
      if (initializer != null)
      {
         AdjustFlagsAndWidth(initializer);
         this.initializer = initializer;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.newKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.initializer);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ArrayCreationExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for implicit array creation expression.</summary>
  internal sealed partial class ImplicitArrayCreationExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken newKeyword;
    internal readonly SyntaxToken openBracketToken;
    internal readonly CSharpSyntaxNode commas;
    internal readonly SyntaxToken closeBracketToken;
    internal readonly InitializerExpressionSyntax initializer;

    internal ImplicitArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBracketToken, CSharpSyntaxNode commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (commas != null)
        {
            this.AdjustFlagsAndWidth(commas);
            this.commas = commas;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
        this.AdjustFlagsAndWidth(initializer);
        this.initializer = initializer;
    }


    internal ImplicitArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBracketToken, CSharpSyntaxNode commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (commas != null)
        {
            this.AdjustFlagsAndWidth(commas);
            this.commas = commas;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
        this.AdjustFlagsAndWidth(initializer);
        this.initializer = initializer;
    }


    internal ImplicitArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBracketToken, CSharpSyntaxNode commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (commas != null)
        {
            this.AdjustFlagsAndWidth(commas);
            this.commas = commas;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
        this.AdjustFlagsAndWidth(initializer);
        this.initializer = initializer;
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword { get { return this.newKeyword; } }
    /// <summary>SyntaxToken representing the open bracket.</summary>
    public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
    /// <summary>SyntaxList of SyntaxToken representing the commas in the implicit array creation expression.</summary>
    public SyntaxList<SyntaxToken> Commas { get { return new SyntaxList<SyntaxToken>(this.commas); } }
    /// <summary>SyntaxToken representing the close bracket.</summary>
    public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }
    /// <summary>InitializerExpressionSyntax representing the initializer expression of the implicit array creation expression.</summary>
    public InitializerExpressionSyntax Initializer { get { return this.initializer; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.newKeyword;
            case 1: return this.openBracketToken;
            case 2: return this.commas;
            case 3: return this.closeBracketToken;
            case 4: return this.initializer;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ImplicitArrayCreationExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitImplicitArrayCreationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitImplicitArrayCreationExpression(this);
    }

    public ImplicitArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxList<SyntaxToken> commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
    {
        if (newKeyword != this.NewKeyword || openBracketToken != this.OpenBracketToken || commas != this.Commas || closeBracketToken != this.CloseBracketToken || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.ImplicitArrayCreationExpression(newKeyword, openBracketToken, commas, closeBracketToken, initializer);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ImplicitArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBracketToken, this.commas, this.closeBracketToken, this.initializer, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ImplicitArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBracketToken, this.commas, this.closeBracketToken, this.initializer, GetDiagnostics(), annotations);
    }

    internal ImplicitArrayCreationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var newKeyword = (SyntaxToken)reader.ReadValue();
      if (newKeyword != null)
      {
         AdjustFlagsAndWidth(newKeyword);
         this.newKeyword = newKeyword;
      }
      var openBracketToken = (SyntaxToken)reader.ReadValue();
      if (openBracketToken != null)
      {
         AdjustFlagsAndWidth(openBracketToken);
         this.openBracketToken = openBracketToken;
      }
      var commas = (CSharpSyntaxNode)reader.ReadValue();
      if (commas != null)
      {
         AdjustFlagsAndWidth(commas);
         this.commas = commas;
      }
      var closeBracketToken = (SyntaxToken)reader.ReadValue();
      if (closeBracketToken != null)
      {
         AdjustFlagsAndWidth(closeBracketToken);
         this.closeBracketToken = closeBracketToken;
      }
      var initializer = (InitializerExpressionSyntax)reader.ReadValue();
      if (initializer != null)
      {
         AdjustFlagsAndWidth(initializer);
         this.initializer = initializer;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.newKeyword);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.commas);
      writer.WriteValue(this.closeBracketToken);
      writer.WriteValue(this.initializer);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ImplicitArrayCreationExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents the syntax node for stackalloc array creation expression.</summary>
  internal sealed partial class StackAllocArrayCreationExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken stackAllocKeyword;
    internal readonly TypeSyntax type;

    internal StackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(stackAllocKeyword);
        this.stackAllocKeyword = stackAllocKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal StackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, TypeSyntax type, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(stackAllocKeyword);
        this.stackAllocKeyword = stackAllocKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal StackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, TypeSyntax type)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(stackAllocKeyword);
        this.stackAllocKeyword = stackAllocKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }

    /// <summary>SyntaxToken representing the stackalloc keyword.</summary>
    public SyntaxToken StackAllocKeyword { get { return this.stackAllocKeyword; } }
    /// <summary>TypeSyntax node representing the type of the stackalloc array.</summary>
    public TypeSyntax Type { get { return this.type; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.stackAllocKeyword;
            case 1: return this.type;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.StackAllocArrayCreationExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitStackAllocArrayCreationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitStackAllocArrayCreationExpression(this);
    }

    public StackAllocArrayCreationExpressionSyntax Update(SyntaxToken stackAllocKeyword, TypeSyntax type)
    {
        if (stackAllocKeyword != this.StackAllocKeyword || type != this.Type)
        {
            var newNode = SyntaxFactory.StackAllocArrayCreationExpression(stackAllocKeyword, type);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new StackAllocArrayCreationExpressionSyntax(this.Kind, this.stackAllocKeyword, this.type, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new StackAllocArrayCreationExpressionSyntax(this.Kind, this.stackAllocKeyword, this.type, GetDiagnostics(), annotations);
    }

    internal StackAllocArrayCreationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var stackAllocKeyword = (SyntaxToken)reader.ReadValue();
      if (stackAllocKeyword != null)
      {
         AdjustFlagsAndWidth(stackAllocKeyword);
         this.stackAllocKeyword = stackAllocKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.stackAllocKeyword);
      writer.WriteValue(this.type);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new StackAllocArrayCreationExpressionSyntax(r);
    }
  }

  internal abstract partial class QueryClauseSyntax : CSharpSyntaxNode
  {
    internal QueryClauseSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal QueryClauseSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected QueryClauseSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal abstract partial class SelectOrGroupClauseSyntax : CSharpSyntaxNode
  {
    internal SelectOrGroupClauseSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal SelectOrGroupClauseSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected SelectOrGroupClauseSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal sealed partial class QueryExpressionSyntax : ExpressionSyntax
  {
    internal readonly FromClauseSyntax fromClause;
    internal readonly QueryBodySyntax body;

    internal QueryExpressionSyntax(SyntaxKind kind, FromClauseSyntax fromClause, QueryBodySyntax body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(fromClause);
        this.fromClause = fromClause;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal QueryExpressionSyntax(SyntaxKind kind, FromClauseSyntax fromClause, QueryBodySyntax body, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(fromClause);
        this.fromClause = fromClause;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal QueryExpressionSyntax(SyntaxKind kind, FromClauseSyntax fromClause, QueryBodySyntax body)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(fromClause);
        this.fromClause = fromClause;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }

    public FromClauseSyntax FromClause { get { return this.fromClause; } }
    public QueryBodySyntax Body { get { return this.body; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.fromClause;
            case 1: return this.body;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.QueryExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQueryExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitQueryExpression(this);
    }

    public QueryExpressionSyntax Update(FromClauseSyntax fromClause, QueryBodySyntax body)
    {
        if (fromClause != this.FromClause || body != this.Body)
        {
            var newNode = SyntaxFactory.QueryExpression(fromClause, body);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new QueryExpressionSyntax(this.Kind, this.fromClause, this.body, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new QueryExpressionSyntax(this.Kind, this.fromClause, this.body, GetDiagnostics(), annotations);
    }

    internal QueryExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var fromClause = (FromClauseSyntax)reader.ReadValue();
      if (fromClause != null)
      {
         AdjustFlagsAndWidth(fromClause);
         this.fromClause = fromClause;
      }
      var body = (QueryBodySyntax)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.fromClause);
      writer.WriteValue(this.body);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new QueryExpressionSyntax(r);
    }
  }

  internal sealed partial class QueryBodySyntax : CSharpSyntaxNode
  {
    internal readonly CSharpSyntaxNode clauses;
    internal readonly SelectOrGroupClauseSyntax selectOrGroup;
    internal readonly QueryContinuationSyntax continuation;

    internal QueryBodySyntax(SyntaxKind kind, CSharpSyntaxNode clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        if (clauses != null)
        {
            this.AdjustFlagsAndWidth(clauses);
            this.clauses = clauses;
        }
        this.AdjustFlagsAndWidth(selectOrGroup);
        this.selectOrGroup = selectOrGroup;
        if (continuation != null)
        {
            this.AdjustFlagsAndWidth(continuation);
            this.continuation = continuation;
        }
    }


    internal QueryBodySyntax(SyntaxKind kind, CSharpSyntaxNode clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        if (clauses != null)
        {
            this.AdjustFlagsAndWidth(clauses);
            this.clauses = clauses;
        }
        this.AdjustFlagsAndWidth(selectOrGroup);
        this.selectOrGroup = selectOrGroup;
        if (continuation != null)
        {
            this.AdjustFlagsAndWidth(continuation);
            this.continuation = continuation;
        }
    }


    internal QueryBodySyntax(SyntaxKind kind, CSharpSyntaxNode clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
        : base(kind)
    {
        this.SlotCount = 3;
        if (clauses != null)
        {
            this.AdjustFlagsAndWidth(clauses);
            this.clauses = clauses;
        }
        this.AdjustFlagsAndWidth(selectOrGroup);
        this.selectOrGroup = selectOrGroup;
        if (continuation != null)
        {
            this.AdjustFlagsAndWidth(continuation);
            this.continuation = continuation;
        }
    }

    public SyntaxList<QueryClauseSyntax> Clauses { get { return new SyntaxList<QueryClauseSyntax>(this.clauses); } }
    public SelectOrGroupClauseSyntax SelectOrGroup { get { return this.selectOrGroup; } }
    public QueryContinuationSyntax Continuation { get { return this.continuation; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.clauses;
            case 1: return this.selectOrGroup;
            case 2: return this.continuation;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.QueryBodySyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQueryBody(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitQueryBody(this);
    }

    public QueryBodySyntax Update(SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
    {
        if (clauses != this.Clauses || selectOrGroup != this.SelectOrGroup || continuation != this.Continuation)
        {
            var newNode = SyntaxFactory.QueryBody(clauses, selectOrGroup, continuation);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new QueryBodySyntax(this.Kind, this.clauses, this.selectOrGroup, this.continuation, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new QueryBodySyntax(this.Kind, this.clauses, this.selectOrGroup, this.continuation, GetDiagnostics(), annotations);
    }

    internal QueryBodySyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var clauses = (CSharpSyntaxNode)reader.ReadValue();
      if (clauses != null)
      {
         AdjustFlagsAndWidth(clauses);
         this.clauses = clauses;
      }
      var selectOrGroup = (SelectOrGroupClauseSyntax)reader.ReadValue();
      if (selectOrGroup != null)
      {
         AdjustFlagsAndWidth(selectOrGroup);
         this.selectOrGroup = selectOrGroup;
      }
      var continuation = (QueryContinuationSyntax)reader.ReadValue();
      if (continuation != null)
      {
         AdjustFlagsAndWidth(continuation);
         this.continuation = continuation;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.clauses);
      writer.WriteValue(this.selectOrGroup);
      writer.WriteValue(this.continuation);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new QueryBodySyntax(r);
    }
  }

  internal sealed partial class FromClauseSyntax : QueryClauseSyntax
  {
    internal readonly SyntaxToken fromKeyword;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken inKeyword;
    internal readonly ExpressionSyntax expression;

    internal FromClauseSyntax(SyntaxKind kind, SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(fromKeyword);
        this.fromKeyword = fromKeyword;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal FromClauseSyntax(SyntaxKind kind, SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(fromKeyword);
        this.fromKeyword = fromKeyword;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal FromClauseSyntax(SyntaxKind kind, SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(fromKeyword);
        this.fromKeyword = fromKeyword;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    public SyntaxToken FromKeyword { get { return this.fromKeyword; } }
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public SyntaxToken InKeyword { get { return this.inKeyword; } }
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.fromKeyword;
            case 1: return this.type;
            case 2: return this.identifier;
            case 3: return this.inKeyword;
            case 4: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.FromClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFromClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitFromClause(this);
    }

    public FromClauseSyntax Update(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
    {
        if (fromKeyword != this.FromKeyword || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.FromClause(fromKeyword, type, identifier, inKeyword, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new FromClauseSyntax(this.Kind, this.fromKeyword, this.type, this.identifier, this.inKeyword, this.expression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new FromClauseSyntax(this.Kind, this.fromKeyword, this.type, this.identifier, this.inKeyword, this.expression, GetDiagnostics(), annotations);
    }

    internal FromClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var fromKeyword = (SyntaxToken)reader.ReadValue();
      if (fromKeyword != null)
      {
         AdjustFlagsAndWidth(fromKeyword);
         this.fromKeyword = fromKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var inKeyword = (SyntaxToken)reader.ReadValue();
      if (inKeyword != null)
      {
         AdjustFlagsAndWidth(inKeyword);
         this.inKeyword = inKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.fromKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.inKeyword);
      writer.WriteValue(this.expression);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new FromClauseSyntax(r);
    }
  }

  internal sealed partial class LetClauseSyntax : QueryClauseSyntax
  {
    internal readonly SyntaxToken letKeyword;
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken equalsToken;
    internal readonly ExpressionSyntax expression;

    internal LetClauseSyntax(SyntaxKind kind, SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(letKeyword);
        this.letKeyword = letKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal LetClauseSyntax(SyntaxKind kind, SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(letKeyword);
        this.letKeyword = letKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal LetClauseSyntax(SyntaxKind kind, SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(letKeyword);
        this.letKeyword = letKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    public SyntaxToken LetKeyword { get { return this.letKeyword; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public SyntaxToken EqualsToken { get { return this.equalsToken; } }
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.letKeyword;
            case 1: return this.identifier;
            case 2: return this.equalsToken;
            case 3: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.LetClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLetClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLetClause(this);
    }

    public LetClauseSyntax Update(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
    {
        if (letKeyword != this.LetKeyword || identifier != this.Identifier || equalsToken != this.EqualsToken || expression != this.Expression)
        {
            var newNode = SyntaxFactory.LetClause(letKeyword, identifier, equalsToken, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new LetClauseSyntax(this.Kind, this.letKeyword, this.identifier, this.equalsToken, this.expression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new LetClauseSyntax(this.Kind, this.letKeyword, this.identifier, this.equalsToken, this.expression, GetDiagnostics(), annotations);
    }

    internal LetClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var letKeyword = (SyntaxToken)reader.ReadValue();
      if (letKeyword != null)
      {
         AdjustFlagsAndWidth(letKeyword);
         this.letKeyword = letKeyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var equalsToken = (SyntaxToken)reader.ReadValue();
      if (equalsToken != null)
      {
         AdjustFlagsAndWidth(equalsToken);
         this.equalsToken = equalsToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.letKeyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.equalsToken);
      writer.WriteValue(this.expression);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new LetClauseSyntax(r);
    }
  }

  internal sealed partial class JoinClauseSyntax : QueryClauseSyntax
  {
    internal readonly SyntaxToken joinKeyword;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken inKeyword;
    internal readonly ExpressionSyntax inExpression;
    internal readonly SyntaxToken onKeyword;
    internal readonly ExpressionSyntax leftExpression;
    internal readonly SyntaxToken equalsKeyword;
    internal readonly ExpressionSyntax rightExpression;
    internal readonly JoinIntoClauseSyntax into;

    internal JoinClauseSyntax(SyntaxKind kind, SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 10;
        this.AdjustFlagsAndWidth(joinKeyword);
        this.joinKeyword = joinKeyword;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(inExpression);
        this.inExpression = inExpression;
        this.AdjustFlagsAndWidth(onKeyword);
        this.onKeyword = onKeyword;
        this.AdjustFlagsAndWidth(leftExpression);
        this.leftExpression = leftExpression;
        this.AdjustFlagsAndWidth(equalsKeyword);
        this.equalsKeyword = equalsKeyword;
        this.AdjustFlagsAndWidth(rightExpression);
        this.rightExpression = rightExpression;
        if (into != null)
        {
            this.AdjustFlagsAndWidth(into);
            this.into = into;
        }
    }


    internal JoinClauseSyntax(SyntaxKind kind, SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 10;
        this.AdjustFlagsAndWidth(joinKeyword);
        this.joinKeyword = joinKeyword;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(inExpression);
        this.inExpression = inExpression;
        this.AdjustFlagsAndWidth(onKeyword);
        this.onKeyword = onKeyword;
        this.AdjustFlagsAndWidth(leftExpression);
        this.leftExpression = leftExpression;
        this.AdjustFlagsAndWidth(equalsKeyword);
        this.equalsKeyword = equalsKeyword;
        this.AdjustFlagsAndWidth(rightExpression);
        this.rightExpression = rightExpression;
        if (into != null)
        {
            this.AdjustFlagsAndWidth(into);
            this.into = into;
        }
    }


    internal JoinClauseSyntax(SyntaxKind kind, SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
        : base(kind)
    {
        this.SlotCount = 10;
        this.AdjustFlagsAndWidth(joinKeyword);
        this.joinKeyword = joinKeyword;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(inExpression);
        this.inExpression = inExpression;
        this.AdjustFlagsAndWidth(onKeyword);
        this.onKeyword = onKeyword;
        this.AdjustFlagsAndWidth(leftExpression);
        this.leftExpression = leftExpression;
        this.AdjustFlagsAndWidth(equalsKeyword);
        this.equalsKeyword = equalsKeyword;
        this.AdjustFlagsAndWidth(rightExpression);
        this.rightExpression = rightExpression;
        if (into != null)
        {
            this.AdjustFlagsAndWidth(into);
            this.into = into;
        }
    }

    public SyntaxToken JoinKeyword { get { return this.joinKeyword; } }
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public SyntaxToken InKeyword { get { return this.inKeyword; } }
    public ExpressionSyntax InExpression { get { return this.inExpression; } }
    public SyntaxToken OnKeyword { get { return this.onKeyword; } }
    public ExpressionSyntax LeftExpression { get { return this.leftExpression; } }
    public SyntaxToken EqualsKeyword { get { return this.equalsKeyword; } }
    public ExpressionSyntax RightExpression { get { return this.rightExpression; } }
    public JoinIntoClauseSyntax Into { get { return this.into; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.joinKeyword;
            case 1: return this.type;
            case 2: return this.identifier;
            case 3: return this.inKeyword;
            case 4: return this.inExpression;
            case 5: return this.onKeyword;
            case 6: return this.leftExpression;
            case 7: return this.equalsKeyword;
            case 8: return this.rightExpression;
            case 9: return this.into;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.JoinClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitJoinClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitJoinClause(this);
    }

    public JoinClauseSyntax Update(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
    {
        if (joinKeyword != this.JoinKeyword || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || inExpression != this.InExpression || onKeyword != this.OnKeyword || leftExpression != this.LeftExpression || equalsKeyword != this.EqualsKeyword || rightExpression != this.RightExpression || into != this.Into)
        {
            var newNode = SyntaxFactory.JoinClause(joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new JoinClauseSyntax(this.Kind, this.joinKeyword, this.type, this.identifier, this.inKeyword, this.inExpression, this.onKeyword, this.leftExpression, this.equalsKeyword, this.rightExpression, this.into, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new JoinClauseSyntax(this.Kind, this.joinKeyword, this.type, this.identifier, this.inKeyword, this.inExpression, this.onKeyword, this.leftExpression, this.equalsKeyword, this.rightExpression, this.into, GetDiagnostics(), annotations);
    }

    internal JoinClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 10;
      var joinKeyword = (SyntaxToken)reader.ReadValue();
      if (joinKeyword != null)
      {
         AdjustFlagsAndWidth(joinKeyword);
         this.joinKeyword = joinKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var inKeyword = (SyntaxToken)reader.ReadValue();
      if (inKeyword != null)
      {
         AdjustFlagsAndWidth(inKeyword);
         this.inKeyword = inKeyword;
      }
      var inExpression = (ExpressionSyntax)reader.ReadValue();
      if (inExpression != null)
      {
         AdjustFlagsAndWidth(inExpression);
         this.inExpression = inExpression;
      }
      var onKeyword = (SyntaxToken)reader.ReadValue();
      if (onKeyword != null)
      {
         AdjustFlagsAndWidth(onKeyword);
         this.onKeyword = onKeyword;
      }
      var leftExpression = (ExpressionSyntax)reader.ReadValue();
      if (leftExpression != null)
      {
         AdjustFlagsAndWidth(leftExpression);
         this.leftExpression = leftExpression;
      }
      var equalsKeyword = (SyntaxToken)reader.ReadValue();
      if (equalsKeyword != null)
      {
         AdjustFlagsAndWidth(equalsKeyword);
         this.equalsKeyword = equalsKeyword;
      }
      var rightExpression = (ExpressionSyntax)reader.ReadValue();
      if (rightExpression != null)
      {
         AdjustFlagsAndWidth(rightExpression);
         this.rightExpression = rightExpression;
      }
      var into = (JoinIntoClauseSyntax)reader.ReadValue();
      if (into != null)
      {
         AdjustFlagsAndWidth(into);
         this.into = into;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.joinKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.inKeyword);
      writer.WriteValue(this.inExpression);
      writer.WriteValue(this.onKeyword);
      writer.WriteValue(this.leftExpression);
      writer.WriteValue(this.equalsKeyword);
      writer.WriteValue(this.rightExpression);
      writer.WriteValue(this.into);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new JoinClauseSyntax(r);
    }
  }

  internal sealed partial class JoinIntoClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken intoKeyword;
    internal readonly SyntaxToken identifier;

    internal JoinIntoClauseSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(intoKeyword);
        this.intoKeyword = intoKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal JoinIntoClauseSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(intoKeyword);
        this.intoKeyword = intoKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal JoinIntoClauseSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(intoKeyword);
        this.intoKeyword = intoKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }

    public SyntaxToken IntoKeyword { get { return this.intoKeyword; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.intoKeyword;
            case 1: return this.identifier;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.JoinIntoClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitJoinIntoClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitJoinIntoClause(this);
    }

    public JoinIntoClauseSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier)
    {
        if (intoKeyword != this.IntoKeyword || identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.JoinIntoClause(intoKeyword, identifier);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new JoinIntoClauseSyntax(this.Kind, this.intoKeyword, this.identifier, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new JoinIntoClauseSyntax(this.Kind, this.intoKeyword, this.identifier, GetDiagnostics(), annotations);
    }

    internal JoinIntoClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var intoKeyword = (SyntaxToken)reader.ReadValue();
      if (intoKeyword != null)
      {
         AdjustFlagsAndWidth(intoKeyword);
         this.intoKeyword = intoKeyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.intoKeyword);
      writer.WriteValue(this.identifier);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new JoinIntoClauseSyntax(r);
    }
  }

  internal sealed partial class WhereClauseSyntax : QueryClauseSyntax
  {
    internal readonly SyntaxToken whereKeyword;
    internal readonly ExpressionSyntax condition;

    internal WhereClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, ExpressionSyntax condition, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(whereKeyword);
        this.whereKeyword = whereKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
    }


    internal WhereClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, ExpressionSyntax condition, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(whereKeyword);
        this.whereKeyword = whereKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
    }


    internal WhereClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, ExpressionSyntax condition)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(whereKeyword);
        this.whereKeyword = whereKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
    }

    public SyntaxToken WhereKeyword { get { return this.whereKeyword; } }
    public ExpressionSyntax Condition { get { return this.condition; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.whereKeyword;
            case 1: return this.condition;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.WhereClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitWhereClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitWhereClause(this);
    }

    public WhereClauseSyntax Update(SyntaxToken whereKeyword, ExpressionSyntax condition)
    {
        if (whereKeyword != this.WhereKeyword || condition != this.Condition)
        {
            var newNode = SyntaxFactory.WhereClause(whereKeyword, condition);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new WhereClauseSyntax(this.Kind, this.whereKeyword, this.condition, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new WhereClauseSyntax(this.Kind, this.whereKeyword, this.condition, GetDiagnostics(), annotations);
    }

    internal WhereClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var whereKeyword = (SyntaxToken)reader.ReadValue();
      if (whereKeyword != null)
      {
         AdjustFlagsAndWidth(whereKeyword);
         this.whereKeyword = whereKeyword;
      }
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.whereKeyword);
      writer.WriteValue(this.condition);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new WhereClauseSyntax(r);
    }
  }

  internal sealed partial class OrderByClauseSyntax : QueryClauseSyntax
  {
    internal readonly SyntaxToken orderByKeyword;
    internal readonly CSharpSyntaxNode orderings;

    internal OrderByClauseSyntax(SyntaxKind kind, SyntaxToken orderByKeyword, CSharpSyntaxNode orderings, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(orderByKeyword);
        this.orderByKeyword = orderByKeyword;
        if (orderings != null)
        {
            this.AdjustFlagsAndWidth(orderings);
            this.orderings = orderings;
        }
    }


    internal OrderByClauseSyntax(SyntaxKind kind, SyntaxToken orderByKeyword, CSharpSyntaxNode orderings, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(orderByKeyword);
        this.orderByKeyword = orderByKeyword;
        if (orderings != null)
        {
            this.AdjustFlagsAndWidth(orderings);
            this.orderings = orderings;
        }
    }


    internal OrderByClauseSyntax(SyntaxKind kind, SyntaxToken orderByKeyword, CSharpSyntaxNode orderings)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(orderByKeyword);
        this.orderByKeyword = orderByKeyword;
        if (orderings != null)
        {
            this.AdjustFlagsAndWidth(orderings);
            this.orderings = orderings;
        }
    }

    public SyntaxToken OrderByKeyword { get { return this.orderByKeyword; } }
    public SeparatedSyntaxList<OrderingSyntax> Orderings { get { return new SeparatedSyntaxList<OrderingSyntax>(new SyntaxList<CSharpSyntaxNode>(this.orderings)); } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.orderByKeyword;
            case 1: return this.orderings;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.OrderByClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOrderByClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOrderByClause(this);
    }

    public OrderByClauseSyntax Update(SyntaxToken orderByKeyword, SeparatedSyntaxList<OrderingSyntax> orderings)
    {
        if (orderByKeyword != this.OrderByKeyword || orderings != this.Orderings)
        {
            var newNode = SyntaxFactory.OrderByClause(orderByKeyword, orderings);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new OrderByClauseSyntax(this.Kind, this.orderByKeyword, this.orderings, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new OrderByClauseSyntax(this.Kind, this.orderByKeyword, this.orderings, GetDiagnostics(), annotations);
    }

    internal OrderByClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var orderByKeyword = (SyntaxToken)reader.ReadValue();
      if (orderByKeyword != null)
      {
         AdjustFlagsAndWidth(orderByKeyword);
         this.orderByKeyword = orderByKeyword;
      }
      var orderings = (CSharpSyntaxNode)reader.ReadValue();
      if (orderings != null)
      {
         AdjustFlagsAndWidth(orderings);
         this.orderings = orderings;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.orderByKeyword);
      writer.WriteValue(this.orderings);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new OrderByClauseSyntax(r);
    }
  }

  internal sealed partial class OrderingSyntax : CSharpSyntaxNode
  {
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken ascendingOrDescendingKeyword;

    internal OrderingSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        if (ascendingOrDescendingKeyword != null)
        {
            this.AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
            this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
        }
    }


    internal OrderingSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        if (ascendingOrDescendingKeyword != null)
        {
            this.AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
            this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
        }
    }


    internal OrderingSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        if (ascendingOrDescendingKeyword != null)
        {
            this.AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
            this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
        }
    }

    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken AscendingOrDescendingKeyword { get { return this.ascendingOrDescendingKeyword; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.ascendingOrDescendingKeyword;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.OrderingSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOrdering(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOrdering(this);
    }

    public OrderingSyntax Update(ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
    {
        if (expression != this.Expression || ascendingOrDescendingKeyword != this.AscendingOrDescendingKeyword)
        {
            var newNode = SyntaxFactory.Ordering(this.Kind, expression, ascendingOrDescendingKeyword);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new OrderingSyntax(this.Kind, this.expression, this.ascendingOrDescendingKeyword, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new OrderingSyntax(this.Kind, this.expression, this.ascendingOrDescendingKeyword, GetDiagnostics(), annotations);
    }

    internal OrderingSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var ascendingOrDescendingKeyword = (SyntaxToken)reader.ReadValue();
      if (ascendingOrDescendingKeyword != null)
      {
         AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
         this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.ascendingOrDescendingKeyword);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new OrderingSyntax(r);
    }
  }

  internal sealed partial class SelectClauseSyntax : SelectOrGroupClauseSyntax
  {
    internal readonly SyntaxToken selectKeyword;
    internal readonly ExpressionSyntax expression;

    internal SelectClauseSyntax(SyntaxKind kind, SyntaxToken selectKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(selectKeyword);
        this.selectKeyword = selectKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal SelectClauseSyntax(SyntaxKind kind, SyntaxToken selectKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(selectKeyword);
        this.selectKeyword = selectKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal SelectClauseSyntax(SyntaxKind kind, SyntaxToken selectKeyword, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(selectKeyword);
        this.selectKeyword = selectKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    public SyntaxToken SelectKeyword { get { return this.selectKeyword; } }
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.selectKeyword;
            case 1: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.SelectClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSelectClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSelectClause(this);
    }

    public SelectClauseSyntax Update(SyntaxToken selectKeyword, ExpressionSyntax expression)
    {
        if (selectKeyword != this.SelectKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.SelectClause(selectKeyword, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new SelectClauseSyntax(this.Kind, this.selectKeyword, this.expression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new SelectClauseSyntax(this.Kind, this.selectKeyword, this.expression, GetDiagnostics(), annotations);
    }

    internal SelectClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var selectKeyword = (SyntaxToken)reader.ReadValue();
      if (selectKeyword != null)
      {
         AdjustFlagsAndWidth(selectKeyword);
         this.selectKeyword = selectKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.selectKeyword);
      writer.WriteValue(this.expression);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new SelectClauseSyntax(r);
    }
  }

  internal sealed partial class GroupClauseSyntax : SelectOrGroupClauseSyntax
  {
    internal readonly SyntaxToken groupKeyword;
    internal readonly ExpressionSyntax groupExpression;
    internal readonly SyntaxToken byKeyword;
    internal readonly ExpressionSyntax byExpression;

    internal GroupClauseSyntax(SyntaxKind kind, SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(groupKeyword);
        this.groupKeyword = groupKeyword;
        this.AdjustFlagsAndWidth(groupExpression);
        this.groupExpression = groupExpression;
        this.AdjustFlagsAndWidth(byKeyword);
        this.byKeyword = byKeyword;
        this.AdjustFlagsAndWidth(byExpression);
        this.byExpression = byExpression;
    }


    internal GroupClauseSyntax(SyntaxKind kind, SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(groupKeyword);
        this.groupKeyword = groupKeyword;
        this.AdjustFlagsAndWidth(groupExpression);
        this.groupExpression = groupExpression;
        this.AdjustFlagsAndWidth(byKeyword);
        this.byKeyword = byKeyword;
        this.AdjustFlagsAndWidth(byExpression);
        this.byExpression = byExpression;
    }


    internal GroupClauseSyntax(SyntaxKind kind, SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(groupKeyword);
        this.groupKeyword = groupKeyword;
        this.AdjustFlagsAndWidth(groupExpression);
        this.groupExpression = groupExpression;
        this.AdjustFlagsAndWidth(byKeyword);
        this.byKeyword = byKeyword;
        this.AdjustFlagsAndWidth(byExpression);
        this.byExpression = byExpression;
    }

    public SyntaxToken GroupKeyword { get { return this.groupKeyword; } }
    public ExpressionSyntax GroupExpression { get { return this.groupExpression; } }
    public SyntaxToken ByKeyword { get { return this.byKeyword; } }
    public ExpressionSyntax ByExpression { get { return this.byExpression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.groupKeyword;
            case 1: return this.groupExpression;
            case 2: return this.byKeyword;
            case 3: return this.byExpression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.GroupClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGroupClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitGroupClause(this);
    }

    public GroupClauseSyntax Update(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
    {
        if (groupKeyword != this.GroupKeyword || groupExpression != this.GroupExpression || byKeyword != this.ByKeyword || byExpression != this.ByExpression)
        {
            var newNode = SyntaxFactory.GroupClause(groupKeyword, groupExpression, byKeyword, byExpression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new GroupClauseSyntax(this.Kind, this.groupKeyword, this.groupExpression, this.byKeyword, this.byExpression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new GroupClauseSyntax(this.Kind, this.groupKeyword, this.groupExpression, this.byKeyword, this.byExpression, GetDiagnostics(), annotations);
    }

    internal GroupClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var groupKeyword = (SyntaxToken)reader.ReadValue();
      if (groupKeyword != null)
      {
         AdjustFlagsAndWidth(groupKeyword);
         this.groupKeyword = groupKeyword;
      }
      var groupExpression = (ExpressionSyntax)reader.ReadValue();
      if (groupExpression != null)
      {
         AdjustFlagsAndWidth(groupExpression);
         this.groupExpression = groupExpression;
      }
      var byKeyword = (SyntaxToken)reader.ReadValue();
      if (byKeyword != null)
      {
         AdjustFlagsAndWidth(byKeyword);
         this.byKeyword = byKeyword;
      }
      var byExpression = (ExpressionSyntax)reader.ReadValue();
      if (byExpression != null)
      {
         AdjustFlagsAndWidth(byExpression);
         this.byExpression = byExpression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.groupKeyword);
      writer.WriteValue(this.groupExpression);
      writer.WriteValue(this.byKeyword);
      writer.WriteValue(this.byExpression);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new GroupClauseSyntax(r);
    }
  }

  internal sealed partial class QueryContinuationSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken intoKeyword;
    internal readonly SyntaxToken identifier;
    internal readonly QueryBodySyntax body;

    internal QueryContinuationSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(intoKeyword);
        this.intoKeyword = intoKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal QueryContinuationSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(intoKeyword);
        this.intoKeyword = intoKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal QueryContinuationSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(intoKeyword);
        this.intoKeyword = intoKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }

    public SyntaxToken IntoKeyword { get { return this.intoKeyword; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public QueryBodySyntax Body { get { return this.body; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.intoKeyword;
            case 1: return this.identifier;
            case 2: return this.body;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.QueryContinuationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQueryContinuation(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitQueryContinuation(this);
    }

    public QueryContinuationSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
    {
        if (intoKeyword != this.IntoKeyword || identifier != this.Identifier || body != this.Body)
        {
            var newNode = SyntaxFactory.QueryContinuation(intoKeyword, identifier, body);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new QueryContinuationSyntax(this.Kind, this.intoKeyword, this.identifier, this.body, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new QueryContinuationSyntax(this.Kind, this.intoKeyword, this.identifier, this.body, GetDiagnostics(), annotations);
    }

    internal QueryContinuationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var intoKeyword = (SyntaxToken)reader.ReadValue();
      if (intoKeyword != null)
      {
         AdjustFlagsAndWidth(intoKeyword);
         this.intoKeyword = intoKeyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var body = (QueryBodySyntax)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.intoKeyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.body);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new QueryContinuationSyntax(r);
    }
  }

  /// <summary>Class which represents a placeholder in an array size list.</summary>
  internal sealed partial class OmittedArraySizeExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken omittedArraySizeExpressionToken;

    internal OmittedArraySizeExpressionSyntax(SyntaxKind kind, SyntaxToken omittedArraySizeExpressionToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
        this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
    }


    internal OmittedArraySizeExpressionSyntax(SyntaxKind kind, SyntaxToken omittedArraySizeExpressionToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
        this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
    }


    internal OmittedArraySizeExpressionSyntax(SyntaxKind kind, SyntaxToken omittedArraySizeExpressionToken)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
        this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
    }

    /// <summary>SyntaxToken representing the omitted array size expression.</summary>
    public SyntaxToken OmittedArraySizeExpressionToken { get { return this.omittedArraySizeExpressionToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.omittedArraySizeExpressionToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.OmittedArraySizeExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOmittedArraySizeExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOmittedArraySizeExpression(this);
    }

    public OmittedArraySizeExpressionSyntax Update(SyntaxToken omittedArraySizeExpressionToken)
    {
        if (omittedArraySizeExpressionToken != this.OmittedArraySizeExpressionToken)
        {
            var newNode = SyntaxFactory.OmittedArraySizeExpression(omittedArraySizeExpressionToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new OmittedArraySizeExpressionSyntax(this.Kind, this.omittedArraySizeExpressionToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new OmittedArraySizeExpressionSyntax(this.Kind, this.omittedArraySizeExpressionToken, GetDiagnostics(), annotations);
    }

    internal OmittedArraySizeExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var omittedArraySizeExpressionToken = (SyntaxToken)reader.ReadValue();
      if (omittedArraySizeExpressionToken != null)
      {
         AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
         this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.omittedArraySizeExpressionToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new OmittedArraySizeExpressionSyntax(r);
    }
  }

  internal sealed partial class InterpolatedStringExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken stringStartToken;
    internal readonly CSharpSyntaxNode contents;
    internal readonly SyntaxToken stringEndToken;

    internal InterpolatedStringExpressionSyntax(SyntaxKind kind, SyntaxToken stringStartToken, CSharpSyntaxNode contents, SyntaxToken stringEndToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(stringStartToken);
        this.stringStartToken = stringStartToken;
        if (contents != null)
        {
            this.AdjustFlagsAndWidth(contents);
            this.contents = contents;
        }
        this.AdjustFlagsAndWidth(stringEndToken);
        this.stringEndToken = stringEndToken;
    }


    internal InterpolatedStringExpressionSyntax(SyntaxKind kind, SyntaxToken stringStartToken, CSharpSyntaxNode contents, SyntaxToken stringEndToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(stringStartToken);
        this.stringStartToken = stringStartToken;
        if (contents != null)
        {
            this.AdjustFlagsAndWidth(contents);
            this.contents = contents;
        }
        this.AdjustFlagsAndWidth(stringEndToken);
        this.stringEndToken = stringEndToken;
    }


    internal InterpolatedStringExpressionSyntax(SyntaxKind kind, SyntaxToken stringStartToken, CSharpSyntaxNode contents, SyntaxToken stringEndToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(stringStartToken);
        this.stringStartToken = stringStartToken;
        if (contents != null)
        {
            this.AdjustFlagsAndWidth(contents);
            this.contents = contents;
        }
        this.AdjustFlagsAndWidth(stringEndToken);
        this.stringEndToken = stringEndToken;
    }

    /// <summary>The first part of an interpolated string, $" or $@"</summary>
    public SyntaxToken StringStartToken { get { return this.stringStartToken; } }
    /// <summary>List of parts of the interpolated string, each one is either a literal part or an interpolation.</summary>
    public SyntaxList<InterpolatedStringContentSyntax> Contents { get { return new SyntaxList<InterpolatedStringContentSyntax>(this.contents); } }
    /// <summary>The closing quote of the interpolated string.</summary>
    public SyntaxToken StringEndToken { get { return this.stringEndToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.stringStartToken;
            case 1: return this.contents;
            case 2: return this.stringEndToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.InterpolatedStringExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterpolatedStringExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterpolatedStringExpression(this);
    }

    public InterpolatedStringExpressionSyntax Update(SyntaxToken stringStartToken, SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
    {
        if (stringStartToken != this.StringStartToken || contents != this.Contents || stringEndToken != this.StringEndToken)
        {
            var newNode = SyntaxFactory.InterpolatedStringExpression(stringStartToken, contents, stringEndToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new InterpolatedStringExpressionSyntax(this.Kind, this.stringStartToken, this.contents, this.stringEndToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new InterpolatedStringExpressionSyntax(this.Kind, this.stringStartToken, this.contents, this.stringEndToken, GetDiagnostics(), annotations);
    }

    internal InterpolatedStringExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var stringStartToken = (SyntaxToken)reader.ReadValue();
      if (stringStartToken != null)
      {
         AdjustFlagsAndWidth(stringStartToken);
         this.stringStartToken = stringStartToken;
      }
      var contents = (CSharpSyntaxNode)reader.ReadValue();
      if (contents != null)
      {
         AdjustFlagsAndWidth(contents);
         this.contents = contents;
      }
      var stringEndToken = (SyntaxToken)reader.ReadValue();
      if (stringEndToken != null)
      {
         AdjustFlagsAndWidth(stringEndToken);
         this.stringEndToken = stringEndToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.stringStartToken);
      writer.WriteValue(this.contents);
      writer.WriteValue(this.stringEndToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new InterpolatedStringExpressionSyntax(r);
    }
  }

  /// <summary>Class which represents a simple pattern-maching expresion using the "is" keyword.</summary>
  internal sealed partial class IsPatternExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken isKeyword;
    internal readonly PatternSyntax pattern;

    internal IsPatternExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(isKeyword);
        this.isKeyword = isKeyword;
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
    }


    internal IsPatternExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(isKeyword);
        this.isKeyword = isKeyword;
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
    }


    internal IsPatternExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(isKeyword);
        this.isKeyword = isKeyword;
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
    }

    /// <summary>ExpressionSyntax node representing the expression on the left of the "is" operator.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken IsKeyword { get { return this.isKeyword; } }
    /// <summary>PatternSyntax node representing the pattern on the right of the "is" operator.</summary>
    public PatternSyntax Pattern { get { return this.pattern; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.isKeyword;
            case 2: return this.pattern;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.IsPatternExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIsPatternExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIsPatternExpression(this);
    }

    public IsPatternExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)
    {
        if (expression != this.Expression || isKeyword != this.IsKeyword || pattern != this.Pattern)
        {
            var newNode = SyntaxFactory.IsPatternExpression(expression, isKeyword, pattern);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new IsPatternExpressionSyntax(this.Kind, this.expression, this.isKeyword, this.pattern, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new IsPatternExpressionSyntax(this.Kind, this.expression, this.isKeyword, this.pattern, GetDiagnostics(), annotations);
    }

    internal IsPatternExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var isKeyword = (SyntaxToken)reader.ReadValue();
      if (isKeyword != null)
      {
         AdjustFlagsAndWidth(isKeyword);
         this.isKeyword = isKeyword;
      }
      var pattern = (PatternSyntax)reader.ReadValue();
      if (pattern != null)
      {
         AdjustFlagsAndWidth(pattern);
         this.pattern = pattern;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.isKeyword);
      writer.WriteValue(this.pattern);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new IsPatternExpressionSyntax(r);
    }
  }

  internal sealed partial class WhenClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken whenKeyword;
    internal readonly ExpressionSyntax condition;

    internal WhenClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, ExpressionSyntax condition, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        if (whenKeyword != null)
        {
            this.AdjustFlagsAndWidth(whenKeyword);
            this.whenKeyword = whenKeyword;
        }
        if (condition != null)
        {
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }
    }


    internal WhenClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, ExpressionSyntax condition, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        if (whenKeyword != null)
        {
            this.AdjustFlagsAndWidth(whenKeyword);
            this.whenKeyword = whenKeyword;
        }
        if (condition != null)
        {
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }
    }


    internal WhenClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, ExpressionSyntax condition)
        : base(kind)
    {
        this.SlotCount = 2;
        if (whenKeyword != null)
        {
            this.AdjustFlagsAndWidth(whenKeyword);
            this.whenKeyword = whenKeyword;
        }
        if (condition != null)
        {
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }
    }

    public SyntaxToken WhenKeyword { get { return this.whenKeyword; } }
    public ExpressionSyntax Condition { get { return this.condition; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.whenKeyword;
            case 1: return this.condition;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.WhenClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitWhenClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitWhenClause(this);
    }

    public WhenClauseSyntax Update(SyntaxToken whenKeyword, ExpressionSyntax condition)
    {
        if (whenKeyword != this.WhenKeyword || condition != this.Condition)
        {
            var newNode = SyntaxFactory.WhenClause(whenKeyword, condition);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new WhenClauseSyntax(this.Kind, this.whenKeyword, this.condition, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new WhenClauseSyntax(this.Kind, this.whenKeyword, this.condition, GetDiagnostics(), annotations);
    }

    internal WhenClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var whenKeyword = (SyntaxToken)reader.ReadValue();
      if (whenKeyword != null)
      {
         AdjustFlagsAndWidth(whenKeyword);
         this.whenKeyword = whenKeyword;
      }
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.whenKeyword);
      writer.WriteValue(this.condition);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new WhenClauseSyntax(r);
    }
  }

  internal abstract partial class PatternSyntax : CSharpSyntaxNode
  {
    internal PatternSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal PatternSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected PatternSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal sealed partial class DeclarationPatternSyntax : PatternSyntax
  {
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken identifier;

    internal DeclarationPatternSyntax(SyntaxKind kind, TypeSyntax type, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal DeclarationPatternSyntax(SyntaxKind kind, TypeSyntax type, SyntaxToken identifier, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal DeclarationPatternSyntax(SyntaxKind kind, TypeSyntax type, SyntaxToken identifier)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }

    public TypeSyntax Type { get { return this.type; } }
    public SyntaxToken Identifier { get { return this.identifier; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            case 1: return this.identifier;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.DeclarationPatternSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDeclarationPattern(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDeclarationPattern(this);
    }

    public DeclarationPatternSyntax Update(TypeSyntax type, SyntaxToken identifier)
    {
        if (type != this.Type || identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.DeclarationPattern(type, identifier);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DeclarationPatternSyntax(this.Kind, this.type, this.identifier, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DeclarationPatternSyntax(this.Kind, this.type, this.identifier, GetDiagnostics(), annotations);
    }

    internal DeclarationPatternSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.type);
      writer.WriteValue(this.identifier);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new DeclarationPatternSyntax(r);
    }
  }

  internal sealed partial class ConstantPatternSyntax : PatternSyntax
  {
    internal readonly ExpressionSyntax expression;

    internal ConstantPatternSyntax(SyntaxKind kind, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal ConstantPatternSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal ConstantPatternSyntax(SyntaxKind kind, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    /// <summary>ExpressionSyntax node representing the constant expression.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ConstantPatternSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstantPattern(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConstantPattern(this);
    }

    public ConstantPatternSyntax Update(ExpressionSyntax expression)
    {
        if (expression != this.Expression)
        {
            var newNode = SyntaxFactory.ConstantPattern(expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ConstantPatternSyntax(this.Kind, this.expression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ConstantPatternSyntax(this.Kind, this.expression, GetDiagnostics(), annotations);
    }

    internal ConstantPatternSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ConstantPatternSyntax(r);
    }
  }

  internal abstract partial class InterpolatedStringContentSyntax : CSharpSyntaxNode
  {
    internal InterpolatedStringContentSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal InterpolatedStringContentSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected InterpolatedStringContentSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal sealed partial class InterpolatedStringTextSyntax : InterpolatedStringContentSyntax
  {
    internal readonly SyntaxToken textToken;

    internal InterpolatedStringTextSyntax(SyntaxKind kind, SyntaxToken textToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(textToken);
        this.textToken = textToken;
    }


    internal InterpolatedStringTextSyntax(SyntaxKind kind, SyntaxToken textToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(textToken);
        this.textToken = textToken;
    }


    internal InterpolatedStringTextSyntax(SyntaxKind kind, SyntaxToken textToken)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(textToken);
        this.textToken = textToken;
    }

    /// <summary>The text contents of a part of the interpolated string.</summary>
    public SyntaxToken TextToken { get { return this.textToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.textToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.InterpolatedStringTextSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterpolatedStringText(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterpolatedStringText(this);
    }

    public InterpolatedStringTextSyntax Update(SyntaxToken textToken)
    {
        if (textToken != this.TextToken)
        {
            var newNode = SyntaxFactory.InterpolatedStringText(textToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new InterpolatedStringTextSyntax(this.Kind, this.textToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new InterpolatedStringTextSyntax(this.Kind, this.textToken, GetDiagnostics(), annotations);
    }

    internal InterpolatedStringTextSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var textToken = (SyntaxToken)reader.ReadValue();
      if (textToken != null)
      {
         AdjustFlagsAndWidth(textToken);
         this.textToken = textToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.textToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new InterpolatedStringTextSyntax(r);
    }
  }

  internal sealed partial class InterpolationSyntax : InterpolatedStringContentSyntax
  {
    internal readonly SyntaxToken openBraceToken;
    internal readonly ExpressionSyntax expression;
    internal readonly InterpolationAlignmentClauseSyntax alignmentClause;
    internal readonly InterpolationFormatClauseSyntax formatClause;
    internal readonly SyntaxToken closeBraceToken;

    internal InterpolationSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        if (alignmentClause != null)
        {
            this.AdjustFlagsAndWidth(alignmentClause);
            this.alignmentClause = alignmentClause;
        }
        if (formatClause != null)
        {
            this.AdjustFlagsAndWidth(formatClause);
            this.formatClause = formatClause;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal InterpolationSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        if (alignmentClause != null)
        {
            this.AdjustFlagsAndWidth(alignmentClause);
            this.alignmentClause = alignmentClause;
        }
        if (formatClause != null)
        {
            this.AdjustFlagsAndWidth(formatClause);
            this.formatClause = formatClause;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal InterpolationSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        if (alignmentClause != null)
        {
            this.AdjustFlagsAndWidth(alignmentClause);
            this.alignmentClause = alignmentClause;
        }
        if (formatClause != null)
        {
            this.AdjustFlagsAndWidth(formatClause);
            this.formatClause = formatClause;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }

    public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    public ExpressionSyntax Expression { get { return this.expression; } }
    public InterpolationAlignmentClauseSyntax AlignmentClause { get { return this.alignmentClause; } }
    public InterpolationFormatClauseSyntax FormatClause { get { return this.formatClause; } }
    public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBraceToken;
            case 1: return this.expression;
            case 2: return this.alignmentClause;
            case 3: return this.formatClause;
            case 4: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.InterpolationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterpolation(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterpolation(this);
    }

    public InterpolationSyntax Update(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || expression != this.Expression || alignmentClause != this.AlignmentClause || formatClause != this.FormatClause || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.Interpolation(openBraceToken, expression, alignmentClause, formatClause, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new InterpolationSyntax(this.Kind, this.openBraceToken, this.expression, this.alignmentClause, this.formatClause, this.closeBraceToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new InterpolationSyntax(this.Kind, this.openBraceToken, this.expression, this.alignmentClause, this.formatClause, this.closeBraceToken, GetDiagnostics(), annotations);
    }

    internal InterpolationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var alignmentClause = (InterpolationAlignmentClauseSyntax)reader.ReadValue();
      if (alignmentClause != null)
      {
         AdjustFlagsAndWidth(alignmentClause);
         this.alignmentClause = alignmentClause;
      }
      var formatClause = (InterpolationFormatClauseSyntax)reader.ReadValue();
      if (formatClause != null)
      {
         AdjustFlagsAndWidth(formatClause);
         this.formatClause = formatClause;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.alignmentClause);
      writer.WriteValue(this.formatClause);
      writer.WriteValue(this.closeBraceToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new InterpolationSyntax(r);
    }
  }

  internal sealed partial class InterpolationAlignmentClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken commaToken;
    internal readonly ExpressionSyntax value;

    internal InterpolationAlignmentClauseSyntax(SyntaxKind kind, SyntaxToken commaToken, ExpressionSyntax value, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(commaToken);
        this.commaToken = commaToken;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
    }


    internal InterpolationAlignmentClauseSyntax(SyntaxKind kind, SyntaxToken commaToken, ExpressionSyntax value, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(commaToken);
        this.commaToken = commaToken;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
    }


    internal InterpolationAlignmentClauseSyntax(SyntaxKind kind, SyntaxToken commaToken, ExpressionSyntax value)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(commaToken);
        this.commaToken = commaToken;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
    }

    public SyntaxToken CommaToken { get { return this.commaToken; } }
    public ExpressionSyntax Value { get { return this.value; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.commaToken;
            case 1: return this.value;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.InterpolationAlignmentClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterpolationAlignmentClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterpolationAlignmentClause(this);
    }

    public InterpolationAlignmentClauseSyntax Update(SyntaxToken commaToken, ExpressionSyntax value)
    {
        if (commaToken != this.CommaToken || value != this.Value)
        {
            var newNode = SyntaxFactory.InterpolationAlignmentClause(commaToken, value);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new InterpolationAlignmentClauseSyntax(this.Kind, this.commaToken, this.value, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new InterpolationAlignmentClauseSyntax(this.Kind, this.commaToken, this.value, GetDiagnostics(), annotations);
    }

    internal InterpolationAlignmentClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var commaToken = (SyntaxToken)reader.ReadValue();
      if (commaToken != null)
      {
         AdjustFlagsAndWidth(commaToken);
         this.commaToken = commaToken;
      }
      var value = (ExpressionSyntax)reader.ReadValue();
      if (value != null)
      {
         AdjustFlagsAndWidth(value);
         this.value = value;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.commaToken);
      writer.WriteValue(this.value);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new InterpolationAlignmentClauseSyntax(r);
    }
  }

  internal sealed partial class InterpolationFormatClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken colonToken;
    internal readonly SyntaxToken formatStringToken;

    internal InterpolationFormatClauseSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken formatStringToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(formatStringToken);
        this.formatStringToken = formatStringToken;
    }


    internal InterpolationFormatClauseSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken formatStringToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(formatStringToken);
        this.formatStringToken = formatStringToken;
    }


    internal InterpolationFormatClauseSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken formatStringToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(formatStringToken);
        this.formatStringToken = formatStringToken;
    }

    public SyntaxToken ColonToken { get { return this.colonToken; } }
    /// <summary>The text contents of the format specifier for an interpolation.</summary>
    public SyntaxToken FormatStringToken { get { return this.formatStringToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.colonToken;
            case 1: return this.formatStringToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.InterpolationFormatClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterpolationFormatClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterpolationFormatClause(this);
    }

    public InterpolationFormatClauseSyntax Update(SyntaxToken colonToken, SyntaxToken formatStringToken)
    {
        if (colonToken != this.ColonToken || formatStringToken != this.FormatStringToken)
        {
            var newNode = SyntaxFactory.InterpolationFormatClause(colonToken, formatStringToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new InterpolationFormatClauseSyntax(this.Kind, this.colonToken, this.formatStringToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new InterpolationFormatClauseSyntax(this.Kind, this.colonToken, this.formatStringToken, GetDiagnostics(), annotations);
    }

    internal InterpolationFormatClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
      var formatStringToken = (SyntaxToken)reader.ReadValue();
      if (formatStringToken != null)
      {
         AdjustFlagsAndWidth(formatStringToken);
         this.formatStringToken = formatStringToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.colonToken);
      writer.WriteValue(this.formatStringToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new InterpolationFormatClauseSyntax(r);
    }
  }

  internal sealed partial class GlobalStatementSyntax : MemberDeclarationSyntax
  {
    internal readonly StatementSyntax statement;

    internal GlobalStatementSyntax(SyntaxKind kind, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal GlobalStatementSyntax(SyntaxKind kind, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal GlobalStatementSyntax(SyntaxKind kind, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    public StatementSyntax Statement { get { return this.statement; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.GlobalStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGlobalStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitGlobalStatement(this);
    }

    public GlobalStatementSyntax Update(StatementSyntax statement)
    {
        if (statement != this.Statement)
        {
            var newNode = SyntaxFactory.GlobalStatement(statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new GlobalStatementSyntax(this.Kind, this.statement, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new GlobalStatementSyntax(this.Kind, this.statement, GetDiagnostics(), annotations);
    }

    internal GlobalStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.statement);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new GlobalStatementSyntax(r);
    }
  }

  /// <summary>Represents the base class for all statements syntax classes.</summary>
  internal abstract partial class StatementSyntax : CSharpSyntaxNode
  {
    internal StatementSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal StatementSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected StatementSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal sealed partial class BlockSyntax : StatementSyntax
  {
    internal readonly SyntaxToken openBraceToken;
    internal readonly CSharpSyntaxNode statements;
    internal readonly SyntaxToken closeBraceToken;

    internal BlockSyntax(SyntaxKind kind, SyntaxToken openBraceToken, CSharpSyntaxNode statements, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (statements != null)
        {
            this.AdjustFlagsAndWidth(statements);
            this.statements = statements;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal BlockSyntax(SyntaxKind kind, SyntaxToken openBraceToken, CSharpSyntaxNode statements, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (statements != null)
        {
            this.AdjustFlagsAndWidth(statements);
            this.statements = statements;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal BlockSyntax(SyntaxKind kind, SyntaxToken openBraceToken, CSharpSyntaxNode statements, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (statements != null)
        {
            this.AdjustFlagsAndWidth(statements);
            this.statements = statements;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }

    public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    public SyntaxList<StatementSyntax> Statements { get { return new SyntaxList<StatementSyntax>(this.statements); } }
    public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBraceToken;
            case 1: return this.statements;
            case 2: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.BlockSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBlock(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBlock(this);
    }

    public BlockSyntax Update(SyntaxToken openBraceToken, SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || statements != this.Statements || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.Block(openBraceToken, statements, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BlockSyntax(this.Kind, this.openBraceToken, this.statements, this.closeBraceToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BlockSyntax(this.Kind, this.openBraceToken, this.statements, this.closeBraceToken, GetDiagnostics(), annotations);
    }

    internal BlockSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var statements = (CSharpSyntaxNode)reader.ReadValue();
      if (statements != null)
      {
         AdjustFlagsAndWidth(statements);
         this.statements = statements;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.statements);
      writer.WriteValue(this.closeBraceToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new BlockSyntax(r);
    }
  }

  internal sealed partial class LocalFunctionStatementSyntax : StatementSyntax
  {
    internal readonly CSharpSyntaxNode modifiers;
    internal readonly SyntaxToken refKeyword;
    internal readonly TypeSyntax returnType;
    internal readonly SyntaxToken identifier;
    internal readonly TypeParameterListSyntax typeParameterList;
    internal readonly ParameterListSyntax parameterList;
    internal readonly CSharpSyntaxNode constraintClauses;
    internal readonly BlockSyntax body;
    internal readonly ArrowExpressionClauseSyntax expressionBody;
    internal readonly SyntaxToken semicolonToken;

    internal LocalFunctionStatementSyntax(SyntaxKind kind, CSharpSyntaxNode modifiers, SyntaxToken refKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, CSharpSyntaxNode constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 10;
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal LocalFunctionStatementSyntax(SyntaxKind kind, CSharpSyntaxNode modifiers, SyntaxToken refKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, CSharpSyntaxNode constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 10;
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal LocalFunctionStatementSyntax(SyntaxKind kind, CSharpSyntaxNode modifiers, SyntaxToken refKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, CSharpSyntaxNode constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 10;
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    public SyntaxToken RefKeyword { get { return this.refKeyword; } }
    public TypeSyntax ReturnType { get { return this.returnType; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public TypeParameterListSyntax TypeParameterList { get { return this.typeParameterList; } }
    public ParameterListSyntax ParameterList { get { return this.parameterList; } }
    public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses); } }
    public BlockSyntax Body { get { return this.body; } }
    public ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
    /// <summary>Gets the optional semicolon token.</summary>
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.modifiers;
            case 1: return this.refKeyword;
            case 2: return this.returnType;
            case 3: return this.identifier;
            case 4: return this.typeParameterList;
            case 5: return this.parameterList;
            case 6: return this.constraintClauses;
            case 7: return this.body;
            case 8: return this.expressionBody;
            case 9: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.LocalFunctionStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLocalFunctionStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLocalFunctionStatement(this);
    }

    public LocalFunctionStatementSyntax Update(SyntaxList<SyntaxToken> modifiers, SyntaxToken refKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (modifiers != this.Modifiers || refKeyword != this.RefKeyword || returnType != this.ReturnType || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || constraintClauses != this.ConstraintClauses || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.LocalFunctionStatement(modifiers, refKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new LocalFunctionStatementSyntax(this.Kind, this.modifiers, this.refKeyword, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new LocalFunctionStatementSyntax(this.Kind, this.modifiers, this.refKeyword, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal LocalFunctionStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 10;
      var modifiers = (CSharpSyntaxNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var refKeyword = (SyntaxToken)reader.ReadValue();
      if (refKeyword != null)
      {
         AdjustFlagsAndWidth(refKeyword);
         this.refKeyword = refKeyword;
      }
      var returnType = (TypeSyntax)reader.ReadValue();
      if (returnType != null)
      {
         AdjustFlagsAndWidth(returnType);
         this.returnType = returnType;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var typeParameterList = (TypeParameterListSyntax)reader.ReadValue();
      if (typeParameterList != null)
      {
         AdjustFlagsAndWidth(typeParameterList);
         this.typeParameterList = typeParameterList;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var constraintClauses = (CSharpSyntaxNode)reader.ReadValue();
      if (constraintClauses != null)
      {
         AdjustFlagsAndWidth(constraintClauses);
         this.constraintClauses = constraintClauses;
      }
      var body = (BlockSyntax)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
      var expressionBody = (ArrowExpressionClauseSyntax)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.refKeyword);
      writer.WriteValue(this.returnType);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeParameterList);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.constraintClauses);
      writer.WriteValue(this.body);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new LocalFunctionStatementSyntax(r);
    }
  }

  internal sealed partial class LocalDeclarationStatementSyntax : StatementSyntax
  {
    internal readonly CSharpSyntaxNode modifiers;
    internal readonly SyntaxToken refKeyword;
    internal readonly VariableDeclarationSyntax declaration;
    internal readonly SyntaxToken semicolonToken;

    internal LocalDeclarationStatementSyntax(SyntaxKind kind, CSharpSyntaxNode modifiers, SyntaxToken refKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal LocalDeclarationStatementSyntax(SyntaxKind kind, CSharpSyntaxNode modifiers, SyntaxToken refKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal LocalDeclarationStatementSyntax(SyntaxKind kind, CSharpSyntaxNode modifiers, SyntaxToken refKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 4;
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    /// <summary>Gets the modifier list.</summary>
    public SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    public SyntaxToken RefKeyword { get { return this.refKeyword; } }
    public VariableDeclarationSyntax Declaration { get { return this.declaration; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.modifiers;
            case 1: return this.refKeyword;
            case 2: return this.declaration;
            case 3: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.LocalDeclarationStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLocalDeclarationStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLocalDeclarationStatement(this);
    }

    public LocalDeclarationStatementSyntax Update(SyntaxList<SyntaxToken> modifiers, SyntaxToken refKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
        if (modifiers != this.Modifiers || refKeyword != this.RefKeyword || declaration != this.Declaration || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.LocalDeclarationStatement(modifiers, refKeyword, declaration, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new LocalDeclarationStatementSyntax(this.Kind, this.modifiers, this.refKeyword, this.declaration, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new LocalDeclarationStatementSyntax(this.Kind, this.modifiers, this.refKeyword, this.declaration, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal LocalDeclarationStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var modifiers = (CSharpSyntaxNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var refKeyword = (SyntaxToken)reader.ReadValue();
      if (refKeyword != null)
      {
         AdjustFlagsAndWidth(refKeyword);
         this.refKeyword = refKeyword;
      }
      var declaration = (VariableDeclarationSyntax)reader.ReadValue();
      if (declaration != null)
      {
         AdjustFlagsAndWidth(declaration);
         this.declaration = declaration;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.refKeyword);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new LocalDeclarationStatementSyntax(r);
    }
  }

  internal sealed partial class VariableDeconstructionDeclaratorSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly CSharpSyntaxNode variables;
    internal readonly SyntaxToken closeParenToken;
    internal readonly SyntaxToken equalsToken;
    internal readonly ExpressionSyntax value;

    internal VariableDeconstructionDeclaratorSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode variables, SyntaxToken closeParenToken, SyntaxToken equalsToken, ExpressionSyntax value, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (variables != null)
        {
            this.AdjustFlagsAndWidth(variables);
            this.variables = variables;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        if (equalsToken != null)
        {
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
        }
        if (value != null)
        {
            this.AdjustFlagsAndWidth(value);
            this.value = value;
        }
    }


    internal VariableDeconstructionDeclaratorSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode variables, SyntaxToken closeParenToken, SyntaxToken equalsToken, ExpressionSyntax value, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (variables != null)
        {
            this.AdjustFlagsAndWidth(variables);
            this.variables = variables;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        if (equalsToken != null)
        {
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
        }
        if (value != null)
        {
            this.AdjustFlagsAndWidth(value);
            this.value = value;
        }
    }


    internal VariableDeconstructionDeclaratorSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode variables, SyntaxToken closeParenToken, SyntaxToken equalsToken, ExpressionSyntax value)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (variables != null)
        {
            this.AdjustFlagsAndWidth(variables);
            this.variables = variables;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        if (equalsToken != null)
        {
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
        }
        if (value != null)
        {
            this.AdjustFlagsAndWidth(value);
            this.value = value;
        }
    }

    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public SeparatedSyntaxList<VariableDeclarationSyntax> Variables { get { return new SeparatedSyntaxList<VariableDeclarationSyntax>(new SyntaxList<CSharpSyntaxNode>(this.variables)); } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    public SyntaxToken EqualsToken { get { return this.equalsToken; } }
    public ExpressionSyntax Value { get { return this.value; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.variables;
            case 2: return this.closeParenToken;
            case 3: return this.equalsToken;
            case 4: return this.value;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.VariableDeconstructionDeclaratorSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitVariableDeconstructionDeclarator(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitVariableDeconstructionDeclarator(this);
    }

    public VariableDeconstructionDeclaratorSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<VariableDeclarationSyntax> variables, SyntaxToken closeParenToken, SyntaxToken equalsToken, ExpressionSyntax value)
    {
        if (openParenToken != this.OpenParenToken || variables != this.Variables || closeParenToken != this.CloseParenToken || equalsToken != this.EqualsToken || value != this.Value)
        {
            var newNode = SyntaxFactory.VariableDeconstructionDeclarator(openParenToken, variables, closeParenToken, equalsToken, value);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new VariableDeconstructionDeclaratorSyntax(this.Kind, this.openParenToken, this.variables, this.closeParenToken, this.equalsToken, this.value, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new VariableDeconstructionDeclaratorSyntax(this.Kind, this.openParenToken, this.variables, this.closeParenToken, this.equalsToken, this.value, GetDiagnostics(), annotations);
    }

    internal VariableDeconstructionDeclaratorSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var variables = (CSharpSyntaxNode)reader.ReadValue();
      if (variables != null)
      {
         AdjustFlagsAndWidth(variables);
         this.variables = variables;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var equalsToken = (SyntaxToken)reader.ReadValue();
      if (equalsToken != null)
      {
         AdjustFlagsAndWidth(equalsToken);
         this.equalsToken = equalsToken;
      }
      var value = (ExpressionSyntax)reader.ReadValue();
      if (value != null)
      {
         AdjustFlagsAndWidth(value);
         this.value = value;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.variables);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.equalsToken);
      writer.WriteValue(this.value);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new VariableDeconstructionDeclaratorSyntax(r);
    }
  }

  internal sealed partial class VariableDeclarationSyntax : CSharpSyntaxNode
  {
    internal readonly TypeSyntax type;
    internal readonly CSharpSyntaxNode variables;
    internal readonly VariableDeconstructionDeclaratorSyntax deconstruction;

    internal VariableDeclarationSyntax(SyntaxKind kind, TypeSyntax type, CSharpSyntaxNode variables, VariableDeconstructionDeclaratorSyntax deconstruction, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        if (variables != null)
        {
            this.AdjustFlagsAndWidth(variables);
            this.variables = variables;
        }
        if (deconstruction != null)
        {
            this.AdjustFlagsAndWidth(deconstruction);
            this.deconstruction = deconstruction;
        }
    }


    internal VariableDeclarationSyntax(SyntaxKind kind, TypeSyntax type, CSharpSyntaxNode variables, VariableDeconstructionDeclaratorSyntax deconstruction, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        if (variables != null)
        {
            this.AdjustFlagsAndWidth(variables);
            this.variables = variables;
        }
        if (deconstruction != null)
        {
            this.AdjustFlagsAndWidth(deconstruction);
            this.deconstruction = deconstruction;
        }
    }


    internal VariableDeclarationSyntax(SyntaxKind kind, TypeSyntax type, CSharpSyntaxNode variables, VariableDeconstructionDeclaratorSyntax deconstruction)
        : base(kind)
    {
        this.SlotCount = 3;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        if (variables != null)
        {
            this.AdjustFlagsAndWidth(variables);
            this.variables = variables;
        }
        if (deconstruction != null)
        {
            this.AdjustFlagsAndWidth(deconstruction);
            this.deconstruction = deconstruction;
        }
    }

    public TypeSyntax Type { get { return this.type; } }
    public SeparatedSyntaxList<VariableDeclaratorSyntax> Variables { get { return new SeparatedSyntaxList<VariableDeclaratorSyntax>(new SyntaxList<CSharpSyntaxNode>(this.variables)); } }
    public VariableDeconstructionDeclaratorSyntax Deconstruction { get { return this.deconstruction; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            case 1: return this.variables;
            case 2: return this.deconstruction;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.VariableDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitVariableDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitVariableDeclaration(this);
    }

    public VariableDeclarationSyntax Update(TypeSyntax type, SeparatedSyntaxList<VariableDeclaratorSyntax> variables, VariableDeconstructionDeclaratorSyntax deconstruction)
    {
        if (type != this.Type || variables != this.Variables || deconstruction != this.Deconstruction)
        {
            var newNode = SyntaxFactory.VariableDeclaration(type, variables, deconstruction);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new VariableDeclarationSyntax(this.Kind, this.type, this.variables, this.deconstruction, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new VariableDeclarationSyntax(this.Kind, this.type, this.variables, this.deconstruction, GetDiagnostics(), annotations);
    }

    internal VariableDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var variables = (CSharpSyntaxNode)reader.ReadValue();
      if (variables != null)
      {
         AdjustFlagsAndWidth(variables);
         this.variables = variables;
      }
      var deconstruction = (VariableDeconstructionDeclaratorSyntax)reader.ReadValue();
      if (deconstruction != null)
      {
         AdjustFlagsAndWidth(deconstruction);
         this.deconstruction = deconstruction;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.type);
      writer.WriteValue(this.variables);
      writer.WriteValue(this.deconstruction);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new VariableDeclarationSyntax(r);
    }
  }

  internal sealed partial class VariableDeclaratorSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken identifier;
    internal readonly BracketedArgumentListSyntax argumentList;
    internal readonly EqualsValueClauseSyntax initializer;

    internal VariableDeclaratorSyntax(SyntaxKind kind, SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }


    internal VariableDeclaratorSyntax(SyntaxKind kind, SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }


    internal VariableDeclaratorSyntax(SyntaxKind kind, SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public BracketedArgumentListSyntax ArgumentList { get { return this.argumentList; } }
    public EqualsValueClauseSyntax Initializer { get { return this.initializer; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            case 1: return this.argumentList;
            case 2: return this.initializer;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.VariableDeclaratorSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitVariableDeclarator(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitVariableDeclarator(this);
    }

    public VariableDeclaratorSyntax Update(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
    {
        if (identifier != this.Identifier || argumentList != this.ArgumentList || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.VariableDeclarator(identifier, argumentList, initializer);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new VariableDeclaratorSyntax(this.Kind, this.identifier, this.argumentList, this.initializer, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new VariableDeclaratorSyntax(this.Kind, this.identifier, this.argumentList, this.initializer, GetDiagnostics(), annotations);
    }

    internal VariableDeclaratorSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var argumentList = (BracketedArgumentListSyntax)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
      var initializer = (EqualsValueClauseSyntax)reader.ReadValue();
      if (initializer != null)
      {
         AdjustFlagsAndWidth(initializer);
         this.initializer = initializer;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.argumentList);
      writer.WriteValue(this.initializer);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new VariableDeclaratorSyntax(r);
    }
  }

  internal sealed partial class EqualsValueClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken equalsToken;
    internal readonly SyntaxToken refKeyword;
    internal readonly ExpressionSyntax value;

    internal EqualsValueClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, SyntaxToken refKeyword, ExpressionSyntax value, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(value);
        this.value = value;
    }


    internal EqualsValueClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, SyntaxToken refKeyword, ExpressionSyntax value, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(value);
        this.value = value;
    }


    internal EqualsValueClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, SyntaxToken refKeyword, ExpressionSyntax value)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(value);
        this.value = value;
    }

    public SyntaxToken EqualsToken { get { return this.equalsToken; } }
    public SyntaxToken RefKeyword { get { return this.refKeyword; } }
    public ExpressionSyntax Value { get { return this.value; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.equalsToken;
            case 1: return this.refKeyword;
            case 2: return this.value;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.EqualsValueClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEqualsValueClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEqualsValueClause(this);
    }

    public EqualsValueClauseSyntax Update(SyntaxToken equalsToken, SyntaxToken refKeyword, ExpressionSyntax value)
    {
        if (equalsToken != this.EqualsToken || refKeyword != this.RefKeyword || value != this.Value)
        {
            var newNode = SyntaxFactory.EqualsValueClause(equalsToken, refKeyword, value);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EqualsValueClauseSyntax(this.Kind, this.equalsToken, this.refKeyword, this.value, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EqualsValueClauseSyntax(this.Kind, this.equalsToken, this.refKeyword, this.value, GetDiagnostics(), annotations);
    }

    internal EqualsValueClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var equalsToken = (SyntaxToken)reader.ReadValue();
      if (equalsToken != null)
      {
         AdjustFlagsAndWidth(equalsToken);
         this.equalsToken = equalsToken;
      }
      var refKeyword = (SyntaxToken)reader.ReadValue();
      if (refKeyword != null)
      {
         AdjustFlagsAndWidth(refKeyword);
         this.refKeyword = refKeyword;
      }
      var value = (ExpressionSyntax)reader.ReadValue();
      if (value != null)
      {
         AdjustFlagsAndWidth(value);
         this.value = value;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.equalsToken);
      writer.WriteValue(this.refKeyword);
      writer.WriteValue(this.value);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new EqualsValueClauseSyntax(r);
    }
  }

  internal sealed partial class ExpressionStatementSyntax : StatementSyntax
  {
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken semicolonToken;

    internal ExpressionStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ExpressionStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ExpressionStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ExpressionStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitExpressionStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitExpressionStatement(this);
    }

    public ExpressionStatementSyntax Update(ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ExpressionStatement(expression, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ExpressionStatementSyntax(this.Kind, this.expression, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ExpressionStatementSyntax(this.Kind, this.expression, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ExpressionStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ExpressionStatementSyntax(r);
    }
  }

  internal sealed partial class EmptyStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken semicolonToken;

    internal EmptyStatementSyntax(SyntaxKind kind, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal EmptyStatementSyntax(SyntaxKind kind, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal EmptyStatementSyntax(SyntaxKind kind, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.EmptyStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEmptyStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEmptyStatement(this);
    }

    public EmptyStatementSyntax Update(SyntaxToken semicolonToken)
    {
        if (semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.EmptyStatement(semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EmptyStatementSyntax(this.Kind, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EmptyStatementSyntax(this.Kind, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal EmptyStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new EmptyStatementSyntax(r);
    }
  }

  /// <summary>Represents a labeled statement syntax.</summary>
  internal sealed partial class LabeledStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken colonToken;
    internal readonly StatementSyntax statement;

    internal LabeledStatementSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal LabeledStatementSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal LabeledStatementSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    /// <summary>Gets a SyntaxToken that represents the colon succeeding the statement's label.</summary>
    public SyntaxToken ColonToken { get { return this.colonToken; } }
    public StatementSyntax Statement { get { return this.statement; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            case 1: return this.colonToken;
            case 2: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.LabeledStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLabeledStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLabeledStatement(this);
    }

    public LabeledStatementSyntax Update(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
    {
        if (identifier != this.Identifier || colonToken != this.ColonToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.LabeledStatement(identifier, colonToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new LabeledStatementSyntax(this.Kind, this.identifier, this.colonToken, this.statement, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new LabeledStatementSyntax(this.Kind, this.identifier, this.colonToken, this.statement, GetDiagnostics(), annotations);
    }

    internal LabeledStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.colonToken);
      writer.WriteValue(this.statement);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new LabeledStatementSyntax(r);
    }
  }

  /// <summary>
  /// Represents a goto statement syntax
  /// </summary>
  internal sealed partial class GotoStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken gotoKeyword;
    internal readonly SyntaxToken caseOrDefaultKeyword;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken semicolonToken;

    internal GotoStatementSyntax(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(gotoKeyword);
        this.gotoKeyword = gotoKeyword;
        if (caseOrDefaultKeyword != null)
        {
            this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
            this.caseOrDefaultKeyword = caseOrDefaultKeyword;
        }
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal GotoStatementSyntax(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(gotoKeyword);
        this.gotoKeyword = gotoKeyword;
        if (caseOrDefaultKeyword != null)
        {
            this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
            this.caseOrDefaultKeyword = caseOrDefaultKeyword;
        }
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal GotoStatementSyntax(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(gotoKeyword);
        this.gotoKeyword = gotoKeyword;
        if (caseOrDefaultKeyword != null)
        {
            this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
            this.caseOrDefaultKeyword = caseOrDefaultKeyword;
        }
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the goto keyword.
    /// </summary>
    public SyntaxToken GotoKeyword { get { return this.gotoKeyword; } }
    /// <summary>
    /// Gets a SyntaxToken that represents the case or default keywords if any exists.
    /// </summary>
    public SyntaxToken CaseOrDefaultKeyword { get { return this.caseOrDefaultKeyword; } }
    /// <summary>
    /// Gets a constant expression for a goto case statement.
    /// </summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>
    /// Gets a SyntaxToken that represents the semi-colon at the end of the statement.
    /// </summary>
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.gotoKeyword;
            case 1: return this.caseOrDefaultKeyword;
            case 2: return this.expression;
            case 3: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.GotoStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGotoStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitGotoStatement(this);
    }

    public GotoStatementSyntax Update(SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (gotoKeyword != this.GotoKeyword || caseOrDefaultKeyword != this.CaseOrDefaultKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.GotoStatement(this.Kind, gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new GotoStatementSyntax(this.Kind, this.gotoKeyword, this.caseOrDefaultKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new GotoStatementSyntax(this.Kind, this.gotoKeyword, this.caseOrDefaultKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal GotoStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var gotoKeyword = (SyntaxToken)reader.ReadValue();
      if (gotoKeyword != null)
      {
         AdjustFlagsAndWidth(gotoKeyword);
         this.gotoKeyword = gotoKeyword;
      }
      var caseOrDefaultKeyword = (SyntaxToken)reader.ReadValue();
      if (caseOrDefaultKeyword != null)
      {
         AdjustFlagsAndWidth(caseOrDefaultKeyword);
         this.caseOrDefaultKeyword = caseOrDefaultKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.gotoKeyword);
      writer.WriteValue(this.caseOrDefaultKeyword);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new GotoStatementSyntax(r);
    }
  }

  internal sealed partial class BreakStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken breakKeyword;
    internal readonly SyntaxToken semicolonToken;

    internal BreakStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(breakKeyword);
        this.breakKeyword = breakKeyword;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal BreakStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(breakKeyword);
        this.breakKeyword = breakKeyword;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal BreakStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(breakKeyword);
        this.breakKeyword = breakKeyword;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken BreakKeyword { get { return this.breakKeyword; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.breakKeyword;
            case 1: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.BreakStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBreakStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBreakStatement(this);
    }

    public BreakStatementSyntax Update(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
    {
        if (breakKeyword != this.BreakKeyword || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.BreakStatement(breakKeyword, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BreakStatementSyntax(this.Kind, this.breakKeyword, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BreakStatementSyntax(this.Kind, this.breakKeyword, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal BreakStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var breakKeyword = (SyntaxToken)reader.ReadValue();
      if (breakKeyword != null)
      {
         AdjustFlagsAndWidth(breakKeyword);
         this.breakKeyword = breakKeyword;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.breakKeyword);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new BreakStatementSyntax(r);
    }
  }

  internal sealed partial class ContinueStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken continueKeyword;
    internal readonly SyntaxToken semicolonToken;

    internal ContinueStatementSyntax(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(continueKeyword);
        this.continueKeyword = continueKeyword;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ContinueStatementSyntax(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(continueKeyword);
        this.continueKeyword = continueKeyword;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ContinueStatementSyntax(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(continueKeyword);
        this.continueKeyword = continueKeyword;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken ContinueKeyword { get { return this.continueKeyword; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.continueKeyword;
            case 1: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ContinueStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitContinueStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitContinueStatement(this);
    }

    public ContinueStatementSyntax Update(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
    {
        if (continueKeyword != this.ContinueKeyword || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ContinueStatement(continueKeyword, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ContinueStatementSyntax(this.Kind, this.continueKeyword, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ContinueStatementSyntax(this.Kind, this.continueKeyword, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ContinueStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var continueKeyword = (SyntaxToken)reader.ReadValue();
      if (continueKeyword != null)
      {
         AdjustFlagsAndWidth(continueKeyword);
         this.continueKeyword = continueKeyword;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.continueKeyword);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ContinueStatementSyntax(r);
    }
  }

  internal sealed partial class ReturnStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken returnKeyword;
    internal readonly SyntaxToken refKeyword;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken semicolonToken;

    internal ReturnStatementSyntax(SyntaxKind kind, SyntaxToken returnKeyword, SyntaxToken refKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(returnKeyword);
        this.returnKeyword = returnKeyword;
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ReturnStatementSyntax(SyntaxKind kind, SyntaxToken returnKeyword, SyntaxToken refKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(returnKeyword);
        this.returnKeyword = returnKeyword;
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ReturnStatementSyntax(SyntaxKind kind, SyntaxToken returnKeyword, SyntaxToken refKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(returnKeyword);
        this.returnKeyword = returnKeyword;
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken ReturnKeyword { get { return this.returnKeyword; } }
    public SyntaxToken RefKeyword { get { return this.refKeyword; } }
    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.returnKeyword;
            case 1: return this.refKeyword;
            case 2: return this.expression;
            case 3: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ReturnStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitReturnStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitReturnStatement(this);
    }

    public ReturnStatementSyntax Update(SyntaxToken returnKeyword, SyntaxToken refKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (returnKeyword != this.ReturnKeyword || refKeyword != this.RefKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ReturnStatement(returnKeyword, refKeyword, expression, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ReturnStatementSyntax(this.Kind, this.returnKeyword, this.refKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ReturnStatementSyntax(this.Kind, this.returnKeyword, this.refKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ReturnStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var returnKeyword = (SyntaxToken)reader.ReadValue();
      if (returnKeyword != null)
      {
         AdjustFlagsAndWidth(returnKeyword);
         this.returnKeyword = returnKeyword;
      }
      var refKeyword = (SyntaxToken)reader.ReadValue();
      if (refKeyword != null)
      {
         AdjustFlagsAndWidth(refKeyword);
         this.refKeyword = refKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.returnKeyword);
      writer.WriteValue(this.refKeyword);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ReturnStatementSyntax(r);
    }
  }

  internal sealed partial class ThrowStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken throwKeyword;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken semicolonToken;

    internal ThrowStatementSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(throwKeyword);
        this.throwKeyword = throwKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ThrowStatementSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(throwKeyword);
        this.throwKeyword = throwKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ThrowStatementSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(throwKeyword);
        this.throwKeyword = throwKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken ThrowKeyword { get { return this.throwKeyword; } }
    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.throwKeyword;
            case 1: return this.expression;
            case 2: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ThrowStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitThrowStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitThrowStatement(this);
    }

    public ThrowStatementSyntax Update(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (throwKeyword != this.ThrowKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ThrowStatement(throwKeyword, expression, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ThrowStatementSyntax(this.Kind, this.throwKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ThrowStatementSyntax(this.Kind, this.throwKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ThrowStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var throwKeyword = (SyntaxToken)reader.ReadValue();
      if (throwKeyword != null)
      {
         AdjustFlagsAndWidth(throwKeyword);
         this.throwKeyword = throwKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.throwKeyword);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ThrowStatementSyntax(r);
    }
  }

  internal sealed partial class YieldStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken yieldKeyword;
    internal readonly SyntaxToken returnOrBreakKeyword;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken semicolonToken;

    internal YieldStatementSyntax(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(yieldKeyword);
        this.yieldKeyword = yieldKeyword;
        this.AdjustFlagsAndWidth(returnOrBreakKeyword);
        this.returnOrBreakKeyword = returnOrBreakKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal YieldStatementSyntax(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(yieldKeyword);
        this.yieldKeyword = yieldKeyword;
        this.AdjustFlagsAndWidth(returnOrBreakKeyword);
        this.returnOrBreakKeyword = returnOrBreakKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal YieldStatementSyntax(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(yieldKeyword);
        this.yieldKeyword = yieldKeyword;
        this.AdjustFlagsAndWidth(returnOrBreakKeyword);
        this.returnOrBreakKeyword = returnOrBreakKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken YieldKeyword { get { return this.yieldKeyword; } }
    public SyntaxToken ReturnOrBreakKeyword { get { return this.returnOrBreakKeyword; } }
    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.yieldKeyword;
            case 1: return this.returnOrBreakKeyword;
            case 2: return this.expression;
            case 3: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.YieldStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitYieldStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitYieldStatement(this);
    }

    public YieldStatementSyntax Update(SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (yieldKeyword != this.YieldKeyword || returnOrBreakKeyword != this.ReturnOrBreakKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.YieldStatement(this.Kind, yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new YieldStatementSyntax(this.Kind, this.yieldKeyword, this.returnOrBreakKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new YieldStatementSyntax(this.Kind, this.yieldKeyword, this.returnOrBreakKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal YieldStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var yieldKeyword = (SyntaxToken)reader.ReadValue();
      if (yieldKeyword != null)
      {
         AdjustFlagsAndWidth(yieldKeyword);
         this.yieldKeyword = yieldKeyword;
      }
      var returnOrBreakKeyword = (SyntaxToken)reader.ReadValue();
      if (returnOrBreakKeyword != null)
      {
         AdjustFlagsAndWidth(returnOrBreakKeyword);
         this.returnOrBreakKeyword = returnOrBreakKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.yieldKeyword);
      writer.WriteValue(this.returnOrBreakKeyword);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new YieldStatementSyntax(r);
    }
  }

  internal sealed partial class WhileStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken whileKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax condition;
    internal readonly SyntaxToken closeParenToken;
    internal readonly StatementSyntax statement;

    internal WhileStatementSyntax(SyntaxKind kind, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(whileKeyword);
        this.whileKeyword = whileKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal WhileStatementSyntax(SyntaxKind kind, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(whileKeyword);
        this.whileKeyword = whileKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal WhileStatementSyntax(SyntaxKind kind, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(whileKeyword);
        this.whileKeyword = whileKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    public SyntaxToken WhileKeyword { get { return this.whileKeyword; } }
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public ExpressionSyntax Condition { get { return this.condition; } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    public StatementSyntax Statement { get { return this.statement; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.whileKeyword;
            case 1: return this.openParenToken;
            case 2: return this.condition;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.WhileStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitWhileStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitWhileStatement(this);
    }

    public WhileStatementSyntax Update(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (whileKeyword != this.WhileKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.WhileStatement(whileKeyword, openParenToken, condition, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new WhileStatementSyntax(this.Kind, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new WhileStatementSyntax(this.Kind, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
    }

    internal WhileStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var whileKeyword = (SyntaxToken)reader.ReadValue();
      if (whileKeyword != null)
      {
         AdjustFlagsAndWidth(whileKeyword);
         this.whileKeyword = whileKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.whileKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new WhileStatementSyntax(r);
    }
  }

  internal sealed partial class DoStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken doKeyword;
    internal readonly StatementSyntax statement;
    internal readonly SyntaxToken whileKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax condition;
    internal readonly SyntaxToken closeParenToken;
    internal readonly SyntaxToken semicolonToken;

    internal DoStatementSyntax(SyntaxKind kind, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(doKeyword);
        this.doKeyword = doKeyword;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
        this.AdjustFlagsAndWidth(whileKeyword);
        this.whileKeyword = whileKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal DoStatementSyntax(SyntaxKind kind, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(doKeyword);
        this.doKeyword = doKeyword;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
        this.AdjustFlagsAndWidth(whileKeyword);
        this.whileKeyword = whileKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal DoStatementSyntax(SyntaxKind kind, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(doKeyword);
        this.doKeyword = doKeyword;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
        this.AdjustFlagsAndWidth(whileKeyword);
        this.whileKeyword = whileKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken DoKeyword { get { return this.doKeyword; } }
    public StatementSyntax Statement { get { return this.statement; } }
    public SyntaxToken WhileKeyword { get { return this.whileKeyword; } }
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public ExpressionSyntax Condition { get { return this.condition; } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.doKeyword;
            case 1: return this.statement;
            case 2: return this.whileKeyword;
            case 3: return this.openParenToken;
            case 4: return this.condition;
            case 5: return this.closeParenToken;
            case 6: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.DoStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDoStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDoStatement(this);
    }

    public DoStatementSyntax Update(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
    {
        if (doKeyword != this.DoKeyword || statement != this.Statement || whileKeyword != this.WhileKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.DoStatement(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DoStatementSyntax(this.Kind, this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DoStatementSyntax(this.Kind, this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal DoStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 7;
      var doKeyword = (SyntaxToken)reader.ReadValue();
      if (doKeyword != null)
      {
         AdjustFlagsAndWidth(doKeyword);
         this.doKeyword = doKeyword;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
      var whileKeyword = (SyntaxToken)reader.ReadValue();
      if (whileKeyword != null)
      {
         AdjustFlagsAndWidth(whileKeyword);
         this.whileKeyword = whileKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.doKeyword);
      writer.WriteValue(this.statement);
      writer.WriteValue(this.whileKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new DoStatementSyntax(r);
    }
  }

  internal sealed partial class ForStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken forKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly SyntaxToken refKeyword;
    internal readonly VariableDeclarationSyntax declaration;
    internal readonly CSharpSyntaxNode initializers;
    internal readonly SyntaxToken firstSemicolonToken;
    internal readonly ExpressionSyntax condition;
    internal readonly SyntaxToken secondSemicolonToken;
    internal readonly CSharpSyntaxNode incrementors;
    internal readonly SyntaxToken closeParenToken;
    internal readonly StatementSyntax statement;

    internal ForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, SyntaxToken openParenToken, SyntaxToken refKeyword, VariableDeclarationSyntax declaration, CSharpSyntaxNode initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, CSharpSyntaxNode incrementors, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 11;
        this.AdjustFlagsAndWidth(forKeyword);
        this.forKeyword = forKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (initializers != null)
        {
            this.AdjustFlagsAndWidth(initializers);
            this.initializers = initializers;
        }
        this.AdjustFlagsAndWidth(firstSemicolonToken);
        this.firstSemicolonToken = firstSemicolonToken;
        if (condition != null)
        {
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }
        this.AdjustFlagsAndWidth(secondSemicolonToken);
        this.secondSemicolonToken = secondSemicolonToken;
        if (incrementors != null)
        {
            this.AdjustFlagsAndWidth(incrementors);
            this.incrementors = incrementors;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal ForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, SyntaxToken openParenToken, SyntaxToken refKeyword, VariableDeclarationSyntax declaration, CSharpSyntaxNode initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, CSharpSyntaxNode incrementors, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 11;
        this.AdjustFlagsAndWidth(forKeyword);
        this.forKeyword = forKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (initializers != null)
        {
            this.AdjustFlagsAndWidth(initializers);
            this.initializers = initializers;
        }
        this.AdjustFlagsAndWidth(firstSemicolonToken);
        this.firstSemicolonToken = firstSemicolonToken;
        if (condition != null)
        {
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }
        this.AdjustFlagsAndWidth(secondSemicolonToken);
        this.secondSemicolonToken = secondSemicolonToken;
        if (incrementors != null)
        {
            this.AdjustFlagsAndWidth(incrementors);
            this.incrementors = incrementors;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal ForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, SyntaxToken openParenToken, SyntaxToken refKeyword, VariableDeclarationSyntax declaration, CSharpSyntaxNode initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, CSharpSyntaxNode incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 11;
        this.AdjustFlagsAndWidth(forKeyword);
        this.forKeyword = forKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (initializers != null)
        {
            this.AdjustFlagsAndWidth(initializers);
            this.initializers = initializers;
        }
        this.AdjustFlagsAndWidth(firstSemicolonToken);
        this.firstSemicolonToken = firstSemicolonToken;
        if (condition != null)
        {
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }
        this.AdjustFlagsAndWidth(secondSemicolonToken);
        this.secondSemicolonToken = secondSemicolonToken;
        if (incrementors != null)
        {
            this.AdjustFlagsAndWidth(incrementors);
            this.incrementors = incrementors;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    public SyntaxToken ForKeyword { get { return this.forKeyword; } }
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public SyntaxToken RefKeyword { get { return this.refKeyword; } }
    public VariableDeclarationSyntax Declaration { get { return this.declaration; } }
    public SeparatedSyntaxList<ExpressionSyntax> Initializers { get { return new SeparatedSyntaxList<ExpressionSyntax>(new SyntaxList<CSharpSyntaxNode>(this.initializers)); } }
    public SyntaxToken FirstSemicolonToken { get { return this.firstSemicolonToken; } }
    public ExpressionSyntax Condition { get { return this.condition; } }
    public SyntaxToken SecondSemicolonToken { get { return this.secondSemicolonToken; } }
    public SeparatedSyntaxList<ExpressionSyntax> Incrementors { get { return new SeparatedSyntaxList<ExpressionSyntax>(new SyntaxList<CSharpSyntaxNode>(this.incrementors)); } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    public StatementSyntax Statement { get { return this.statement; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.forKeyword;
            case 1: return this.openParenToken;
            case 2: return this.refKeyword;
            case 3: return this.declaration;
            case 4: return this.initializers;
            case 5: return this.firstSemicolonToken;
            case 6: return this.condition;
            case 7: return this.secondSemicolonToken;
            case 8: return this.incrementors;
            case 9: return this.closeParenToken;
            case 10: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ForStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitForStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitForStatement(this);
    }

    public ForStatementSyntax Update(SyntaxToken forKeyword, SyntaxToken openParenToken, SyntaxToken refKeyword, VariableDeclarationSyntax declaration, SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (forKeyword != this.ForKeyword || openParenToken != this.OpenParenToken || refKeyword != this.RefKeyword || declaration != this.Declaration || initializers != this.Initializers || firstSemicolonToken != this.FirstSemicolonToken || condition != this.Condition || secondSemicolonToken != this.SecondSemicolonToken || incrementors != this.Incrementors || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.ForStatement(forKeyword, openParenToken, refKeyword, declaration, initializers, firstSemicolonToken, condition, secondSemicolonToken, incrementors, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ForStatementSyntax(this.Kind, this.forKeyword, this.openParenToken, this.refKeyword, this.declaration, this.initializers, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementors, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ForStatementSyntax(this.Kind, this.forKeyword, this.openParenToken, this.refKeyword, this.declaration, this.initializers, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementors, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
    }

    internal ForStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 11;
      var forKeyword = (SyntaxToken)reader.ReadValue();
      if (forKeyword != null)
      {
         AdjustFlagsAndWidth(forKeyword);
         this.forKeyword = forKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var refKeyword = (SyntaxToken)reader.ReadValue();
      if (refKeyword != null)
      {
         AdjustFlagsAndWidth(refKeyword);
         this.refKeyword = refKeyword;
      }
      var declaration = (VariableDeclarationSyntax)reader.ReadValue();
      if (declaration != null)
      {
         AdjustFlagsAndWidth(declaration);
         this.declaration = declaration;
      }
      var initializers = (CSharpSyntaxNode)reader.ReadValue();
      if (initializers != null)
      {
         AdjustFlagsAndWidth(initializers);
         this.initializers = initializers;
      }
      var firstSemicolonToken = (SyntaxToken)reader.ReadValue();
      if (firstSemicolonToken != null)
      {
         AdjustFlagsAndWidth(firstSemicolonToken);
         this.firstSemicolonToken = firstSemicolonToken;
      }
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
      var secondSemicolonToken = (SyntaxToken)reader.ReadValue();
      if (secondSemicolonToken != null)
      {
         AdjustFlagsAndWidth(secondSemicolonToken);
         this.secondSemicolonToken = secondSemicolonToken;
      }
      var incrementors = (CSharpSyntaxNode)reader.ReadValue();
      if (incrementors != null)
      {
         AdjustFlagsAndWidth(incrementors);
         this.incrementors = incrementors;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.forKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.refKeyword);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.initializers);
      writer.WriteValue(this.firstSemicolonToken);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.secondSemicolonToken);
      writer.WriteValue(this.incrementors);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ForStatementSyntax(r);
    }
  }

  internal sealed partial class ForEachStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken forEachKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken identifier;
    internal readonly VariableDeclarationSyntax deconstructionVariables;
    internal readonly SyntaxToken inKeyword;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;
    internal readonly StatementSyntax statement;

    internal ForEachStatementSyntax(SyntaxKind kind, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, VariableDeclarationSyntax deconstructionVariables, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 9;
        this.AdjustFlagsAndWidth(forEachKeyword);
        this.forEachKeyword = forEachKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        if (identifier != null)
        {
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }
        if (deconstructionVariables != null)
        {
            this.AdjustFlagsAndWidth(deconstructionVariables);
            this.deconstructionVariables = deconstructionVariables;
        }
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal ForEachStatementSyntax(SyntaxKind kind, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, VariableDeclarationSyntax deconstructionVariables, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 9;
        this.AdjustFlagsAndWidth(forEachKeyword);
        this.forEachKeyword = forEachKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        if (identifier != null)
        {
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }
        if (deconstructionVariables != null)
        {
            this.AdjustFlagsAndWidth(deconstructionVariables);
            this.deconstructionVariables = deconstructionVariables;
        }
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal ForEachStatementSyntax(SyntaxKind kind, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, VariableDeclarationSyntax deconstructionVariables, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 9;
        this.AdjustFlagsAndWidth(forEachKeyword);
        this.forEachKeyword = forEachKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        if (identifier != null)
        {
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }
        if (deconstructionVariables != null)
        {
            this.AdjustFlagsAndWidth(deconstructionVariables);
            this.deconstructionVariables = deconstructionVariables;
        }
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    public SyntaxToken ForEachKeyword { get { return this.forEachKeyword; } }
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public VariableDeclarationSyntax DeconstructionVariables { get { return this.deconstructionVariables; } }
    public SyntaxToken InKeyword { get { return this.inKeyword; } }
    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    public StatementSyntax Statement { get { return this.statement; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.forEachKeyword;
            case 1: return this.openParenToken;
            case 2: return this.type;
            case 3: return this.identifier;
            case 4: return this.deconstructionVariables;
            case 5: return this.inKeyword;
            case 6: return this.expression;
            case 7: return this.closeParenToken;
            case 8: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ForEachStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitForEachStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitForEachStatement(this);
    }

    public ForEachStatementSyntax Update(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, VariableDeclarationSyntax deconstructionVariables, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (forEachKeyword != this.ForEachKeyword || openParenToken != this.OpenParenToken || type != this.Type || identifier != this.Identifier || deconstructionVariables != this.DeconstructionVariables || inKeyword != this.InKeyword || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.ForEachStatement(forEachKeyword, openParenToken, type, identifier, deconstructionVariables, inKeyword, expression, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ForEachStatementSyntax(this.Kind, this.forEachKeyword, this.openParenToken, this.type, this.identifier, this.deconstructionVariables, this.inKeyword, this.expression, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ForEachStatementSyntax(this.Kind, this.forEachKeyword, this.openParenToken, this.type, this.identifier, this.deconstructionVariables, this.inKeyword, this.expression, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
    }

    internal ForEachStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 9;
      var forEachKeyword = (SyntaxToken)reader.ReadValue();
      if (forEachKeyword != null)
      {
         AdjustFlagsAndWidth(forEachKeyword);
         this.forEachKeyword = forEachKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var deconstructionVariables = (VariableDeclarationSyntax)reader.ReadValue();
      if (deconstructionVariables != null)
      {
         AdjustFlagsAndWidth(deconstructionVariables);
         this.deconstructionVariables = deconstructionVariables;
      }
      var inKeyword = (SyntaxToken)reader.ReadValue();
      if (inKeyword != null)
      {
         AdjustFlagsAndWidth(inKeyword);
         this.inKeyword = inKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.forEachKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.deconstructionVariables);
      writer.WriteValue(this.inKeyword);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ForEachStatementSyntax(r);
    }
  }

  internal sealed partial class UsingStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken usingKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly VariableDeclarationSyntax declaration;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;
    internal readonly StatementSyntax statement;

    internal UsingStatementSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(usingKeyword);
        this.usingKeyword = usingKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal UsingStatementSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(usingKeyword);
        this.usingKeyword = usingKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal UsingStatementSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(usingKeyword);
        this.usingKeyword = usingKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    public SyntaxToken UsingKeyword { get { return this.usingKeyword; } }
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public VariableDeclarationSyntax Declaration { get { return this.declaration; } }
    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    public StatementSyntax Statement { get { return this.statement; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.usingKeyword;
            case 1: return this.openParenToken;
            case 2: return this.declaration;
            case 3: return this.expression;
            case 4: return this.closeParenToken;
            case 5: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.UsingStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitUsingStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitUsingStatement(this);
    }

    public UsingStatementSyntax Update(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (usingKeyword != this.UsingKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.UsingStatement(usingKeyword, openParenToken, declaration, expression, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new UsingStatementSyntax(this.Kind, this.usingKeyword, this.openParenToken, this.declaration, this.expression, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new UsingStatementSyntax(this.Kind, this.usingKeyword, this.openParenToken, this.declaration, this.expression, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
    }

    internal UsingStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 6;
      var usingKeyword = (SyntaxToken)reader.ReadValue();
      if (usingKeyword != null)
      {
         AdjustFlagsAndWidth(usingKeyword);
         this.usingKeyword = usingKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var declaration = (VariableDeclarationSyntax)reader.ReadValue();
      if (declaration != null)
      {
         AdjustFlagsAndWidth(declaration);
         this.declaration = declaration;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.usingKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new UsingStatementSyntax(r);
    }
  }

  internal sealed partial class FixedStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken fixedKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly VariableDeclarationSyntax declaration;
    internal readonly SyntaxToken closeParenToken;
    internal readonly StatementSyntax statement;

    internal FixedStatementSyntax(SyntaxKind kind, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(fixedKeyword);
        this.fixedKeyword = fixedKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal FixedStatementSyntax(SyntaxKind kind, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(fixedKeyword);
        this.fixedKeyword = fixedKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal FixedStatementSyntax(SyntaxKind kind, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(fixedKeyword);
        this.fixedKeyword = fixedKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    public SyntaxToken FixedKeyword { get { return this.fixedKeyword; } }
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public VariableDeclarationSyntax Declaration { get { return this.declaration; } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    public StatementSyntax Statement { get { return this.statement; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.fixedKeyword;
            case 1: return this.openParenToken;
            case 2: return this.declaration;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.FixedStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFixedStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitFixedStatement(this);
    }

    public FixedStatementSyntax Update(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (fixedKeyword != this.FixedKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.FixedStatement(fixedKeyword, openParenToken, declaration, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new FixedStatementSyntax(this.Kind, this.fixedKeyword, this.openParenToken, this.declaration, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new FixedStatementSyntax(this.Kind, this.fixedKeyword, this.openParenToken, this.declaration, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
    }

    internal FixedStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var fixedKeyword = (SyntaxToken)reader.ReadValue();
      if (fixedKeyword != null)
      {
         AdjustFlagsAndWidth(fixedKeyword);
         this.fixedKeyword = fixedKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var declaration = (VariableDeclarationSyntax)reader.ReadValue();
      if (declaration != null)
      {
         AdjustFlagsAndWidth(declaration);
         this.declaration = declaration;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.fixedKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new FixedStatementSyntax(r);
    }
  }

  internal sealed partial class CheckedStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly BlockSyntax block;

    internal CheckedStatementSyntax(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal CheckedStatementSyntax(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal CheckedStatementSyntax(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }

    public SyntaxToken Keyword { get { return this.keyword; } }
    public BlockSyntax Block { get { return this.block; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.block;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CheckedStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCheckedStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCheckedStatement(this);
    }

    public CheckedStatementSyntax Update(SyntaxToken keyword, BlockSyntax block)
    {
        if (keyword != this.Keyword || block != this.Block)
        {
            var newNode = SyntaxFactory.CheckedStatement(this.Kind, keyword, block);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CheckedStatementSyntax(this.Kind, this.keyword, this.block, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CheckedStatementSyntax(this.Kind, this.keyword, this.block, GetDiagnostics(), annotations);
    }

    internal CheckedStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var block = (BlockSyntax)reader.ReadValue();
      if (block != null)
      {
         AdjustFlagsAndWidth(block);
         this.block = block;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.block);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new CheckedStatementSyntax(r);
    }
  }

  internal sealed partial class UnsafeStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken unsafeKeyword;
    internal readonly BlockSyntax block;

    internal UnsafeStatementSyntax(SyntaxKind kind, SyntaxToken unsafeKeyword, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(unsafeKeyword);
        this.unsafeKeyword = unsafeKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal UnsafeStatementSyntax(SyntaxKind kind, SyntaxToken unsafeKeyword, BlockSyntax block, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(unsafeKeyword);
        this.unsafeKeyword = unsafeKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal UnsafeStatementSyntax(SyntaxKind kind, SyntaxToken unsafeKeyword, BlockSyntax block)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(unsafeKeyword);
        this.unsafeKeyword = unsafeKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }

    public SyntaxToken UnsafeKeyword { get { return this.unsafeKeyword; } }
    public BlockSyntax Block { get { return this.block; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.unsafeKeyword;
            case 1: return this.block;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.UnsafeStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitUnsafeStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitUnsafeStatement(this);
    }

    public UnsafeStatementSyntax Update(SyntaxToken unsafeKeyword, BlockSyntax block)
    {
        if (unsafeKeyword != this.UnsafeKeyword || block != this.Block)
        {
            var newNode = SyntaxFactory.UnsafeStatement(unsafeKeyword, block);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new UnsafeStatementSyntax(this.Kind, this.unsafeKeyword, this.block, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new UnsafeStatementSyntax(this.Kind, this.unsafeKeyword, this.block, GetDiagnostics(), annotations);
    }

    internal UnsafeStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var unsafeKeyword = (SyntaxToken)reader.ReadValue();
      if (unsafeKeyword != null)
      {
         AdjustFlagsAndWidth(unsafeKeyword);
         this.unsafeKeyword = unsafeKeyword;
      }
      var block = (BlockSyntax)reader.ReadValue();
      if (block != null)
      {
         AdjustFlagsAndWidth(block);
         this.block = block;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.unsafeKeyword);
      writer.WriteValue(this.block);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new UnsafeStatementSyntax(r);
    }
  }

  internal sealed partial class LockStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken lockKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;
    internal readonly StatementSyntax statement;

    internal LockStatementSyntax(SyntaxKind kind, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(lockKeyword);
        this.lockKeyword = lockKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal LockStatementSyntax(SyntaxKind kind, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(lockKeyword);
        this.lockKeyword = lockKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal LockStatementSyntax(SyntaxKind kind, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(lockKeyword);
        this.lockKeyword = lockKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    public SyntaxToken LockKeyword { get { return this.lockKeyword; } }
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    public StatementSyntax Statement { get { return this.statement; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lockKeyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.LockStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLockStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLockStatement(this);
    }

    public LockStatementSyntax Update(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (lockKeyword != this.LockKeyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.LockStatement(lockKeyword, openParenToken, expression, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new LockStatementSyntax(this.Kind, this.lockKeyword, this.openParenToken, this.expression, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new LockStatementSyntax(this.Kind, this.lockKeyword, this.openParenToken, this.expression, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
    }

    internal LockStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var lockKeyword = (SyntaxToken)reader.ReadValue();
      if (lockKeyword != null)
      {
         AdjustFlagsAndWidth(lockKeyword);
         this.lockKeyword = lockKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lockKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new LockStatementSyntax(r);
    }
  }

  /// <summary>
  /// Represents an if statement syntax.
  /// </summary>
  internal sealed partial class IfStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken ifKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax condition;
    internal readonly SyntaxToken closeParenToken;
    internal readonly StatementSyntax statement;
    internal readonly ElseClauseSyntax @else;

    internal IfStatementSyntax(SyntaxKind kind, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(ifKeyword);
        this.ifKeyword = ifKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
        if (@else != null)
        {
            this.AdjustFlagsAndWidth(@else);
            this.@else = @else;
        }
    }


    internal IfStatementSyntax(SyntaxKind kind, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(ifKeyword);
        this.ifKeyword = ifKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
        if (@else != null)
        {
            this.AdjustFlagsAndWidth(@else);
            this.@else = @else;
        }
    }


    internal IfStatementSyntax(SyntaxKind kind, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)
        : base(kind)
    {
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(ifKeyword);
        this.ifKeyword = ifKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
        if (@else != null)
        {
            this.AdjustFlagsAndWidth(@else);
            this.@else = @else;
        }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the if keyword.
    /// </summary>
    public SyntaxToken IfKeyword { get { return this.ifKeyword; } }
    /// <summary>
    /// Gets a SyntaxToken that represents the open parenthesis before the if statement's condition expression.
    /// </summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>
    /// Gets an ExpressionSyntax that represents the condition of the if statement.
    /// </summary>
    public ExpressionSyntax Condition { get { return this.condition; } }
    /// <summary>
    /// Gets a SyntaxToken that represents the close parenthesis after the if statement's condition expression.
    /// </summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    /// <summary>
    /// Gets a StatementSyntax the represents the statement to be executed when the condition is true.
    /// </summary>
    public StatementSyntax Statement { get { return this.statement; } }
    /// <summary>
    /// Gets an ElseClauseSyntax that represents the statement to be executed when the condition is false if such statement exists.
    /// </summary>
    public ElseClauseSyntax Else { get { return this.@else; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.ifKeyword;
            case 1: return this.openParenToken;
            case 2: return this.condition;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
            case 5: return this.@else;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.IfStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIfStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIfStatement(this);
    }

    public IfStatementSyntax Update(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)
    {
        if (ifKeyword != this.IfKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || statement != this.Statement || @else != this.Else)
        {
            var newNode = SyntaxFactory.IfStatement(ifKeyword, openParenToken, condition, closeParenToken, statement, @else);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new IfStatementSyntax(this.Kind, this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.@else, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new IfStatementSyntax(this.Kind, this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.@else, GetDiagnostics(), annotations);
    }

    internal IfStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 6;
      var ifKeyword = (SyntaxToken)reader.ReadValue();
      if (ifKeyword != null)
      {
         AdjustFlagsAndWidth(ifKeyword);
         this.ifKeyword = ifKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
      var @else = (ElseClauseSyntax)reader.ReadValue();
      if (@else != null)
      {
         AdjustFlagsAndWidth(@else);
         this.@else = @else;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.ifKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
      writer.WriteValue(this.@else);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new IfStatementSyntax(r);
    }
  }

  /// <summary>Represents an else statement syntax.</summary>
  internal sealed partial class ElseClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken elseKeyword;
    internal readonly StatementSyntax statement;

    internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elseKeyword);
        this.elseKeyword = elseKeyword;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elseKeyword);
        this.elseKeyword = elseKeyword;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elseKeyword);
        this.elseKeyword = elseKeyword;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    /// <summary>
    /// Gets a syntax token
    /// </summary>
    public SyntaxToken ElseKeyword { get { return this.elseKeyword; } }
    public StatementSyntax Statement { get { return this.statement; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.elseKeyword;
            case 1: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ElseClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElseClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitElseClause(this);
    }

    public ElseClauseSyntax Update(SyntaxToken elseKeyword, StatementSyntax statement)
    {
        if (elseKeyword != this.ElseKeyword || statement != this.Statement)
        {
            var newNode = SyntaxFactory.ElseClause(elseKeyword, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ElseClauseSyntax(this.Kind, this.elseKeyword, this.statement, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ElseClauseSyntax(this.Kind, this.elseKeyword, this.statement, GetDiagnostics(), annotations);
    }

    internal ElseClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var elseKeyword = (SyntaxToken)reader.ReadValue();
      if (elseKeyword != null)
      {
         AdjustFlagsAndWidth(elseKeyword);
         this.elseKeyword = elseKeyword;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.elseKeyword);
      writer.WriteValue(this.statement);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ElseClauseSyntax(r);
    }
  }

  /// <summary>Represents a switch statement syntax.</summary>
  internal sealed partial class SwitchStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken switchKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;
    internal readonly SyntaxToken openBraceToken;
    internal readonly CSharpSyntaxNode sections;
    internal readonly SyntaxToken closeBraceToken;

    internal SwitchStatementSyntax(SyntaxKind kind, SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, CSharpSyntaxNode sections, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(switchKeyword);
        this.switchKeyword = switchKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (sections != null)
        {
            this.AdjustFlagsAndWidth(sections);
            this.sections = sections;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal SwitchStatementSyntax(SyntaxKind kind, SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, CSharpSyntaxNode sections, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(switchKeyword);
        this.switchKeyword = switchKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (sections != null)
        {
            this.AdjustFlagsAndWidth(sections);
            this.sections = sections;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal SwitchStatementSyntax(SyntaxKind kind, SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, CSharpSyntaxNode sections, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(switchKeyword);
        this.switchKeyword = switchKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (sections != null)
        {
            this.AdjustFlagsAndWidth(sections);
            this.sections = sections;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the switch keyword.
    /// </summary>
    public SyntaxToken SwitchKeyword { get { return this.switchKeyword; } }
    /// <summary>
    /// Gets a SyntaxToken that represents the open parenthesis preceding the switch expression.
    /// </summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>
    /// Gets an ExpressionSyntax representing the expression of the switch statement.
    /// </summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>
    /// Gets a SyntaxToken that represents the close parenthesis succeeding the switch expression.
    /// </summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    /// <summary>
    /// Gets a SyntaxToken that represents the open braces preceding the switch sections.
    /// </summary>
    public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    /// <summary>
    /// Gets a SyntaxList of SwitchSectionSyntax's that represents the switch sections of the switch statement.
    /// </summary>
    public SyntaxList<SwitchSectionSyntax> Sections { get { return new SyntaxList<SwitchSectionSyntax>(this.sections); } }
    /// <summary>
    /// Gets a SyntaxToken that represents the open braces succeeding the switch sections.
    /// </summary>
    public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.switchKeyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.closeParenToken;
            case 4: return this.openBraceToken;
            case 5: return this.sections;
            case 6: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.SwitchStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSwitchStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSwitchStatement(this);
    }

    public SwitchStatementSyntax Update(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)
    {
        if (switchKeyword != this.SwitchKeyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken || openBraceToken != this.OpenBraceToken || sections != this.Sections || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.SwitchStatement(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new SwitchStatementSyntax(this.Kind, this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.sections, this.closeBraceToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new SwitchStatementSyntax(this.Kind, this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.sections, this.closeBraceToken, GetDiagnostics(), annotations);
    }

    internal SwitchStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 7;
      var switchKeyword = (SyntaxToken)reader.ReadValue();
      if (switchKeyword != null)
      {
         AdjustFlagsAndWidth(switchKeyword);
         this.switchKeyword = switchKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var sections = (CSharpSyntaxNode)reader.ReadValue();
      if (sections != null)
      {
         AdjustFlagsAndWidth(sections);
         this.sections = sections;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.switchKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.sections);
      writer.WriteValue(this.closeBraceToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new SwitchStatementSyntax(r);
    }
  }

  /// <summary>Represents a switch section syntax of a switch statement.</summary>
  internal sealed partial class SwitchSectionSyntax : CSharpSyntaxNode
  {
    internal readonly CSharpSyntaxNode labels;
    internal readonly CSharpSyntaxNode statements;

    internal SwitchSectionSyntax(SyntaxKind kind, CSharpSyntaxNode labels, CSharpSyntaxNode statements, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        if (labels != null)
        {
            this.AdjustFlagsAndWidth(labels);
            this.labels = labels;
        }
        if (statements != null)
        {
            this.AdjustFlagsAndWidth(statements);
            this.statements = statements;
        }
    }


    internal SwitchSectionSyntax(SyntaxKind kind, CSharpSyntaxNode labels, CSharpSyntaxNode statements, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        if (labels != null)
        {
            this.AdjustFlagsAndWidth(labels);
            this.labels = labels;
        }
        if (statements != null)
        {
            this.AdjustFlagsAndWidth(statements);
            this.statements = statements;
        }
    }


    internal SwitchSectionSyntax(SyntaxKind kind, CSharpSyntaxNode labels, CSharpSyntaxNode statements)
        : base(kind)
    {
        this.SlotCount = 2;
        if (labels != null)
        {
            this.AdjustFlagsAndWidth(labels);
            this.labels = labels;
        }
        if (statements != null)
        {
            this.AdjustFlagsAndWidth(statements);
            this.statements = statements;
        }
    }

    /// <summary>
    /// Gets a SyntaxList of SwitchLabelSyntax's the represents the possible labels that control can transfer to within the section.
    /// </summary>
    public SyntaxList<SwitchLabelSyntax> Labels { get { return new SyntaxList<SwitchLabelSyntax>(this.labels); } }
    /// <summary>
    /// Gets a SyntaxList of StatementSyntax's the represents the statements to be executed when control transfer to a label the belongs to the section.
    /// </summary>
    public SyntaxList<StatementSyntax> Statements { get { return new SyntaxList<StatementSyntax>(this.statements); } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.labels;
            case 1: return this.statements;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.SwitchSectionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSwitchSection(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSwitchSection(this);
    }

    public SwitchSectionSyntax Update(SyntaxList<SwitchLabelSyntax> labels, SyntaxList<StatementSyntax> statements)
    {
        if (labels != this.Labels || statements != this.Statements)
        {
            var newNode = SyntaxFactory.SwitchSection(labels, statements);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new SwitchSectionSyntax(this.Kind, this.labels, this.statements, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new SwitchSectionSyntax(this.Kind, this.labels, this.statements, GetDiagnostics(), annotations);
    }

    internal SwitchSectionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var labels = (CSharpSyntaxNode)reader.ReadValue();
      if (labels != null)
      {
         AdjustFlagsAndWidth(labels);
         this.labels = labels;
      }
      var statements = (CSharpSyntaxNode)reader.ReadValue();
      if (statements != null)
      {
         AdjustFlagsAndWidth(statements);
         this.statements = statements;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.labels);
      writer.WriteValue(this.statements);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new SwitchSectionSyntax(r);
    }
  }

  /// <summary>Represents a switch label within a switch statement.</summary>
  internal abstract partial class SwitchLabelSyntax : CSharpSyntaxNode
  {
    internal SwitchLabelSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal SwitchLabelSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected SwitchLabelSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>
    /// Gets a SyntaxToken that represents a case or default keywords that belongs to a switch label.
    /// </summary>
    public abstract SyntaxToken Keyword { get; }

    /// <summary>
    /// Gets a SyntaxToken that represents the colon that terminates the switch label.
    /// </summary>
    public abstract SyntaxToken ColonToken { get; }
  }

  /// <summary>Represents a case label within a switch statement.</summary>
  internal sealed partial class CasePatternSwitchLabelSyntax : SwitchLabelSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly PatternSyntax pattern;
    internal readonly WhenClauseSyntax whenClause;
    internal readonly SyntaxToken colonToken;

    internal CasePatternSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
        if (whenClause != null)
        {
            this.AdjustFlagsAndWidth(whenClause);
            this.whenClause = whenClause;
        }
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal CasePatternSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
        if (whenClause != null)
        {
            this.AdjustFlagsAndWidth(whenClause);
            this.whenClause = whenClause;
        }
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal CasePatternSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
        if (whenClause != null)
        {
            this.AdjustFlagsAndWidth(whenClause);
            this.whenClause = whenClause;
        }
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }

    /// <summary>Gets the case keyword token.</summary>
    public override SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>
    /// Gets a PatternSyntax that represents the pattern that gets matched for the case label.
    /// </summary>
    public PatternSyntax Pattern { get { return this.pattern; } }
    public WhenClauseSyntax WhenClause { get { return this.whenClause; } }
    public override SyntaxToken ColonToken { get { return this.colonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.pattern;
            case 2: return this.whenClause;
            case 3: return this.colonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CasePatternSwitchLabelSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCasePatternSwitchLabel(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCasePatternSwitchLabel(this);
    }

    public CasePatternSwitchLabelSyntax Update(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)
    {
        if (keyword != this.Keyword || pattern != this.Pattern || whenClause != this.WhenClause || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.CasePatternSwitchLabel(keyword, pattern, whenClause, colonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CasePatternSwitchLabelSyntax(this.Kind, this.keyword, this.pattern, this.whenClause, this.colonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CasePatternSwitchLabelSyntax(this.Kind, this.keyword, this.pattern, this.whenClause, this.colonToken, GetDiagnostics(), annotations);
    }

    internal CasePatternSwitchLabelSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var pattern = (PatternSyntax)reader.ReadValue();
      if (pattern != null)
      {
         AdjustFlagsAndWidth(pattern);
         this.pattern = pattern;
      }
      var whenClause = (WhenClauseSyntax)reader.ReadValue();
      if (whenClause != null)
      {
         AdjustFlagsAndWidth(whenClause);
         this.whenClause = whenClause;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.pattern);
      writer.WriteValue(this.whenClause);
      writer.WriteValue(this.colonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new CasePatternSwitchLabelSyntax(r);
    }
  }

  /// <summary>Represents a case label within a switch statement.</summary>
  internal sealed partial class CaseSwitchLabelSyntax : SwitchLabelSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly ExpressionSyntax value;
    internal readonly SyntaxToken colonToken;

    internal CaseSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal CaseSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal CaseSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }

    /// <summary>Gets the case keyword token.</summary>
    public override SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>
    /// Gets an ExpressionSyntax that represents the constant expression that gets matched for the case label.
    /// </summary>
    public ExpressionSyntax Value { get { return this.value; } }
    public override SyntaxToken ColonToken { get { return this.colonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.value;
            case 2: return this.colonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CaseSwitchLabelSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCaseSwitchLabel(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCaseSwitchLabel(this);
    }

    public CaseSwitchLabelSyntax Update(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)
    {
        if (keyword != this.Keyword || value != this.Value || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.CaseSwitchLabel(keyword, value, colonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CaseSwitchLabelSyntax(this.Kind, this.keyword, this.value, this.colonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CaseSwitchLabelSyntax(this.Kind, this.keyword, this.value, this.colonToken, GetDiagnostics(), annotations);
    }

    internal CaseSwitchLabelSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var value = (ExpressionSyntax)reader.ReadValue();
      if (value != null)
      {
         AdjustFlagsAndWidth(value);
         this.value = value;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.value);
      writer.WriteValue(this.colonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new CaseSwitchLabelSyntax(r);
    }
  }

  /// <summary>Represents a default label within a switch statement.</summary>
  internal sealed partial class DefaultSwitchLabelSyntax : SwitchLabelSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken colonToken;

    internal DefaultSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal DefaultSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken colonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal DefaultSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken colonToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }

    /// <summary>Gets the default keyword token.</summary>
    public override SyntaxToken Keyword { get { return this.keyword; } }
    public override SyntaxToken ColonToken { get { return this.colonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.colonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.DefaultSwitchLabelSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDefaultSwitchLabel(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDefaultSwitchLabel(this);
    }

    public DefaultSwitchLabelSyntax Update(SyntaxToken keyword, SyntaxToken colonToken)
    {
        if (keyword != this.Keyword || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.DefaultSwitchLabel(keyword, colonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DefaultSwitchLabelSyntax(this.Kind, this.keyword, this.colonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DefaultSwitchLabelSyntax(this.Kind, this.keyword, this.colonToken, GetDiagnostics(), annotations);
    }

    internal DefaultSwitchLabelSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.colonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new DefaultSwitchLabelSyntax(r);
    }
  }

  internal sealed partial class TryStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken tryKeyword;
    internal readonly BlockSyntax block;
    internal readonly CSharpSyntaxNode catches;
    internal readonly FinallyClauseSyntax @finally;

    internal TryStatementSyntax(SyntaxKind kind, SyntaxToken tryKeyword, BlockSyntax block, CSharpSyntaxNode catches, FinallyClauseSyntax @finally, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(tryKeyword);
        this.tryKeyword = tryKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
        if (catches != null)
        {
            this.AdjustFlagsAndWidth(catches);
            this.catches = catches;
        }
        if (@finally != null)
        {
            this.AdjustFlagsAndWidth(@finally);
            this.@finally = @finally;
        }
    }


    internal TryStatementSyntax(SyntaxKind kind, SyntaxToken tryKeyword, BlockSyntax block, CSharpSyntaxNode catches, FinallyClauseSyntax @finally, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(tryKeyword);
        this.tryKeyword = tryKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
        if (catches != null)
        {
            this.AdjustFlagsAndWidth(catches);
            this.catches = catches;
        }
        if (@finally != null)
        {
            this.AdjustFlagsAndWidth(@finally);
            this.@finally = @finally;
        }
    }


    internal TryStatementSyntax(SyntaxKind kind, SyntaxToken tryKeyword, BlockSyntax block, CSharpSyntaxNode catches, FinallyClauseSyntax @finally)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(tryKeyword);
        this.tryKeyword = tryKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
        if (catches != null)
        {
            this.AdjustFlagsAndWidth(catches);
            this.catches = catches;
        }
        if (@finally != null)
        {
            this.AdjustFlagsAndWidth(@finally);
            this.@finally = @finally;
        }
    }

    public SyntaxToken TryKeyword { get { return this.tryKeyword; } }
    public BlockSyntax Block { get { return this.block; } }
    public SyntaxList<CatchClauseSyntax> Catches { get { return new SyntaxList<CatchClauseSyntax>(this.catches); } }
    public FinallyClauseSyntax Finally { get { return this.@finally; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.tryKeyword;
            case 1: return this.block;
            case 2: return this.catches;
            case 3: return this.@finally;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.TryStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTryStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTryStatement(this);
    }

    public TryStatementSyntax Update(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
    {
        if (tryKeyword != this.TryKeyword || block != this.Block || catches != this.Catches || @finally != this.Finally)
        {
            var newNode = SyntaxFactory.TryStatement(tryKeyword, block, catches, @finally);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TryStatementSyntax(this.Kind, this.tryKeyword, this.block, this.catches, this.@finally, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TryStatementSyntax(this.Kind, this.tryKeyword, this.block, this.catches, this.@finally, GetDiagnostics(), annotations);
    }

    internal TryStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var tryKeyword = (SyntaxToken)reader.ReadValue();
      if (tryKeyword != null)
      {
         AdjustFlagsAndWidth(tryKeyword);
         this.tryKeyword = tryKeyword;
      }
      var block = (BlockSyntax)reader.ReadValue();
      if (block != null)
      {
         AdjustFlagsAndWidth(block);
         this.block = block;
      }
      var catches = (CSharpSyntaxNode)reader.ReadValue();
      if (catches != null)
      {
         AdjustFlagsAndWidth(catches);
         this.catches = catches;
      }
      var @finally = (FinallyClauseSyntax)reader.ReadValue();
      if (@finally != null)
      {
         AdjustFlagsAndWidth(@finally);
         this.@finally = @finally;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.tryKeyword);
      writer.WriteValue(this.block);
      writer.WriteValue(this.catches);
      writer.WriteValue(this.@finally);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new TryStatementSyntax(r);
    }
  }

  internal sealed partial class CatchClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken catchKeyword;
    internal readonly CatchDeclarationSyntax declaration;
    internal readonly CatchFilterClauseSyntax filter;
    internal readonly BlockSyntax block;

    internal CatchClauseSyntax(SyntaxKind kind, SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(catchKeyword);
        this.catchKeyword = catchKeyword;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (filter != null)
        {
            this.AdjustFlagsAndWidth(filter);
            this.filter = filter;
        }
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal CatchClauseSyntax(SyntaxKind kind, SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(catchKeyword);
        this.catchKeyword = catchKeyword;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (filter != null)
        {
            this.AdjustFlagsAndWidth(filter);
            this.filter = filter;
        }
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal CatchClauseSyntax(SyntaxKind kind, SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(catchKeyword);
        this.catchKeyword = catchKeyword;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (filter != null)
        {
            this.AdjustFlagsAndWidth(filter);
            this.filter = filter;
        }
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }

    public SyntaxToken CatchKeyword { get { return this.catchKeyword; } }
    public CatchDeclarationSyntax Declaration { get { return this.declaration; } }
    public CatchFilterClauseSyntax Filter { get { return this.filter; } }
    public BlockSyntax Block { get { return this.block; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.catchKeyword;
            case 1: return this.declaration;
            case 2: return this.filter;
            case 3: return this.block;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CatchClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCatchClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCatchClause(this);
    }

    public CatchClauseSyntax Update(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)
    {
        if (catchKeyword != this.CatchKeyword || declaration != this.Declaration || filter != this.Filter || block != this.Block)
        {
            var newNode = SyntaxFactory.CatchClause(catchKeyword, declaration, filter, block);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CatchClauseSyntax(this.Kind, this.catchKeyword, this.declaration, this.filter, this.block, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CatchClauseSyntax(this.Kind, this.catchKeyword, this.declaration, this.filter, this.block, GetDiagnostics(), annotations);
    }

    internal CatchClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var catchKeyword = (SyntaxToken)reader.ReadValue();
      if (catchKeyword != null)
      {
         AdjustFlagsAndWidth(catchKeyword);
         this.catchKeyword = catchKeyword;
      }
      var declaration = (CatchDeclarationSyntax)reader.ReadValue();
      if (declaration != null)
      {
         AdjustFlagsAndWidth(declaration);
         this.declaration = declaration;
      }
      var filter = (CatchFilterClauseSyntax)reader.ReadValue();
      if (filter != null)
      {
         AdjustFlagsAndWidth(filter);
         this.filter = filter;
      }
      var block = (BlockSyntax)reader.ReadValue();
      if (block != null)
      {
         AdjustFlagsAndWidth(block);
         this.block = block;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.catchKeyword);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.filter);
      writer.WriteValue(this.block);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new CatchClauseSyntax(r);
    }
  }

  internal sealed partial class CatchDeclarationSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken closeParenToken;

    internal CatchDeclarationSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (identifier != null)
        {
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CatchDeclarationSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (identifier != null)
        {
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CatchDeclarationSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (identifier != null)
        {
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public TypeSyntax Type { get { return this.type; } }
    public SyntaxToken Identifier { get { return this.identifier; } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.type;
            case 2: return this.identifier;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CatchDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCatchDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCatchDeclaration(this);
    }

    public CatchDeclarationSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || type != this.Type || identifier != this.Identifier || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.CatchDeclaration(openParenToken, type, identifier, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CatchDeclarationSyntax(this.Kind, this.openParenToken, this.type, this.identifier, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CatchDeclarationSyntax(this.Kind, this.openParenToken, this.type, this.identifier, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal CatchDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.closeParenToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new CatchDeclarationSyntax(r);
    }
  }

  internal sealed partial class CatchFilterClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken whenKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax filterExpression;
    internal readonly SyntaxToken closeParenToken;

    internal CatchFilterClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(whenKeyword);
        this.whenKeyword = whenKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(filterExpression);
        this.filterExpression = filterExpression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CatchFilterClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(whenKeyword);
        this.whenKeyword = whenKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(filterExpression);
        this.filterExpression = filterExpression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CatchFilterClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(whenKeyword);
        this.whenKeyword = whenKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(filterExpression);
        this.filterExpression = filterExpression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    public SyntaxToken WhenKeyword { get { return this.whenKeyword; } }
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public ExpressionSyntax FilterExpression { get { return this.filterExpression; } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.whenKeyword;
            case 1: return this.openParenToken;
            case 2: return this.filterExpression;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CatchFilterClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCatchFilterClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCatchFilterClause(this);
    }

    public CatchFilterClauseSyntax Update(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)
    {
        if (whenKeyword != this.WhenKeyword || openParenToken != this.OpenParenToken || filterExpression != this.FilterExpression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.CatchFilterClause(whenKeyword, openParenToken, filterExpression, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CatchFilterClauseSyntax(this.Kind, this.whenKeyword, this.openParenToken, this.filterExpression, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CatchFilterClauseSyntax(this.Kind, this.whenKeyword, this.openParenToken, this.filterExpression, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal CatchFilterClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var whenKeyword = (SyntaxToken)reader.ReadValue();
      if (whenKeyword != null)
      {
         AdjustFlagsAndWidth(whenKeyword);
         this.whenKeyword = whenKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var filterExpression = (ExpressionSyntax)reader.ReadValue();
      if (filterExpression != null)
      {
         AdjustFlagsAndWidth(filterExpression);
         this.filterExpression = filterExpression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.whenKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.filterExpression);
      writer.WriteValue(this.closeParenToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new CatchFilterClauseSyntax(r);
    }
  }

  internal sealed partial class FinallyClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken finallyKeyword;
    internal readonly BlockSyntax block;

    internal FinallyClauseSyntax(SyntaxKind kind, SyntaxToken finallyKeyword, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(finallyKeyword);
        this.finallyKeyword = finallyKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal FinallyClauseSyntax(SyntaxKind kind, SyntaxToken finallyKeyword, BlockSyntax block, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(finallyKeyword);
        this.finallyKeyword = finallyKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal FinallyClauseSyntax(SyntaxKind kind, SyntaxToken finallyKeyword, BlockSyntax block)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(finallyKeyword);
        this.finallyKeyword = finallyKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }

    public SyntaxToken FinallyKeyword { get { return this.finallyKeyword; } }
    public BlockSyntax Block { get { return this.block; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.finallyKeyword;
            case 1: return this.block;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.FinallyClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFinallyClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitFinallyClause(this);
    }

    public FinallyClauseSyntax Update(SyntaxToken finallyKeyword, BlockSyntax block)
    {
        if (finallyKeyword != this.FinallyKeyword || block != this.Block)
        {
            var newNode = SyntaxFactory.FinallyClause(finallyKeyword, block);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new FinallyClauseSyntax(this.Kind, this.finallyKeyword, this.block, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new FinallyClauseSyntax(this.Kind, this.finallyKeyword, this.block, GetDiagnostics(), annotations);
    }

    internal FinallyClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var finallyKeyword = (SyntaxToken)reader.ReadValue();
      if (finallyKeyword != null)
      {
         AdjustFlagsAndWidth(finallyKeyword);
         this.finallyKeyword = finallyKeyword;
      }
      var block = (BlockSyntax)reader.ReadValue();
      if (block != null)
      {
         AdjustFlagsAndWidth(block);
         this.block = block;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.finallyKeyword);
      writer.WriteValue(this.block);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new FinallyClauseSyntax(r);
    }
  }

  internal sealed partial class CompilationUnitSyntax : CSharpSyntaxNode
  {
    internal readonly CSharpSyntaxNode externs;
    internal readonly CSharpSyntaxNode usings;
    internal readonly CSharpSyntaxNode attributeLists;
    internal readonly CSharpSyntaxNode members;
    internal readonly SyntaxToken endOfFileToken;

    internal CompilationUnitSyntax(SyntaxKind kind, CSharpSyntaxNode externs, CSharpSyntaxNode usings, CSharpSyntaxNode attributeLists, CSharpSyntaxNode members, SyntaxToken endOfFileToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        if (externs != null)
        {
            this.AdjustFlagsAndWidth(externs);
            this.externs = externs;
        }
        if (usings != null)
        {
            this.AdjustFlagsAndWidth(usings);
            this.usings = usings;
        }
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(endOfFileToken);
        this.endOfFileToken = endOfFileToken;
    }


    internal CompilationUnitSyntax(SyntaxKind kind, CSharpSyntaxNode externs, CSharpSyntaxNode usings, CSharpSyntaxNode attributeLists, CSharpSyntaxNode members, SyntaxToken endOfFileToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        if (externs != null)
        {
            this.AdjustFlagsAndWidth(externs);
            this.externs = externs;
        }
        if (usings != null)
        {
            this.AdjustFlagsAndWidth(usings);
            this.usings = usings;
        }
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(endOfFileToken);
        this.endOfFileToken = endOfFileToken;
    }


    internal CompilationUnitSyntax(SyntaxKind kind, CSharpSyntaxNode externs, CSharpSyntaxNode usings, CSharpSyntaxNode attributeLists, CSharpSyntaxNode members, SyntaxToken endOfFileToken)
        : base(kind)
    {
        this.SlotCount = 5;
        if (externs != null)
        {
            this.AdjustFlagsAndWidth(externs);
            this.externs = externs;
        }
        if (usings != null)
        {
            this.AdjustFlagsAndWidth(usings);
            this.usings = usings;
        }
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(endOfFileToken);
        this.endOfFileToken = endOfFileToken;
    }

    public SyntaxList<ExternAliasDirectiveSyntax> Externs { get { return new SyntaxList<ExternAliasDirectiveSyntax>(this.externs); } }
    public SyntaxList<UsingDirectiveSyntax> Usings { get { return new SyntaxList<UsingDirectiveSyntax>(this.usings); } }
    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public SyntaxList<MemberDeclarationSyntax> Members { get { return new SyntaxList<MemberDeclarationSyntax>(this.members); } }
    public SyntaxToken EndOfFileToken { get { return this.endOfFileToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.externs;
            case 1: return this.usings;
            case 2: return this.attributeLists;
            case 3: return this.members;
            case 4: return this.endOfFileToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CompilationUnitSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCompilationUnit(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCompilationUnit(this);
    }

    public CompilationUnitSyntax Update(SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)
    {
        if (externs != this.Externs || usings != this.Usings || attributeLists != this.AttributeLists || members != this.Members || endOfFileToken != this.EndOfFileToken)
        {
            var newNode = SyntaxFactory.CompilationUnit(externs, usings, attributeLists, members, endOfFileToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CompilationUnitSyntax(this.Kind, this.externs, this.usings, this.attributeLists, this.members, this.endOfFileToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CompilationUnitSyntax(this.Kind, this.externs, this.usings, this.attributeLists, this.members, this.endOfFileToken, GetDiagnostics(), annotations);
    }

    internal CompilationUnitSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var externs = (CSharpSyntaxNode)reader.ReadValue();
      if (externs != null)
      {
         AdjustFlagsAndWidth(externs);
         this.externs = externs;
      }
      var usings = (CSharpSyntaxNode)reader.ReadValue();
      if (usings != null)
      {
         AdjustFlagsAndWidth(usings);
         this.usings = usings;
      }
      var attributeLists = (CSharpSyntaxNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var members = (CSharpSyntaxNode)reader.ReadValue();
      if (members != null)
      {
         AdjustFlagsAndWidth(members);
         this.members = members;
      }
      var endOfFileToken = (SyntaxToken)reader.ReadValue();
      if (endOfFileToken != null)
      {
         AdjustFlagsAndWidth(endOfFileToken);
         this.endOfFileToken = endOfFileToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.externs);
      writer.WriteValue(this.usings);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.members);
      writer.WriteValue(this.endOfFileToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new CompilationUnitSyntax(r);
    }
  }

  /// <summary>
  /// Represents an ExternAlias directive syntax, e.g. "extern alias MyAlias;" with specifying "/r:MyAlias=SomeAssembly.dll " on the compiler command line.
  /// </summary>
  internal sealed partial class ExternAliasDirectiveSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken externKeyword;
    internal readonly SyntaxToken aliasKeyword;
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken semicolonToken;

    internal ExternAliasDirectiveSyntax(SyntaxKind kind, SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(externKeyword);
        this.externKeyword = externKeyword;
        this.AdjustFlagsAndWidth(aliasKeyword);
        this.aliasKeyword = aliasKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ExternAliasDirectiveSyntax(SyntaxKind kind, SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(externKeyword);
        this.externKeyword = externKeyword;
        this.AdjustFlagsAndWidth(aliasKeyword);
        this.aliasKeyword = aliasKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ExternAliasDirectiveSyntax(SyntaxKind kind, SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(externKeyword);
        this.externKeyword = externKeyword;
        this.AdjustFlagsAndWidth(aliasKeyword);
        this.aliasKeyword = aliasKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    /// <summary>SyntaxToken representing the extern keyword.</summary>
    public SyntaxToken ExternKeyword { get { return this.externKeyword; } }
    /// <summary>SyntaxToken representing the alias keyword.</summary>
    public SyntaxToken AliasKeyword { get { return this.aliasKeyword; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    /// <summary>SyntaxToken representing the semicolon token.</summary>
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.externKeyword;
            case 1: return this.aliasKeyword;
            case 2: return this.identifier;
            case 3: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ExternAliasDirectiveSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitExternAliasDirective(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitExternAliasDirective(this);
    }

    public ExternAliasDirectiveSyntax Update(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
    {
        if (externKeyword != this.ExternKeyword || aliasKeyword != this.AliasKeyword || identifier != this.Identifier || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ExternAliasDirective(externKeyword, aliasKeyword, identifier, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ExternAliasDirectiveSyntax(this.Kind, this.externKeyword, this.aliasKeyword, this.identifier, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ExternAliasDirectiveSyntax(this.Kind, this.externKeyword, this.aliasKeyword, this.identifier, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ExternAliasDirectiveSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var externKeyword = (SyntaxToken)reader.ReadValue();
      if (externKeyword != null)
      {
         AdjustFlagsAndWidth(externKeyword);
         this.externKeyword = externKeyword;
      }
      var aliasKeyword = (SyntaxToken)reader.ReadValue();
      if (aliasKeyword != null)
      {
         AdjustFlagsAndWidth(aliasKeyword);
         this.aliasKeyword = aliasKeyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.externKeyword);
      writer.WriteValue(this.aliasKeyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ExternAliasDirectiveSyntax(r);
    }
  }

  internal sealed partial class UsingDirectiveSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken usingKeyword;
    internal readonly SyntaxToken staticKeyword;
    internal readonly NameEqualsSyntax alias;
    internal readonly NameSyntax name;
    internal readonly SyntaxToken semicolonToken;

    internal UsingDirectiveSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(usingKeyword);
        this.usingKeyword = usingKeyword;
        if (staticKeyword != null)
        {
            this.AdjustFlagsAndWidth(staticKeyword);
            this.staticKeyword = staticKeyword;
        }
        if (alias != null)
        {
            this.AdjustFlagsAndWidth(alias);
            this.alias = alias;
        }
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal UsingDirectiveSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(usingKeyword);
        this.usingKeyword = usingKeyword;
        if (staticKeyword != null)
        {
            this.AdjustFlagsAndWidth(staticKeyword);
            this.staticKeyword = staticKeyword;
        }
        if (alias != null)
        {
            this.AdjustFlagsAndWidth(alias);
            this.alias = alias;
        }
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal UsingDirectiveSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(usingKeyword);
        this.usingKeyword = usingKeyword;
        if (staticKeyword != null)
        {
            this.AdjustFlagsAndWidth(staticKeyword);
            this.staticKeyword = staticKeyword;
        }
        if (alias != null)
        {
            this.AdjustFlagsAndWidth(alias);
            this.alias = alias;
        }
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken UsingKeyword { get { return this.usingKeyword; } }
    public SyntaxToken StaticKeyword { get { return this.staticKeyword; } }
    public NameEqualsSyntax Alias { get { return this.alias; } }
    public NameSyntax Name { get { return this.name; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.usingKeyword;
            case 1: return this.staticKeyword;
            case 2: return this.alias;
            case 3: return this.name;
            case 4: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.UsingDirectiveSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitUsingDirective(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitUsingDirective(this);
    }

    public UsingDirectiveSyntax Update(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)
    {
        if (usingKeyword != this.UsingKeyword || staticKeyword != this.StaticKeyword || alias != this.Alias || name != this.Name || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.UsingDirective(usingKeyword, staticKeyword, alias, name, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new UsingDirectiveSyntax(this.Kind, this.usingKeyword, this.staticKeyword, this.alias, this.name, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new UsingDirectiveSyntax(this.Kind, this.usingKeyword, this.staticKeyword, this.alias, this.name, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal UsingDirectiveSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var usingKeyword = (SyntaxToken)reader.ReadValue();
      if (usingKeyword != null)
      {
         AdjustFlagsAndWidth(usingKeyword);
         this.usingKeyword = usingKeyword;
      }
      var staticKeyword = (SyntaxToken)reader.ReadValue();
      if (staticKeyword != null)
      {
         AdjustFlagsAndWidth(staticKeyword);
         this.staticKeyword = staticKeyword;
      }
      var alias = (NameEqualsSyntax)reader.ReadValue();
      if (alias != null)
      {
         AdjustFlagsAndWidth(alias);
         this.alias = alias;
      }
      var name = (NameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.usingKeyword);
      writer.WriteValue(this.staticKeyword);
      writer.WriteValue(this.alias);
      writer.WriteValue(this.name);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new UsingDirectiveSyntax(r);
    }
  }

  /// <summary>Member declaration syntax.</summary>
  internal abstract partial class MemberDeclarationSyntax : CSharpSyntaxNode
  {
    internal MemberDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal MemberDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected MemberDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal sealed partial class NamespaceDeclarationSyntax : MemberDeclarationSyntax
  {
    internal readonly SyntaxToken namespaceKeyword;
    internal readonly NameSyntax name;
    internal readonly SyntaxToken openBraceToken;
    internal readonly CSharpSyntaxNode externs;
    internal readonly CSharpSyntaxNode usings;
    internal readonly CSharpSyntaxNode members;
    internal readonly SyntaxToken closeBraceToken;
    internal readonly SyntaxToken semicolonToken;

    internal NamespaceDeclarationSyntax(SyntaxKind kind, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, CSharpSyntaxNode externs, CSharpSyntaxNode usings, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 8;
        this.AdjustFlagsAndWidth(namespaceKeyword);
        this.namespaceKeyword = namespaceKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (externs != null)
        {
            this.AdjustFlagsAndWidth(externs);
            this.externs = externs;
        }
        if (usings != null)
        {
            this.AdjustFlagsAndWidth(usings);
            this.usings = usings;
        }
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal NamespaceDeclarationSyntax(SyntaxKind kind, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, CSharpSyntaxNode externs, CSharpSyntaxNode usings, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 8;
        this.AdjustFlagsAndWidth(namespaceKeyword);
        this.namespaceKeyword = namespaceKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (externs != null)
        {
            this.AdjustFlagsAndWidth(externs);
            this.externs = externs;
        }
        if (usings != null)
        {
            this.AdjustFlagsAndWidth(usings);
            this.usings = usings;
        }
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal NamespaceDeclarationSyntax(SyntaxKind kind, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, CSharpSyntaxNode externs, CSharpSyntaxNode usings, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 8;
        this.AdjustFlagsAndWidth(namespaceKeyword);
        this.namespaceKeyword = namespaceKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (externs != null)
        {
            this.AdjustFlagsAndWidth(externs);
            this.externs = externs;
        }
        if (usings != null)
        {
            this.AdjustFlagsAndWidth(usings);
            this.usings = usings;
        }
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public SyntaxToken NamespaceKeyword { get { return this.namespaceKeyword; } }
    public NameSyntax Name { get { return this.name; } }
    public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    public SyntaxList<ExternAliasDirectiveSyntax> Externs { get { return new SyntaxList<ExternAliasDirectiveSyntax>(this.externs); } }
    public SyntaxList<UsingDirectiveSyntax> Usings { get { return new SyntaxList<UsingDirectiveSyntax>(this.usings); } }
    public SyntaxList<MemberDeclarationSyntax> Members { get { return new SyntaxList<MemberDeclarationSyntax>(this.members); } }
    public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }
    /// <summary>Gets the optional semicolon token.</summary>
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.namespaceKeyword;
            case 1: return this.name;
            case 2: return this.openBraceToken;
            case 3: return this.externs;
            case 4: return this.usings;
            case 5: return this.members;
            case 6: return this.closeBraceToken;
            case 7: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.NamespaceDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNamespaceDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitNamespaceDeclaration(this);
    }

    public NamespaceDeclarationSyntax Update(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (namespaceKeyword != this.NamespaceKeyword || name != this.Name || openBraceToken != this.OpenBraceToken || externs != this.Externs || usings != this.Usings || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.NamespaceDeclaration(namespaceKeyword, name, openBraceToken, externs, usings, members, closeBraceToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new NamespaceDeclarationSyntax(this.Kind, this.namespaceKeyword, this.name, this.openBraceToken, this.externs, this.usings, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new NamespaceDeclarationSyntax(this.Kind, this.namespaceKeyword, this.name, this.openBraceToken, this.externs, this.usings, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal NamespaceDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 8;
      var namespaceKeyword = (SyntaxToken)reader.ReadValue();
      if (namespaceKeyword != null)
      {
         AdjustFlagsAndWidth(namespaceKeyword);
         this.namespaceKeyword = namespaceKeyword;
      }
      var name = (NameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var externs = (CSharpSyntaxNode)reader.ReadValue();
      if (externs != null)
      {
         AdjustFlagsAndWidth(externs);
         this.externs = externs;
      }
      var usings = (CSharpSyntaxNode)reader.ReadValue();
      if (usings != null)
      {
         AdjustFlagsAndWidth(usings);
         this.usings = usings;
      }
      var members = (CSharpSyntaxNode)reader.ReadValue();
      if (members != null)
      {
         AdjustFlagsAndWidth(members);
         this.members = members;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.namespaceKeyword);
      writer.WriteValue(this.name);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.externs);
      writer.WriteValue(this.usings);
      writer.WriteValue(this.members);
      writer.WriteValue(this.closeBraceToken);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new NamespaceDeclarationSyntax(r);
    }
  }

  /// <summary>Class representing one or more attributes applied to a language construct.</summary>
  internal sealed partial class AttributeListSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken openBracketToken;
    internal readonly AttributeTargetSpecifierSyntax target;
    internal readonly CSharpSyntaxNode attributes;
    internal readonly SyntaxToken closeBracketToken;

    internal AttributeListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, CSharpSyntaxNode attributes, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (target != null)
        {
            this.AdjustFlagsAndWidth(target);
            this.target = target;
        }
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal AttributeListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, CSharpSyntaxNode attributes, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (target != null)
        {
            this.AdjustFlagsAndWidth(target);
            this.target = target;
        }
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal AttributeListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, CSharpSyntaxNode attributes, SyntaxToken closeBracketToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (target != null)
        {
            this.AdjustFlagsAndWidth(target);
            this.target = target;
        }
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }

    /// <summary>Gets the open bracket token.</summary>
    public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
    /// <summary>Gets the optional construct targeted by the attribute.</summary>
    public AttributeTargetSpecifierSyntax Target { get { return this.target; } }
    /// <summary>Gets the attribute declaration list.</summary>
    public SeparatedSyntaxList<AttributeSyntax> Attributes { get { return new SeparatedSyntaxList<AttributeSyntax>(new SyntaxList<CSharpSyntaxNode>(this.attributes)); } }
    /// <summary>Gets the close bracket token.</summary>
    public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBracketToken;
            case 1: return this.target;
            case 2: return this.attributes;
            case 3: return this.closeBracketToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AttributeListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttributeList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAttributeList(this);
    }

    public AttributeListSyntax Update(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || target != this.Target || attributes != this.Attributes || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.AttributeList(openBracketToken, target, attributes, closeBracketToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AttributeListSyntax(this.Kind, this.openBracketToken, this.target, this.attributes, this.closeBracketToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AttributeListSyntax(this.Kind, this.openBracketToken, this.target, this.attributes, this.closeBracketToken, GetDiagnostics(), annotations);
    }

    internal AttributeListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var openBracketToken = (SyntaxToken)reader.ReadValue();
      if (openBracketToken != null)
      {
         AdjustFlagsAndWidth(openBracketToken);
         this.openBracketToken = openBracketToken;
      }
      var target = (AttributeTargetSpecifierSyntax)reader.ReadValue();
      if (target != null)
      {
         AdjustFlagsAndWidth(target);
         this.target = target;
      }
      var attributes = (CSharpSyntaxNode)reader.ReadValue();
      if (attributes != null)
      {
         AdjustFlagsAndWidth(attributes);
         this.attributes = attributes;
      }
      var closeBracketToken = (SyntaxToken)reader.ReadValue();
      if (closeBracketToken != null)
      {
         AdjustFlagsAndWidth(closeBracketToken);
         this.closeBracketToken = closeBracketToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.target);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.closeBracketToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new AttributeListSyntax(r);
    }
  }

  /// <summary>Class representing what language construct an attribute targets.</summary>
  internal sealed partial class AttributeTargetSpecifierSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken colonToken;

    internal AttributeTargetSpecifierSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal AttributeTargetSpecifierSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal AttributeTargetSpecifierSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken { get { return this.colonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            case 1: return this.colonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AttributeTargetSpecifierSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttributeTargetSpecifier(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAttributeTargetSpecifier(this);
    }

    public AttributeTargetSpecifierSyntax Update(SyntaxToken identifier, SyntaxToken colonToken)
    {
        if (identifier != this.Identifier || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.AttributeTargetSpecifier(identifier, colonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AttributeTargetSpecifierSyntax(this.Kind, this.identifier, this.colonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AttributeTargetSpecifierSyntax(this.Kind, this.identifier, this.colonToken, GetDiagnostics(), annotations);
    }

    internal AttributeTargetSpecifierSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.colonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new AttributeTargetSpecifierSyntax(r);
    }
  }

  /// <summary>Attribute syntax.</summary>
  internal sealed partial class AttributeSyntax : CSharpSyntaxNode
  {
    internal readonly NameSyntax name;
    internal readonly AttributeArgumentListSyntax argumentList;

    internal AttributeSyntax(SyntaxKind kind, NameSyntax name, AttributeArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
    }


    internal AttributeSyntax(SyntaxKind kind, NameSyntax name, AttributeArgumentListSyntax argumentList, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
    }


    internal AttributeSyntax(SyntaxKind kind, NameSyntax name, AttributeArgumentListSyntax argumentList)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
    }

    /// <summary>Gets the name.</summary>
    public NameSyntax Name { get { return this.name; } }
    public AttributeArgumentListSyntax ArgumentList { get { return this.argumentList; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.argumentList;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AttributeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttribute(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAttribute(this);
    }

    public AttributeSyntax Update(NameSyntax name, AttributeArgumentListSyntax argumentList)
    {
        if (name != this.Name || argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.Attribute(name, argumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AttributeSyntax(this.Kind, this.name, this.argumentList, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AttributeSyntax(this.Kind, this.name, this.argumentList, GetDiagnostics(), annotations);
    }

    internal AttributeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var name = (NameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var argumentList = (AttributeArgumentListSyntax)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.argumentList);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new AttributeSyntax(r);
    }
  }

  /// <summary>Attribute argument list syntax.</summary>
  internal sealed partial class AttributeArgumentListSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly CSharpSyntaxNode arguments;
    internal readonly SyntaxToken closeParenToken;

    internal AttributeArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode arguments, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal AttributeArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode arguments, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal AttributeArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode arguments, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>Gets the open paren token.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Gets the arguments syntax list.</summary>
    public SeparatedSyntaxList<AttributeArgumentSyntax> Arguments { get { return new SeparatedSyntaxList<AttributeArgumentSyntax>(new SyntaxList<CSharpSyntaxNode>(this.arguments)); } }
    /// <summary>Gets the close paren token.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.arguments;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AttributeArgumentListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttributeArgumentList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAttributeArgumentList(this);
    }

    public AttributeArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.AttributeArgumentList(openParenToken, arguments, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AttributeArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AttributeArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal AttributeArgumentListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var arguments = (CSharpSyntaxNode)reader.ReadValue();
      if (arguments != null)
      {
         AdjustFlagsAndWidth(arguments);
         this.arguments = arguments;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.arguments);
      writer.WriteValue(this.closeParenToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new AttributeArgumentListSyntax(r);
    }
  }

  /// <summary>Attribute argument syntax.</summary>
  internal sealed partial class AttributeArgumentSyntax : CSharpSyntaxNode
  {
    internal readonly NameEqualsSyntax nameEquals;
    internal readonly NameColonSyntax nameColon;
    internal readonly ExpressionSyntax expression;

    internal AttributeArgumentSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        if (nameEquals != null)
        {
            this.AdjustFlagsAndWidth(nameEquals);
            this.nameEquals = nameEquals;
        }
        if (nameColon != null)
        {
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal AttributeArgumentSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        if (nameEquals != null)
        {
            this.AdjustFlagsAndWidth(nameEquals);
            this.nameEquals = nameEquals;
        }
        if (nameColon != null)
        {
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal AttributeArgumentSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 3;
        if (nameEquals != null)
        {
            this.AdjustFlagsAndWidth(nameEquals);
            this.nameEquals = nameEquals;
        }
        if (nameColon != null)
        {
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    public NameEqualsSyntax NameEquals { get { return this.nameEquals; } }
    public NameColonSyntax NameColon { get { return this.nameColon; } }
    /// <summary>Gets the expression.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nameEquals;
            case 1: return this.nameColon;
            case 2: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AttributeArgumentSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttributeArgument(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAttributeArgument(this);
    }

    public AttributeArgumentSyntax Update(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
    {
        if (nameEquals != this.NameEquals || nameColon != this.NameColon || expression != this.Expression)
        {
            var newNode = SyntaxFactory.AttributeArgument(nameEquals, nameColon, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AttributeArgumentSyntax(this.Kind, this.nameEquals, this.nameColon, this.expression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AttributeArgumentSyntax(this.Kind, this.nameEquals, this.nameColon, this.expression, GetDiagnostics(), annotations);
    }

    internal AttributeArgumentSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var nameEquals = (NameEqualsSyntax)reader.ReadValue();
      if (nameEquals != null)
      {
         AdjustFlagsAndWidth(nameEquals);
         this.nameEquals = nameEquals;
      }
      var nameColon = (NameColonSyntax)reader.ReadValue();
      if (nameColon != null)
      {
         AdjustFlagsAndWidth(nameColon);
         this.nameColon = nameColon;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.nameEquals);
      writer.WriteValue(this.nameColon);
      writer.WriteValue(this.expression);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new AttributeArgumentSyntax(r);
    }
  }

  /// <summary>Class representing an identifier name followed by an equals token.</summary>
  internal sealed partial class NameEqualsSyntax : CSharpSyntaxNode
  {
    internal readonly IdentifierNameSyntax name;
    internal readonly SyntaxToken equalsToken;

    internal NameEqualsSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken equalsToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
    }


    internal NameEqualsSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken equalsToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
    }


    internal NameEqualsSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken equalsToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
    }

    /// <summary>Gets the identifier name.</summary>
    public IdentifierNameSyntax Name { get { return this.name; } }
    public SyntaxToken EqualsToken { get { return this.equalsToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.equalsToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.NameEqualsSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNameEquals(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitNameEquals(this);
    }

    public NameEqualsSyntax Update(IdentifierNameSyntax name, SyntaxToken equalsToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken)
        {
            var newNode = SyntaxFactory.NameEquals(name, equalsToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new NameEqualsSyntax(this.Kind, this.name, this.equalsToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new NameEqualsSyntax(this.Kind, this.name, this.equalsToken, GetDiagnostics(), annotations);
    }

    internal NameEqualsSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var name = (IdentifierNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var equalsToken = (SyntaxToken)reader.ReadValue();
      if (equalsToken != null)
      {
         AdjustFlagsAndWidth(equalsToken);
         this.equalsToken = equalsToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.equalsToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new NameEqualsSyntax(r);
    }
  }

  /// <summary>Type parameter list syntax.</summary>
  internal sealed partial class TypeParameterListSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken lessThanToken;
    internal readonly CSharpSyntaxNode parameters;
    internal readonly SyntaxToken greaterThanToken;

    internal TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, CSharpSyntaxNode parameters, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, CSharpSyntaxNode parameters, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, CSharpSyntaxNode parameters, SyntaxToken greaterThanToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }

    /// <summary>Gets the &lt; token.</summary>
    public SyntaxToken LessThanToken { get { return this.lessThanToken; } }
    /// <summary>Gets the parameter list.</summary>
    public SeparatedSyntaxList<TypeParameterSyntax> Parameters { get { return new SeparatedSyntaxList<TypeParameterSyntax>(new SyntaxList<CSharpSyntaxNode>(this.parameters)); } }
    /// <summary>Gets the &gt; token.</summary>
    public SyntaxToken GreaterThanToken { get { return this.greaterThanToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanToken;
            case 1: return this.parameters;
            case 2: return this.greaterThanToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.TypeParameterListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeParameterList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeParameterList(this);
    }

    public TypeParameterListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || parameters != this.Parameters || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = SyntaxFactory.TypeParameterList(lessThanToken, parameters, greaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TypeParameterListSyntax(this.Kind, this.lessThanToken, this.parameters, this.greaterThanToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TypeParameterListSyntax(this.Kind, this.lessThanToken, this.parameters, this.greaterThanToken, GetDiagnostics(), annotations);
    }

    internal TypeParameterListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var lessThanToken = (SyntaxToken)reader.ReadValue();
      if (lessThanToken != null)
      {
         AdjustFlagsAndWidth(lessThanToken);
         this.lessThanToken = lessThanToken;
      }
      var parameters = (CSharpSyntaxNode)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
      var greaterThanToken = (SyntaxToken)reader.ReadValue();
      if (greaterThanToken != null)
      {
         AdjustFlagsAndWidth(greaterThanToken);
         this.greaterThanToken = greaterThanToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanToken);
      writer.WriteValue(this.parameters);
      writer.WriteValue(this.greaterThanToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new TypeParameterListSyntax(r);
    }
  }

  /// <summary>Type parameter syntax.</summary>
  internal sealed partial class TypeParameterSyntax : CSharpSyntaxNode
  {
    internal readonly CSharpSyntaxNode attributeLists;
    internal readonly SyntaxToken varianceKeyword;
    internal readonly SyntaxToken identifier;

    internal TypeParameterSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (varianceKeyword != null)
        {
            this.AdjustFlagsAndWidth(varianceKeyword);
            this.varianceKeyword = varianceKeyword;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal TypeParameterSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (varianceKeyword != null)
        {
            this.AdjustFlagsAndWidth(varianceKeyword);
            this.varianceKeyword = varianceKeyword;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal TypeParameterSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)
        : base(kind)
    {
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (varianceKeyword != null)
        {
            this.AdjustFlagsAndWidth(varianceKeyword);
            this.varianceKeyword = varianceKeyword;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public SyntaxToken VarianceKeyword { get { return this.varianceKeyword; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.varianceKeyword;
            case 2: return this.identifier;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.TypeParameterSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeParameter(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeParameter(this);
    }

    public TypeParameterSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)
    {
        if (attributeLists != this.AttributeLists || varianceKeyword != this.VarianceKeyword || identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.TypeParameter(attributeLists, varianceKeyword, identifier);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TypeParameterSyntax(this.Kind, this.attributeLists, this.varianceKeyword, this.identifier, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TypeParameterSyntax(this.Kind, this.attributeLists, this.varianceKeyword, this.identifier, GetDiagnostics(), annotations);
    }

    internal TypeParameterSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var attributeLists = (CSharpSyntaxNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var varianceKeyword = (SyntaxToken)reader.ReadValue();
      if (varianceKeyword != null)
      {
         AdjustFlagsAndWidth(varianceKeyword);
         this.varianceKeyword = varianceKeyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.varianceKeyword);
      writer.WriteValue(this.identifier);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new TypeParameterSyntax(r);
    }
  }

  /// <summary>Base class for type declaration syntax.</summary>
  internal abstract partial class BaseTypeDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BaseTypeDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseTypeDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseTypeDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }

    /// <summary>Gets the modifier list.</summary>
    public abstract SyntaxList<SyntaxToken> Modifiers { get; }

    /// <summary>Gets the identifier.</summary>
    public abstract SyntaxToken Identifier { get; }

    /// <summary>Gets the base type list.</summary>
    public abstract BaseListSyntax BaseList { get; }

    /// <summary>Gets the open brace token.</summary>
    public abstract SyntaxToken OpenBraceToken { get; }

    /// <summary>Gets the close brace token.</summary>
    public abstract SyntaxToken CloseBraceToken { get; }

    /// <summary>Gets the optional semicolon token.</summary>
    public abstract SyntaxToken SemicolonToken { get; }
  }

  /// <summary>Base class for type declaration syntax (class, struct, interface).</summary>
  internal abstract partial class TypeDeclarationSyntax : BaseTypeDeclarationSyntax
  {
    internal TypeDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal TypeDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected TypeDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the type keyword token ("class", "struct", "interface").</summary>
    public abstract SyntaxToken Keyword { get; }

    public abstract TypeParameterListSyntax TypeParameterList { get; }

    /// <summary>Gets the type constraint list.</summary>
    public abstract SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }

    /// <summary>Gets the member declarations.</summary>
    public abstract SyntaxList<MemberDeclarationSyntax> Members { get; }
  }

  /// <summary>Class type declaration syntax.</summary>
  internal sealed partial class ClassDeclarationSyntax : TypeDeclarationSyntax
  {
    internal readonly CSharpSyntaxNode attributeLists;
    internal readonly CSharpSyntaxNode modifiers;
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken identifier;
    internal readonly TypeParameterListSyntax typeParameterList;
    internal readonly BaseListSyntax baseList;
    internal readonly CSharpSyntaxNode constraintClauses;
    internal readonly SyntaxToken openBraceToken;
    internal readonly CSharpSyntaxNode members;
    internal readonly SyntaxToken closeBraceToken;
    internal readonly SyntaxToken semicolonToken;

    internal ClassDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, CSharpSyntaxNode constraintClauses, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal ClassDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, CSharpSyntaxNode constraintClauses, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal ClassDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, CSharpSyntaxNode constraintClauses, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the class keyword token.</summary>
    public override SyntaxToken Keyword { get { return this.keyword; } }
    public override SyntaxToken Identifier { get { return this.identifier; } }
    public override TypeParameterListSyntax TypeParameterList { get { return this.typeParameterList; } }
    public override BaseListSyntax BaseList { get { return this.baseList; } }
    public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses); } }
    public override SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    public override SyntaxList<MemberDeclarationSyntax> Members { get { return new SyntaxList<MemberDeclarationSyntax>(this.members); } }
    public override SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.keyword;
            case 3: return this.identifier;
            case 4: return this.typeParameterList;
            case 5: return this.baseList;
            case 6: return this.constraintClauses;
            case 7: return this.openBraceToken;
            case 8: return this.members;
            case 9: return this.closeBraceToken;
            case 10: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ClassDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitClassDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitClassDeclaration(this);
    }

    public ClassDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ClassDeclaration(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ClassDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ClassDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ClassDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 11;
      var attributeLists = (CSharpSyntaxNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (CSharpSyntaxNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var typeParameterList = (TypeParameterListSyntax)reader.ReadValue();
      if (typeParameterList != null)
      {
         AdjustFlagsAndWidth(typeParameterList);
         this.typeParameterList = typeParameterList;
      }
      var baseList = (BaseListSyntax)reader.ReadValue();
      if (baseList != null)
      {
         AdjustFlagsAndWidth(baseList);
         this.baseList = baseList;
      }
      var constraintClauses = (CSharpSyntaxNode)reader.ReadValue();
      if (constraintClauses != null)
      {
         AdjustFlagsAndWidth(constraintClauses);
         this.constraintClauses = constraintClauses;
      }
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var members = (CSharpSyntaxNode)reader.ReadValue();
      if (members != null)
      {
         AdjustFlagsAndWidth(members);
         this.members = members;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeParameterList);
      writer.WriteValue(this.baseList);
      writer.WriteValue(this.constraintClauses);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.members);
      writer.WriteValue(this.closeBraceToken);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ClassDeclarationSyntax(r);
    }
  }

  /// <summary>Struct type declaration syntax.</summary>
  internal sealed partial class StructDeclarationSyntax : TypeDeclarationSyntax
  {
    internal readonly CSharpSyntaxNode attributeLists;
    internal readonly CSharpSyntaxNode modifiers;
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken identifier;
    internal readonly TypeParameterListSyntax typeParameterList;
    internal readonly BaseListSyntax baseList;
    internal readonly CSharpSyntaxNode constraintClauses;
    internal readonly SyntaxToken openBraceToken;
    internal readonly CSharpSyntaxNode members;
    internal readonly SyntaxToken closeBraceToken;
    internal readonly SyntaxToken semicolonToken;

    internal StructDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, CSharpSyntaxNode constraintClauses, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal StructDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, CSharpSyntaxNode constraintClauses, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal StructDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, CSharpSyntaxNode constraintClauses, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the struct keyword token.</summary>
    public override SyntaxToken Keyword { get { return this.keyword; } }
    public override SyntaxToken Identifier { get { return this.identifier; } }
    public override TypeParameterListSyntax TypeParameterList { get { return this.typeParameterList; } }
    public override BaseListSyntax BaseList { get { return this.baseList; } }
    public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses); } }
    public override SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    public override SyntaxList<MemberDeclarationSyntax> Members { get { return new SyntaxList<MemberDeclarationSyntax>(this.members); } }
    public override SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.keyword;
            case 3: return this.identifier;
            case 4: return this.typeParameterList;
            case 5: return this.baseList;
            case 6: return this.constraintClauses;
            case 7: return this.openBraceToken;
            case 8: return this.members;
            case 9: return this.closeBraceToken;
            case 10: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.StructDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitStructDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitStructDeclaration(this);
    }

    public StructDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.StructDeclaration(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new StructDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new StructDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal StructDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 11;
      var attributeLists = (CSharpSyntaxNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (CSharpSyntaxNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var typeParameterList = (TypeParameterListSyntax)reader.ReadValue();
      if (typeParameterList != null)
      {
         AdjustFlagsAndWidth(typeParameterList);
         this.typeParameterList = typeParameterList;
      }
      var baseList = (BaseListSyntax)reader.ReadValue();
      if (baseList != null)
      {
         AdjustFlagsAndWidth(baseList);
         this.baseList = baseList;
      }
      var constraintClauses = (CSharpSyntaxNode)reader.ReadValue();
      if (constraintClauses != null)
      {
         AdjustFlagsAndWidth(constraintClauses);
         this.constraintClauses = constraintClauses;
      }
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var members = (CSharpSyntaxNode)reader.ReadValue();
      if (members != null)
      {
         AdjustFlagsAndWidth(members);
         this.members = members;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeParameterList);
      writer.WriteValue(this.baseList);
      writer.WriteValue(this.constraintClauses);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.members);
      writer.WriteValue(this.closeBraceToken);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new StructDeclarationSyntax(r);
    }
  }

  /// <summary>Interface type declaration syntax.</summary>
  internal sealed partial class InterfaceDeclarationSyntax : TypeDeclarationSyntax
  {
    internal readonly CSharpSyntaxNode attributeLists;
    internal readonly CSharpSyntaxNode modifiers;
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken identifier;
    internal readonly TypeParameterListSyntax typeParameterList;
    internal readonly BaseListSyntax baseList;
    internal readonly CSharpSyntaxNode constraintClauses;
    internal readonly SyntaxToken openBraceToken;
    internal readonly CSharpSyntaxNode members;
    internal readonly SyntaxToken closeBraceToken;
    internal readonly SyntaxToken semicolonToken;

    internal InterfaceDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, CSharpSyntaxNode constraintClauses, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal InterfaceDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, CSharpSyntaxNode constraintClauses, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal InterfaceDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, CSharpSyntaxNode constraintClauses, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the interface keyword token.</summary>
    public override SyntaxToken Keyword { get { return this.keyword; } }
    public override SyntaxToken Identifier { get { return this.identifier; } }
    public override TypeParameterListSyntax TypeParameterList { get { return this.typeParameterList; } }
    public override BaseListSyntax BaseList { get { return this.baseList; } }
    public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses); } }
    public override SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    public override SyntaxList<MemberDeclarationSyntax> Members { get { return new SyntaxList<MemberDeclarationSyntax>(this.members); } }
    public override SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.keyword;
            case 3: return this.identifier;
            case 4: return this.typeParameterList;
            case 5: return this.baseList;
            case 6: return this.constraintClauses;
            case 7: return this.openBraceToken;
            case 8: return this.members;
            case 9: return this.closeBraceToken;
            case 10: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.InterfaceDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterfaceDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterfaceDeclaration(this);
    }

    public InterfaceDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.InterfaceDeclaration(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new InterfaceDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new InterfaceDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal InterfaceDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 11;
      var attributeLists = (CSharpSyntaxNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (CSharpSyntaxNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var typeParameterList = (TypeParameterListSyntax)reader.ReadValue();
      if (typeParameterList != null)
      {
         AdjustFlagsAndWidth(typeParameterList);
         this.typeParameterList = typeParameterList;
      }
      var baseList = (BaseListSyntax)reader.ReadValue();
      if (baseList != null)
      {
         AdjustFlagsAndWidth(baseList);
         this.baseList = baseList;
      }
      var constraintClauses = (CSharpSyntaxNode)reader.ReadValue();
      if (constraintClauses != null)
      {
         AdjustFlagsAndWidth(constraintClauses);
         this.constraintClauses = constraintClauses;
      }
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var members = (CSharpSyntaxNode)reader.ReadValue();
      if (members != null)
      {
         AdjustFlagsAndWidth(members);
         this.members = members;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeParameterList);
      writer.WriteValue(this.baseList);
      writer.WriteValue(this.constraintClauses);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.members);
      writer.WriteValue(this.closeBraceToken);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new InterfaceDeclarationSyntax(r);
    }
  }

  /// <summary>Enum type declaration syntax.</summary>
  internal sealed partial class EnumDeclarationSyntax : BaseTypeDeclarationSyntax
  {
    internal readonly CSharpSyntaxNode attributeLists;
    internal readonly CSharpSyntaxNode modifiers;
    internal readonly SyntaxToken enumKeyword;
    internal readonly SyntaxToken identifier;
    internal readonly BaseListSyntax baseList;
    internal readonly SyntaxToken openBraceToken;
    internal readonly CSharpSyntaxNode members;
    internal readonly SyntaxToken closeBraceToken;
    internal readonly SyntaxToken semicolonToken;

    internal EnumDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(enumKeyword);
        this.enumKeyword = enumKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal EnumDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(enumKeyword);
        this.enumKeyword = enumKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal EnumDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(enumKeyword);
        this.enumKeyword = enumKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the enum keyword token.</summary>
    public SyntaxToken EnumKeyword { get { return this.enumKeyword; } }
    public override SyntaxToken Identifier { get { return this.identifier; } }
    public override BaseListSyntax BaseList { get { return this.baseList; } }
    public override SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    /// <summary>Gets the members declaration list.</summary>
    public SeparatedSyntaxList<EnumMemberDeclarationSyntax> Members { get { return new SeparatedSyntaxList<EnumMemberDeclarationSyntax>(new SyntaxList<CSharpSyntaxNode>(this.members)); } }
    public override SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }
    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.enumKeyword;
            case 3: return this.identifier;
            case 4: return this.baseList;
            case 5: return this.openBraceToken;
            case 6: return this.members;
            case 7: return this.closeBraceToken;
            case 8: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.EnumDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEnumDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEnumDeclaration(this);
    }

    public EnumDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || enumKeyword != this.EnumKeyword || identifier != this.Identifier || baseList != this.BaseList || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.EnumDeclaration(attributeLists, modifiers, enumKeyword, identifier, baseList, openBraceToken, members, closeBraceToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EnumDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.enumKeyword, this.identifier, this.baseList, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EnumDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.enumKeyword, this.identifier, this.baseList, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal EnumDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 9;
      var attributeLists = (CSharpSyntaxNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (CSharpSyntaxNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var enumKeyword = (SyntaxToken)reader.ReadValue();
      if (enumKeyword != null)
      {
         AdjustFlagsAndWidth(enumKeyword);
         this.enumKeyword = enumKeyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var baseList = (BaseListSyntax)reader.ReadValue();
      if (baseList != null)
      {
         AdjustFlagsAndWidth(baseList);
         this.baseList = baseList;
      }
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var members = (CSharpSyntaxNode)reader.ReadValue();
      if (members != null)
      {
         AdjustFlagsAndWidth(members);
         this.members = members;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.enumKeyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.baseList);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.members);
      writer.WriteValue(this.closeBraceToken);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new EnumDeclarationSyntax(r);
    }
  }

  /// <summary>Delegate declaration syntax.</summary>
  internal sealed partial class DelegateDeclarationSyntax : MemberDeclarationSyntax
  {
    internal readonly CSharpSyntaxNode attributeLists;
    internal readonly CSharpSyntaxNode modifiers;
    internal readonly SyntaxToken delegateKeyword;
    internal readonly SyntaxToken refKeyword;
    internal readonly TypeSyntax returnType;
    internal readonly SyntaxToken identifier;
    internal readonly TypeParameterListSyntax typeParameterList;
    internal readonly ParameterListSyntax parameterList;
    internal readonly CSharpSyntaxNode constraintClauses;
    internal readonly SyntaxToken semicolonToken;

    internal DelegateDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken delegateKeyword, SyntaxToken refKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, CSharpSyntaxNode constraintClauses, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 10;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(delegateKeyword);
        this.delegateKeyword = delegateKeyword;
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal DelegateDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken delegateKeyword, SyntaxToken refKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, CSharpSyntaxNode constraintClauses, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 10;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(delegateKeyword);
        this.delegateKeyword = delegateKeyword;
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal DelegateDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken delegateKeyword, SyntaxToken refKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, CSharpSyntaxNode constraintClauses, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 10;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(delegateKeyword);
        this.delegateKeyword = delegateKeyword;
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    /// <summary>Gets the modifier list.</summary>
    public SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the "delegate" keyword.</summary>
    public SyntaxToken DelegateKeyword { get { return this.delegateKeyword; } }
    /// <summary>Gets the "ref" keyword if present.</summary>
    public SyntaxToken RefKeyword { get { return this.refKeyword; } }
    /// <summary>Gets the return type.</summary>
    public TypeSyntax ReturnType { get { return this.returnType; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public TypeParameterListSyntax TypeParameterList { get { return this.typeParameterList; } }
    /// <summary>Gets the parameter list.</summary>
    public ParameterListSyntax ParameterList { get { return this.parameterList; } }
    /// <summary>Gets the constraint clause list.</summary>
    public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses); } }
    /// <summary>Gets the semicolon token.</summary>
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.delegateKeyword;
            case 3: return this.refKeyword;
            case 4: return this.returnType;
            case 5: return this.identifier;
            case 6: return this.typeParameterList;
            case 7: return this.parameterList;
            case 8: return this.constraintClauses;
            case 9: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.DelegateDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDelegateDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDelegateDeclaration(this);
    }

    public DelegateDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken delegateKeyword, SyntaxToken refKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || delegateKeyword != this.DelegateKeyword || refKeyword != this.RefKeyword || returnType != this.ReturnType || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || constraintClauses != this.ConstraintClauses || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.DelegateDeclaration(attributeLists, modifiers, delegateKeyword, refKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DelegateDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.delegateKeyword, this.refKeyword, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DelegateDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.delegateKeyword, this.refKeyword, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal DelegateDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 10;
      var attributeLists = (CSharpSyntaxNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (CSharpSyntaxNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var delegateKeyword = (SyntaxToken)reader.ReadValue();
      if (delegateKeyword != null)
      {
         AdjustFlagsAndWidth(delegateKeyword);
         this.delegateKeyword = delegateKeyword;
      }
      var refKeyword = (SyntaxToken)reader.ReadValue();
      if (refKeyword != null)
      {
         AdjustFlagsAndWidth(refKeyword);
         this.refKeyword = refKeyword;
      }
      var returnType = (TypeSyntax)reader.ReadValue();
      if (returnType != null)
      {
         AdjustFlagsAndWidth(returnType);
         this.returnType = returnType;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var typeParameterList = (TypeParameterListSyntax)reader.ReadValue();
      if (typeParameterList != null)
      {
         AdjustFlagsAndWidth(typeParameterList);
         this.typeParameterList = typeParameterList;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var constraintClauses = (CSharpSyntaxNode)reader.ReadValue();
      if (constraintClauses != null)
      {
         AdjustFlagsAndWidth(constraintClauses);
         this.constraintClauses = constraintClauses;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.delegateKeyword);
      writer.WriteValue(this.refKeyword);
      writer.WriteValue(this.returnType);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeParameterList);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.constraintClauses);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new DelegateDeclarationSyntax(r);
    }
  }

  internal sealed partial class EnumMemberDeclarationSyntax : MemberDeclarationSyntax
  {
    internal readonly CSharpSyntaxNode attributeLists;
    internal readonly SyntaxToken identifier;
    internal readonly EqualsValueClauseSyntax equalsValue;

    internal EnumMemberDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (equalsValue != null)
        {
            this.AdjustFlagsAndWidth(equalsValue);
            this.equalsValue = equalsValue;
        }
    }


    internal EnumMemberDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (equalsValue != null)
        {
            this.AdjustFlagsAndWidth(equalsValue);
            this.equalsValue = equalsValue;
        }
    }


    internal EnumMemberDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
        : base(kind)
    {
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (equalsValue != null)
        {
            this.AdjustFlagsAndWidth(equalsValue);
            this.equalsValue = equalsValue;
        }
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public EqualsValueClauseSyntax EqualsValue { get { return this.equalsValue; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.identifier;
            case 2: return this.equalsValue;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.EnumMemberDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEnumMemberDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEnumMemberDeclaration(this);
    }

    public EnumMemberDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
    {
        if (attributeLists != this.AttributeLists || identifier != this.Identifier || equalsValue != this.EqualsValue)
        {
            var newNode = SyntaxFactory.EnumMemberDeclaration(attributeLists, identifier, equalsValue);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EnumMemberDeclarationSyntax(this.Kind, this.attributeLists, this.identifier, this.equalsValue, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EnumMemberDeclarationSyntax(this.Kind, this.attributeLists, this.identifier, this.equalsValue, GetDiagnostics(), annotations);
    }

    internal EnumMemberDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var attributeLists = (CSharpSyntaxNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var equalsValue = (EqualsValueClauseSyntax)reader.ReadValue();
      if (equalsValue != null)
      {
         AdjustFlagsAndWidth(equalsValue);
         this.equalsValue = equalsValue;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.equalsValue);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new EnumMemberDeclarationSyntax(r);
    }
  }

  /// <summary>Base list syntax.</summary>
  internal sealed partial class BaseListSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken colonToken;
    internal readonly CSharpSyntaxNode types;

    internal BaseListSyntax(SyntaxKind kind, SyntaxToken colonToken, CSharpSyntaxNode types, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        if (types != null)
        {
            this.AdjustFlagsAndWidth(types);
            this.types = types;
        }
    }


    internal BaseListSyntax(SyntaxKind kind, SyntaxToken colonToken, CSharpSyntaxNode types, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        if (types != null)
        {
            this.AdjustFlagsAndWidth(types);
            this.types = types;
        }
    }


    internal BaseListSyntax(SyntaxKind kind, SyntaxToken colonToken, CSharpSyntaxNode types)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        if (types != null)
        {
            this.AdjustFlagsAndWidth(types);
            this.types = types;
        }
    }

    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken { get { return this.colonToken; } }
    /// <summary>Gets the base type references.</summary>
    public SeparatedSyntaxList<BaseTypeSyntax> Types { get { return new SeparatedSyntaxList<BaseTypeSyntax>(new SyntaxList<CSharpSyntaxNode>(this.types)); } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.colonToken;
            case 1: return this.types;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.BaseListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBaseList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBaseList(this);
    }

    public BaseListSyntax Update(SyntaxToken colonToken, SeparatedSyntaxList<BaseTypeSyntax> types)
    {
        if (colonToken != this.ColonToken || types != this.Types)
        {
            var newNode = SyntaxFactory.BaseList(colonToken, types);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BaseListSyntax(this.Kind, this.colonToken, this.types, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BaseListSyntax(this.Kind, this.colonToken, this.types, GetDiagnostics(), annotations);
    }

    internal BaseListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
      var types = (CSharpSyntaxNode)reader.ReadValue();
      if (types != null)
      {
         AdjustFlagsAndWidth(types);
         this.types = types;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.colonToken);
      writer.WriteValue(this.types);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new BaseListSyntax(r);
    }
  }

  /// <summary>Provides the base class from which the classes that represent base type syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class BaseTypeSyntax : CSharpSyntaxNode
  {
    internal BaseTypeSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseTypeSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseTypeSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    public abstract TypeSyntax Type { get; }
  }

  internal sealed partial class SimpleBaseTypeSyntax : BaseTypeSyntax
  {
    internal readonly TypeSyntax type;

    internal SimpleBaseTypeSyntax(SyntaxKind kind, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal SimpleBaseTypeSyntax(SyntaxKind kind, TypeSyntax type, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal SimpleBaseTypeSyntax(SyntaxKind kind, TypeSyntax type)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }

    public override TypeSyntax Type { get { return this.type; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.SimpleBaseTypeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSimpleBaseType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSimpleBaseType(this);
    }

    public SimpleBaseTypeSyntax Update(TypeSyntax type)
    {
        if (type != this.Type)
        {
            var newNode = SyntaxFactory.SimpleBaseType(type);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new SimpleBaseTypeSyntax(this.Kind, this.type, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new SimpleBaseTypeSyntax(this.Kind, this.type, GetDiagnostics(), annotations);
    }

    internal SimpleBaseTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.type);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new SimpleBaseTypeSyntax(r);
    }
  }

  /// <summary>Type parameter constraint clause.</summary>
  internal sealed partial class TypeParameterConstraintClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken whereKeyword;
    internal readonly IdentifierNameSyntax name;
    internal readonly SyntaxToken colonToken;
    internal readonly CSharpSyntaxNode constraints;

    internal TypeParameterConstraintClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, CSharpSyntaxNode constraints, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(whereKeyword);
        this.whereKeyword = whereKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        if (constraints != null)
        {
            this.AdjustFlagsAndWidth(constraints);
            this.constraints = constraints;
        }
    }


    internal TypeParameterConstraintClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, CSharpSyntaxNode constraints, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(whereKeyword);
        this.whereKeyword = whereKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        if (constraints != null)
        {
            this.AdjustFlagsAndWidth(constraints);
            this.constraints = constraints;
        }
    }


    internal TypeParameterConstraintClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, CSharpSyntaxNode constraints)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(whereKeyword);
        this.whereKeyword = whereKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        if (constraints != null)
        {
            this.AdjustFlagsAndWidth(constraints);
            this.constraints = constraints;
        }
    }

    public SyntaxToken WhereKeyword { get { return this.whereKeyword; } }
    /// <summary>Gets the identifier.</summary>
    public IdentifierNameSyntax Name { get { return this.name; } }
    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken { get { return this.colonToken; } }
    /// <summary>Gets the constraints list.</summary>
    public SeparatedSyntaxList<TypeParameterConstraintSyntax> Constraints { get { return new SeparatedSyntaxList<TypeParameterConstraintSyntax>(new SyntaxList<CSharpSyntaxNode>(this.constraints)); } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.whereKeyword;
            case 1: return this.name;
            case 2: return this.colonToken;
            case 3: return this.constraints;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.TypeParameterConstraintClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeParameterConstraintClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeParameterConstraintClause(this);
    }

    public TypeParameterConstraintClauseSyntax Update(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
    {
        if (whereKeyword != this.WhereKeyword || name != this.Name || colonToken != this.ColonToken || constraints != this.Constraints)
        {
            var newNode = SyntaxFactory.TypeParameterConstraintClause(whereKeyword, name, colonToken, constraints);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TypeParameterConstraintClauseSyntax(this.Kind, this.whereKeyword, this.name, this.colonToken, this.constraints, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TypeParameterConstraintClauseSyntax(this.Kind, this.whereKeyword, this.name, this.colonToken, this.constraints, GetDiagnostics(), annotations);
    }

    internal TypeParameterConstraintClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var whereKeyword = (SyntaxToken)reader.ReadValue();
      if (whereKeyword != null)
      {
         AdjustFlagsAndWidth(whereKeyword);
         this.whereKeyword = whereKeyword;
      }
      var name = (IdentifierNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
      var constraints = (CSharpSyntaxNode)reader.ReadValue();
      if (constraints != null)
      {
         AdjustFlagsAndWidth(constraints);
         this.constraints = constraints;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.whereKeyword);
      writer.WriteValue(this.name);
      writer.WriteValue(this.colonToken);
      writer.WriteValue(this.constraints);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new TypeParameterConstraintClauseSyntax(r);
    }
  }

  /// <summary>Base type for type parameter constraint syntax.</summary>
  internal abstract partial class TypeParameterConstraintSyntax : CSharpSyntaxNode
  {
    internal TypeParameterConstraintSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal TypeParameterConstraintSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected TypeParameterConstraintSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>Constructor constraint syntax.</summary>
  internal sealed partial class ConstructorConstraintSyntax : TypeParameterConstraintSyntax
  {
    internal readonly SyntaxToken newKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly SyntaxToken closeParenToken;

    internal ConstructorConstraintSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ConstructorConstraintSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ConstructorConstraintSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>Gets the "new" keyword.</summary>
    public SyntaxToken NewKeyword { get { return this.newKeyword; } }
    /// <summary>Gets the open paren keyword.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Gets the close paren keyword.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.newKeyword;
            case 1: return this.openParenToken;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ConstructorConstraintSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstructorConstraint(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConstructorConstraint(this);
    }

    public ConstructorConstraintSyntax Update(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
    {
        if (newKeyword != this.NewKeyword || openParenToken != this.OpenParenToken || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.ConstructorConstraint(newKeyword, openParenToken, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ConstructorConstraintSyntax(this.Kind, this.newKeyword, this.openParenToken, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ConstructorConstraintSyntax(this.Kind, this.newKeyword, this.openParenToken, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal ConstructorConstraintSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var newKeyword = (SyntaxToken)reader.ReadValue();
      if (newKeyword != null)
      {
         AdjustFlagsAndWidth(newKeyword);
         this.newKeyword = newKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.newKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.closeParenToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ConstructorConstraintSyntax(r);
    }
  }

  /// <summary>Base type for class or struct constraint syntax.</summary>
  internal sealed partial class ClassOrStructConstraintSyntax : TypeParameterConstraintSyntax
  {
    internal readonly SyntaxToken classOrStructKeyword;

    internal ClassOrStructConstraintSyntax(SyntaxKind kind, SyntaxToken classOrStructKeyword, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(classOrStructKeyword);
        this.classOrStructKeyword = classOrStructKeyword;
    }


    internal ClassOrStructConstraintSyntax(SyntaxKind kind, SyntaxToken classOrStructKeyword, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(classOrStructKeyword);
        this.classOrStructKeyword = classOrStructKeyword;
    }


    internal ClassOrStructConstraintSyntax(SyntaxKind kind, SyntaxToken classOrStructKeyword)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(classOrStructKeyword);
        this.classOrStructKeyword = classOrStructKeyword;
    }

    /// <summary>Gets the constraint keyword ("class" or "struct").</summary>
    public SyntaxToken ClassOrStructKeyword { get { return this.classOrStructKeyword; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.classOrStructKeyword;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ClassOrStructConstraintSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitClassOrStructConstraint(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitClassOrStructConstraint(this);
    }

    public ClassOrStructConstraintSyntax Update(SyntaxToken classOrStructKeyword)
    {
        if (classOrStructKeyword != this.ClassOrStructKeyword)
        {
            var newNode = SyntaxFactory.ClassOrStructConstraint(this.Kind, classOrStructKeyword);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ClassOrStructConstraintSyntax(this.Kind, this.classOrStructKeyword, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ClassOrStructConstraintSyntax(this.Kind, this.classOrStructKeyword, GetDiagnostics(), annotations);
    }

    internal ClassOrStructConstraintSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var classOrStructKeyword = (SyntaxToken)reader.ReadValue();
      if (classOrStructKeyword != null)
      {
         AdjustFlagsAndWidth(classOrStructKeyword);
         this.classOrStructKeyword = classOrStructKeyword;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.classOrStructKeyword);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ClassOrStructConstraintSyntax(r);
    }
  }

  /// <summary>Type constraint syntax.</summary>
  internal sealed partial class TypeConstraintSyntax : TypeParameterConstraintSyntax
  {
    internal readonly TypeSyntax type;

    internal TypeConstraintSyntax(SyntaxKind kind, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal TypeConstraintSyntax(SyntaxKind kind, TypeSyntax type, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal TypeConstraintSyntax(SyntaxKind kind, TypeSyntax type)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }

    /// <summary>Gets the type syntax.</summary>
    public TypeSyntax Type { get { return this.type; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.TypeConstraintSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeConstraint(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeConstraint(this);
    }

    public TypeConstraintSyntax Update(TypeSyntax type)
    {
        if (type != this.Type)
        {
            var newNode = SyntaxFactory.TypeConstraint(type);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TypeConstraintSyntax(this.Kind, this.type, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TypeConstraintSyntax(this.Kind, this.type, GetDiagnostics(), annotations);
    }

    internal TypeConstraintSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.type);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new TypeConstraintSyntax(r);
    }
  }

  internal abstract partial class BaseFieldDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BaseFieldDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseFieldDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseFieldDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }

    /// <summary>Gets the modifier list.</summary>
    public abstract SyntaxList<SyntaxToken> Modifiers { get; }

    public abstract VariableDeclarationSyntax Declaration { get; }

    public abstract SyntaxToken SemicolonToken { get; }
  }

  internal sealed partial class FieldDeclarationSyntax : BaseFieldDeclarationSyntax
  {
    internal readonly CSharpSyntaxNode attributeLists;
    internal readonly CSharpSyntaxNode modifiers;
    internal readonly VariableDeclarationSyntax declaration;
    internal readonly SyntaxToken semicolonToken;

    internal FieldDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal FieldDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal FieldDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 4;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    /// <summary>Gets the modifier list.</summary>
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    public override VariableDeclarationSyntax Declaration { get { return this.declaration; } }
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.declaration;
            case 3: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.FieldDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFieldDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitFieldDeclaration(this);
    }

    public FieldDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || declaration != this.Declaration || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.FieldDeclaration(attributeLists, modifiers, declaration, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new FieldDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.declaration, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new FieldDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.declaration, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal FieldDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var attributeLists = (CSharpSyntaxNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (CSharpSyntaxNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var declaration = (VariableDeclarationSyntax)reader.ReadValue();
      if (declaration != null)
      {
         AdjustFlagsAndWidth(declaration);
         this.declaration = declaration;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new FieldDeclarationSyntax(r);
    }
  }

  internal sealed partial class EventFieldDeclarationSyntax : BaseFieldDeclarationSyntax
  {
    internal readonly CSharpSyntaxNode attributeLists;
    internal readonly CSharpSyntaxNode modifiers;
    internal readonly SyntaxToken eventKeyword;
    internal readonly VariableDeclarationSyntax declaration;
    internal readonly SyntaxToken semicolonToken;

    internal EventFieldDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(eventKeyword);
        this.eventKeyword = eventKeyword;
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal EventFieldDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(eventKeyword);
        this.eventKeyword = eventKeyword;
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal EventFieldDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 5;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(eventKeyword);
        this.eventKeyword = eventKeyword;
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    /// <summary>Gets the modifier list.</summary>
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    public SyntaxToken EventKeyword { get { return this.eventKeyword; } }
    public override VariableDeclarationSyntax Declaration { get { return this.declaration; } }
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.eventKeyword;
            case 3: return this.declaration;
            case 4: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.EventFieldDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEventFieldDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEventFieldDeclaration(this);
    }

    public EventFieldDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || eventKeyword != this.EventKeyword || declaration != this.Declaration || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.EventFieldDeclaration(attributeLists, modifiers, eventKeyword, declaration, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EventFieldDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.declaration, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EventFieldDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.declaration, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal EventFieldDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var attributeLists = (CSharpSyntaxNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (CSharpSyntaxNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var eventKeyword = (SyntaxToken)reader.ReadValue();
      if (eventKeyword != null)
      {
         AdjustFlagsAndWidth(eventKeyword);
         this.eventKeyword = eventKeyword;
      }
      var declaration = (VariableDeclarationSyntax)reader.ReadValue();
      if (declaration != null)
      {
         AdjustFlagsAndWidth(declaration);
         this.declaration = declaration;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.eventKeyword);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new EventFieldDeclarationSyntax(r);
    }
  }

  internal sealed partial class ExplicitInterfaceSpecifierSyntax : CSharpSyntaxNode
  {
    internal readonly NameSyntax name;
    internal readonly SyntaxToken dotToken;

    internal ExplicitInterfaceSpecifierSyntax(SyntaxKind kind, NameSyntax name, SyntaxToken dotToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
    }


    internal ExplicitInterfaceSpecifierSyntax(SyntaxKind kind, NameSyntax name, SyntaxToken dotToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
    }


    internal ExplicitInterfaceSpecifierSyntax(SyntaxKind kind, NameSyntax name, SyntaxToken dotToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
    }

    public NameSyntax Name { get { return this.name; } }
    public SyntaxToken DotToken { get { return this.dotToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.dotToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ExplicitInterfaceSpecifierSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitExplicitInterfaceSpecifier(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitExplicitInterfaceSpecifier(this);
    }

    public ExplicitInterfaceSpecifierSyntax Update(NameSyntax name, SyntaxToken dotToken)
    {
        if (name != this.Name || dotToken != this.DotToken)
        {
            var newNode = SyntaxFactory.ExplicitInterfaceSpecifier(name, dotToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ExplicitInterfaceSpecifierSyntax(this.Kind, this.name, this.dotToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ExplicitInterfaceSpecifierSyntax(this.Kind, this.name, this.dotToken, GetDiagnostics(), annotations);
    }

    internal ExplicitInterfaceSpecifierSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var name = (NameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var dotToken = (SyntaxToken)reader.ReadValue();
      if (dotToken != null)
      {
         AdjustFlagsAndWidth(dotToken);
         this.dotToken = dotToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.dotToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ExplicitInterfaceSpecifierSyntax(r);
    }
  }

  /// <summary>Base type for method declaration syntax.</summary>
  internal abstract partial class BaseMethodDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BaseMethodDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseMethodDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseMethodDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }

    /// <summary>Gets the modifier list.</summary>
    public abstract SyntaxList<SyntaxToken> Modifiers { get; }

    /// <summary>Gets the parameter list.</summary>
    public abstract ParameterListSyntax ParameterList { get; }

    public abstract BlockSyntax Body { get; }

    /// <summary>Gets the optional semicolon token.</summary>
    public abstract SyntaxToken SemicolonToken { get; }
  }

  /// <summary>Method declaration syntax.</summary>
  internal sealed partial class MethodDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    internal readonly CSharpSyntaxNode attributeLists;
    internal readonly CSharpSyntaxNode modifiers;
    internal readonly SyntaxToken refKeyword;
    internal readonly TypeSyntax returnType;
    internal readonly ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    internal readonly SyntaxToken identifier;
    internal readonly TypeParameterListSyntax typeParameterList;
    internal readonly ParameterListSyntax parameterList;
    internal readonly CSharpSyntaxNode constraintClauses;
    internal readonly BlockSyntax body;
    internal readonly ArrowExpressionClauseSyntax expressionBody;
    internal readonly SyntaxToken semicolonToken;

    internal MethodDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken refKeyword, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, CSharpSyntaxNode constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 12;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal MethodDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken refKeyword, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, CSharpSyntaxNode constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 12;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal MethodDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken refKeyword, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, CSharpSyntaxNode constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 12;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    public SyntaxToken RefKeyword { get { return this.refKeyword; } }
    /// <summary>Gets the return type syntax.</summary>
    public TypeSyntax ReturnType { get { return this.returnType; } }
    public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get { return this.explicitInterfaceSpecifier; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public TypeParameterListSyntax TypeParameterList { get { return this.typeParameterList; } }
    public override ParameterListSyntax ParameterList { get { return this.parameterList; } }
    /// <summary>Gets the constraint clause list.</summary>
    public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses); } }
    public override BlockSyntax Body { get { return this.body; } }
    public ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.refKeyword;
            case 3: return this.returnType;
            case 4: return this.explicitInterfaceSpecifier;
            case 5: return this.identifier;
            case 6: return this.typeParameterList;
            case 7: return this.parameterList;
            case 8: return this.constraintClauses;
            case 9: return this.body;
            case 10: return this.expressionBody;
            case 11: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.MethodDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitMethodDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitMethodDeclaration(this);
    }

    public MethodDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken refKeyword, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || refKeyword != this.RefKeyword || returnType != this.ReturnType || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || constraintClauses != this.ConstraintClauses || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.MethodDeclaration(attributeLists, modifiers, refKeyword, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new MethodDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.refKeyword, this.returnType, this.explicitInterfaceSpecifier, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new MethodDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.refKeyword, this.returnType, this.explicitInterfaceSpecifier, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal MethodDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 12;
      var attributeLists = (CSharpSyntaxNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (CSharpSyntaxNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var refKeyword = (SyntaxToken)reader.ReadValue();
      if (refKeyword != null)
      {
         AdjustFlagsAndWidth(refKeyword);
         this.refKeyword = refKeyword;
      }
      var returnType = (TypeSyntax)reader.ReadValue();
      if (returnType != null)
      {
         AdjustFlagsAndWidth(returnType);
         this.returnType = returnType;
      }
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)reader.ReadValue();
      if (explicitInterfaceSpecifier != null)
      {
         AdjustFlagsAndWidth(explicitInterfaceSpecifier);
         this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var typeParameterList = (TypeParameterListSyntax)reader.ReadValue();
      if (typeParameterList != null)
      {
         AdjustFlagsAndWidth(typeParameterList);
         this.typeParameterList = typeParameterList;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var constraintClauses = (CSharpSyntaxNode)reader.ReadValue();
      if (constraintClauses != null)
      {
         AdjustFlagsAndWidth(constraintClauses);
         this.constraintClauses = constraintClauses;
      }
      var body = (BlockSyntax)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
      var expressionBody = (ArrowExpressionClauseSyntax)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.refKeyword);
      writer.WriteValue(this.returnType);
      writer.WriteValue(this.explicitInterfaceSpecifier);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeParameterList);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.constraintClauses);
      writer.WriteValue(this.body);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new MethodDeclarationSyntax(r);
    }
  }

  /// <summary>Operator declaration syntax.</summary>
  internal sealed partial class OperatorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    internal readonly CSharpSyntaxNode attributeLists;
    internal readonly CSharpSyntaxNode modifiers;
    internal readonly TypeSyntax returnType;
    internal readonly SyntaxToken operatorKeyword;
    internal readonly SyntaxToken operatorToken;
    internal readonly ParameterListSyntax parameterList;
    internal readonly BlockSyntax body;
    internal readonly ArrowExpressionClauseSyntax expressionBody;
    internal readonly SyntaxToken semicolonToken;

    internal OperatorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal OperatorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal OperatorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the return type.</summary>
    public TypeSyntax ReturnType { get { return this.returnType; } }
    /// <summary>Gets the "operator" keyword.</summary>
    public SyntaxToken OperatorKeyword { get { return this.operatorKeyword; } }
    /// <summary>Gets the operator token.</summary>
    public SyntaxToken OperatorToken { get { return this.operatorToken; } }
    public override ParameterListSyntax ParameterList { get { return this.parameterList; } }
    public override BlockSyntax Body { get { return this.body; } }
    public ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.returnType;
            case 3: return this.operatorKeyword;
            case 4: return this.operatorToken;
            case 5: return this.parameterList;
            case 6: return this.body;
            case 7: return this.expressionBody;
            case 8: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.OperatorDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOperatorDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOperatorDeclaration(this);
    }

    public OperatorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || returnType != this.ReturnType || operatorKeyword != this.OperatorKeyword || operatorToken != this.OperatorToken || parameterList != this.ParameterList || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.OperatorDeclaration(attributeLists, modifiers, returnType, operatorKeyword, operatorToken, parameterList, body, expressionBody, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new OperatorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.operatorKeyword, this.operatorToken, this.parameterList, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new OperatorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.operatorKeyword, this.operatorToken, this.parameterList, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal OperatorDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 9;
      var attributeLists = (CSharpSyntaxNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (CSharpSyntaxNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var returnType = (TypeSyntax)reader.ReadValue();
      if (returnType != null)
      {
         AdjustFlagsAndWidth(returnType);
         this.returnType = returnType;
      }
      var operatorKeyword = (SyntaxToken)reader.ReadValue();
      if (operatorKeyword != null)
      {
         AdjustFlagsAndWidth(operatorKeyword);
         this.operatorKeyword = operatorKeyword;
      }
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var body = (BlockSyntax)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
      var expressionBody = (ArrowExpressionClauseSyntax)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.returnType);
      writer.WriteValue(this.operatorKeyword);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.body);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new OperatorDeclarationSyntax(r);
    }
  }

  /// <summary>Conversion operator declaration syntax.</summary>
  internal sealed partial class ConversionOperatorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    internal readonly CSharpSyntaxNode attributeLists;
    internal readonly CSharpSyntaxNode modifiers;
    internal readonly SyntaxToken implicitOrExplicitKeyword;
    internal readonly SyntaxToken operatorKeyword;
    internal readonly TypeSyntax type;
    internal readonly ParameterListSyntax parameterList;
    internal readonly BlockSyntax body;
    internal readonly ArrowExpressionClauseSyntax expressionBody;
    internal readonly SyntaxToken semicolonToken;

    internal ConversionOperatorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
        this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal ConversionOperatorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
        this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal ConversionOperatorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
        this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the "implicit" or "explicit" token.</summary>
    public SyntaxToken ImplicitOrExplicitKeyword { get { return this.implicitOrExplicitKeyword; } }
    /// <summary>Gets the "operator" token.</summary>
    public SyntaxToken OperatorKeyword { get { return this.operatorKeyword; } }
    /// <summary>Gets the type.</summary>
    public TypeSyntax Type { get { return this.type; } }
    public override ParameterListSyntax ParameterList { get { return this.parameterList; } }
    public override BlockSyntax Body { get { return this.body; } }
    public ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.implicitOrExplicitKeyword;
            case 3: return this.operatorKeyword;
            case 4: return this.type;
            case 5: return this.parameterList;
            case 6: return this.body;
            case 7: return this.expressionBody;
            case 8: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ConversionOperatorDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConversionOperatorDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConversionOperatorDeclaration(this);
    }

    public ConversionOperatorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || implicitOrExplicitKeyword != this.ImplicitOrExplicitKeyword || operatorKeyword != this.OperatorKeyword || type != this.Type || parameterList != this.ParameterList || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ConversionOperatorDeclaration(attributeLists, modifiers, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, expressionBody, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ConversionOperatorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameterList, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ConversionOperatorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameterList, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ConversionOperatorDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 9;
      var attributeLists = (CSharpSyntaxNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (CSharpSyntaxNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var implicitOrExplicitKeyword = (SyntaxToken)reader.ReadValue();
      if (implicitOrExplicitKeyword != null)
      {
         AdjustFlagsAndWidth(implicitOrExplicitKeyword);
         this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
      }
      var operatorKeyword = (SyntaxToken)reader.ReadValue();
      if (operatorKeyword != null)
      {
         AdjustFlagsAndWidth(operatorKeyword);
         this.operatorKeyword = operatorKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var body = (BlockSyntax)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
      var expressionBody = (ArrowExpressionClauseSyntax)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.implicitOrExplicitKeyword);
      writer.WriteValue(this.operatorKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.body);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ConversionOperatorDeclarationSyntax(r);
    }
  }

  /// <summary>Constructor declaration syntax.</summary>
  internal sealed partial class ConstructorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    internal readonly CSharpSyntaxNode attributeLists;
    internal readonly CSharpSyntaxNode modifiers;
    internal readonly SyntaxToken identifier;
    internal readonly ParameterListSyntax parameterList;
    internal readonly ConstructorInitializerSyntax initializer;
    internal readonly BlockSyntax body;
    internal readonly SyntaxToken semicolonToken;

    internal ConstructorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 7;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal ConstructorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 7;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal ConstructorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 7;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public override ParameterListSyntax ParameterList { get { return this.parameterList; } }
    public ConstructorInitializerSyntax Initializer { get { return this.initializer; } }
    public override BlockSyntax Body { get { return this.body; } }
    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.identifier;
            case 3: return this.parameterList;
            case 4: return this.initializer;
            case 5: return this.body;
            case 6: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ConstructorDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstructorDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConstructorDeclaration(this);
    }

    public ConstructorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || identifier != this.Identifier || parameterList != this.ParameterList || initializer != this.Initializer || body != this.Body || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ConstructorDeclaration(attributeLists, modifiers, identifier, parameterList, initializer, body, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ConstructorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.identifier, this.parameterList, this.initializer, this.body, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ConstructorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.identifier, this.parameterList, this.initializer, this.body, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ConstructorDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 7;
      var attributeLists = (CSharpSyntaxNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (CSharpSyntaxNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var initializer = (ConstructorInitializerSyntax)reader.ReadValue();
      if (initializer != null)
      {
         AdjustFlagsAndWidth(initializer);
         this.initializer = initializer;
      }
      var body = (BlockSyntax)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.initializer);
      writer.WriteValue(this.body);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ConstructorDeclarationSyntax(r);
    }
  }

  /// <summary>Constructor initializer syntax.</summary>
  internal sealed partial class ConstructorInitializerSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken colonToken;
    internal readonly SyntaxToken thisOrBaseKeyword;
    internal readonly ArgumentListSyntax argumentList;

    internal ConstructorInitializerSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(thisOrBaseKeyword);
        this.thisOrBaseKeyword = thisOrBaseKeyword;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ConstructorInitializerSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(thisOrBaseKeyword);
        this.thisOrBaseKeyword = thisOrBaseKeyword;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ConstructorInitializerSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(thisOrBaseKeyword);
        this.thisOrBaseKeyword = thisOrBaseKeyword;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }

    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken { get { return this.colonToken; } }
    /// <summary>Gets the "this" or "base" keyword.</summary>
    public SyntaxToken ThisOrBaseKeyword { get { return this.thisOrBaseKeyword; } }
    public ArgumentListSyntax ArgumentList { get { return this.argumentList; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.colonToken;
            case 1: return this.thisOrBaseKeyword;
            case 2: return this.argumentList;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ConstructorInitializerSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstructorInitializer(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConstructorInitializer(this);
    }

    public ConstructorInitializerSyntax Update(SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
    {
        if (colonToken != this.ColonToken || thisOrBaseKeyword != this.ThisOrBaseKeyword || argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.ConstructorInitializer(this.Kind, colonToken, thisOrBaseKeyword, argumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ConstructorInitializerSyntax(this.Kind, this.colonToken, this.thisOrBaseKeyword, this.argumentList, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ConstructorInitializerSyntax(this.Kind, this.colonToken, this.thisOrBaseKeyword, this.argumentList, GetDiagnostics(), annotations);
    }

    internal ConstructorInitializerSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
      var thisOrBaseKeyword = (SyntaxToken)reader.ReadValue();
      if (thisOrBaseKeyword != null)
      {
         AdjustFlagsAndWidth(thisOrBaseKeyword);
         this.thisOrBaseKeyword = thisOrBaseKeyword;
      }
      var argumentList = (ArgumentListSyntax)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.colonToken);
      writer.WriteValue(this.thisOrBaseKeyword);
      writer.WriteValue(this.argumentList);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ConstructorInitializerSyntax(r);
    }
  }

  /// <summary>Destructor declaration syntax.</summary>
  internal sealed partial class DestructorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    internal readonly CSharpSyntaxNode attributeLists;
    internal readonly CSharpSyntaxNode modifiers;
    internal readonly SyntaxToken tildeToken;
    internal readonly SyntaxToken identifier;
    internal readonly ParameterListSyntax parameterList;
    internal readonly BlockSyntax body;
    internal readonly SyntaxToken semicolonToken;

    internal DestructorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 7;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(tildeToken);
        this.tildeToken = tildeToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal DestructorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 7;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(tildeToken);
        this.tildeToken = tildeToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal DestructorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 7;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(tildeToken);
        this.tildeToken = tildeToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the tilde token.</summary>
    public SyntaxToken TildeToken { get { return this.tildeToken; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public override ParameterListSyntax ParameterList { get { return this.parameterList; } }
    public override BlockSyntax Body { get { return this.body; } }
    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.tildeToken;
            case 3: return this.identifier;
            case 4: return this.parameterList;
            case 5: return this.body;
            case 6: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.DestructorDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDestructorDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDestructorDeclaration(this);
    }

    public DestructorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || tildeToken != this.TildeToken || identifier != this.Identifier || parameterList != this.ParameterList || body != this.Body || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.DestructorDeclaration(attributeLists, modifiers, tildeToken, identifier, parameterList, body, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DestructorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.tildeToken, this.identifier, this.parameterList, this.body, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DestructorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.tildeToken, this.identifier, this.parameterList, this.body, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal DestructorDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 7;
      var attributeLists = (CSharpSyntaxNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (CSharpSyntaxNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var tildeToken = (SyntaxToken)reader.ReadValue();
      if (tildeToken != null)
      {
         AdjustFlagsAndWidth(tildeToken);
         this.tildeToken = tildeToken;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var body = (BlockSyntax)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.tildeToken);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.body);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new DestructorDeclarationSyntax(r);
    }
  }

  /// <summary>Base type for property declaration syntax.</summary>
  internal abstract partial class BasePropertyDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BasePropertyDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BasePropertyDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BasePropertyDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }

    /// <summary>Gets the modifier list.</summary>
    public abstract SyntaxList<SyntaxToken> Modifiers { get; }

    /// <summary>Gets the type syntax.</summary>
    public abstract TypeSyntax Type { get; }

    /// <summary>Gets the optional explicit interface specifier.</summary>
    public abstract ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }

    public abstract AccessorListSyntax AccessorList { get; }
  }

  internal sealed partial class PropertyDeclarationSyntax : BasePropertyDeclarationSyntax
  {
    internal readonly CSharpSyntaxNode attributeLists;
    internal readonly CSharpSyntaxNode modifiers;
    internal readonly SyntaxToken refKeyword;
    internal readonly TypeSyntax type;
    internal readonly ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    internal readonly SyntaxToken identifier;
    internal readonly AccessorListSyntax accessorList;
    internal readonly ArrowExpressionClauseSyntax expressionBody;
    internal readonly EqualsValueClauseSyntax initializer;
    internal readonly SyntaxToken semicolonToken;

    internal PropertyDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken refKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 10;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (accessorList != null)
        {
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal PropertyDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken refKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 10;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (accessorList != null)
        {
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal PropertyDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken refKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 10;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (accessorList != null)
        {
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    public SyntaxToken RefKeyword { get { return this.refKeyword; } }
    public override TypeSyntax Type { get { return this.type; } }
    public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get { return this.explicitInterfaceSpecifier; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public override AccessorListSyntax AccessorList { get { return this.accessorList; } }
    public ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
    public EqualsValueClauseSyntax Initializer { get { return this.initializer; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.refKeyword;
            case 3: return this.type;
            case 4: return this.explicitInterfaceSpecifier;
            case 5: return this.identifier;
            case 6: return this.accessorList;
            case 7: return this.expressionBody;
            case 8: return this.initializer;
            case 9: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.PropertyDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPropertyDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPropertyDeclaration(this);
    }

    public PropertyDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken refKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || refKeyword != this.RefKeyword || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || accessorList != this.AccessorList || expressionBody != this.ExpressionBody || initializer != this.Initializer || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.PropertyDeclaration(attributeLists, modifiers, refKeyword, type, explicitInterfaceSpecifier, identifier, accessorList, expressionBody, initializer, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new PropertyDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.refKeyword, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, this.expressionBody, this.initializer, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new PropertyDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.refKeyword, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, this.expressionBody, this.initializer, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal PropertyDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 10;
      var attributeLists = (CSharpSyntaxNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (CSharpSyntaxNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var refKeyword = (SyntaxToken)reader.ReadValue();
      if (refKeyword != null)
      {
         AdjustFlagsAndWidth(refKeyword);
         this.refKeyword = refKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)reader.ReadValue();
      if (explicitInterfaceSpecifier != null)
      {
         AdjustFlagsAndWidth(explicitInterfaceSpecifier);
         this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var accessorList = (AccessorListSyntax)reader.ReadValue();
      if (accessorList != null)
      {
         AdjustFlagsAndWidth(accessorList);
         this.accessorList = accessorList;
      }
      var expressionBody = (ArrowExpressionClauseSyntax)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var initializer = (EqualsValueClauseSyntax)reader.ReadValue();
      if (initializer != null)
      {
         AdjustFlagsAndWidth(initializer);
         this.initializer = initializer;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.refKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.explicitInterfaceSpecifier);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.accessorList);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.initializer);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new PropertyDeclarationSyntax(r);
    }
  }

  /// <summary>The syntax for the expression body of an expression-bodied member.</summary>
  internal sealed partial class ArrowExpressionClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken arrowToken;
    internal readonly SyntaxToken refKeyword;
    internal readonly ExpressionSyntax expression;

    internal ArrowExpressionClauseSyntax(SyntaxKind kind, SyntaxToken arrowToken, SyntaxToken refKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal ArrowExpressionClauseSyntax(SyntaxKind kind, SyntaxToken arrowToken, SyntaxToken refKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal ArrowExpressionClauseSyntax(SyntaxKind kind, SyntaxToken arrowToken, SyntaxToken refKeyword, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    public SyntaxToken ArrowToken { get { return this.arrowToken; } }
    public SyntaxToken RefKeyword { get { return this.refKeyword; } }
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.arrowToken;
            case 1: return this.refKeyword;
            case 2: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ArrowExpressionClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArrowExpressionClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArrowExpressionClause(this);
    }

    public ArrowExpressionClauseSyntax Update(SyntaxToken arrowToken, SyntaxToken refKeyword, ExpressionSyntax expression)
    {
        if (arrowToken != this.ArrowToken || refKeyword != this.RefKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.ArrowExpressionClause(arrowToken, refKeyword, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ArrowExpressionClauseSyntax(this.Kind, this.arrowToken, this.refKeyword, this.expression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ArrowExpressionClauseSyntax(this.Kind, this.arrowToken, this.refKeyword, this.expression, GetDiagnostics(), annotations);
    }

    internal ArrowExpressionClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var arrowToken = (SyntaxToken)reader.ReadValue();
      if (arrowToken != null)
      {
         AdjustFlagsAndWidth(arrowToken);
         this.arrowToken = arrowToken;
      }
      var refKeyword = (SyntaxToken)reader.ReadValue();
      if (refKeyword != null)
      {
         AdjustFlagsAndWidth(refKeyword);
         this.refKeyword = refKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.arrowToken);
      writer.WriteValue(this.refKeyword);
      writer.WriteValue(this.expression);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ArrowExpressionClauseSyntax(r);
    }
  }

  internal sealed partial class EventDeclarationSyntax : BasePropertyDeclarationSyntax
  {
    internal readonly CSharpSyntaxNode attributeLists;
    internal readonly CSharpSyntaxNode modifiers;
    internal readonly SyntaxToken eventKeyword;
    internal readonly TypeSyntax type;
    internal readonly ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    internal readonly SyntaxToken identifier;
    internal readonly AccessorListSyntax accessorList;

    internal EventDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 7;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(eventKeyword);
        this.eventKeyword = eventKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(accessorList);
        this.accessorList = accessorList;
    }


    internal EventDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 7;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(eventKeyword);
        this.eventKeyword = eventKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(accessorList);
        this.accessorList = accessorList;
    }


    internal EventDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
        : base(kind)
    {
        this.SlotCount = 7;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(eventKeyword);
        this.eventKeyword = eventKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(accessorList);
        this.accessorList = accessorList;
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    public SyntaxToken EventKeyword { get { return this.eventKeyword; } }
    public override TypeSyntax Type { get { return this.type; } }
    public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get { return this.explicitInterfaceSpecifier; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public override AccessorListSyntax AccessorList { get { return this.accessorList; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.eventKeyword;
            case 3: return this.type;
            case 4: return this.explicitInterfaceSpecifier;
            case 5: return this.identifier;
            case 6: return this.accessorList;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.EventDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEventDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEventDeclaration(this);
    }

    public EventDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || eventKeyword != this.EventKeyword || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || accessorList != this.AccessorList)
        {
            var newNode = SyntaxFactory.EventDeclaration(attributeLists, modifiers, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EventDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EventDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, GetDiagnostics(), annotations);
    }

    internal EventDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 7;
      var attributeLists = (CSharpSyntaxNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (CSharpSyntaxNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var eventKeyword = (SyntaxToken)reader.ReadValue();
      if (eventKeyword != null)
      {
         AdjustFlagsAndWidth(eventKeyword);
         this.eventKeyword = eventKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)reader.ReadValue();
      if (explicitInterfaceSpecifier != null)
      {
         AdjustFlagsAndWidth(explicitInterfaceSpecifier);
         this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var accessorList = (AccessorListSyntax)reader.ReadValue();
      if (accessorList != null)
      {
         AdjustFlagsAndWidth(accessorList);
         this.accessorList = accessorList;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.eventKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.explicitInterfaceSpecifier);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.accessorList);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new EventDeclarationSyntax(r);
    }
  }

  internal sealed partial class IndexerDeclarationSyntax : BasePropertyDeclarationSyntax
  {
    internal readonly CSharpSyntaxNode attributeLists;
    internal readonly CSharpSyntaxNode modifiers;
    internal readonly SyntaxToken refKeyword;
    internal readonly TypeSyntax type;
    internal readonly ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    internal readonly SyntaxToken thisKeyword;
    internal readonly BracketedParameterListSyntax parameterList;
    internal readonly AccessorListSyntax accessorList;
    internal readonly ArrowExpressionClauseSyntax expressionBody;
    internal readonly SyntaxToken semicolonToken;

    internal IndexerDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken refKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 10;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(thisKeyword);
        this.thisKeyword = thisKeyword;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (accessorList != null)
        {
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal IndexerDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken refKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 10;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(thisKeyword);
        this.thisKeyword = thisKeyword;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (accessorList != null)
        {
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal IndexerDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken refKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 10;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(thisKeyword);
        this.thisKeyword = thisKeyword;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (accessorList != null)
        {
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    public SyntaxToken RefKeyword { get { return this.refKeyword; } }
    public override TypeSyntax Type { get { return this.type; } }
    public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get { return this.explicitInterfaceSpecifier; } }
    public SyntaxToken ThisKeyword { get { return this.thisKeyword; } }
    /// <summary>Gets the parameter list.</summary>
    public BracketedParameterListSyntax ParameterList { get { return this.parameterList; } }
    public override AccessorListSyntax AccessorList { get { return this.accessorList; } }
    public ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.refKeyword;
            case 3: return this.type;
            case 4: return this.explicitInterfaceSpecifier;
            case 5: return this.thisKeyword;
            case 6: return this.parameterList;
            case 7: return this.accessorList;
            case 8: return this.expressionBody;
            case 9: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.IndexerDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIndexerDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIndexerDeclaration(this);
    }

    public IndexerDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken refKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || refKeyword != this.RefKeyword || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || thisKeyword != this.ThisKeyword || parameterList != this.ParameterList || accessorList != this.AccessorList || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.IndexerDeclaration(attributeLists, modifiers, refKeyword, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList, expressionBody, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new IndexerDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.refKeyword, this.type, this.explicitInterfaceSpecifier, this.thisKeyword, this.parameterList, this.accessorList, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new IndexerDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.refKeyword, this.type, this.explicitInterfaceSpecifier, this.thisKeyword, this.parameterList, this.accessorList, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal IndexerDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 10;
      var attributeLists = (CSharpSyntaxNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (CSharpSyntaxNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var refKeyword = (SyntaxToken)reader.ReadValue();
      if (refKeyword != null)
      {
         AdjustFlagsAndWidth(refKeyword);
         this.refKeyword = refKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)reader.ReadValue();
      if (explicitInterfaceSpecifier != null)
      {
         AdjustFlagsAndWidth(explicitInterfaceSpecifier);
         this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
      }
      var thisKeyword = (SyntaxToken)reader.ReadValue();
      if (thisKeyword != null)
      {
         AdjustFlagsAndWidth(thisKeyword);
         this.thisKeyword = thisKeyword;
      }
      var parameterList = (BracketedParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var accessorList = (AccessorListSyntax)reader.ReadValue();
      if (accessorList != null)
      {
         AdjustFlagsAndWidth(accessorList);
         this.accessorList = accessorList;
      }
      var expressionBody = (ArrowExpressionClauseSyntax)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.refKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.explicitInterfaceSpecifier);
      writer.WriteValue(this.thisKeyword);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.accessorList);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new IndexerDeclarationSyntax(r);
    }
  }

  internal sealed partial class AccessorListSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken openBraceToken;
    internal readonly CSharpSyntaxNode accessors;
    internal readonly SyntaxToken closeBraceToken;

    internal AccessorListSyntax(SyntaxKind kind, SyntaxToken openBraceToken, CSharpSyntaxNode accessors, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (accessors != null)
        {
            this.AdjustFlagsAndWidth(accessors);
            this.accessors = accessors;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal AccessorListSyntax(SyntaxKind kind, SyntaxToken openBraceToken, CSharpSyntaxNode accessors, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (accessors != null)
        {
            this.AdjustFlagsAndWidth(accessors);
            this.accessors = accessors;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal AccessorListSyntax(SyntaxKind kind, SyntaxToken openBraceToken, CSharpSyntaxNode accessors, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (accessors != null)
        {
            this.AdjustFlagsAndWidth(accessors);
            this.accessors = accessors;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }

    public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    public SyntaxList<AccessorDeclarationSyntax> Accessors { get { return new SyntaxList<AccessorDeclarationSyntax>(this.accessors); } }
    public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBraceToken;
            case 1: return this.accessors;
            case 2: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AccessorListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAccessorList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAccessorList(this);
    }

    public AccessorListSyntax Update(SyntaxToken openBraceToken, SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || accessors != this.Accessors || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.AccessorList(openBraceToken, accessors, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AccessorListSyntax(this.Kind, this.openBraceToken, this.accessors, this.closeBraceToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AccessorListSyntax(this.Kind, this.openBraceToken, this.accessors, this.closeBraceToken, GetDiagnostics(), annotations);
    }

    internal AccessorListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var accessors = (CSharpSyntaxNode)reader.ReadValue();
      if (accessors != null)
      {
         AdjustFlagsAndWidth(accessors);
         this.accessors = accessors;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.accessors);
      writer.WriteValue(this.closeBraceToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new AccessorListSyntax(r);
    }
  }

  internal sealed partial class AccessorDeclarationSyntax : CSharpSyntaxNode
  {
    internal readonly CSharpSyntaxNode attributeLists;
    internal readonly CSharpSyntaxNode modifiers;
    internal readonly SyntaxToken keyword;
    internal readonly BlockSyntax body;
    internal readonly SyntaxToken semicolonToken;

    internal AccessorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal AccessorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal AccessorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 5;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    /// <summary>Gets the modifier list.</summary>
    public SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the keyword token, or identifier if an erroneous accessor declaration.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>Gets the optional body block which may be empty, but it is null if there are no braces.</summary>
    public BlockSyntax Body { get { return this.body; } }
    /// <summary>Gets the optional semicolon token.</summary>
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.keyword;
            case 3: return this.body;
            case 4: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AccessorDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAccessorDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAccessorDeclaration(this);
    }

    public AccessorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || body != this.Body || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.AccessorDeclaration(this.Kind, attributeLists, modifiers, keyword, body, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AccessorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.body, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AccessorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.body, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal AccessorDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var attributeLists = (CSharpSyntaxNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (CSharpSyntaxNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var body = (BlockSyntax)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.body);
      writer.WriteValue(this.semicolonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new AccessorDeclarationSyntax(r);
    }
  }

  /// <summary>Base type for parameter list syntax.</summary>
  internal abstract partial class BaseParameterListSyntax : CSharpSyntaxNode
  {
    internal BaseParameterListSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseParameterListSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseParameterListSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the parameter list.</summary>
    public abstract SeparatedSyntaxList<ParameterSyntax> Parameters { get; }
  }

  /// <summary>Parameter list syntax.</summary>
  internal sealed partial class ParameterListSyntax : BaseParameterListSyntax
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly CSharpSyntaxNode parameters;
    internal readonly SyntaxToken closeParenToken;

    internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode parameters, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode parameters, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode parameters, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>Gets the open paren token.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public override SeparatedSyntaxList<ParameterSyntax> Parameters { get { return new SeparatedSyntaxList<ParameterSyntax>(new SyntaxList<CSharpSyntaxNode>(this.parameters)); } }
    /// <summary>Gets the close paren token.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.parameters;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ParameterListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParameterList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitParameterList(this);
    }

    public ParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || parameters != this.Parameters || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.ParameterList(openParenToken, parameters, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal ParameterListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var parameters = (CSharpSyntaxNode)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.parameters);
      writer.WriteValue(this.closeParenToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ParameterListSyntax(r);
    }
  }

  /// <summary>Parameter list syntax with surrounding brackets.</summary>
  internal sealed partial class BracketedParameterListSyntax : BaseParameterListSyntax
  {
    internal readonly SyntaxToken openBracketToken;
    internal readonly CSharpSyntaxNode parameters;
    internal readonly SyntaxToken closeBracketToken;

    internal BracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode parameters, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal BracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode parameters, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal BracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode parameters, SyntaxToken closeBracketToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }

    /// <summary>Gets the open bracket token.</summary>
    public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
    public override SeparatedSyntaxList<ParameterSyntax> Parameters { get { return new SeparatedSyntaxList<ParameterSyntax>(new SyntaxList<CSharpSyntaxNode>(this.parameters)); } }
    /// <summary>Gets the close bracket token.</summary>
    public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBracketToken;
            case 1: return this.parameters;
            case 2: return this.closeBracketToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.BracketedParameterListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBracketedParameterList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBracketedParameterList(this);
    }

    public BracketedParameterListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || parameters != this.Parameters || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.BracketedParameterList(openBracketToken, parameters, closeBracketToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, GetDiagnostics(), annotations);
    }

    internal BracketedParameterListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openBracketToken = (SyntaxToken)reader.ReadValue();
      if (openBracketToken != null)
      {
         AdjustFlagsAndWidth(openBracketToken);
         this.openBracketToken = openBracketToken;
      }
      var parameters = (CSharpSyntaxNode)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
      var closeBracketToken = (SyntaxToken)reader.ReadValue();
      if (closeBracketToken != null)
      {
         AdjustFlagsAndWidth(closeBracketToken);
         this.closeBracketToken = closeBracketToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.parameters);
      writer.WriteValue(this.closeBracketToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new BracketedParameterListSyntax(r);
    }
  }

  /// <summary>Parameter syntax.</summary>
  internal sealed partial class ParameterSyntax : CSharpSyntaxNode
  {
    internal readonly CSharpSyntaxNode attributeLists;
    internal readonly CSharpSyntaxNode modifiers;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken identifier;
    internal readonly EqualsValueClauseSyntax @default;

    internal ParameterSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (@default != null)
        {
            this.AdjustFlagsAndWidth(@default);
            this.@default = @default;
        }
    }


    internal ParameterSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (@default != null)
        {
            this.AdjustFlagsAndWidth(@default);
            this.@default = @default;
        }
    }


    internal ParameterSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)
        : base(kind)
    {
        this.SlotCount = 5;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (@default != null)
        {
            this.AdjustFlagsAndWidth(@default);
            this.@default = @default;
        }
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    /// <summary>Gets the modifier list.</summary>
    public SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public EqualsValueClauseSyntax Default { get { return this.@default; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.type;
            case 3: return this.identifier;
            case 4: return this.@default;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ParameterSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParameter(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitParameter(this);
    }

    public ParameterSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type || identifier != this.Identifier || @default != this.Default)
        {
            var newNode = SyntaxFactory.Parameter(attributeLists, modifiers, type, identifier, @default);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ParameterSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.identifier, this.@default, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ParameterSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.identifier, this.@default, GetDiagnostics(), annotations);
    }

    internal ParameterSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var attributeLists = (CSharpSyntaxNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (CSharpSyntaxNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var @default = (EqualsValueClauseSyntax)reader.ReadValue();
      if (@default != null)
      {
         AdjustFlagsAndWidth(@default);
         this.@default = @default;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.type);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.@default);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ParameterSyntax(r);
    }
  }

  internal sealed partial class IncompleteMemberSyntax : MemberDeclarationSyntax
  {
    internal readonly CSharpSyntaxNode attributeLists;
    internal readonly CSharpSyntaxNode modifiers;
    internal readonly SyntaxToken refKeyword;
    internal readonly TypeSyntax type;

    internal IncompleteMemberSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken refKeyword, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
    }


    internal IncompleteMemberSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken refKeyword, TypeSyntax type, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
    }


    internal IncompleteMemberSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken refKeyword, TypeSyntax type)
        : base(kind)
    {
        this.SlotCount = 4;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (refKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
        }
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeListSyntax> AttributeLists { get { return new SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    /// <summary>Gets the modifier list.</summary>
    public SyntaxList<SyntaxToken> Modifiers { get { return new SyntaxList<SyntaxToken>(this.modifiers); } }
    public SyntaxToken RefKeyword { get { return this.refKeyword; } }
    public TypeSyntax Type { get { return this.type; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.refKeyword;
            case 3: return this.type;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.IncompleteMemberSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIncompleteMember(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIncompleteMember(this);
    }

    public IncompleteMemberSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken refKeyword, TypeSyntax type)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || refKeyword != this.RefKeyword || type != this.Type)
        {
            var newNode = SyntaxFactory.IncompleteMember(attributeLists, modifiers, refKeyword, type);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new IncompleteMemberSyntax(this.Kind, this.attributeLists, this.modifiers, this.refKeyword, this.type, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new IncompleteMemberSyntax(this.Kind, this.attributeLists, this.modifiers, this.refKeyword, this.type, GetDiagnostics(), annotations);
    }

    internal IncompleteMemberSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var attributeLists = (CSharpSyntaxNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (CSharpSyntaxNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var refKeyword = (SyntaxToken)reader.ReadValue();
      if (refKeyword != null)
      {
         AdjustFlagsAndWidth(refKeyword);
         this.refKeyword = refKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.refKeyword);
      writer.WriteValue(this.type);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new IncompleteMemberSyntax(r);
    }
  }

  internal sealed partial class SkippedTokensTriviaSyntax : StructuredTriviaSyntax
  {
    internal readonly CSharpSyntaxNode tokens;

    internal SkippedTokensTriviaSyntax(SyntaxKind kind, CSharpSyntaxNode tokens, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        if (tokens != null)
        {
            this.AdjustFlagsAndWidth(tokens);
            this.tokens = tokens;
        }
    }


    internal SkippedTokensTriviaSyntax(SyntaxKind kind, CSharpSyntaxNode tokens, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        if (tokens != null)
        {
            this.AdjustFlagsAndWidth(tokens);
            this.tokens = tokens;
        }
    }


    internal SkippedTokensTriviaSyntax(SyntaxKind kind, CSharpSyntaxNode tokens)
        : base(kind)
    {
        this.SlotCount = 1;
        if (tokens != null)
        {
            this.AdjustFlagsAndWidth(tokens);
            this.tokens = tokens;
        }
    }

    public SyntaxList<SyntaxToken> Tokens { get { return new SyntaxList<SyntaxToken>(this.tokens); } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.tokens;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.SkippedTokensTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSkippedTokensTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSkippedTokensTrivia(this);
    }

    public SkippedTokensTriviaSyntax Update(SyntaxList<SyntaxToken> tokens)
    {
        if (tokens != this.Tokens)
        {
            var newNode = SyntaxFactory.SkippedTokensTrivia(tokens);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new SkippedTokensTriviaSyntax(this.Kind, this.tokens, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new SkippedTokensTriviaSyntax(this.Kind, this.tokens, GetDiagnostics(), annotations);
    }

    internal SkippedTokensTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var tokens = (CSharpSyntaxNode)reader.ReadValue();
      if (tokens != null)
      {
         AdjustFlagsAndWidth(tokens);
         this.tokens = tokens;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.tokens);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new SkippedTokensTriviaSyntax(r);
    }
  }

  internal sealed partial class DocumentationCommentTriviaSyntax : StructuredTriviaSyntax
  {
    internal readonly CSharpSyntaxNode content;
    internal readonly SyntaxToken endOfComment;

    internal DocumentationCommentTriviaSyntax(SyntaxKind kind, CSharpSyntaxNode content, SyntaxToken endOfComment, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        if (content != null)
        {
            this.AdjustFlagsAndWidth(content);
            this.content = content;
        }
        this.AdjustFlagsAndWidth(endOfComment);
        this.endOfComment = endOfComment;
    }


    internal DocumentationCommentTriviaSyntax(SyntaxKind kind, CSharpSyntaxNode content, SyntaxToken endOfComment, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        if (content != null)
        {
            this.AdjustFlagsAndWidth(content);
            this.content = content;
        }
        this.AdjustFlagsAndWidth(endOfComment);
        this.endOfComment = endOfComment;
    }


    internal DocumentationCommentTriviaSyntax(SyntaxKind kind, CSharpSyntaxNode content, SyntaxToken endOfComment)
        : base(kind)
    {
        this.SlotCount = 2;
        if (content != null)
        {
            this.AdjustFlagsAndWidth(content);
            this.content = content;
        }
        this.AdjustFlagsAndWidth(endOfComment);
        this.endOfComment = endOfComment;
    }

    public SyntaxList<XmlNodeSyntax> Content { get { return new SyntaxList<XmlNodeSyntax>(this.content); } }
    public SyntaxToken EndOfComment { get { return this.endOfComment; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.content;
            case 1: return this.endOfComment;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.DocumentationCommentTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDocumentationCommentTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDocumentationCommentTrivia(this);
    }

    public DocumentationCommentTriviaSyntax Update(SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment)
    {
        if (content != this.Content || endOfComment != this.EndOfComment)
        {
            var newNode = SyntaxFactory.DocumentationCommentTrivia(this.Kind, content, endOfComment);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DocumentationCommentTriviaSyntax(this.Kind, this.content, this.endOfComment, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DocumentationCommentTriviaSyntax(this.Kind, this.content, this.endOfComment, GetDiagnostics(), annotations);
    }

    internal DocumentationCommentTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var content = (CSharpSyntaxNode)reader.ReadValue();
      if (content != null)
      {
         AdjustFlagsAndWidth(content);
         this.content = content;
      }
      var endOfComment = (SyntaxToken)reader.ReadValue();
      if (endOfComment != null)
      {
         AdjustFlagsAndWidth(endOfComment);
         this.endOfComment = endOfComment;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.content);
      writer.WriteValue(this.endOfComment);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new DocumentationCommentTriviaSyntax(r);
    }
  }

  /// <summary>
  /// A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or &lt;seealso&gt; documentation comment tag).
  /// For example, the M in &lt;see cref="M" /&gt;.
  /// </summary>
  internal abstract partial class CrefSyntax : CSharpSyntaxNode
  {
    internal CrefSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal CrefSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected CrefSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>
  /// A symbol reference that definitely refers to a type.
  /// For example, "int", "A::B", "A.B", "A&lt;T&gt;", but not "M()" (has parameter list) or "this" (indexer).
  /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
  /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
  /// might be a non-type member.
  /// </summary>
  internal sealed partial class TypeCrefSyntax : CrefSyntax
  {
    internal readonly TypeSyntax type;

    internal TypeCrefSyntax(SyntaxKind kind, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal TypeCrefSyntax(SyntaxKind kind, TypeSyntax type, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal TypeCrefSyntax(SyntaxKind kind, TypeSyntax type)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }

    public TypeSyntax Type { get { return this.type; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.TypeCrefSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeCref(this);
    }

    public TypeCrefSyntax Update(TypeSyntax type)
    {
        if (type != this.Type)
        {
            var newNode = SyntaxFactory.TypeCref(type);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TypeCrefSyntax(this.Kind, this.type, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TypeCrefSyntax(this.Kind, this.type, GetDiagnostics(), annotations);
    }

    internal TypeCrefSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.type);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new TypeCrefSyntax(r);
    }
  }

  /// <summary>
  /// A symbol reference to a type or non-type member that is qualified by an enclosing type or namespace.
  /// For example, cref="System.String.ToString()".
  /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
  /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
  /// might be a non-type member.
  /// </summary>
  internal sealed partial class QualifiedCrefSyntax : CrefSyntax
  {
    internal readonly TypeSyntax container;
    internal readonly SyntaxToken dotToken;
    internal readonly MemberCrefSyntax member;

    internal QualifiedCrefSyntax(SyntaxKind kind, TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(container);
        this.container = container;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(member);
        this.member = member;
    }


    internal QualifiedCrefSyntax(SyntaxKind kind, TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(container);
        this.container = container;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(member);
        this.member = member;
    }


    internal QualifiedCrefSyntax(SyntaxKind kind, TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(container);
        this.container = container;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(member);
        this.member = member;
    }

    public TypeSyntax Container { get { return this.container; } }
    public SyntaxToken DotToken { get { return this.dotToken; } }
    public MemberCrefSyntax Member { get { return this.member; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.container;
            case 1: return this.dotToken;
            case 2: return this.member;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.QualifiedCrefSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQualifiedCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitQualifiedCref(this);
    }

    public QualifiedCrefSyntax Update(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)
    {
        if (container != this.Container || dotToken != this.DotToken || member != this.Member)
        {
            var newNode = SyntaxFactory.QualifiedCref(container, dotToken, member);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new QualifiedCrefSyntax(this.Kind, this.container, this.dotToken, this.member, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new QualifiedCrefSyntax(this.Kind, this.container, this.dotToken, this.member, GetDiagnostics(), annotations);
    }

    internal QualifiedCrefSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var container = (TypeSyntax)reader.ReadValue();
      if (container != null)
      {
         AdjustFlagsAndWidth(container);
         this.container = container;
      }
      var dotToken = (SyntaxToken)reader.ReadValue();
      if (dotToken != null)
      {
         AdjustFlagsAndWidth(dotToken);
         this.dotToken = dotToken;
      }
      var member = (MemberCrefSyntax)reader.ReadValue();
      if (member != null)
      {
         AdjustFlagsAndWidth(member);
         this.member = member;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.container);
      writer.WriteValue(this.dotToken);
      writer.WriteValue(this.member);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new QualifiedCrefSyntax(r);
    }
  }

  /// <summary>
  /// The unqualified part of a CrefSyntax.
  /// For example, "ToString()" in "object.ToString()".
  /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
  /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
  /// might be a non-type member.
  /// </summary>
  internal abstract partial class MemberCrefSyntax : CrefSyntax
  {
    internal MemberCrefSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal MemberCrefSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected MemberCrefSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>
  /// A MemberCrefSyntax specified by a name (an identifier, predefined type keyword, or an alias-qualified name,
  /// with an optional type parameter list) and an optional parameter list.
  /// For example, "M", "M&lt;T&gt;" or "M(int)".
  /// Also, "A::B()" or "string()".
  /// </summary>
  internal sealed partial class NameMemberCrefSyntax : MemberCrefSyntax
  {
    internal readonly TypeSyntax name;
    internal readonly CrefParameterListSyntax parameters;

    internal NameMemberCrefSyntax(SyntaxKind kind, TypeSyntax name, CrefParameterListSyntax parameters, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal NameMemberCrefSyntax(SyntaxKind kind, TypeSyntax name, CrefParameterListSyntax parameters, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal NameMemberCrefSyntax(SyntaxKind kind, TypeSyntax name, CrefParameterListSyntax parameters)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }

    public TypeSyntax Name { get { return this.name; } }
    public CrefParameterListSyntax Parameters { get { return this.parameters; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.parameters;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.NameMemberCrefSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNameMemberCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitNameMemberCref(this);
    }

    public NameMemberCrefSyntax Update(TypeSyntax name, CrefParameterListSyntax parameters)
    {
        if (name != this.Name || parameters != this.Parameters)
        {
            var newNode = SyntaxFactory.NameMemberCref(name, parameters);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new NameMemberCrefSyntax(this.Kind, this.name, this.parameters, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new NameMemberCrefSyntax(this.Kind, this.name, this.parameters, GetDiagnostics(), annotations);
    }

    internal NameMemberCrefSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var name = (TypeSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var parameters = (CrefParameterListSyntax)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.parameters);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new NameMemberCrefSyntax(r);
    }
  }

  /// <summary>
  /// A MemberCrefSyntax specified by a this keyword and an optional parameter list.
  /// For example, "this" or "this[int]".
  /// </summary>
  internal sealed partial class IndexerMemberCrefSyntax : MemberCrefSyntax
  {
    internal readonly SyntaxToken thisKeyword;
    internal readonly CrefBracketedParameterListSyntax parameters;

    internal IndexerMemberCrefSyntax(SyntaxKind kind, SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(thisKeyword);
        this.thisKeyword = thisKeyword;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal IndexerMemberCrefSyntax(SyntaxKind kind, SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(thisKeyword);
        this.thisKeyword = thisKeyword;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal IndexerMemberCrefSyntax(SyntaxKind kind, SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(thisKeyword);
        this.thisKeyword = thisKeyword;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }

    public SyntaxToken ThisKeyword { get { return this.thisKeyword; } }
    public CrefBracketedParameterListSyntax Parameters { get { return this.parameters; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.thisKeyword;
            case 1: return this.parameters;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.IndexerMemberCrefSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIndexerMemberCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIndexerMemberCref(this);
    }

    public IndexerMemberCrefSyntax Update(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)
    {
        if (thisKeyword != this.ThisKeyword || parameters != this.Parameters)
        {
            var newNode = SyntaxFactory.IndexerMemberCref(thisKeyword, parameters);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new IndexerMemberCrefSyntax(this.Kind, this.thisKeyword, this.parameters, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new IndexerMemberCrefSyntax(this.Kind, this.thisKeyword, this.parameters, GetDiagnostics(), annotations);
    }

    internal IndexerMemberCrefSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var thisKeyword = (SyntaxToken)reader.ReadValue();
      if (thisKeyword != null)
      {
         AdjustFlagsAndWidth(thisKeyword);
         this.thisKeyword = thisKeyword;
      }
      var parameters = (CrefBracketedParameterListSyntax)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.thisKeyword);
      writer.WriteValue(this.parameters);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new IndexerMemberCrefSyntax(r);
    }
  }

  /// <summary>
  /// A MemberCrefSyntax specified by an operator keyword, an operator symbol and an optional parameter list.
  /// For example, "operator +" or "operator -[int]".
  /// NOTE: the operator must be overloadable.
  /// </summary>
  internal sealed partial class OperatorMemberCrefSyntax : MemberCrefSyntax
  {
    internal readonly SyntaxToken operatorKeyword;
    internal readonly SyntaxToken operatorToken;
    internal readonly CrefParameterListSyntax parameters;

    internal OperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal OperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal OperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }

    public SyntaxToken OperatorKeyword { get { return this.operatorKeyword; } }
    /// <summary>Gets the operator token.</summary>
    public SyntaxToken OperatorToken { get { return this.operatorToken; } }
    public CrefParameterListSyntax Parameters { get { return this.parameters; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.operatorKeyword;
            case 1: return this.operatorToken;
            case 2: return this.parameters;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.OperatorMemberCrefSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOperatorMemberCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOperatorMemberCref(this);
    }

    public OperatorMemberCrefSyntax Update(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)
    {
        if (operatorKeyword != this.OperatorKeyword || operatorToken != this.OperatorToken || parameters != this.Parameters)
        {
            var newNode = SyntaxFactory.OperatorMemberCref(operatorKeyword, operatorToken, parameters);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new OperatorMemberCrefSyntax(this.Kind, this.operatorKeyword, this.operatorToken, this.parameters, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new OperatorMemberCrefSyntax(this.Kind, this.operatorKeyword, this.operatorToken, this.parameters, GetDiagnostics(), annotations);
    }

    internal OperatorMemberCrefSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var operatorKeyword = (SyntaxToken)reader.ReadValue();
      if (operatorKeyword != null)
      {
         AdjustFlagsAndWidth(operatorKeyword);
         this.operatorKeyword = operatorKeyword;
      }
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var parameters = (CrefParameterListSyntax)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.operatorKeyword);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.parameters);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new OperatorMemberCrefSyntax(r);
    }
  }

  /// <summary>
  /// A MemberCrefSyntax specified by an implicit or explicit keyword, an operator keyword, a destination type, and an optional parameter list.
  /// For example, "implicit operator int" or "explicit operator MyType(int)".
  /// </summary>
  internal sealed partial class ConversionOperatorMemberCrefSyntax : MemberCrefSyntax
  {
    internal readonly SyntaxToken implicitOrExplicitKeyword;
    internal readonly SyntaxToken operatorKeyword;
    internal readonly TypeSyntax type;
    internal readonly CrefParameterListSyntax parameters;

    internal ConversionOperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
        this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal ConversionOperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
        this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal ConversionOperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
        this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }

    public SyntaxToken ImplicitOrExplicitKeyword { get { return this.implicitOrExplicitKeyword; } }
    public SyntaxToken OperatorKeyword { get { return this.operatorKeyword; } }
    public TypeSyntax Type { get { return this.type; } }
    public CrefParameterListSyntax Parameters { get { return this.parameters; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.implicitOrExplicitKeyword;
            case 1: return this.operatorKeyword;
            case 2: return this.type;
            case 3: return this.parameters;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ConversionOperatorMemberCrefSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConversionOperatorMemberCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConversionOperatorMemberCref(this);
    }

    public ConversionOperatorMemberCrefSyntax Update(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters)
    {
        if (implicitOrExplicitKeyword != this.ImplicitOrExplicitKeyword || operatorKeyword != this.OperatorKeyword || type != this.Type || parameters != this.Parameters)
        {
            var newNode = SyntaxFactory.ConversionOperatorMemberCref(implicitOrExplicitKeyword, operatorKeyword, type, parameters);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ConversionOperatorMemberCrefSyntax(this.Kind, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameters, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ConversionOperatorMemberCrefSyntax(this.Kind, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameters, GetDiagnostics(), annotations);
    }

    internal ConversionOperatorMemberCrefSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var implicitOrExplicitKeyword = (SyntaxToken)reader.ReadValue();
      if (implicitOrExplicitKeyword != null)
      {
         AdjustFlagsAndWidth(implicitOrExplicitKeyword);
         this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
      }
      var operatorKeyword = (SyntaxToken)reader.ReadValue();
      if (operatorKeyword != null)
      {
         AdjustFlagsAndWidth(operatorKeyword);
         this.operatorKeyword = operatorKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var parameters = (CrefParameterListSyntax)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.implicitOrExplicitKeyword);
      writer.WriteValue(this.operatorKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.parameters);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ConversionOperatorMemberCrefSyntax(r);
    }
  }

  /// <summary>
  /// A list of cref parameters with surrounding punctuation.
  /// Unlike regular parameters, cref parameters do not have names.
  /// </summary>
  internal abstract partial class BaseCrefParameterListSyntax : CSharpSyntaxNode
  {
    internal BaseCrefParameterListSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseCrefParameterListSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseCrefParameterListSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the parameter list.</summary>
    public abstract SeparatedSyntaxList<CrefParameterSyntax> Parameters { get; }
  }

  /// <summary>
  /// A parenthesized list of cref parameters.
  /// </summary>
  internal sealed partial class CrefParameterListSyntax : BaseCrefParameterListSyntax
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly CSharpSyntaxNode parameters;
    internal readonly SyntaxToken closeParenToken;

    internal CrefParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode parameters, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CrefParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode parameters, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CrefParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode parameters, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>Gets the open paren token.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public override SeparatedSyntaxList<CrefParameterSyntax> Parameters { get { return new SeparatedSyntaxList<CrefParameterSyntax>(new SyntaxList<CSharpSyntaxNode>(this.parameters)); } }
    /// <summary>Gets the close paren token.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.parameters;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CrefParameterListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCrefParameterList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCrefParameterList(this);
    }

    public CrefParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || parameters != this.Parameters || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.CrefParameterList(openParenToken, parameters, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CrefParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CrefParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal CrefParameterListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var parameters = (CSharpSyntaxNode)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.parameters);
      writer.WriteValue(this.closeParenToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new CrefParameterListSyntax(r);
    }
  }

  /// <summary>
  /// A bracketed list of cref parameters.
  /// </summary>
  internal sealed partial class CrefBracketedParameterListSyntax : BaseCrefParameterListSyntax
  {
    internal readonly SyntaxToken openBracketToken;
    internal readonly CSharpSyntaxNode parameters;
    internal readonly SyntaxToken closeBracketToken;

    internal CrefBracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode parameters, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal CrefBracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode parameters, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal CrefBracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode parameters, SyntaxToken closeBracketToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }

    /// <summary>Gets the open bracket token.</summary>
    public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
    public override SeparatedSyntaxList<CrefParameterSyntax> Parameters { get { return new SeparatedSyntaxList<CrefParameterSyntax>(new SyntaxList<CSharpSyntaxNode>(this.parameters)); } }
    /// <summary>Gets the close bracket token.</summary>
    public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBracketToken;
            case 1: return this.parameters;
            case 2: return this.closeBracketToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CrefBracketedParameterListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCrefBracketedParameterList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCrefBracketedParameterList(this);
    }

    public CrefBracketedParameterListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || parameters != this.Parameters || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.CrefBracketedParameterList(openBracketToken, parameters, closeBracketToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CrefBracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CrefBracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, GetDiagnostics(), annotations);
    }

    internal CrefBracketedParameterListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openBracketToken = (SyntaxToken)reader.ReadValue();
      if (openBracketToken != null)
      {
         AdjustFlagsAndWidth(openBracketToken);
         this.openBracketToken = openBracketToken;
      }
      var parameters = (CSharpSyntaxNode)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
      var closeBracketToken = (SyntaxToken)reader.ReadValue();
      if (closeBracketToken != null)
      {
         AdjustFlagsAndWidth(closeBracketToken);
         this.closeBracketToken = closeBracketToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.parameters);
      writer.WriteValue(this.closeBracketToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new CrefBracketedParameterListSyntax(r);
    }
  }

  /// <summary>
  /// An element of a BaseCrefParameterListSyntax.
  /// Unlike a regular parameter, a cref parameter has only an optional ref or out keyword and a type -
  /// there is no name and there are no attributes or other modifiers.
  /// </summary>
  internal sealed partial class CrefParameterSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken refOrOutKeyword;
    internal readonly TypeSyntax type;

    internal CrefParameterSyntax(SyntaxKind kind, SyntaxToken refOrOutKeyword, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        if (refOrOutKeyword != null)
        {
            this.AdjustFlagsAndWidth(refOrOutKeyword);
            this.refOrOutKeyword = refOrOutKeyword;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal CrefParameterSyntax(SyntaxKind kind, SyntaxToken refOrOutKeyword, TypeSyntax type, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        if (refOrOutKeyword != null)
        {
            this.AdjustFlagsAndWidth(refOrOutKeyword);
            this.refOrOutKeyword = refOrOutKeyword;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal CrefParameterSyntax(SyntaxKind kind, SyntaxToken refOrOutKeyword, TypeSyntax type)
        : base(kind)
    {
        this.SlotCount = 2;
        if (refOrOutKeyword != null)
        {
            this.AdjustFlagsAndWidth(refOrOutKeyword);
            this.refOrOutKeyword = refOrOutKeyword;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }

    public SyntaxToken RefOrOutKeyword { get { return this.refOrOutKeyword; } }
    public TypeSyntax Type { get { return this.type; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.refOrOutKeyword;
            case 1: return this.type;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CrefParameterSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCrefParameter(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCrefParameter(this);
    }

    public CrefParameterSyntax Update(SyntaxToken refOrOutKeyword, TypeSyntax type)
    {
        if (refOrOutKeyword != this.RefOrOutKeyword || type != this.Type)
        {
            var newNode = SyntaxFactory.CrefParameter(refOrOutKeyword, type);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CrefParameterSyntax(this.Kind, this.refOrOutKeyword, this.type, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CrefParameterSyntax(this.Kind, this.refOrOutKeyword, this.type, GetDiagnostics(), annotations);
    }

    internal CrefParameterSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var refOrOutKeyword = (SyntaxToken)reader.ReadValue();
      if (refOrOutKeyword != null)
      {
         AdjustFlagsAndWidth(refOrOutKeyword);
         this.refOrOutKeyword = refOrOutKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.refOrOutKeyword);
      writer.WriteValue(this.type);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new CrefParameterSyntax(r);
    }
  }

  internal abstract partial class XmlNodeSyntax : CSharpSyntaxNode
  {
    internal XmlNodeSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal XmlNodeSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected XmlNodeSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal sealed partial class XmlElementSyntax : XmlNodeSyntax
  {
    internal readonly XmlElementStartTagSyntax startTag;
    internal readonly CSharpSyntaxNode content;
    internal readonly XmlElementEndTagSyntax endTag;

    internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, CSharpSyntaxNode content, XmlElementEndTagSyntax endTag, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startTag);
        this.startTag = startTag;
        if (content != null)
        {
            this.AdjustFlagsAndWidth(content);
            this.content = content;
        }
        this.AdjustFlagsAndWidth(endTag);
        this.endTag = endTag;
    }


    internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, CSharpSyntaxNode content, XmlElementEndTagSyntax endTag, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startTag);
        this.startTag = startTag;
        if (content != null)
        {
            this.AdjustFlagsAndWidth(content);
            this.content = content;
        }
        this.AdjustFlagsAndWidth(endTag);
        this.endTag = endTag;
    }


    internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, CSharpSyntaxNode content, XmlElementEndTagSyntax endTag)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startTag);
        this.startTag = startTag;
        if (content != null)
        {
            this.AdjustFlagsAndWidth(content);
            this.content = content;
        }
        this.AdjustFlagsAndWidth(endTag);
        this.endTag = endTag;
    }

    public XmlElementStartTagSyntax StartTag { get { return this.startTag; } }
    public SyntaxList<XmlNodeSyntax> Content { get { return new SyntaxList<XmlNodeSyntax>(this.content); } }
    public XmlElementEndTagSyntax EndTag { get { return this.endTag; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.startTag;
            case 1: return this.content;
            case 2: return this.endTag;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlElementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlElement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlElement(this);
    }

    public XmlElementSyntax Update(XmlElementStartTagSyntax startTag, SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
    {
        if (startTag != this.StartTag || content != this.Content || endTag != this.EndTag)
        {
            var newNode = SyntaxFactory.XmlElement(startTag, content, endTag);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlElementSyntax(this.Kind, this.startTag, this.content, this.endTag, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlElementSyntax(this.Kind, this.startTag, this.content, this.endTag, GetDiagnostics(), annotations);
    }

    internal XmlElementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var startTag = (XmlElementStartTagSyntax)reader.ReadValue();
      if (startTag != null)
      {
         AdjustFlagsAndWidth(startTag);
         this.startTag = startTag;
      }
      var content = (CSharpSyntaxNode)reader.ReadValue();
      if (content != null)
      {
         AdjustFlagsAndWidth(content);
         this.content = content;
      }
      var endTag = (XmlElementEndTagSyntax)reader.ReadValue();
      if (endTag != null)
      {
         AdjustFlagsAndWidth(endTag);
         this.endTag = endTag;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.startTag);
      writer.WriteValue(this.content);
      writer.WriteValue(this.endTag);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new XmlElementSyntax(r);
    }
  }

  internal sealed partial class XmlElementStartTagSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken lessThanToken;
    internal readonly XmlNameSyntax name;
    internal readonly CSharpSyntaxNode attributes;
    internal readonly SyntaxToken greaterThanToken;

    internal XmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, CSharpSyntaxNode attributes, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal XmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, CSharpSyntaxNode attributes, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal XmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, CSharpSyntaxNode attributes, SyntaxToken greaterThanToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }

    public SyntaxToken LessThanToken { get { return this.lessThanToken; } }
    public XmlNameSyntax Name { get { return this.name; } }
    public SyntaxList<XmlAttributeSyntax> Attributes { get { return new SyntaxList<XmlAttributeSyntax>(this.attributes); } }
    public SyntaxToken GreaterThanToken { get { return this.greaterThanToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanToken;
            case 1: return this.name;
            case 2: return this.attributes;
            case 3: return this.greaterThanToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlElementStartTagSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlElementStartTag(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlElementStartTag(this);
    }

    public XmlElementStartTagSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlElementStartTag(lessThanToken, name, attributes, greaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlElementStartTagSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.greaterThanToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlElementStartTagSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.greaterThanToken, GetDiagnostics(), annotations);
    }

    internal XmlElementStartTagSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var lessThanToken = (SyntaxToken)reader.ReadValue();
      if (lessThanToken != null)
      {
         AdjustFlagsAndWidth(lessThanToken);
         this.lessThanToken = lessThanToken;
      }
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var attributes = (CSharpSyntaxNode)reader.ReadValue();
      if (attributes != null)
      {
         AdjustFlagsAndWidth(attributes);
         this.attributes = attributes;
      }
      var greaterThanToken = (SyntaxToken)reader.ReadValue();
      if (greaterThanToken != null)
      {
         AdjustFlagsAndWidth(greaterThanToken);
         this.greaterThanToken = greaterThanToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanToken);
      writer.WriteValue(this.name);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.greaterThanToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new XmlElementStartTagSyntax(r);
    }
  }

  internal sealed partial class XmlElementEndTagSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken lessThanSlashToken;
    internal readonly XmlNameSyntax name;
    internal readonly SyntaxToken greaterThanToken;

    internal XmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanSlashToken);
        this.lessThanSlashToken = lessThanSlashToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal XmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanSlashToken);
        this.lessThanSlashToken = lessThanSlashToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal XmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanSlashToken);
        this.lessThanSlashToken = lessThanSlashToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }

    public SyntaxToken LessThanSlashToken { get { return this.lessThanSlashToken; } }
    public XmlNameSyntax Name { get { return this.name; } }
    public SyntaxToken GreaterThanToken { get { return this.greaterThanToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanSlashToken;
            case 1: return this.name;
            case 2: return this.greaterThanToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlElementEndTagSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlElementEndTag(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlElementEndTag(this);
    }

    public XmlElementEndTagSyntax Update(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
    {
        if (lessThanSlashToken != this.LessThanSlashToken || name != this.Name || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlElementEndTag(lessThanSlashToken, name, greaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlElementEndTagSyntax(this.Kind, this.lessThanSlashToken, this.name, this.greaterThanToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlElementEndTagSyntax(this.Kind, this.lessThanSlashToken, this.name, this.greaterThanToken, GetDiagnostics(), annotations);
    }

    internal XmlElementEndTagSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var lessThanSlashToken = (SyntaxToken)reader.ReadValue();
      if (lessThanSlashToken != null)
      {
         AdjustFlagsAndWidth(lessThanSlashToken);
         this.lessThanSlashToken = lessThanSlashToken;
      }
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var greaterThanToken = (SyntaxToken)reader.ReadValue();
      if (greaterThanToken != null)
      {
         AdjustFlagsAndWidth(greaterThanToken);
         this.greaterThanToken = greaterThanToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanSlashToken);
      writer.WriteValue(this.name);
      writer.WriteValue(this.greaterThanToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new XmlElementEndTagSyntax(r);
    }
  }

  internal sealed partial class XmlEmptyElementSyntax : XmlNodeSyntax
  {
    internal readonly SyntaxToken lessThanToken;
    internal readonly XmlNameSyntax name;
    internal readonly CSharpSyntaxNode attributes;
    internal readonly SyntaxToken slashGreaterThanToken;

    internal XmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, CSharpSyntaxNode attributes, SyntaxToken slashGreaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(slashGreaterThanToken);
        this.slashGreaterThanToken = slashGreaterThanToken;
    }


    internal XmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, CSharpSyntaxNode attributes, SyntaxToken slashGreaterThanToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(slashGreaterThanToken);
        this.slashGreaterThanToken = slashGreaterThanToken;
    }


    internal XmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, CSharpSyntaxNode attributes, SyntaxToken slashGreaterThanToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(slashGreaterThanToken);
        this.slashGreaterThanToken = slashGreaterThanToken;
    }

    public SyntaxToken LessThanToken { get { return this.lessThanToken; } }
    public XmlNameSyntax Name { get { return this.name; } }
    public SyntaxList<XmlAttributeSyntax> Attributes { get { return new SyntaxList<XmlAttributeSyntax>(this.attributes); } }
    public SyntaxToken SlashGreaterThanToken { get { return this.slashGreaterThanToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanToken;
            case 1: return this.name;
            case 2: return this.attributes;
            case 3: return this.slashGreaterThanToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlEmptyElementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlEmptyElement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlEmptyElement(this);
    }

    public XmlEmptyElementSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || slashGreaterThanToken != this.SlashGreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlEmptyElement(lessThanToken, name, attributes, slashGreaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlEmptyElementSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.slashGreaterThanToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlEmptyElementSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.slashGreaterThanToken, GetDiagnostics(), annotations);
    }

    internal XmlEmptyElementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var lessThanToken = (SyntaxToken)reader.ReadValue();
      if (lessThanToken != null)
      {
         AdjustFlagsAndWidth(lessThanToken);
         this.lessThanToken = lessThanToken;
      }
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var attributes = (CSharpSyntaxNode)reader.ReadValue();
      if (attributes != null)
      {
         AdjustFlagsAndWidth(attributes);
         this.attributes = attributes;
      }
      var slashGreaterThanToken = (SyntaxToken)reader.ReadValue();
      if (slashGreaterThanToken != null)
      {
         AdjustFlagsAndWidth(slashGreaterThanToken);
         this.slashGreaterThanToken = slashGreaterThanToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanToken);
      writer.WriteValue(this.name);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.slashGreaterThanToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new XmlEmptyElementSyntax(r);
    }
  }

  internal sealed partial class XmlNameSyntax : CSharpSyntaxNode
  {
    internal readonly XmlPrefixSyntax prefix;
    internal readonly SyntaxToken localName;

    internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax prefix, SyntaxToken localName, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        if (prefix != null)
        {
            this.AdjustFlagsAndWidth(prefix);
            this.prefix = prefix;
        }
        this.AdjustFlagsAndWidth(localName);
        this.localName = localName;
    }


    internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax prefix, SyntaxToken localName, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        if (prefix != null)
        {
            this.AdjustFlagsAndWidth(prefix);
            this.prefix = prefix;
        }
        this.AdjustFlagsAndWidth(localName);
        this.localName = localName;
    }


    internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax prefix, SyntaxToken localName)
        : base(kind)
    {
        this.SlotCount = 2;
        if (prefix != null)
        {
            this.AdjustFlagsAndWidth(prefix);
            this.prefix = prefix;
        }
        this.AdjustFlagsAndWidth(localName);
        this.localName = localName;
    }

    public XmlPrefixSyntax Prefix { get { return this.prefix; } }
    public SyntaxToken LocalName { get { return this.localName; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.prefix;
            case 1: return this.localName;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlNameSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlName(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlName(this);
    }

    public XmlNameSyntax Update(XmlPrefixSyntax prefix, SyntaxToken localName)
    {
        if (prefix != this.Prefix || localName != this.LocalName)
        {
            var newNode = SyntaxFactory.XmlName(prefix, localName);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlNameSyntax(this.Kind, this.prefix, this.localName, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlNameSyntax(this.Kind, this.prefix, this.localName, GetDiagnostics(), annotations);
    }

    internal XmlNameSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var prefix = (XmlPrefixSyntax)reader.ReadValue();
      if (prefix != null)
      {
         AdjustFlagsAndWidth(prefix);
         this.prefix = prefix;
      }
      var localName = (SyntaxToken)reader.ReadValue();
      if (localName != null)
      {
         AdjustFlagsAndWidth(localName);
         this.localName = localName;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.prefix);
      writer.WriteValue(this.localName);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new XmlNameSyntax(r);
    }
  }

  internal sealed partial class XmlPrefixSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken prefix;
    internal readonly SyntaxToken colonToken;

    internal XmlPrefixSyntax(SyntaxKind kind, SyntaxToken prefix, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(prefix);
        this.prefix = prefix;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal XmlPrefixSyntax(SyntaxKind kind, SyntaxToken prefix, SyntaxToken colonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(prefix);
        this.prefix = prefix;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal XmlPrefixSyntax(SyntaxKind kind, SyntaxToken prefix, SyntaxToken colonToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(prefix);
        this.prefix = prefix;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }

    public SyntaxToken Prefix { get { return this.prefix; } }
    public SyntaxToken ColonToken { get { return this.colonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.prefix;
            case 1: return this.colonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlPrefixSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlPrefix(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlPrefix(this);
    }

    public XmlPrefixSyntax Update(SyntaxToken prefix, SyntaxToken colonToken)
    {
        if (prefix != this.Prefix || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.XmlPrefix(prefix, colonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlPrefixSyntax(this.Kind, this.prefix, this.colonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlPrefixSyntax(this.Kind, this.prefix, this.colonToken, GetDiagnostics(), annotations);
    }

    internal XmlPrefixSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var prefix = (SyntaxToken)reader.ReadValue();
      if (prefix != null)
      {
         AdjustFlagsAndWidth(prefix);
         this.prefix = prefix;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.prefix);
      writer.WriteValue(this.colonToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new XmlPrefixSyntax(r);
    }
  }

  internal abstract partial class XmlAttributeSyntax : CSharpSyntaxNode
  {
    internal XmlAttributeSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal XmlAttributeSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected XmlAttributeSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    public abstract XmlNameSyntax Name { get; }

    public abstract SyntaxToken EqualsToken { get; }

    public abstract SyntaxToken StartQuoteToken { get; }

    public abstract SyntaxToken EndQuoteToken { get; }
  }

  internal sealed partial class XmlTextAttributeSyntax : XmlAttributeSyntax
  {
    internal readonly XmlNameSyntax name;
    internal readonly SyntaxToken equalsToken;
    internal readonly SyntaxToken startQuoteToken;
    internal readonly CSharpSyntaxNode textTokens;
    internal readonly SyntaxToken endQuoteToken;

    internal XmlTextAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CSharpSyntaxNode textTokens, SyntaxToken endQuoteToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }


    internal XmlTextAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CSharpSyntaxNode textTokens, SyntaxToken endQuoteToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }


    internal XmlTextAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CSharpSyntaxNode textTokens, SyntaxToken endQuoteToken)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }

    public override XmlNameSyntax Name { get { return this.name; } }
    public override SyntaxToken EqualsToken { get { return this.equalsToken; } }
    public override SyntaxToken StartQuoteToken { get { return this.startQuoteToken; } }
    public SyntaxList<SyntaxToken> TextTokens { get { return new SyntaxList<SyntaxToken>(this.textTokens); } }
    public override SyntaxToken EndQuoteToken { get { return this.endQuoteToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.equalsToken;
            case 2: return this.startQuoteToken;
            case 3: return this.textTokens;
            case 4: return this.endQuoteToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlTextAttributeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlTextAttribute(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlTextAttribute(this);
    }

    public XmlTextAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxList<SyntaxToken> textTokens, SyntaxToken endQuoteToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || textTokens != this.TextTokens || endQuoteToken != this.EndQuoteToken)
        {
            var newNode = SyntaxFactory.XmlTextAttribute(name, equalsToken, startQuoteToken, textTokens, endQuoteToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlTextAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.textTokens, this.endQuoteToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlTextAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.textTokens, this.endQuoteToken, GetDiagnostics(), annotations);
    }

    internal XmlTextAttributeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var equalsToken = (SyntaxToken)reader.ReadValue();
      if (equalsToken != null)
      {
         AdjustFlagsAndWidth(equalsToken);
         this.equalsToken = equalsToken;
      }
      var startQuoteToken = (SyntaxToken)reader.ReadValue();
      if (startQuoteToken != null)
      {
         AdjustFlagsAndWidth(startQuoteToken);
         this.startQuoteToken = startQuoteToken;
      }
      var textTokens = (CSharpSyntaxNode)reader.ReadValue();
      if (textTokens != null)
      {
         AdjustFlagsAndWidth(textTokens);
         this.textTokens = textTokens;
      }
      var endQuoteToken = (SyntaxToken)reader.ReadValue();
      if (endQuoteToken != null)
      {
         AdjustFlagsAndWidth(endQuoteToken);
         this.endQuoteToken = endQuoteToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.equalsToken);
      writer.WriteValue(this.startQuoteToken);
      writer.WriteValue(this.textTokens);
      writer.WriteValue(this.endQuoteToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new XmlTextAttributeSyntax(r);
    }
  }

  internal sealed partial class XmlCrefAttributeSyntax : XmlAttributeSyntax
  {
    internal readonly XmlNameSyntax name;
    internal readonly SyntaxToken equalsToken;
    internal readonly SyntaxToken startQuoteToken;
    internal readonly CrefSyntax cref;
    internal readonly SyntaxToken endQuoteToken;

    internal XmlCrefAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        this.AdjustFlagsAndWidth(cref);
        this.cref = cref;
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }


    internal XmlCrefAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        this.AdjustFlagsAndWidth(cref);
        this.cref = cref;
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }


    internal XmlCrefAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        this.AdjustFlagsAndWidth(cref);
        this.cref = cref;
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }

    public override XmlNameSyntax Name { get { return this.name; } }
    public override SyntaxToken EqualsToken { get { return this.equalsToken; } }
    public override SyntaxToken StartQuoteToken { get { return this.startQuoteToken; } }
    public CrefSyntax Cref { get { return this.cref; } }
    public override SyntaxToken EndQuoteToken { get { return this.endQuoteToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.equalsToken;
            case 2: return this.startQuoteToken;
            case 3: return this.cref;
            case 4: return this.endQuoteToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlCrefAttributeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlCrefAttribute(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlCrefAttribute(this);
    }

    public XmlCrefAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || cref != this.Cref || endQuoteToken != this.EndQuoteToken)
        {
            var newNode = SyntaxFactory.XmlCrefAttribute(name, equalsToken, startQuoteToken, cref, endQuoteToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlCrefAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.cref, this.endQuoteToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlCrefAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.cref, this.endQuoteToken, GetDiagnostics(), annotations);
    }

    internal XmlCrefAttributeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var equalsToken = (SyntaxToken)reader.ReadValue();
      if (equalsToken != null)
      {
         AdjustFlagsAndWidth(equalsToken);
         this.equalsToken = equalsToken;
      }
      var startQuoteToken = (SyntaxToken)reader.ReadValue();
      if (startQuoteToken != null)
      {
         AdjustFlagsAndWidth(startQuoteToken);
         this.startQuoteToken = startQuoteToken;
      }
      var cref = (CrefSyntax)reader.ReadValue();
      if (cref != null)
      {
         AdjustFlagsAndWidth(cref);
         this.cref = cref;
      }
      var endQuoteToken = (SyntaxToken)reader.ReadValue();
      if (endQuoteToken != null)
      {
         AdjustFlagsAndWidth(endQuoteToken);
         this.endQuoteToken = endQuoteToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.equalsToken);
      writer.WriteValue(this.startQuoteToken);
      writer.WriteValue(this.cref);
      writer.WriteValue(this.endQuoteToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new XmlCrefAttributeSyntax(r);
    }
  }

  internal sealed partial class XmlNameAttributeSyntax : XmlAttributeSyntax
  {
    internal readonly XmlNameSyntax name;
    internal readonly SyntaxToken equalsToken;
    internal readonly SyntaxToken startQuoteToken;
    internal readonly IdentifierNameSyntax identifier;
    internal readonly SyntaxToken endQuoteToken;

    internal XmlNameAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }


    internal XmlNameAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }


    internal XmlNameAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }

    public override XmlNameSyntax Name { get { return this.name; } }
    public override SyntaxToken EqualsToken { get { return this.equalsToken; } }
    public override SyntaxToken StartQuoteToken { get { return this.startQuoteToken; } }
    public IdentifierNameSyntax Identifier { get { return this.identifier; } }
    public override SyntaxToken EndQuoteToken { get { return this.endQuoteToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.equalsToken;
            case 2: return this.startQuoteToken;
            case 3: return this.identifier;
            case 4: return this.endQuoteToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlNameAttributeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlNameAttribute(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlNameAttribute(this);
    }

    public XmlNameAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || identifier != this.Identifier || endQuoteToken != this.EndQuoteToken)
        {
            var newNode = SyntaxFactory.XmlNameAttribute(name, equalsToken, startQuoteToken, identifier, endQuoteToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlNameAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.identifier, this.endQuoteToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlNameAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.identifier, this.endQuoteToken, GetDiagnostics(), annotations);
    }

    internal XmlNameAttributeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var equalsToken = (SyntaxToken)reader.ReadValue();
      if (equalsToken != null)
      {
         AdjustFlagsAndWidth(equalsToken);
         this.equalsToken = equalsToken;
      }
      var startQuoteToken = (SyntaxToken)reader.ReadValue();
      if (startQuoteToken != null)
      {
         AdjustFlagsAndWidth(startQuoteToken);
         this.startQuoteToken = startQuoteToken;
      }
      var identifier = (IdentifierNameSyntax)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var endQuoteToken = (SyntaxToken)reader.ReadValue();
      if (endQuoteToken != null)
      {
         AdjustFlagsAndWidth(endQuoteToken);
         this.endQuoteToken = endQuoteToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.equalsToken);
      writer.WriteValue(this.startQuoteToken);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.endQuoteToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new XmlNameAttributeSyntax(r);
    }
  }

  internal sealed partial class XmlTextSyntax : XmlNodeSyntax
  {
    internal readonly CSharpSyntaxNode textTokens;

    internal XmlTextSyntax(SyntaxKind kind, CSharpSyntaxNode textTokens, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
    }


    internal XmlTextSyntax(SyntaxKind kind, CSharpSyntaxNode textTokens, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
    }


    internal XmlTextSyntax(SyntaxKind kind, CSharpSyntaxNode textTokens)
        : base(kind)
    {
        this.SlotCount = 1;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
    }

    public SyntaxList<SyntaxToken> TextTokens { get { return new SyntaxList<SyntaxToken>(this.textTokens); } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.textTokens;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlTextSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlText(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlText(this);
    }

    public XmlTextSyntax Update(SyntaxList<SyntaxToken> textTokens)
    {
        if (textTokens != this.TextTokens)
        {
            var newNode = SyntaxFactory.XmlText(textTokens);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlTextSyntax(this.Kind, this.textTokens, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlTextSyntax(this.Kind, this.textTokens, GetDiagnostics(), annotations);
    }

    internal XmlTextSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var textTokens = (CSharpSyntaxNode)reader.ReadValue();
      if (textTokens != null)
      {
         AdjustFlagsAndWidth(textTokens);
         this.textTokens = textTokens;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.textTokens);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new XmlTextSyntax(r);
    }
  }

  internal sealed partial class XmlCDataSectionSyntax : XmlNodeSyntax
  {
    internal readonly SyntaxToken startCDataToken;
    internal readonly CSharpSyntaxNode textTokens;
    internal readonly SyntaxToken endCDataToken;

    internal XmlCDataSectionSyntax(SyntaxKind kind, SyntaxToken startCDataToken, CSharpSyntaxNode textTokens, SyntaxToken endCDataToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startCDataToken);
        this.startCDataToken = startCDataToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endCDataToken);
        this.endCDataToken = endCDataToken;
    }


    internal XmlCDataSectionSyntax(SyntaxKind kind, SyntaxToken startCDataToken, CSharpSyntaxNode textTokens, SyntaxToken endCDataToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startCDataToken);
        this.startCDataToken = startCDataToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endCDataToken);
        this.endCDataToken = endCDataToken;
    }


    internal XmlCDataSectionSyntax(SyntaxKind kind, SyntaxToken startCDataToken, CSharpSyntaxNode textTokens, SyntaxToken endCDataToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startCDataToken);
        this.startCDataToken = startCDataToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endCDataToken);
        this.endCDataToken = endCDataToken;
    }

    public SyntaxToken StartCDataToken { get { return this.startCDataToken; } }
    public SyntaxList<SyntaxToken> TextTokens { get { return new SyntaxList<SyntaxToken>(this.textTokens); } }
    public SyntaxToken EndCDataToken { get { return this.endCDataToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.startCDataToken;
            case 1: return this.textTokens;
            case 2: return this.endCDataToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlCDataSectionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlCDataSection(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlCDataSection(this);
    }

    public XmlCDataSectionSyntax Update(SyntaxToken startCDataToken, SyntaxList<SyntaxToken> textTokens, SyntaxToken endCDataToken)
    {
        if (startCDataToken != this.StartCDataToken || textTokens != this.TextTokens || endCDataToken != this.EndCDataToken)
        {
            var newNode = SyntaxFactory.XmlCDataSection(startCDataToken, textTokens, endCDataToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlCDataSectionSyntax(this.Kind, this.startCDataToken, this.textTokens, this.endCDataToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlCDataSectionSyntax(this.Kind, this.startCDataToken, this.textTokens, this.endCDataToken, GetDiagnostics(), annotations);
    }

    internal XmlCDataSectionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var startCDataToken = (SyntaxToken)reader.ReadValue();
      if (startCDataToken != null)
      {
         AdjustFlagsAndWidth(startCDataToken);
         this.startCDataToken = startCDataToken;
      }
      var textTokens = (CSharpSyntaxNode)reader.ReadValue();
      if (textTokens != null)
      {
         AdjustFlagsAndWidth(textTokens);
         this.textTokens = textTokens;
      }
      var endCDataToken = (SyntaxToken)reader.ReadValue();
      if (endCDataToken != null)
      {
         AdjustFlagsAndWidth(endCDataToken);
         this.endCDataToken = endCDataToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.startCDataToken);
      writer.WriteValue(this.textTokens);
      writer.WriteValue(this.endCDataToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new XmlCDataSectionSyntax(r);
    }
  }

  internal sealed partial class XmlProcessingInstructionSyntax : XmlNodeSyntax
  {
    internal readonly SyntaxToken startProcessingInstructionToken;
    internal readonly XmlNameSyntax name;
    internal readonly CSharpSyntaxNode textTokens;
    internal readonly SyntaxToken endProcessingInstructionToken;

    internal XmlProcessingInstructionSyntax(SyntaxKind kind, SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, CSharpSyntaxNode textTokens, SyntaxToken endProcessingInstructionToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(startProcessingInstructionToken);
        this.startProcessingInstructionToken = startProcessingInstructionToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endProcessingInstructionToken);
        this.endProcessingInstructionToken = endProcessingInstructionToken;
    }


    internal XmlProcessingInstructionSyntax(SyntaxKind kind, SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, CSharpSyntaxNode textTokens, SyntaxToken endProcessingInstructionToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(startProcessingInstructionToken);
        this.startProcessingInstructionToken = startProcessingInstructionToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endProcessingInstructionToken);
        this.endProcessingInstructionToken = endProcessingInstructionToken;
    }


    internal XmlProcessingInstructionSyntax(SyntaxKind kind, SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, CSharpSyntaxNode textTokens, SyntaxToken endProcessingInstructionToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(startProcessingInstructionToken);
        this.startProcessingInstructionToken = startProcessingInstructionToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endProcessingInstructionToken);
        this.endProcessingInstructionToken = endProcessingInstructionToken;
    }

    public SyntaxToken StartProcessingInstructionToken { get { return this.startProcessingInstructionToken; } }
    public XmlNameSyntax Name { get { return this.name; } }
    public SyntaxList<SyntaxToken> TextTokens { get { return new SyntaxList<SyntaxToken>(this.textTokens); } }
    public SyntaxToken EndProcessingInstructionToken { get { return this.endProcessingInstructionToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.startProcessingInstructionToken;
            case 1: return this.name;
            case 2: return this.textTokens;
            case 3: return this.endProcessingInstructionToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlProcessingInstructionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlProcessingInstruction(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlProcessingInstruction(this);
    }

    public XmlProcessingInstructionSyntax Update(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxList<SyntaxToken> textTokens, SyntaxToken endProcessingInstructionToken)
    {
        if (startProcessingInstructionToken != this.StartProcessingInstructionToken || name != this.Name || textTokens != this.TextTokens || endProcessingInstructionToken != this.EndProcessingInstructionToken)
        {
            var newNode = SyntaxFactory.XmlProcessingInstruction(startProcessingInstructionToken, name, textTokens, endProcessingInstructionToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlProcessingInstructionSyntax(this.Kind, this.startProcessingInstructionToken, this.name, this.textTokens, this.endProcessingInstructionToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlProcessingInstructionSyntax(this.Kind, this.startProcessingInstructionToken, this.name, this.textTokens, this.endProcessingInstructionToken, GetDiagnostics(), annotations);
    }

    internal XmlProcessingInstructionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var startProcessingInstructionToken = (SyntaxToken)reader.ReadValue();
      if (startProcessingInstructionToken != null)
      {
         AdjustFlagsAndWidth(startProcessingInstructionToken);
         this.startProcessingInstructionToken = startProcessingInstructionToken;
      }
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var textTokens = (CSharpSyntaxNode)reader.ReadValue();
      if (textTokens != null)
      {
         AdjustFlagsAndWidth(textTokens);
         this.textTokens = textTokens;
      }
      var endProcessingInstructionToken = (SyntaxToken)reader.ReadValue();
      if (endProcessingInstructionToken != null)
      {
         AdjustFlagsAndWidth(endProcessingInstructionToken);
         this.endProcessingInstructionToken = endProcessingInstructionToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.startProcessingInstructionToken);
      writer.WriteValue(this.name);
      writer.WriteValue(this.textTokens);
      writer.WriteValue(this.endProcessingInstructionToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new XmlProcessingInstructionSyntax(r);
    }
  }

  internal sealed partial class XmlCommentSyntax : XmlNodeSyntax
  {
    internal readonly SyntaxToken lessThanExclamationMinusMinusToken;
    internal readonly CSharpSyntaxNode textTokens;
    internal readonly SyntaxToken minusMinusGreaterThanToken;

    internal XmlCommentSyntax(SyntaxKind kind, SyntaxToken lessThanExclamationMinusMinusToken, CSharpSyntaxNode textTokens, SyntaxToken minusMinusGreaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
        this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
        this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
    }


    internal XmlCommentSyntax(SyntaxKind kind, SyntaxToken lessThanExclamationMinusMinusToken, CSharpSyntaxNode textTokens, SyntaxToken minusMinusGreaterThanToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
        this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
        this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
    }


    internal XmlCommentSyntax(SyntaxKind kind, SyntaxToken lessThanExclamationMinusMinusToken, CSharpSyntaxNode textTokens, SyntaxToken minusMinusGreaterThanToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
        this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
        this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
    }

    public SyntaxToken LessThanExclamationMinusMinusToken { get { return this.lessThanExclamationMinusMinusToken; } }
    public SyntaxList<SyntaxToken> TextTokens { get { return new SyntaxList<SyntaxToken>(this.textTokens); } }
    public SyntaxToken MinusMinusGreaterThanToken { get { return this.minusMinusGreaterThanToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanExclamationMinusMinusToken;
            case 1: return this.textTokens;
            case 2: return this.minusMinusGreaterThanToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlCommentSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlComment(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlComment(this);
    }

    public XmlCommentSyntax Update(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxList<SyntaxToken> textTokens, SyntaxToken minusMinusGreaterThanToken)
    {
        if (lessThanExclamationMinusMinusToken != this.LessThanExclamationMinusMinusToken || textTokens != this.TextTokens || minusMinusGreaterThanToken != this.MinusMinusGreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlComment(lessThanExclamationMinusMinusToken, textTokens, minusMinusGreaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlCommentSyntax(this.Kind, this.lessThanExclamationMinusMinusToken, this.textTokens, this.minusMinusGreaterThanToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlCommentSyntax(this.Kind, this.lessThanExclamationMinusMinusToken, this.textTokens, this.minusMinusGreaterThanToken, GetDiagnostics(), annotations);
    }

    internal XmlCommentSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var lessThanExclamationMinusMinusToken = (SyntaxToken)reader.ReadValue();
      if (lessThanExclamationMinusMinusToken != null)
      {
         AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
         this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
      }
      var textTokens = (CSharpSyntaxNode)reader.ReadValue();
      if (textTokens != null)
      {
         AdjustFlagsAndWidth(textTokens);
         this.textTokens = textTokens;
      }
      var minusMinusGreaterThanToken = (SyntaxToken)reader.ReadValue();
      if (minusMinusGreaterThanToken != null)
      {
         AdjustFlagsAndWidth(minusMinusGreaterThanToken);
         this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanExclamationMinusMinusToken);
      writer.WriteValue(this.textTokens);
      writer.WriteValue(this.minusMinusGreaterThanToken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new XmlCommentSyntax(r);
    }
  }

  internal abstract partial class DirectiveTriviaSyntax : StructuredTriviaSyntax
  {
    internal DirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
      this.flags |= NodeFlags.ContainsDirectives;
    }
    internal DirectiveTriviaSyntax(SyntaxKind kind)
      : base(kind)
    {
      this.flags |= NodeFlags.ContainsDirectives;
    }

    protected DirectiveTriviaSyntax(ObjectReader reader)
       : base(reader)
    {
      this.flags |= NodeFlags.ContainsDirectives;
    }

    public abstract SyntaxToken HashToken { get; }

    public abstract SyntaxToken EndOfDirectiveToken { get; }

    public abstract bool IsActive { get; }
  }

  internal abstract partial class BranchingDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal BranchingDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BranchingDirectiveTriviaSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BranchingDirectiveTriviaSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    public abstract bool BranchTaken { get; }
  }

  internal abstract partial class ConditionalDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax
  {
    internal ConditionalDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal ConditionalDirectiveTriviaSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected ConditionalDirectiveTriviaSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    public abstract ExpressionSyntax Condition { get; }

    public abstract bool ConditionValue { get; }
  }

  internal sealed partial class IfDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken ifKeyword;
    internal readonly ExpressionSyntax condition;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;
    internal readonly bool branchTaken;
    internal readonly bool conditionValue;

    internal IfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(ifKeyword);
        this.ifKeyword = ifKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
        this.conditionValue = conditionValue;
    }


    internal IfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(ifKeyword);
        this.ifKeyword = ifKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
        this.conditionValue = conditionValue;
    }


    internal IfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(ifKeyword);
        this.ifKeyword = ifKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
        this.conditionValue = conditionValue;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken IfKeyword { get { return this.ifKeyword; } }
    public override ExpressionSyntax Condition { get { return this.condition; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }
    public override bool BranchTaken { get { return this.branchTaken; } }
    public override bool ConditionValue { get { return this.conditionValue; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.ifKeyword;
            case 2: return this.condition;
            case 3: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.IfDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIfDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIfDirectiveTrivia(this);
    }

    public IfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
        if (hashToken != this.HashToken || ifKeyword != this.IfKeyword || condition != this.Condition || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.IfDirectiveTrivia(hashToken, ifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new IfDirectiveTriviaSyntax(this.Kind, this.hashToken, this.ifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new IfDirectiveTriviaSyntax(this.Kind, this.hashToken, this.ifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, GetDiagnostics(), annotations);
    }

    internal IfDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var ifKeyword = (SyntaxToken)reader.ReadValue();
      if (ifKeyword != null)
      {
         AdjustFlagsAndWidth(ifKeyword);
         this.ifKeyword = ifKeyword;
      }
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
      this.branchTaken = (bool)reader.ReadBoolean();
      this.conditionValue = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.ifKeyword);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
      writer.WriteBoolean(this.branchTaken);
      writer.WriteBoolean(this.conditionValue);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new IfDirectiveTriviaSyntax(r);
    }
  }

  internal sealed partial class ElifDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken elifKeyword;
    internal readonly ExpressionSyntax condition;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;
    internal readonly bool branchTaken;
    internal readonly bool conditionValue;

    internal ElifDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(elifKeyword);
        this.elifKeyword = elifKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
        this.conditionValue = conditionValue;
    }


    internal ElifDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(elifKeyword);
        this.elifKeyword = elifKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
        this.conditionValue = conditionValue;
    }


    internal ElifDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(elifKeyword);
        this.elifKeyword = elifKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
        this.conditionValue = conditionValue;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken ElifKeyword { get { return this.elifKeyword; } }
    public override ExpressionSyntax Condition { get { return this.condition; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }
    public override bool BranchTaken { get { return this.branchTaken; } }
    public override bool ConditionValue { get { return this.conditionValue; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.elifKeyword;
            case 2: return this.condition;
            case 3: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ElifDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElifDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitElifDirectiveTrivia(this);
    }

    public ElifDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
        if (hashToken != this.HashToken || elifKeyword != this.ElifKeyword || condition != this.Condition || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ElifDirectiveTrivia(hashToken, elifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ElifDirectiveTriviaSyntax(this.Kind, this.hashToken, this.elifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ElifDirectiveTriviaSyntax(this.Kind, this.hashToken, this.elifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, GetDiagnostics(), annotations);
    }

    internal ElifDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var elifKeyword = (SyntaxToken)reader.ReadValue();
      if (elifKeyword != null)
      {
         AdjustFlagsAndWidth(elifKeyword);
         this.elifKeyword = elifKeyword;
      }
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
      this.branchTaken = (bool)reader.ReadBoolean();
      this.conditionValue = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.elifKeyword);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
      writer.WriteBoolean(this.branchTaken);
      writer.WriteBoolean(this.conditionValue);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ElifDirectiveTriviaSyntax(r);
    }
  }

  internal sealed partial class ElseDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken elseKeyword;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;
    internal readonly bool branchTaken;

    internal ElseDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(elseKeyword);
        this.elseKeyword = elseKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
    }


    internal ElseDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(elseKeyword);
        this.elseKeyword = elseKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
    }


    internal ElseDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(elseKeyword);
        this.elseKeyword = elseKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken ElseKeyword { get { return this.elseKeyword; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }
    public override bool BranchTaken { get { return this.branchTaken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.elseKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ElseDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElseDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitElseDirectiveTrivia(this);
    }

    public ElseDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
    {
        if (hashToken != this.HashToken || elseKeyword != this.ElseKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ElseDirectiveTrivia(hashToken, elseKeyword, endOfDirectiveToken, isActive, branchTaken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ElseDirectiveTriviaSyntax(this.Kind, this.hashToken, this.elseKeyword, this.endOfDirectiveToken, this.isActive, this.branchTaken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ElseDirectiveTriviaSyntax(this.Kind, this.hashToken, this.elseKeyword, this.endOfDirectiveToken, this.isActive, this.branchTaken, GetDiagnostics(), annotations);
    }

    internal ElseDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var elseKeyword = (SyntaxToken)reader.ReadValue();
      if (elseKeyword != null)
      {
         AdjustFlagsAndWidth(elseKeyword);
         this.elseKeyword = elseKeyword;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
      this.branchTaken = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.elseKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
      writer.WriteBoolean(this.branchTaken);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ElseDirectiveTriviaSyntax(r);
    }
  }

  internal sealed partial class EndIfDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken endIfKeyword;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal EndIfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(endIfKeyword);
        this.endIfKeyword = endIfKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal EndIfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(endIfKeyword);
        this.endIfKeyword = endIfKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal EndIfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(endIfKeyword);
        this.endIfKeyword = endIfKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken EndIfKeyword { get { return this.endIfKeyword; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.endIfKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.EndIfDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEndIfDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEndIfDirectiveTrivia(this);
    }

    public EndIfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || endIfKeyword != this.EndIfKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.EndIfDirectiveTrivia(hashToken, endIfKeyword, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EndIfDirectiveTriviaSyntax(this.Kind, this.hashToken, this.endIfKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EndIfDirectiveTriviaSyntax(this.Kind, this.hashToken, this.endIfKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal EndIfDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var endIfKeyword = (SyntaxToken)reader.ReadValue();
      if (endIfKeyword != null)
      {
         AdjustFlagsAndWidth(endIfKeyword);
         this.endIfKeyword = endIfKeyword;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.endIfKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new EndIfDirectiveTriviaSyntax(r);
    }
  }

  internal sealed partial class RegionDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken regionKeyword;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal RegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(regionKeyword);
        this.regionKeyword = regionKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal RegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(regionKeyword);
        this.regionKeyword = regionKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal RegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(regionKeyword);
        this.regionKeyword = regionKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken RegionKeyword { get { return this.regionKeyword; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.regionKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.RegionDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRegionDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitRegionDirectiveTrivia(this);
    }

    public RegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || regionKeyword != this.RegionKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.RegionDirectiveTrivia(hashToken, regionKeyword, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new RegionDirectiveTriviaSyntax(this.Kind, this.hashToken, this.regionKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new RegionDirectiveTriviaSyntax(this.Kind, this.hashToken, this.regionKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal RegionDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var regionKeyword = (SyntaxToken)reader.ReadValue();
      if (regionKeyword != null)
      {
         AdjustFlagsAndWidth(regionKeyword);
         this.regionKeyword = regionKeyword;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.regionKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new RegionDirectiveTriviaSyntax(r);
    }
  }

  internal sealed partial class EndRegionDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken endRegionKeyword;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal EndRegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(endRegionKeyword);
        this.endRegionKeyword = endRegionKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal EndRegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(endRegionKeyword);
        this.endRegionKeyword = endRegionKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal EndRegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(endRegionKeyword);
        this.endRegionKeyword = endRegionKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken EndRegionKeyword { get { return this.endRegionKeyword; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.endRegionKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.EndRegionDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEndRegionDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEndRegionDirectiveTrivia(this);
    }

    public EndRegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || endRegionKeyword != this.EndRegionKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.EndRegionDirectiveTrivia(hashToken, endRegionKeyword, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EndRegionDirectiveTriviaSyntax(this.Kind, this.hashToken, this.endRegionKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EndRegionDirectiveTriviaSyntax(this.Kind, this.hashToken, this.endRegionKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal EndRegionDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var endRegionKeyword = (SyntaxToken)reader.ReadValue();
      if (endRegionKeyword != null)
      {
         AdjustFlagsAndWidth(endRegionKeyword);
         this.endRegionKeyword = endRegionKeyword;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.endRegionKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new EndRegionDirectiveTriviaSyntax(r);
    }
  }

  internal sealed partial class ErrorDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken errorKeyword;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal ErrorDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(errorKeyword);
        this.errorKeyword = errorKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal ErrorDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(errorKeyword);
        this.errorKeyword = errorKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal ErrorDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(errorKeyword);
        this.errorKeyword = errorKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken ErrorKeyword { get { return this.errorKeyword; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.errorKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ErrorDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitErrorDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitErrorDirectiveTrivia(this);
    }

    public ErrorDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || errorKeyword != this.ErrorKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ErrorDirectiveTrivia(hashToken, errorKeyword, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ErrorDirectiveTriviaSyntax(this.Kind, this.hashToken, this.errorKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ErrorDirectiveTriviaSyntax(this.Kind, this.hashToken, this.errorKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal ErrorDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var errorKeyword = (SyntaxToken)reader.ReadValue();
      if (errorKeyword != null)
      {
         AdjustFlagsAndWidth(errorKeyword);
         this.errorKeyword = errorKeyword;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.errorKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ErrorDirectiveTriviaSyntax(r);
    }
  }

  internal sealed partial class WarningDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken warningKeyword;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal WarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(warningKeyword);
        this.warningKeyword = warningKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal WarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(warningKeyword);
        this.warningKeyword = warningKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal WarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(warningKeyword);
        this.warningKeyword = warningKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken WarningKeyword { get { return this.warningKeyword; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.warningKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.WarningDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitWarningDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitWarningDirectiveTrivia(this);
    }

    public WarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || warningKeyword != this.WarningKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.WarningDirectiveTrivia(hashToken, warningKeyword, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new WarningDirectiveTriviaSyntax(this.Kind, this.hashToken, this.warningKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new WarningDirectiveTriviaSyntax(this.Kind, this.hashToken, this.warningKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal WarningDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var warningKeyword = (SyntaxToken)reader.ReadValue();
      if (warningKeyword != null)
      {
         AdjustFlagsAndWidth(warningKeyword);
         this.warningKeyword = warningKeyword;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.warningKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new WarningDirectiveTriviaSyntax(r);
    }
  }

  internal sealed partial class BadDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal BadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal BadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal BadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken Identifier { get { return this.identifier; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.identifier;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.BadDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBadDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBadDirectiveTrivia(this);
    }

    public BadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || identifier != this.Identifier || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.BadDirectiveTrivia(hashToken, identifier, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BadDirectiveTriviaSyntax(this.Kind, this.hashToken, this.identifier, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BadDirectiveTriviaSyntax(this.Kind, this.hashToken, this.identifier, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal BadDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new BadDirectiveTriviaSyntax(r);
    }
  }

  internal sealed partial class DefineDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken defineKeyword;
    internal readonly SyntaxToken name;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal DefineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(defineKeyword);
        this.defineKeyword = defineKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal DefineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(defineKeyword);
        this.defineKeyword = defineKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal DefineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(defineKeyword);
        this.defineKeyword = defineKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken DefineKeyword { get { return this.defineKeyword; } }
    public SyntaxToken Name { get { return this.name; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.defineKeyword;
            case 2: return this.name;
            case 3: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.DefineDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDefineDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDefineDirectiveTrivia(this);
    }

    public DefineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || defineKeyword != this.DefineKeyword || name != this.Name || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.DefineDirectiveTrivia(hashToken, defineKeyword, name, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DefineDirectiveTriviaSyntax(this.Kind, this.hashToken, this.defineKeyword, this.name, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DefineDirectiveTriviaSyntax(this.Kind, this.hashToken, this.defineKeyword, this.name, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal DefineDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var defineKeyword = (SyntaxToken)reader.ReadValue();
      if (defineKeyword != null)
      {
         AdjustFlagsAndWidth(defineKeyword);
         this.defineKeyword = defineKeyword;
      }
      var name = (SyntaxToken)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.defineKeyword);
      writer.WriteValue(this.name);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new DefineDirectiveTriviaSyntax(r);
    }
  }

  internal sealed partial class UndefDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken undefKeyword;
    internal readonly SyntaxToken name;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal UndefDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(undefKeyword);
        this.undefKeyword = undefKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal UndefDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(undefKeyword);
        this.undefKeyword = undefKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal UndefDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(undefKeyword);
        this.undefKeyword = undefKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken UndefKeyword { get { return this.undefKeyword; } }
    public SyntaxToken Name { get { return this.name; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.undefKeyword;
            case 2: return this.name;
            case 3: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.UndefDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitUndefDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitUndefDirectiveTrivia(this);
    }

    public UndefDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || undefKeyword != this.UndefKeyword || name != this.Name || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.UndefDirectiveTrivia(hashToken, undefKeyword, name, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new UndefDirectiveTriviaSyntax(this.Kind, this.hashToken, this.undefKeyword, this.name, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new UndefDirectiveTriviaSyntax(this.Kind, this.hashToken, this.undefKeyword, this.name, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal UndefDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var undefKeyword = (SyntaxToken)reader.ReadValue();
      if (undefKeyword != null)
      {
         AdjustFlagsAndWidth(undefKeyword);
         this.undefKeyword = undefKeyword;
      }
      var name = (SyntaxToken)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.undefKeyword);
      writer.WriteValue(this.name);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new UndefDirectiveTriviaSyntax(r);
    }
  }

  internal sealed partial class LineDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken lineKeyword;
    internal readonly SyntaxToken line;
    internal readonly SyntaxToken file;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal LineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(lineKeyword);
        this.lineKeyword = lineKeyword;
        this.AdjustFlagsAndWidth(line);
        this.line = line;
        if (file != null)
        {
            this.AdjustFlagsAndWidth(file);
            this.file = file;
        }
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal LineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(lineKeyword);
        this.lineKeyword = lineKeyword;
        this.AdjustFlagsAndWidth(line);
        this.line = line;
        if (file != null)
        {
            this.AdjustFlagsAndWidth(file);
            this.file = file;
        }
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal LineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(lineKeyword);
        this.lineKeyword = lineKeyword;
        this.AdjustFlagsAndWidth(line);
        this.line = line;
        if (file != null)
        {
            this.AdjustFlagsAndWidth(file);
            this.file = file;
        }
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken LineKeyword { get { return this.lineKeyword; } }
    public SyntaxToken Line { get { return this.line; } }
    public SyntaxToken File { get { return this.file; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.lineKeyword;
            case 2: return this.line;
            case 3: return this.file;
            case 4: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.LineDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLineDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLineDirectiveTrivia(this);
    }

    public LineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || lineKeyword != this.LineKeyword || line != this.Line || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.LineDirectiveTrivia(hashToken, lineKeyword, line, file, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new LineDirectiveTriviaSyntax(this.Kind, this.hashToken, this.lineKeyword, this.line, this.file, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new LineDirectiveTriviaSyntax(this.Kind, this.hashToken, this.lineKeyword, this.line, this.file, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal LineDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var lineKeyword = (SyntaxToken)reader.ReadValue();
      if (lineKeyword != null)
      {
         AdjustFlagsAndWidth(lineKeyword);
         this.lineKeyword = lineKeyword;
      }
      var line = (SyntaxToken)reader.ReadValue();
      if (line != null)
      {
         AdjustFlagsAndWidth(line);
         this.line = line;
      }
      var file = (SyntaxToken)reader.ReadValue();
      if (file != null)
      {
         AdjustFlagsAndWidth(file);
         this.file = file;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.lineKeyword);
      writer.WriteValue(this.line);
      writer.WriteValue(this.file);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new LineDirectiveTriviaSyntax(r);
    }
  }

  internal sealed partial class PragmaWarningDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken pragmaKeyword;
    internal readonly SyntaxToken warningKeyword;
    internal readonly SyntaxToken disableOrRestoreKeyword;
    internal readonly CSharpSyntaxNode errorCodes;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal PragmaWarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, CSharpSyntaxNode errorCodes, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(pragmaKeyword);
        this.pragmaKeyword = pragmaKeyword;
        this.AdjustFlagsAndWidth(warningKeyword);
        this.warningKeyword = warningKeyword;
        this.AdjustFlagsAndWidth(disableOrRestoreKeyword);
        this.disableOrRestoreKeyword = disableOrRestoreKeyword;
        if (errorCodes != null)
        {
            this.AdjustFlagsAndWidth(errorCodes);
            this.errorCodes = errorCodes;
        }
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal PragmaWarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, CSharpSyntaxNode errorCodes, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(pragmaKeyword);
        this.pragmaKeyword = pragmaKeyword;
        this.AdjustFlagsAndWidth(warningKeyword);
        this.warningKeyword = warningKeyword;
        this.AdjustFlagsAndWidth(disableOrRestoreKeyword);
        this.disableOrRestoreKeyword = disableOrRestoreKeyword;
        if (errorCodes != null)
        {
            this.AdjustFlagsAndWidth(errorCodes);
            this.errorCodes = errorCodes;
        }
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal PragmaWarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, CSharpSyntaxNode errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(pragmaKeyword);
        this.pragmaKeyword = pragmaKeyword;
        this.AdjustFlagsAndWidth(warningKeyword);
        this.warningKeyword = warningKeyword;
        this.AdjustFlagsAndWidth(disableOrRestoreKeyword);
        this.disableOrRestoreKeyword = disableOrRestoreKeyword;
        if (errorCodes != null)
        {
            this.AdjustFlagsAndWidth(errorCodes);
            this.errorCodes = errorCodes;
        }
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken PragmaKeyword { get { return this.pragmaKeyword; } }
    public SyntaxToken WarningKeyword { get { return this.warningKeyword; } }
    public SyntaxToken DisableOrRestoreKeyword { get { return this.disableOrRestoreKeyword; } }
    public SeparatedSyntaxList<ExpressionSyntax> ErrorCodes { get { return new SeparatedSyntaxList<ExpressionSyntax>(new SyntaxList<CSharpSyntaxNode>(this.errorCodes)); } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.pragmaKeyword;
            case 2: return this.warningKeyword;
            case 3: return this.disableOrRestoreKeyword;
            case 4: return this.errorCodes;
            case 5: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPragmaWarningDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPragmaWarningDirectiveTrivia(this);
    }

    public PragmaWarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || pragmaKeyword != this.PragmaKeyword || warningKeyword != this.WarningKeyword || disableOrRestoreKeyword != this.DisableOrRestoreKeyword || errorCodes != this.ErrorCodes || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.PragmaWarningDirectiveTrivia(hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new PragmaWarningDirectiveTriviaSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.warningKeyword, this.disableOrRestoreKeyword, this.errorCodes, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new PragmaWarningDirectiveTriviaSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.warningKeyword, this.disableOrRestoreKeyword, this.errorCodes, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal PragmaWarningDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 6;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var pragmaKeyword = (SyntaxToken)reader.ReadValue();
      if (pragmaKeyword != null)
      {
         AdjustFlagsAndWidth(pragmaKeyword);
         this.pragmaKeyword = pragmaKeyword;
      }
      var warningKeyword = (SyntaxToken)reader.ReadValue();
      if (warningKeyword != null)
      {
         AdjustFlagsAndWidth(warningKeyword);
         this.warningKeyword = warningKeyword;
      }
      var disableOrRestoreKeyword = (SyntaxToken)reader.ReadValue();
      if (disableOrRestoreKeyword != null)
      {
         AdjustFlagsAndWidth(disableOrRestoreKeyword);
         this.disableOrRestoreKeyword = disableOrRestoreKeyword;
      }
      var errorCodes = (CSharpSyntaxNode)reader.ReadValue();
      if (errorCodes != null)
      {
         AdjustFlagsAndWidth(errorCodes);
         this.errorCodes = errorCodes;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.pragmaKeyword);
      writer.WriteValue(this.warningKeyword);
      writer.WriteValue(this.disableOrRestoreKeyword);
      writer.WriteValue(this.errorCodes);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new PragmaWarningDirectiveTriviaSyntax(r);
    }
  }

  internal sealed partial class PragmaChecksumDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken pragmaKeyword;
    internal readonly SyntaxToken checksumKeyword;
    internal readonly SyntaxToken file;
    internal readonly SyntaxToken guid;
    internal readonly SyntaxToken bytes;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal PragmaChecksumDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(pragmaKeyword);
        this.pragmaKeyword = pragmaKeyword;
        this.AdjustFlagsAndWidth(checksumKeyword);
        this.checksumKeyword = checksumKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(guid);
        this.guid = guid;
        this.AdjustFlagsAndWidth(bytes);
        this.bytes = bytes;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal PragmaChecksumDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(pragmaKeyword);
        this.pragmaKeyword = pragmaKeyword;
        this.AdjustFlagsAndWidth(checksumKeyword);
        this.checksumKeyword = checksumKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(guid);
        this.guid = guid;
        this.AdjustFlagsAndWidth(bytes);
        this.bytes = bytes;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal PragmaChecksumDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(pragmaKeyword);
        this.pragmaKeyword = pragmaKeyword;
        this.AdjustFlagsAndWidth(checksumKeyword);
        this.checksumKeyword = checksumKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(guid);
        this.guid = guid;
        this.AdjustFlagsAndWidth(bytes);
        this.bytes = bytes;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken PragmaKeyword { get { return this.pragmaKeyword; } }
    public SyntaxToken ChecksumKeyword { get { return this.checksumKeyword; } }
    public SyntaxToken File { get { return this.file; } }
    public SyntaxToken Guid { get { return this.guid; } }
    public SyntaxToken Bytes { get { return this.bytes; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.pragmaKeyword;
            case 2: return this.checksumKeyword;
            case 3: return this.file;
            case 4: return this.guid;
            case 5: return this.bytes;
            case 6: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPragmaChecksumDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPragmaChecksumDirectiveTrivia(this);
    }

    public PragmaChecksumDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || pragmaKeyword != this.PragmaKeyword || checksumKeyword != this.ChecksumKeyword || file != this.File || guid != this.Guid || bytes != this.Bytes || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.PragmaChecksumDirectiveTrivia(hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new PragmaChecksumDirectiveTriviaSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.checksumKeyword, this.file, this.guid, this.bytes, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new PragmaChecksumDirectiveTriviaSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.checksumKeyword, this.file, this.guid, this.bytes, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal PragmaChecksumDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 7;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var pragmaKeyword = (SyntaxToken)reader.ReadValue();
      if (pragmaKeyword != null)
      {
         AdjustFlagsAndWidth(pragmaKeyword);
         this.pragmaKeyword = pragmaKeyword;
      }
      var checksumKeyword = (SyntaxToken)reader.ReadValue();
      if (checksumKeyword != null)
      {
         AdjustFlagsAndWidth(checksumKeyword);
         this.checksumKeyword = checksumKeyword;
      }
      var file = (SyntaxToken)reader.ReadValue();
      if (file != null)
      {
         AdjustFlagsAndWidth(file);
         this.file = file;
      }
      var guid = (SyntaxToken)reader.ReadValue();
      if (guid != null)
      {
         AdjustFlagsAndWidth(guid);
         this.guid = guid;
      }
      var bytes = (SyntaxToken)reader.ReadValue();
      if (bytes != null)
      {
         AdjustFlagsAndWidth(bytes);
         this.bytes = bytes;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.pragmaKeyword);
      writer.WriteValue(this.checksumKeyword);
      writer.WriteValue(this.file);
      writer.WriteValue(this.guid);
      writer.WriteValue(this.bytes);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new PragmaChecksumDirectiveTriviaSyntax(r);
    }
  }

  internal sealed partial class ReferenceDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken referenceKeyword;
    internal readonly SyntaxToken file;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal ReferenceDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(referenceKeyword);
        this.referenceKeyword = referenceKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal ReferenceDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(referenceKeyword);
        this.referenceKeyword = referenceKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal ReferenceDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(referenceKeyword);
        this.referenceKeyword = referenceKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken ReferenceKeyword { get { return this.referenceKeyword; } }
    public SyntaxToken File { get { return this.file; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.referenceKeyword;
            case 2: return this.file;
            case 3: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ReferenceDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitReferenceDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitReferenceDirectiveTrivia(this);
    }

    public ReferenceDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || referenceKeyword != this.ReferenceKeyword || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ReferenceDirectiveTrivia(hashToken, referenceKeyword, file, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ReferenceDirectiveTriviaSyntax(this.Kind, this.hashToken, this.referenceKeyword, this.file, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ReferenceDirectiveTriviaSyntax(this.Kind, this.hashToken, this.referenceKeyword, this.file, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal ReferenceDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var referenceKeyword = (SyntaxToken)reader.ReadValue();
      if (referenceKeyword != null)
      {
         AdjustFlagsAndWidth(referenceKeyword);
         this.referenceKeyword = referenceKeyword;
      }
      var file = (SyntaxToken)reader.ReadValue();
      if (file != null)
      {
         AdjustFlagsAndWidth(file);
         this.file = file;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.referenceKeyword);
      writer.WriteValue(this.file);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ReferenceDirectiveTriviaSyntax(r);
    }
  }

  internal sealed partial class LoadDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken loadKeyword;
    internal readonly SyntaxToken file;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal LoadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(loadKeyword);
        this.loadKeyword = loadKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal LoadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(loadKeyword);
        this.loadKeyword = loadKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal LoadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(loadKeyword);
        this.loadKeyword = loadKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken LoadKeyword { get { return this.loadKeyword; } }
    public SyntaxToken File { get { return this.file; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.loadKeyword;
            case 2: return this.file;
            case 3: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.LoadDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLoadDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLoadDirectiveTrivia(this);
    }

    public LoadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || loadKeyword != this.LoadKeyword || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.LoadDirectiveTrivia(hashToken, loadKeyword, file, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new LoadDirectiveTriviaSyntax(this.Kind, this.hashToken, this.loadKeyword, this.file, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new LoadDirectiveTriviaSyntax(this.Kind, this.hashToken, this.loadKeyword, this.file, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal LoadDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var loadKeyword = (SyntaxToken)reader.ReadValue();
      if (loadKeyword != null)
      {
         AdjustFlagsAndWidth(loadKeyword);
         this.loadKeyword = loadKeyword;
      }
      var file = (SyntaxToken)reader.ReadValue();
      if (file != null)
      {
         AdjustFlagsAndWidth(file);
         this.file = file;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.loadKeyword);
      writer.WriteValue(this.file);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new LoadDirectiveTriviaSyntax(r);
    }
  }

  internal sealed partial class ShebangDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken exclamationToken;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal ShebangDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(exclamationToken);
        this.exclamationToken = exclamationToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal ShebangDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(exclamationToken);
        this.exclamationToken = exclamationToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal ShebangDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(exclamationToken);
        this.exclamationToken = exclamationToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken ExclamationToken { get { return this.exclamationToken; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.exclamationToken;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ShebangDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitShebangDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitShebangDirectiveTrivia(this);
    }

    public ShebangDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || exclamationToken != this.ExclamationToken || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ShebangDirectiveTrivia(hashToken, exclamationToken, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ShebangDirectiveTriviaSyntax(this.Kind, this.hashToken, this.exclamationToken, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ShebangDirectiveTriviaSyntax(this.Kind, this.hashToken, this.exclamationToken, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal ShebangDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var exclamationToken = (SyntaxToken)reader.ReadValue();
      if (exclamationToken != null)
      {
         AdjustFlagsAndWidth(exclamationToken);
         this.exclamationToken = exclamationToken;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.exclamationToken);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    internal override Func<ObjectReader, object> GetReader()
    {
       return r => new ShebangDirectiveTriviaSyntax(r);
    }
  }

  internal partial class CSharpSyntaxVisitor<TResult>
  {
    public virtual TResult VisitIdentifierName(IdentifierNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitQualifiedName(QualifiedNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitGenericName(GenericNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTypeArgumentList(TypeArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAliasQualifiedName(AliasQualifiedNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitPredefinedType(PredefinedTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitArrayType(ArrayTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitPointerType(PointerTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitNullableType(NullableTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTupleType(TupleTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTupleElement(TupleElementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTupleExpression(TupleExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAwaitExpression(AwaitExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitMemberBindingExpression(MemberBindingExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitElementBindingExpression(ElementBindingExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitImplicitElementAccess(ImplicitElementAccessSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBinaryExpression(BinaryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAssignmentExpression(AssignmentExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitConditionalExpression(ConditionalExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitThisExpression(ThisExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBaseExpression(BaseExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitOriginalExpression(OriginalExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitLiteralExpression(LiteralExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitMakeRefExpression(MakeRefExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitRefTypeExpression(RefTypeExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitRefValueExpression(RefValueExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCheckedExpression(CheckedExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDefaultExpression(DefaultExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTypeOfExpression(TypeOfExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitSizeOfExpression(SizeOfExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitInvocationExpression(InvocationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitElementAccessExpression(ElementAccessExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitArgumentList(ArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBracketedArgumentList(BracketedArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitArgument(ArgumentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitNameColon(NameColonSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCastExpression(CastExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitInitializerExpression(InitializerExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitQueryExpression(QueryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitQueryBody(QueryBodySyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitFromClause(FromClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitLetClause(LetClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitJoinClause(JoinClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitJoinIntoClause(JoinIntoClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitWhereClause(WhereClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitOrderByClause(OrderByClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitOrdering(OrderingSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitSelectClause(SelectClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitGroupClause(GroupClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitQueryContinuation(QueryContinuationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitIsPatternExpression(IsPatternExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitWhenClause(WhenClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDeclarationPattern(DeclarationPatternSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitConstantPattern(ConstantPatternSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitInterpolatedStringText(InterpolatedStringTextSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitInterpolation(InterpolationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitGlobalStatement(GlobalStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBlock(BlockSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitLocalFunctionStatement(LocalFunctionStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitVariableDeconstructionDeclarator(VariableDeconstructionDeclaratorSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitVariableDeclaration(VariableDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitVariableDeclarator(VariableDeclaratorSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEqualsValueClause(EqualsValueClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitExpressionStatement(ExpressionStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEmptyStatement(EmptyStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitLabeledStatement(LabeledStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitGotoStatement(GotoStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBreakStatement(BreakStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitContinueStatement(ContinueStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitReturnStatement(ReturnStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitThrowStatement(ThrowStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitYieldStatement(YieldStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitWhileStatement(WhileStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDoStatement(DoStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitForStatement(ForStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitForEachStatement(ForEachStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitUsingStatement(UsingStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitFixedStatement(FixedStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCheckedStatement(CheckedStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitUnsafeStatement(UnsafeStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitLockStatement(LockStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitIfStatement(IfStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitElseClause(ElseClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitSwitchStatement(SwitchStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitSwitchSection(SwitchSectionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCaseSwitchLabel(CaseSwitchLabelSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTryStatement(TryStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCatchClause(CatchClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCatchDeclaration(CatchDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCatchFilterClause(CatchFilterClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitFinallyClause(FinallyClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCompilationUnit(CompilationUnitSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitExternAliasDirective(ExternAliasDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitUsingDirective(UsingDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAttributeList(AttributeListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAttribute(AttributeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAttributeArgumentList(AttributeArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAttributeArgument(AttributeArgumentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitNameEquals(NameEqualsSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTypeParameterList(TypeParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTypeParameter(TypeParameterSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitClassDeclaration(ClassDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitStructDeclaration(StructDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDelegateDeclaration(DelegateDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBaseList(BaseListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitSimpleBaseType(SimpleBaseTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitConstructorConstraint(ConstructorConstraintSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTypeConstraint(TypeConstraintSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitFieldDeclaration(FieldDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitOperatorDeclaration(OperatorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitConstructorInitializer(ConstructorInitializerSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDestructorDeclaration(DestructorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitArrowExpressionClause(ArrowExpressionClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEventDeclaration(EventDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitIndexerDeclaration(IndexerDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAccessorList(AccessorListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAccessorDeclaration(AccessorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitParameterList(ParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBracketedParameterList(BracketedParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitParameter(ParameterSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitIncompleteMember(IncompleteMemberSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTypeCref(TypeCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitQualifiedCref(QualifiedCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitNameMemberCref(NameMemberCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitIndexerMemberCref(IndexerMemberCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitOperatorMemberCref(OperatorMemberCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCrefParameterList(CrefParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCrefParameter(CrefParameterSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlElement(XmlElementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlElementStartTag(XmlElementStartTagSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlElementEndTag(XmlElementEndTagSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlEmptyElement(XmlEmptyElementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlName(XmlNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlPrefix(XmlPrefixSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlTextAttribute(XmlTextAttributeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlCrefAttribute(XmlCrefAttributeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlNameAttribute(XmlNameAttributeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlText(XmlTextSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlCDataSection(XmlCDataSectionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlComment(XmlCommentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }
  }


  internal partial class CSharpSyntaxVisitor
  {
    public virtual void VisitIdentifierName(IdentifierNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitQualifiedName(QualifiedNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitGenericName(GenericNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTypeArgumentList(TypeArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAliasQualifiedName(AliasQualifiedNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitPredefinedType(PredefinedTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitArrayType(ArrayTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitPointerType(PointerTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitNullableType(NullableTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTupleType(TupleTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTupleElement(TupleElementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTupleExpression(TupleExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAwaitExpression(AwaitExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitMemberBindingExpression(MemberBindingExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitElementBindingExpression(ElementBindingExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitImplicitElementAccess(ImplicitElementAccessSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBinaryExpression(BinaryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAssignmentExpression(AssignmentExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitConditionalExpression(ConditionalExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitThisExpression(ThisExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBaseExpression(BaseExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitOriginalExpression(OriginalExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitLiteralExpression(LiteralExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitMakeRefExpression(MakeRefExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitRefTypeExpression(RefTypeExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitRefValueExpression(RefValueExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCheckedExpression(CheckedExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDefaultExpression(DefaultExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTypeOfExpression(TypeOfExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitSizeOfExpression(SizeOfExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitInvocationExpression(InvocationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitElementAccessExpression(ElementAccessExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitArgumentList(ArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBracketedArgumentList(BracketedArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitArgument(ArgumentSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitNameColon(NameColonSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCastExpression(CastExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitInitializerExpression(InitializerExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitQueryExpression(QueryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitQueryBody(QueryBodySyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitFromClause(FromClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitLetClause(LetClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitJoinClause(JoinClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitJoinIntoClause(JoinIntoClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitWhereClause(WhereClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitOrderByClause(OrderByClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitOrdering(OrderingSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitSelectClause(SelectClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitGroupClause(GroupClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitQueryContinuation(QueryContinuationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitIsPatternExpression(IsPatternExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitWhenClause(WhenClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDeclarationPattern(DeclarationPatternSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitConstantPattern(ConstantPatternSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitInterpolatedStringText(InterpolatedStringTextSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitInterpolation(InterpolationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitGlobalStatement(GlobalStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBlock(BlockSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitLocalFunctionStatement(LocalFunctionStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitVariableDeconstructionDeclarator(VariableDeconstructionDeclaratorSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitVariableDeclaration(VariableDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitVariableDeclarator(VariableDeclaratorSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEqualsValueClause(EqualsValueClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitExpressionStatement(ExpressionStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEmptyStatement(EmptyStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitLabeledStatement(LabeledStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitGotoStatement(GotoStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBreakStatement(BreakStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitContinueStatement(ContinueStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitReturnStatement(ReturnStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitThrowStatement(ThrowStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitYieldStatement(YieldStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitWhileStatement(WhileStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDoStatement(DoStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitForStatement(ForStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitForEachStatement(ForEachStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitUsingStatement(UsingStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitFixedStatement(FixedStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCheckedStatement(CheckedStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitUnsafeStatement(UnsafeStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitLockStatement(LockStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitIfStatement(IfStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitElseClause(ElseClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitSwitchStatement(SwitchStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitSwitchSection(SwitchSectionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCaseSwitchLabel(CaseSwitchLabelSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTryStatement(TryStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCatchClause(CatchClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCatchDeclaration(CatchDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCatchFilterClause(CatchFilterClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitFinallyClause(FinallyClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCompilationUnit(CompilationUnitSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitExternAliasDirective(ExternAliasDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitUsingDirective(UsingDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAttributeList(AttributeListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAttribute(AttributeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAttributeArgumentList(AttributeArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAttributeArgument(AttributeArgumentSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitNameEquals(NameEqualsSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTypeParameterList(TypeParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTypeParameter(TypeParameterSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitClassDeclaration(ClassDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitStructDeclaration(StructDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDelegateDeclaration(DelegateDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBaseList(BaseListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitSimpleBaseType(SimpleBaseTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitConstructorConstraint(ConstructorConstraintSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTypeConstraint(TypeConstraintSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitFieldDeclaration(FieldDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitOperatorDeclaration(OperatorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitConstructorInitializer(ConstructorInitializerSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDestructorDeclaration(DestructorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitArrowExpressionClause(ArrowExpressionClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEventDeclaration(EventDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitIndexerDeclaration(IndexerDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAccessorList(AccessorListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAccessorDeclaration(AccessorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitParameterList(ParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBracketedParameterList(BracketedParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitParameter(ParameterSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitIncompleteMember(IncompleteMemberSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTypeCref(TypeCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitQualifiedCref(QualifiedCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitNameMemberCref(NameMemberCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitIndexerMemberCref(IndexerMemberCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitOperatorMemberCref(OperatorMemberCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCrefParameterList(CrefParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCrefParameter(CrefParameterSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlElement(XmlElementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlElementStartTag(XmlElementStartTagSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlElementEndTag(XmlElementEndTagSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlEmptyElement(XmlEmptyElementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlName(XmlNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlPrefix(XmlPrefixSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlTextAttribute(XmlTextAttributeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlCrefAttribute(XmlCrefAttributeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlNameAttribute(XmlNameAttributeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlText(XmlTextSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlCDataSection(XmlCDataSectionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlComment(XmlCommentSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }
  }

  internal partial class CSharpSyntaxRewriter : CSharpSyntaxVisitor<CSharpSyntaxNode>
  {
    public override CSharpSyntaxNode VisitIdentifierName(IdentifierNameSyntax node)
    {
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      return node.Update(identifier);
    }

    public override CSharpSyntaxNode VisitQualifiedName(QualifiedNameSyntax node)
    {
      var left = (NameSyntax)this.Visit(node.Left);
      var dotToken = (SyntaxToken)this.Visit(node.DotToken);
      var right = (SimpleNameSyntax)this.Visit(node.Right);
      return node.Update(left, dotToken, right);
    }

    public override CSharpSyntaxNode VisitGenericName(GenericNameSyntax node)
    {
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeArgumentList = (TypeArgumentListSyntax)this.Visit(node.TypeArgumentList);
      return node.Update(identifier, typeArgumentList);
    }

    public override CSharpSyntaxNode VisitTypeArgumentList(TypeArgumentListSyntax node)
    {
      var lessThanToken = (SyntaxToken)this.Visit(node.LessThanToken);
      var arguments = this.VisitList(node.Arguments);
      var greaterThanToken = (SyntaxToken)this.Visit(node.GreaterThanToken);
      return node.Update(lessThanToken, arguments, greaterThanToken);
    }

    public override CSharpSyntaxNode VisitAliasQualifiedName(AliasQualifiedNameSyntax node)
    {
      var alias = (IdentifierNameSyntax)this.Visit(node.Alias);
      var colonColonToken = (SyntaxToken)this.Visit(node.ColonColonToken);
      var name = (SimpleNameSyntax)this.Visit(node.Name);
      return node.Update(alias, colonColonToken, name);
    }

    public override CSharpSyntaxNode VisitPredefinedType(PredefinedTypeSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      return node.Update(keyword);
    }

    public override CSharpSyntaxNode VisitArrayType(ArrayTypeSyntax node)
    {
      var elementType = (TypeSyntax)this.Visit(node.ElementType);
      var rankSpecifiers = this.VisitList(node.RankSpecifiers);
      return node.Update(elementType, rankSpecifiers);
    }

    public override CSharpSyntaxNode VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
    {
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var sizes = this.VisitList(node.Sizes);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      return node.Update(openBracketToken, sizes, closeBracketToken);
    }

    public override CSharpSyntaxNode VisitPointerType(PointerTypeSyntax node)
    {
      var elementType = (TypeSyntax)this.Visit(node.ElementType);
      var asteriskToken = (SyntaxToken)this.Visit(node.AsteriskToken);
      return node.Update(elementType, asteriskToken);
    }

    public override CSharpSyntaxNode VisitNullableType(NullableTypeSyntax node)
    {
      var elementType = (TypeSyntax)this.Visit(node.ElementType);
      var questionToken = (SyntaxToken)this.Visit(node.QuestionToken);
      return node.Update(elementType, questionToken);
    }

    public override CSharpSyntaxNode VisitTupleType(TupleTypeSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var elements = this.VisitList(node.Elements);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, elements, closeParenToken);
    }

    public override CSharpSyntaxNode VisitTupleElement(TupleElementSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      var name = (IdentifierNameSyntax)this.Visit(node.Name);
      return node.Update(type, name);
    }

    public override CSharpSyntaxNode VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)
    {
      var omittedTypeArgumentToken = (SyntaxToken)this.Visit(node.OmittedTypeArgumentToken);
      return node.Update(omittedTypeArgumentToken);
    }

    public override CSharpSyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, expression, closeParenToken);
    }

    public override CSharpSyntaxNode VisitTupleExpression(TupleExpressionSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var arguments = this.VisitList(node.Arguments);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, arguments, closeParenToken);
    }

    public override CSharpSyntaxNode VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
    {
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var operand = (ExpressionSyntax)this.Visit(node.Operand);
      return node.Update(operatorToken, operand);
    }

    public override CSharpSyntaxNode VisitAwaitExpression(AwaitExpressionSyntax node)
    {
      var awaitKeyword = (SyntaxToken)this.Visit(node.AwaitKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(awaitKeyword, expression);
    }

    public override CSharpSyntaxNode VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)
    {
      var operand = (ExpressionSyntax)this.Visit(node.Operand);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      return node.Update(operand, operatorToken);
    }

    public override CSharpSyntaxNode VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var name = (SimpleNameSyntax)this.Visit(node.Name);
      return node.Update(expression, operatorToken, name);
    }

    public override CSharpSyntaxNode VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var whenNotNull = (ExpressionSyntax)this.Visit(node.WhenNotNull);
      return node.Update(expression, operatorToken, whenNotNull);
    }

    public override CSharpSyntaxNode VisitMemberBindingExpression(MemberBindingExpressionSyntax node)
    {
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var name = (SimpleNameSyntax)this.Visit(node.Name);
      return node.Update(operatorToken, name);
    }

    public override CSharpSyntaxNode VisitElementBindingExpression(ElementBindingExpressionSyntax node)
    {
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(argumentList);
    }

    public override CSharpSyntaxNode VisitImplicitElementAccess(ImplicitElementAccessSyntax node)
    {
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(argumentList);
    }

    public override CSharpSyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node)
    {
      var left = (ExpressionSyntax)this.Visit(node.Left);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var right = (ExpressionSyntax)this.Visit(node.Right);
      return node.Update(left, operatorToken, right);
    }

    public override CSharpSyntaxNode VisitAssignmentExpression(AssignmentExpressionSyntax node)
    {
      var left = (ExpressionSyntax)this.Visit(node.Left);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var right = (ExpressionSyntax)this.Visit(node.Right);
      return node.Update(left, operatorToken, right);
    }

    public override CSharpSyntaxNode VisitConditionalExpression(ConditionalExpressionSyntax node)
    {
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var questionToken = (SyntaxToken)this.Visit(node.QuestionToken);
      var whenTrue = (ExpressionSyntax)this.Visit(node.WhenTrue);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      var whenFalse = (ExpressionSyntax)this.Visit(node.WhenFalse);
      return node.Update(condition, questionToken, whenTrue, colonToken, whenFalse);
    }

    public override CSharpSyntaxNode VisitThisExpression(ThisExpressionSyntax node)
    {
      var token = (SyntaxToken)this.Visit(node.Token);
      return node.Update(token);
    }

    public override CSharpSyntaxNode VisitBaseExpression(BaseExpressionSyntax node)
    {
      var token = (SyntaxToken)this.Visit(node.Token);
      return node.Update(token);
    }

    public override CSharpSyntaxNode VisitOriginalExpression(OriginalExpressionSyntax node)
    {
      var token = (SyntaxToken)this.Visit(node.Token);
      return node.Update(token);
    }

    public override CSharpSyntaxNode VisitLiteralExpression(LiteralExpressionSyntax node)
    {
      var token = (SyntaxToken)this.Visit(node.Token);
      return node.Update(token);
    }

    public override CSharpSyntaxNode VisitMakeRefExpression(MakeRefExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, closeParenToken);
    }

    public override CSharpSyntaxNode VisitRefTypeExpression(RefTypeExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, closeParenToken);
    }

    public override CSharpSyntaxNode VisitRefValueExpression(RefValueExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var comma = (SyntaxToken)this.Visit(node.Comma);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, comma, type, closeParenToken);
    }

    public override CSharpSyntaxNode VisitCheckedExpression(CheckedExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, closeParenToken);
    }

    public override CSharpSyntaxNode VisitDefaultExpression(DefaultExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, type, closeParenToken);
    }

    public override CSharpSyntaxNode VisitTypeOfExpression(TypeOfExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, type, closeParenToken);
    }

    public override CSharpSyntaxNode VisitSizeOfExpression(SizeOfExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, type, closeParenToken);
    }

    public override CSharpSyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var argumentList = (ArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(expression, argumentList);
    }

    public override CSharpSyntaxNode VisitElementAccessExpression(ElementAccessExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(expression, argumentList);
    }

    public override CSharpSyntaxNode VisitArgumentList(ArgumentListSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var arguments = this.VisitList(node.Arguments);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, arguments, closeParenToken);
    }

    public override CSharpSyntaxNode VisitBracketedArgumentList(BracketedArgumentListSyntax node)
    {
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var arguments = this.VisitList(node.Arguments);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      return node.Update(openBracketToken, arguments, closeBracketToken);
    }

    public override CSharpSyntaxNode VisitArgument(ArgumentSyntax node)
    {
      var nameColon = (NameColonSyntax)this.Visit(node.NameColon);
      var refOrOutKeyword = (SyntaxToken)this.Visit(node.RefOrOutKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(nameColon, refOrOutKeyword, expression);
    }

    public override CSharpSyntaxNode VisitNameColon(NameColonSyntax node)
    {
      var name = (IdentifierNameSyntax)this.Visit(node.Name);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      return node.Update(name, colonToken);
    }

    public override CSharpSyntaxNode VisitCastExpression(CastExpressionSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(openParenToken, type, closeParenToken, expression);
    }

    public override CSharpSyntaxNode VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
    {
      var asyncKeyword = (SyntaxToken)this.Visit(node.AsyncKeyword);
      var delegateKeyword = (SyntaxToken)this.Visit(node.DelegateKeyword);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (CSharpSyntaxNode)this.Visit(node.Body);
      return node.Update(asyncKeyword, delegateKeyword, parameterList, body);
    }

    public override CSharpSyntaxNode VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
    {
      var asyncKeyword = (SyntaxToken)this.Visit(node.AsyncKeyword);
      var parameter = (ParameterSyntax)this.Visit(node.Parameter);
      var arrowToken = (SyntaxToken)this.Visit(node.ArrowToken);
      var refKeyword = (SyntaxToken)this.Visit(node.RefKeyword);
      var body = (CSharpSyntaxNode)this.Visit(node.Body);
      return node.Update(asyncKeyword, parameter, arrowToken, refKeyword, body);
    }

    public override CSharpSyntaxNode VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
    {
      var asyncKeyword = (SyntaxToken)this.Visit(node.AsyncKeyword);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var arrowToken = (SyntaxToken)this.Visit(node.ArrowToken);
      var refKeyword = (SyntaxToken)this.Visit(node.RefKeyword);
      var body = (CSharpSyntaxNode)this.Visit(node.Body);
      return node.Update(asyncKeyword, parameterList, arrowToken, refKeyword, body);
    }

    public override CSharpSyntaxNode VisitInitializerExpression(InitializerExpressionSyntax node)
    {
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var expressions = this.VisitList(node.Expressions);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(openBraceToken, expressions, closeBraceToken);
    }

    public override CSharpSyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
      var newKeyword = (SyntaxToken)this.Visit(node.NewKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var argumentList = (ArgumentListSyntax)this.Visit(node.ArgumentList);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(newKeyword, type, argumentList, initializer);
    }

    public override CSharpSyntaxNode VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)
    {
      var nameEquals = (NameEqualsSyntax)this.Visit(node.NameEquals);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(nameEquals, expression);
    }

    public override CSharpSyntaxNode VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)
    {
      var newKeyword = (SyntaxToken)this.Visit(node.NewKeyword);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var initializers = this.VisitList(node.Initializers);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(newKeyword, openBraceToken, initializers, closeBraceToken);
    }

    public override CSharpSyntaxNode VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)
    {
      var newKeyword = (SyntaxToken)this.Visit(node.NewKeyword);
      var type = (ArrayTypeSyntax)this.Visit(node.Type);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(newKeyword, type, initializer);
    }

    public override CSharpSyntaxNode VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)
    {
      var newKeyword = (SyntaxToken)this.Visit(node.NewKeyword);
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var commas = this.VisitList(node.Commas);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(newKeyword, openBracketToken, commas, closeBracketToken, initializer);
    }

    public override CSharpSyntaxNode VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)
    {
      var stackAllocKeyword = (SyntaxToken)this.Visit(node.StackAllocKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(stackAllocKeyword, type);
    }

    public override CSharpSyntaxNode VisitQueryExpression(QueryExpressionSyntax node)
    {
      var fromClause = (FromClauseSyntax)this.Visit(node.FromClause);
      var body = (QueryBodySyntax)this.Visit(node.Body);
      return node.Update(fromClause, body);
    }

    public override CSharpSyntaxNode VisitQueryBody(QueryBodySyntax node)
    {
      var clauses = this.VisitList(node.Clauses);
      var selectOrGroup = (SelectOrGroupClauseSyntax)this.Visit(node.SelectOrGroup);
      var continuation = (QueryContinuationSyntax)this.Visit(node.Continuation);
      return node.Update(clauses, selectOrGroup, continuation);
    }

    public override CSharpSyntaxNode VisitFromClause(FromClauseSyntax node)
    {
      var fromKeyword = (SyntaxToken)this.Visit(node.FromKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var inKeyword = (SyntaxToken)this.Visit(node.InKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(fromKeyword, type, identifier, inKeyword, expression);
    }

    public override CSharpSyntaxNode VisitLetClause(LetClauseSyntax node)
    {
      var letKeyword = (SyntaxToken)this.Visit(node.LetKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(letKeyword, identifier, equalsToken, expression);
    }

    public override CSharpSyntaxNode VisitJoinClause(JoinClauseSyntax node)
    {
      var joinKeyword = (SyntaxToken)this.Visit(node.JoinKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var inKeyword = (SyntaxToken)this.Visit(node.InKeyword);
      var inExpression = (ExpressionSyntax)this.Visit(node.InExpression);
      var onKeyword = (SyntaxToken)this.Visit(node.OnKeyword);
      var leftExpression = (ExpressionSyntax)this.Visit(node.LeftExpression);
      var equalsKeyword = (SyntaxToken)this.Visit(node.EqualsKeyword);
      var rightExpression = (ExpressionSyntax)this.Visit(node.RightExpression);
      var into = (JoinIntoClauseSyntax)this.Visit(node.Into);
      return node.Update(joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into);
    }

    public override CSharpSyntaxNode VisitJoinIntoClause(JoinIntoClauseSyntax node)
    {
      var intoKeyword = (SyntaxToken)this.Visit(node.IntoKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      return node.Update(intoKeyword, identifier);
    }

    public override CSharpSyntaxNode VisitWhereClause(WhereClauseSyntax node)
    {
      var whereKeyword = (SyntaxToken)this.Visit(node.WhereKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      return node.Update(whereKeyword, condition);
    }

    public override CSharpSyntaxNode VisitOrderByClause(OrderByClauseSyntax node)
    {
      var orderByKeyword = (SyntaxToken)this.Visit(node.OrderByKeyword);
      var orderings = this.VisitList(node.Orderings);
      return node.Update(orderByKeyword, orderings);
    }

    public override CSharpSyntaxNode VisitOrdering(OrderingSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var ascendingOrDescendingKeyword = (SyntaxToken)this.Visit(node.AscendingOrDescendingKeyword);
      return node.Update(expression, ascendingOrDescendingKeyword);
    }

    public override CSharpSyntaxNode VisitSelectClause(SelectClauseSyntax node)
    {
      var selectKeyword = (SyntaxToken)this.Visit(node.SelectKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(selectKeyword, expression);
    }

    public override CSharpSyntaxNode VisitGroupClause(GroupClauseSyntax node)
    {
      var groupKeyword = (SyntaxToken)this.Visit(node.GroupKeyword);
      var groupExpression = (ExpressionSyntax)this.Visit(node.GroupExpression);
      var byKeyword = (SyntaxToken)this.Visit(node.ByKeyword);
      var byExpression = (ExpressionSyntax)this.Visit(node.ByExpression);
      return node.Update(groupKeyword, groupExpression, byKeyword, byExpression);
    }

    public override CSharpSyntaxNode VisitQueryContinuation(QueryContinuationSyntax node)
    {
      var intoKeyword = (SyntaxToken)this.Visit(node.IntoKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var body = (QueryBodySyntax)this.Visit(node.Body);
      return node.Update(intoKeyword, identifier, body);
    }

    public override CSharpSyntaxNode VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)
    {
      var omittedArraySizeExpressionToken = (SyntaxToken)this.Visit(node.OmittedArraySizeExpressionToken);
      return node.Update(omittedArraySizeExpressionToken);
    }

    public override CSharpSyntaxNode VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)
    {
      var stringStartToken = (SyntaxToken)this.Visit(node.StringStartToken);
      var contents = this.VisitList(node.Contents);
      var stringEndToken = (SyntaxToken)this.Visit(node.StringEndToken);
      return node.Update(stringStartToken, contents, stringEndToken);
    }

    public override CSharpSyntaxNode VisitIsPatternExpression(IsPatternExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var isKeyword = (SyntaxToken)this.Visit(node.IsKeyword);
      var pattern = (PatternSyntax)this.Visit(node.Pattern);
      return node.Update(expression, isKeyword, pattern);
    }

    public override CSharpSyntaxNode VisitWhenClause(WhenClauseSyntax node)
    {
      var whenKeyword = (SyntaxToken)this.Visit(node.WhenKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      return node.Update(whenKeyword, condition);
    }

    public override CSharpSyntaxNode VisitDeclarationPattern(DeclarationPatternSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      return node.Update(type, identifier);
    }

    public override CSharpSyntaxNode VisitConstantPattern(ConstantPatternSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(expression);
    }

    public override CSharpSyntaxNode VisitInterpolatedStringText(InterpolatedStringTextSyntax node)
    {
      var textToken = (SyntaxToken)this.Visit(node.TextToken);
      return node.Update(textToken);
    }

    public override CSharpSyntaxNode VisitInterpolation(InterpolationSyntax node)
    {
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var alignmentClause = (InterpolationAlignmentClauseSyntax)this.Visit(node.AlignmentClause);
      var formatClause = (InterpolationFormatClauseSyntax)this.Visit(node.FormatClause);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(openBraceToken, expression, alignmentClause, formatClause, closeBraceToken);
    }

    public override CSharpSyntaxNode VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node)
    {
      var commaToken = (SyntaxToken)this.Visit(node.CommaToken);
      var value = (ExpressionSyntax)this.Visit(node.Value);
      return node.Update(commaToken, value);
    }

    public override CSharpSyntaxNode VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node)
    {
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      var formatStringToken = (SyntaxToken)this.Visit(node.FormatStringToken);
      return node.Update(colonToken, formatStringToken);
    }

    public override CSharpSyntaxNode VisitGlobalStatement(GlobalStatementSyntax node)
    {
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(statement);
    }

    public override CSharpSyntaxNode VisitBlock(BlockSyntax node)
    {
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var statements = this.VisitList(node.Statements);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(openBraceToken, statements, closeBraceToken);
    }

    public override CSharpSyntaxNode VisitLocalFunctionStatement(LocalFunctionStatementSyntax node)
    {
      var modifiers = this.VisitList(node.Modifiers);
      var refKeyword = (SyntaxToken)this.Visit(node.RefKeyword);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(modifiers, refKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, semicolonToken);
    }

    public override CSharpSyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
    {
      var modifiers = this.VisitList(node.Modifiers);
      var refKeyword = (SyntaxToken)this.Visit(node.RefKeyword);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(modifiers, refKeyword, declaration, semicolonToken);
    }

    public override CSharpSyntaxNode VisitVariableDeconstructionDeclarator(VariableDeconstructionDeclaratorSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var variables = this.VisitList(node.Variables);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      var value = (ExpressionSyntax)this.Visit(node.Value);
      return node.Update(openParenToken, variables, closeParenToken, equalsToken, value);
    }

    public override CSharpSyntaxNode VisitVariableDeclaration(VariableDeclarationSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      var variables = this.VisitList(node.Variables);
      var deconstruction = (VariableDeconstructionDeclaratorSyntax)this.Visit(node.Deconstruction);
      return node.Update(type, variables, deconstruction);
    }

    public override CSharpSyntaxNode VisitVariableDeclarator(VariableDeclaratorSyntax node)
    {
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      var initializer = (EqualsValueClauseSyntax)this.Visit(node.Initializer);
      return node.Update(identifier, argumentList, initializer);
    }

    public override CSharpSyntaxNode VisitEqualsValueClause(EqualsValueClauseSyntax node)
    {
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      var refKeyword = (SyntaxToken)this.Visit(node.RefKeyword);
      var value = (ExpressionSyntax)this.Visit(node.Value);
      return node.Update(equalsToken, refKeyword, value);
    }

    public override CSharpSyntaxNode VisitExpressionStatement(ExpressionStatementSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(expression, semicolonToken);
    }

    public override CSharpSyntaxNode VisitEmptyStatement(EmptyStatementSyntax node)
    {
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(semicolonToken);
    }

    public override CSharpSyntaxNode VisitLabeledStatement(LabeledStatementSyntax node)
    {
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(identifier, colonToken, statement);
    }

    public override CSharpSyntaxNode VisitGotoStatement(GotoStatementSyntax node)
    {
      var gotoKeyword = (SyntaxToken)this.Visit(node.GotoKeyword);
      var caseOrDefaultKeyword = (SyntaxToken)this.Visit(node.CaseOrDefaultKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
    }

    public override CSharpSyntaxNode VisitBreakStatement(BreakStatementSyntax node)
    {
      var breakKeyword = (SyntaxToken)this.Visit(node.BreakKeyword);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(breakKeyword, semicolonToken);
    }

    public override CSharpSyntaxNode VisitContinueStatement(ContinueStatementSyntax node)
    {
      var continueKeyword = (SyntaxToken)this.Visit(node.ContinueKeyword);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(continueKeyword, semicolonToken);
    }

    public override CSharpSyntaxNode VisitReturnStatement(ReturnStatementSyntax node)
    {
      var returnKeyword = (SyntaxToken)this.Visit(node.ReturnKeyword);
      var refKeyword = (SyntaxToken)this.Visit(node.RefKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(returnKeyword, refKeyword, expression, semicolonToken);
    }

    public override CSharpSyntaxNode VisitThrowStatement(ThrowStatementSyntax node)
    {
      var throwKeyword = (SyntaxToken)this.Visit(node.ThrowKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(throwKeyword, expression, semicolonToken);
    }

    public override CSharpSyntaxNode VisitYieldStatement(YieldStatementSyntax node)
    {
      var yieldKeyword = (SyntaxToken)this.Visit(node.YieldKeyword);
      var returnOrBreakKeyword = (SyntaxToken)this.Visit(node.ReturnOrBreakKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
    }

    public override CSharpSyntaxNode VisitWhileStatement(WhileStatementSyntax node)
    {
      var whileKeyword = (SyntaxToken)this.Visit(node.WhileKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(whileKeyword, openParenToken, condition, closeParenToken, statement);
    }

    public override CSharpSyntaxNode VisitDoStatement(DoStatementSyntax node)
    {
      var doKeyword = (SyntaxToken)this.Visit(node.DoKeyword);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      var whileKeyword = (SyntaxToken)this.Visit(node.WhileKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
    }

    public override CSharpSyntaxNode VisitForStatement(ForStatementSyntax node)
    {
      var forKeyword = (SyntaxToken)this.Visit(node.ForKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var refKeyword = (SyntaxToken)this.Visit(node.RefKeyword);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var initializers = this.VisitList(node.Initializers);
      var firstSemicolonToken = (SyntaxToken)this.Visit(node.FirstSemicolonToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var secondSemicolonToken = (SyntaxToken)this.Visit(node.SecondSemicolonToken);
      var incrementors = this.VisitList(node.Incrementors);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(forKeyword, openParenToken, refKeyword, declaration, initializers, firstSemicolonToken, condition, secondSemicolonToken, incrementors, closeParenToken, statement);
    }

    public override CSharpSyntaxNode VisitForEachStatement(ForEachStatementSyntax node)
    {
      var forEachKeyword = (SyntaxToken)this.Visit(node.ForEachKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var deconstructionVariables = (VariableDeclarationSyntax)this.Visit(node.DeconstructionVariables);
      var inKeyword = (SyntaxToken)this.Visit(node.InKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(forEachKeyword, openParenToken, type, identifier, deconstructionVariables, inKeyword, expression, closeParenToken, statement);
    }

    public override CSharpSyntaxNode VisitUsingStatement(UsingStatementSyntax node)
    {
      var usingKeyword = (SyntaxToken)this.Visit(node.UsingKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(usingKeyword, openParenToken, declaration, expression, closeParenToken, statement);
    }

    public override CSharpSyntaxNode VisitFixedStatement(FixedStatementSyntax node)
    {
      var fixedKeyword = (SyntaxToken)this.Visit(node.FixedKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(fixedKeyword, openParenToken, declaration, closeParenToken, statement);
    }

    public override CSharpSyntaxNode VisitCheckedStatement(CheckedStatementSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(keyword, block);
    }

    public override CSharpSyntaxNode VisitUnsafeStatement(UnsafeStatementSyntax node)
    {
      var unsafeKeyword = (SyntaxToken)this.Visit(node.UnsafeKeyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(unsafeKeyword, block);
    }

    public override CSharpSyntaxNode VisitLockStatement(LockStatementSyntax node)
    {
      var lockKeyword = (SyntaxToken)this.Visit(node.LockKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(lockKeyword, openParenToken, expression, closeParenToken, statement);
    }

    public override CSharpSyntaxNode VisitIfStatement(IfStatementSyntax node)
    {
      var ifKeyword = (SyntaxToken)this.Visit(node.IfKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      var @else = (ElseClauseSyntax)this.Visit(node.Else);
      return node.Update(ifKeyword, openParenToken, condition, closeParenToken, statement, @else);
    }

    public override CSharpSyntaxNode VisitElseClause(ElseClauseSyntax node)
    {
      var elseKeyword = (SyntaxToken)this.Visit(node.ElseKeyword);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(elseKeyword, statement);
    }

    public override CSharpSyntaxNode VisitSwitchStatement(SwitchStatementSyntax node)
    {
      var switchKeyword = (SyntaxToken)this.Visit(node.SwitchKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var sections = this.VisitList(node.Sections);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections, closeBraceToken);
    }

    public override CSharpSyntaxNode VisitSwitchSection(SwitchSectionSyntax node)
    {
      var labels = this.VisitList(node.Labels);
      var statements = this.VisitList(node.Statements);
      return node.Update(labels, statements);
    }

    public override CSharpSyntaxNode VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var pattern = (PatternSyntax)this.Visit(node.Pattern);
      var whenClause = (WhenClauseSyntax)this.Visit(node.WhenClause);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      return node.Update(keyword, pattern, whenClause, colonToken);
    }

    public override CSharpSyntaxNode VisitCaseSwitchLabel(CaseSwitchLabelSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var value = (ExpressionSyntax)this.Visit(node.Value);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      return node.Update(keyword, value, colonToken);
    }

    public override CSharpSyntaxNode VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      return node.Update(keyword, colonToken);
    }

    public override CSharpSyntaxNode VisitTryStatement(TryStatementSyntax node)
    {
      var tryKeyword = (SyntaxToken)this.Visit(node.TryKeyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      var catches = this.VisitList(node.Catches);
      var @finally = (FinallyClauseSyntax)this.Visit(node.Finally);
      return node.Update(tryKeyword, block, catches, @finally);
    }

    public override CSharpSyntaxNode VisitCatchClause(CatchClauseSyntax node)
    {
      var catchKeyword = (SyntaxToken)this.Visit(node.CatchKeyword);
      var declaration = (CatchDeclarationSyntax)this.Visit(node.Declaration);
      var filter = (CatchFilterClauseSyntax)this.Visit(node.Filter);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(catchKeyword, declaration, filter, block);
    }

    public override CSharpSyntaxNode VisitCatchDeclaration(CatchDeclarationSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, type, identifier, closeParenToken);
    }

    public override CSharpSyntaxNode VisitCatchFilterClause(CatchFilterClauseSyntax node)
    {
      var whenKeyword = (SyntaxToken)this.Visit(node.WhenKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var filterExpression = (ExpressionSyntax)this.Visit(node.FilterExpression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(whenKeyword, openParenToken, filterExpression, closeParenToken);
    }

    public override CSharpSyntaxNode VisitFinallyClause(FinallyClauseSyntax node)
    {
      var finallyKeyword = (SyntaxToken)this.Visit(node.FinallyKeyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(finallyKeyword, block);
    }

    public override CSharpSyntaxNode VisitCompilationUnit(CompilationUnitSyntax node)
    {
      var externs = this.VisitList(node.Externs);
      var usings = this.VisitList(node.Usings);
      var attributeLists = this.VisitList(node.AttributeLists);
      var members = this.VisitList(node.Members);
      var endOfFileToken = (SyntaxToken)this.Visit(node.EndOfFileToken);
      return node.Update(externs, usings, attributeLists, members, endOfFileToken);
    }

    public override CSharpSyntaxNode VisitExternAliasDirective(ExternAliasDirectiveSyntax node)
    {
      var externKeyword = (SyntaxToken)this.Visit(node.ExternKeyword);
      var aliasKeyword = (SyntaxToken)this.Visit(node.AliasKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(externKeyword, aliasKeyword, identifier, semicolonToken);
    }

    public override CSharpSyntaxNode VisitUsingDirective(UsingDirectiveSyntax node)
    {
      var usingKeyword = (SyntaxToken)this.Visit(node.UsingKeyword);
      var staticKeyword = (SyntaxToken)this.Visit(node.StaticKeyword);
      var alias = (NameEqualsSyntax)this.Visit(node.Alias);
      var name = (NameSyntax)this.Visit(node.Name);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(usingKeyword, staticKeyword, alias, name, semicolonToken);
    }

    public override CSharpSyntaxNode VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
      var namespaceKeyword = (SyntaxToken)this.Visit(node.NamespaceKeyword);
      var name = (NameSyntax)this.Visit(node.Name);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var externs = this.VisitList(node.Externs);
      var usings = this.VisitList(node.Usings);
      var members = this.VisitList(node.Members);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(namespaceKeyword, name, openBraceToken, externs, usings, members, closeBraceToken, semicolonToken);
    }

    public override CSharpSyntaxNode VisitAttributeList(AttributeListSyntax node)
    {
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var target = (AttributeTargetSpecifierSyntax)this.Visit(node.Target);
      var attributes = this.VisitList(node.Attributes);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      return node.Update(openBracketToken, target, attributes, closeBracketToken);
    }

    public override CSharpSyntaxNode VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)
    {
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      return node.Update(identifier, colonToken);
    }

    public override CSharpSyntaxNode VisitAttribute(AttributeSyntax node)
    {
      var name = (NameSyntax)this.Visit(node.Name);
      var argumentList = (AttributeArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(name, argumentList);
    }

    public override CSharpSyntaxNode VisitAttributeArgumentList(AttributeArgumentListSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var arguments = this.VisitList(node.Arguments);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, arguments, closeParenToken);
    }

    public override CSharpSyntaxNode VisitAttributeArgument(AttributeArgumentSyntax node)
    {
      var nameEquals = (NameEqualsSyntax)this.Visit(node.NameEquals);
      var nameColon = (NameColonSyntax)this.Visit(node.NameColon);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(nameEquals, nameColon, expression);
    }

    public override CSharpSyntaxNode VisitNameEquals(NameEqualsSyntax node)
    {
      var name = (IdentifierNameSyntax)this.Visit(node.Name);
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      return node.Update(name, equalsToken);
    }

    public override CSharpSyntaxNode VisitTypeParameterList(TypeParameterListSyntax node)
    {
      var lessThanToken = (SyntaxToken)this.Visit(node.LessThanToken);
      var parameters = this.VisitList(node.Parameters);
      var greaterThanToken = (SyntaxToken)this.Visit(node.GreaterThanToken);
      return node.Update(lessThanToken, parameters, greaterThanToken);
    }

    public override CSharpSyntaxNode VisitTypeParameter(TypeParameterSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var varianceKeyword = (SyntaxToken)this.Visit(node.VarianceKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      return node.Update(attributeLists, varianceKeyword, identifier);
    }

    public override CSharpSyntaxNode VisitClassDeclaration(ClassDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override CSharpSyntaxNode VisitStructDeclaration(StructDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override CSharpSyntaxNode VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override CSharpSyntaxNode VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var enumKeyword = (SyntaxToken)this.Visit(node.EnumKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, enumKeyword, identifier, baseList, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override CSharpSyntaxNode VisitDelegateDeclaration(DelegateDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var delegateKeyword = (SyntaxToken)this.Visit(node.DelegateKeyword);
      var refKeyword = (SyntaxToken)this.Visit(node.RefKeyword);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, delegateKeyword, refKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses, semicolonToken);
    }

    public override CSharpSyntaxNode VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var equalsValue = (EqualsValueClauseSyntax)this.Visit(node.EqualsValue);
      return node.Update(attributeLists, identifier, equalsValue);
    }

    public override CSharpSyntaxNode VisitBaseList(BaseListSyntax node)
    {
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      var types = this.VisitList(node.Types);
      return node.Update(colonToken, types);
    }

    public override CSharpSyntaxNode VisitSimpleBaseType(SimpleBaseTypeSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(type);
    }

    public override CSharpSyntaxNode VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)
    {
      var whereKeyword = (SyntaxToken)this.Visit(node.WhereKeyword);
      var name = (IdentifierNameSyntax)this.Visit(node.Name);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      var constraints = this.VisitList(node.Constraints);
      return node.Update(whereKeyword, name, colonToken, constraints);
    }

    public override CSharpSyntaxNode VisitConstructorConstraint(ConstructorConstraintSyntax node)
    {
      var newKeyword = (SyntaxToken)this.Visit(node.NewKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(newKeyword, openParenToken, closeParenToken);
    }

    public override CSharpSyntaxNode VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)
    {
      var classOrStructKeyword = (SyntaxToken)this.Visit(node.ClassOrStructKeyword);
      return node.Update(classOrStructKeyword);
    }

    public override CSharpSyntaxNode VisitTypeConstraint(TypeConstraintSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(type);
    }

    public override CSharpSyntaxNode VisitFieldDeclaration(FieldDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, declaration, semicolonToken);
    }

    public override CSharpSyntaxNode VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var eventKeyword = (SyntaxToken)this.Visit(node.EventKeyword);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, eventKeyword, declaration, semicolonToken);
    }

    public override CSharpSyntaxNode VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)
    {
      var name = (NameSyntax)this.Visit(node.Name);
      var dotToken = (SyntaxToken)this.Visit(node.DotToken);
      return node.Update(name, dotToken);
    }

    public override CSharpSyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var refKeyword = (SyntaxToken)this.Visit(node.RefKeyword);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, refKeyword, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, semicolonToken);
    }

    public override CSharpSyntaxNode VisitOperatorDeclaration(OperatorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var operatorKeyword = (SyntaxToken)this.Visit(node.OperatorKeyword);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, returnType, operatorKeyword, operatorToken, parameterList, body, expressionBody, semicolonToken);
    }

    public override CSharpSyntaxNode VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var implicitOrExplicitKeyword = (SyntaxToken)this.Visit(node.ImplicitOrExplicitKeyword);
      var operatorKeyword = (SyntaxToken)this.Visit(node.OperatorKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, expressionBody, semicolonToken);
    }

    public override CSharpSyntaxNode VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var initializer = (ConstructorInitializerSyntax)this.Visit(node.Initializer);
      var body = (BlockSyntax)this.Visit(node.Body);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, identifier, parameterList, initializer, body, semicolonToken);
    }

    public override CSharpSyntaxNode VisitConstructorInitializer(ConstructorInitializerSyntax node)
    {
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      var thisOrBaseKeyword = (SyntaxToken)this.Visit(node.ThisOrBaseKeyword);
      var argumentList = (ArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(colonToken, thisOrBaseKeyword, argumentList);
    }

    public override CSharpSyntaxNode VisitDestructorDeclaration(DestructorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var tildeToken = (SyntaxToken)this.Visit(node.TildeToken);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (BlockSyntax)this.Visit(node.Body);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, tildeToken, identifier, parameterList, body, semicolonToken);
    }

    public override CSharpSyntaxNode VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var refKeyword = (SyntaxToken)this.Visit(node.RefKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var accessorList = (AccessorListSyntax)this.Visit(node.AccessorList);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var initializer = (EqualsValueClauseSyntax)this.Visit(node.Initializer);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, refKeyword, type, explicitInterfaceSpecifier, identifier, accessorList, expressionBody, initializer, semicolonToken);
    }

    public override CSharpSyntaxNode VisitArrowExpressionClause(ArrowExpressionClauseSyntax node)
    {
      var arrowToken = (SyntaxToken)this.Visit(node.ArrowToken);
      var refKeyword = (SyntaxToken)this.Visit(node.RefKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(arrowToken, refKeyword, expression);
    }

    public override CSharpSyntaxNode VisitEventDeclaration(EventDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var eventKeyword = (SyntaxToken)this.Visit(node.EventKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var accessorList = (AccessorListSyntax)this.Visit(node.AccessorList);
      return node.Update(attributeLists, modifiers, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList);
    }

    public override CSharpSyntaxNode VisitIndexerDeclaration(IndexerDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var refKeyword = (SyntaxToken)this.Visit(node.RefKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var thisKeyword = (SyntaxToken)this.Visit(node.ThisKeyword);
      var parameterList = (BracketedParameterListSyntax)this.Visit(node.ParameterList);
      var accessorList = (AccessorListSyntax)this.Visit(node.AccessorList);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, refKeyword, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList, expressionBody, semicolonToken);
    }

    public override CSharpSyntaxNode VisitAccessorList(AccessorListSyntax node)
    {
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var accessors = this.VisitList(node.Accessors);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(openBraceToken, accessors, closeBraceToken);
    }

    public override CSharpSyntaxNode VisitAccessorDeclaration(AccessorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var body = (BlockSyntax)this.Visit(node.Body);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, keyword, body, semicolonToken);
    }

    public override CSharpSyntaxNode VisitParameterList(ParameterListSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var parameters = this.VisitList(node.Parameters);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, parameters, closeParenToken);
    }

    public override CSharpSyntaxNode VisitBracketedParameterList(BracketedParameterListSyntax node)
    {
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var parameters = this.VisitList(node.Parameters);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      return node.Update(openBracketToken, parameters, closeBracketToken);
    }

    public override CSharpSyntaxNode VisitParameter(ParameterSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var @default = (EqualsValueClauseSyntax)this.Visit(node.Default);
      return node.Update(attributeLists, modifiers, type, identifier, @default);
    }

    public override CSharpSyntaxNode VisitIncompleteMember(IncompleteMemberSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var refKeyword = (SyntaxToken)this.Visit(node.RefKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(attributeLists, modifiers, refKeyword, type);
    }

    public override CSharpSyntaxNode VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
    {
      var tokens = this.VisitList(node.Tokens);
      return node.Update(tokens);
    }

    public override CSharpSyntaxNode VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node)
    {
      var content = this.VisitList(node.Content);
      var endOfComment = (SyntaxToken)this.Visit(node.EndOfComment);
      return node.Update(content, endOfComment);
    }

    public override CSharpSyntaxNode VisitTypeCref(TypeCrefSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(type);
    }

    public override CSharpSyntaxNode VisitQualifiedCref(QualifiedCrefSyntax node)
    {
      var container = (TypeSyntax)this.Visit(node.Container);
      var dotToken = (SyntaxToken)this.Visit(node.DotToken);
      var member = (MemberCrefSyntax)this.Visit(node.Member);
      return node.Update(container, dotToken, member);
    }

    public override CSharpSyntaxNode VisitNameMemberCref(NameMemberCrefSyntax node)
    {
      var name = (TypeSyntax)this.Visit(node.Name);
      var parameters = (CrefParameterListSyntax)this.Visit(node.Parameters);
      return node.Update(name, parameters);
    }

    public override CSharpSyntaxNode VisitIndexerMemberCref(IndexerMemberCrefSyntax node)
    {
      var thisKeyword = (SyntaxToken)this.Visit(node.ThisKeyword);
      var parameters = (CrefBracketedParameterListSyntax)this.Visit(node.Parameters);
      return node.Update(thisKeyword, parameters);
    }

    public override CSharpSyntaxNode VisitOperatorMemberCref(OperatorMemberCrefSyntax node)
    {
      var operatorKeyword = (SyntaxToken)this.Visit(node.OperatorKeyword);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var parameters = (CrefParameterListSyntax)this.Visit(node.Parameters);
      return node.Update(operatorKeyword, operatorToken, parameters);
    }

    public override CSharpSyntaxNode VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node)
    {
      var implicitOrExplicitKeyword = (SyntaxToken)this.Visit(node.ImplicitOrExplicitKeyword);
      var operatorKeyword = (SyntaxToken)this.Visit(node.OperatorKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var parameters = (CrefParameterListSyntax)this.Visit(node.Parameters);
      return node.Update(implicitOrExplicitKeyword, operatorKeyword, type, parameters);
    }

    public override CSharpSyntaxNode VisitCrefParameterList(CrefParameterListSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var parameters = this.VisitList(node.Parameters);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, parameters, closeParenToken);
    }

    public override CSharpSyntaxNode VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node)
    {
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var parameters = this.VisitList(node.Parameters);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      return node.Update(openBracketToken, parameters, closeBracketToken);
    }

    public override CSharpSyntaxNode VisitCrefParameter(CrefParameterSyntax node)
    {
      var refOrOutKeyword = (SyntaxToken)this.Visit(node.RefOrOutKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(refOrOutKeyword, type);
    }

    public override CSharpSyntaxNode VisitXmlElement(XmlElementSyntax node)
    {
      var startTag = (XmlElementStartTagSyntax)this.Visit(node.StartTag);
      var content = this.VisitList(node.Content);
      var endTag = (XmlElementEndTagSyntax)this.Visit(node.EndTag);
      return node.Update(startTag, content, endTag);
    }

    public override CSharpSyntaxNode VisitXmlElementStartTag(XmlElementStartTagSyntax node)
    {
      var lessThanToken = (SyntaxToken)this.Visit(node.LessThanToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var attributes = this.VisitList(node.Attributes);
      var greaterThanToken = (SyntaxToken)this.Visit(node.GreaterThanToken);
      return node.Update(lessThanToken, name, attributes, greaterThanToken);
    }

    public override CSharpSyntaxNode VisitXmlElementEndTag(XmlElementEndTagSyntax node)
    {
      var lessThanSlashToken = (SyntaxToken)this.Visit(node.LessThanSlashToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var greaterThanToken = (SyntaxToken)this.Visit(node.GreaterThanToken);
      return node.Update(lessThanSlashToken, name, greaterThanToken);
    }

    public override CSharpSyntaxNode VisitXmlEmptyElement(XmlEmptyElementSyntax node)
    {
      var lessThanToken = (SyntaxToken)this.Visit(node.LessThanToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var attributes = this.VisitList(node.Attributes);
      var slashGreaterThanToken = (SyntaxToken)this.Visit(node.SlashGreaterThanToken);
      return node.Update(lessThanToken, name, attributes, slashGreaterThanToken);
    }

    public override CSharpSyntaxNode VisitXmlName(XmlNameSyntax node)
    {
      var prefix = (XmlPrefixSyntax)this.Visit(node.Prefix);
      var localName = (SyntaxToken)this.Visit(node.LocalName);
      return node.Update(prefix, localName);
    }

    public override CSharpSyntaxNode VisitXmlPrefix(XmlPrefixSyntax node)
    {
      var prefix = (SyntaxToken)this.Visit(node.Prefix);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      return node.Update(prefix, colonToken);
    }

    public override CSharpSyntaxNode VisitXmlTextAttribute(XmlTextAttributeSyntax node)
    {
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      var startQuoteToken = (SyntaxToken)this.Visit(node.StartQuoteToken);
      var textTokens = this.VisitList(node.TextTokens);
      var endQuoteToken = (SyntaxToken)this.Visit(node.EndQuoteToken);
      return node.Update(name, equalsToken, startQuoteToken, textTokens, endQuoteToken);
    }

    public override CSharpSyntaxNode VisitXmlCrefAttribute(XmlCrefAttributeSyntax node)
    {
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      var startQuoteToken = (SyntaxToken)this.Visit(node.StartQuoteToken);
      var cref = (CrefSyntax)this.Visit(node.Cref);
      var endQuoteToken = (SyntaxToken)this.Visit(node.EndQuoteToken);
      return node.Update(name, equalsToken, startQuoteToken, cref, endQuoteToken);
    }

    public override CSharpSyntaxNode VisitXmlNameAttribute(XmlNameAttributeSyntax node)
    {
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      var startQuoteToken = (SyntaxToken)this.Visit(node.StartQuoteToken);
      var identifier = (IdentifierNameSyntax)this.Visit(node.Identifier);
      var endQuoteToken = (SyntaxToken)this.Visit(node.EndQuoteToken);
      return node.Update(name, equalsToken, startQuoteToken, identifier, endQuoteToken);
    }

    public override CSharpSyntaxNode VisitXmlText(XmlTextSyntax node)
    {
      var textTokens = this.VisitList(node.TextTokens);
      return node.Update(textTokens);
    }

    public override CSharpSyntaxNode VisitXmlCDataSection(XmlCDataSectionSyntax node)
    {
      var startCDataToken = (SyntaxToken)this.Visit(node.StartCDataToken);
      var textTokens = this.VisitList(node.TextTokens);
      var endCDataToken = (SyntaxToken)this.Visit(node.EndCDataToken);
      return node.Update(startCDataToken, textTokens, endCDataToken);
    }

    public override CSharpSyntaxNode VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
    {
      var startProcessingInstructionToken = (SyntaxToken)this.Visit(node.StartProcessingInstructionToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var textTokens = this.VisitList(node.TextTokens);
      var endProcessingInstructionToken = (SyntaxToken)this.Visit(node.EndProcessingInstructionToken);
      return node.Update(startProcessingInstructionToken, name, textTokens, endProcessingInstructionToken);
    }

    public override CSharpSyntaxNode VisitXmlComment(XmlCommentSyntax node)
    {
      var lessThanExclamationMinusMinusToken = (SyntaxToken)this.Visit(node.LessThanExclamationMinusMinusToken);
      var textTokens = this.VisitList(node.TextTokens);
      var minusMinusGreaterThanToken = (SyntaxToken)this.Visit(node.MinusMinusGreaterThanToken);
      return node.Update(lessThanExclamationMinusMinusToken, textTokens, minusMinusGreaterThanToken);
    }

    public override CSharpSyntaxNode VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var ifKeyword = (SyntaxToken)this.Visit(node.IfKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, ifKeyword, condition, endOfDirectiveToken, node.IsActive, node.BranchTaken, node.ConditionValue);
    }

    public override CSharpSyntaxNode VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var elifKeyword = (SyntaxToken)this.Visit(node.ElifKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, elifKeyword, condition, endOfDirectiveToken, node.IsActive, node.BranchTaken, node.ConditionValue);
    }

    public override CSharpSyntaxNode VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var elseKeyword = (SyntaxToken)this.Visit(node.ElseKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, elseKeyword, endOfDirectiveToken, node.IsActive, node.BranchTaken);
    }

    public override CSharpSyntaxNode VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var endIfKeyword = (SyntaxToken)this.Visit(node.EndIfKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, endIfKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var regionKeyword = (SyntaxToken)this.Visit(node.RegionKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, regionKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var endRegionKeyword = (SyntaxToken)this.Visit(node.EndRegionKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, endRegionKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var errorKeyword = (SyntaxToken)this.Visit(node.ErrorKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, errorKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var warningKeyword = (SyntaxToken)this.Visit(node.WarningKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, warningKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, identifier, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var defineKeyword = (SyntaxToken)this.Visit(node.DefineKeyword);
      var name = (SyntaxToken)this.Visit(node.Name);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, defineKeyword, name, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var undefKeyword = (SyntaxToken)this.Visit(node.UndefKeyword);
      var name = (SyntaxToken)this.Visit(node.Name);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, undefKeyword, name, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var lineKeyword = (SyntaxToken)this.Visit(node.LineKeyword);
      var line = (SyntaxToken)this.Visit(node.Line);
      var file = (SyntaxToken)this.Visit(node.File);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, lineKeyword, line, file, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var pragmaKeyword = (SyntaxToken)this.Visit(node.PragmaKeyword);
      var warningKeyword = (SyntaxToken)this.Visit(node.WarningKeyword);
      var disableOrRestoreKeyword = (SyntaxToken)this.Visit(node.DisableOrRestoreKeyword);
      var errorCodes = this.VisitList(node.ErrorCodes);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var pragmaKeyword = (SyntaxToken)this.Visit(node.PragmaKeyword);
      var checksumKeyword = (SyntaxToken)this.Visit(node.ChecksumKeyword);
      var file = (SyntaxToken)this.Visit(node.File);
      var guid = (SyntaxToken)this.Visit(node.Guid);
      var bytes = (SyntaxToken)this.Visit(node.Bytes);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var referenceKeyword = (SyntaxToken)this.Visit(node.ReferenceKeyword);
      var file = (SyntaxToken)this.Visit(node.File);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, referenceKeyword, file, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var loadKeyword = (SyntaxToken)this.Visit(node.LoadKeyword);
      var file = (SyntaxToken)this.Visit(node.File);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, loadKeyword, file, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var exclamationToken = (SyntaxToken)this.Visit(node.ExclamationToken);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, exclamationToken, endOfDirectiveToken, node.IsActive);
    }
  }

  internal class ContextAwareSyntax
  {
    private SyntaxFactoryContext context;


    public ContextAwareSyntax(SyntaxFactoryContext context)
    {
        this.context = context;
    }
    public IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.GlobalKeyword:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IdentifierName, identifier, this.context, out hash);
      if (cached != null) return (IdentifierNameSyntax)cached;

      var result = new IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public QualifiedNameSyntax QualifiedName(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
    {
#if DEBUG
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      if (dotToken == null)
        throw new ArgumentNullException(nameof(dotToken));
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("dotToken");
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QualifiedName, left, dotToken, right, this.context, out hash);
      if (cached != null) return (QualifiedNameSyntax)cached;

      var result = new QualifiedNameSyntax(SyntaxKind.QualifiedName, left, dotToken, right, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public GenericNameSyntax GenericName(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (typeArgumentList == null)
        throw new ArgumentNullException(nameof(typeArgumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.GenericName, identifier, typeArgumentList, this.context, out hash);
      if (cached != null) return (GenericNameSyntax)cached;

      var result = new GenericNameSyntax(SyntaxKind.GenericName, identifier, typeArgumentList, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken, this.context, out hash);
      if (cached != null) return (TypeArgumentListSyntax)cached;

      var result = new TypeArgumentListSyntax(SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
    {
#if DEBUG
      if (alias == null)
        throw new ArgumentNullException(nameof(alias));
      if (colonColonToken == null)
        throw new ArgumentNullException(nameof(colonColonToken));
      switch (colonColonToken.Kind)
      {
        case SyntaxKind.ColonColonToken:
          break;
        default:
          throw new ArgumentException("colonColonToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AliasQualifiedName, alias, colonColonToken, name, this.context, out hash);
      if (cached != null) return (AliasQualifiedNameSyntax)cached;

      var result = new AliasQualifiedNameSyntax(SyntaxKind.AliasQualifiedName, alias, colonColonToken, name, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public PredefinedTypeSyntax PredefinedType(SyntaxToken keyword)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.BoolKeyword:
        case SyntaxKind.ByteKeyword:
        case SyntaxKind.SByteKeyword:
        case SyntaxKind.IntKeyword:
        case SyntaxKind.UIntKeyword:
        case SyntaxKind.ShortKeyword:
        case SyntaxKind.UShortKeyword:
        case SyntaxKind.LongKeyword:
        case SyntaxKind.ULongKeyword:
        case SyntaxKind.FloatKeyword:
        case SyntaxKind.DoubleKeyword:
        case SyntaxKind.DecimalKeyword:
        case SyntaxKind.StringKeyword:
        case SyntaxKind.CharKeyword:
        case SyntaxKind.ObjectKeyword:
        case SyntaxKind.VoidKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.PredefinedType, keyword, this.context, out hash);
      if (cached != null) return (PredefinedTypeSyntax)cached;

      var result = new PredefinedTypeSyntax(SyntaxKind.PredefinedType, keyword, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ArrayTypeSyntax ArrayType(TypeSyntax elementType, SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
    {
#if DEBUG
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayType, elementType, rankSpecifiers.Node, this.context, out hash);
      if (cached != null) return (ArrayTypeSyntax)cached;

      var result = new ArrayTypeSyntax(SyntaxKind.ArrayType, elementType, rankSpecifiers.Node, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openBracketToken, SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayRankSpecifier, openBracketToken, sizes.Node, closeBracketToken, this.context, out hash);
      if (cached != null) return (ArrayRankSpecifierSyntax)cached;

      var result = new ArrayRankSpecifierSyntax(SyntaxKind.ArrayRankSpecifier, openBracketToken, sizes.Node, closeBracketToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public PointerTypeSyntax PointerType(TypeSyntax elementType, SyntaxToken asteriskToken)
    {
#if DEBUG
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
      if (asteriskToken == null)
        throw new ArgumentNullException(nameof(asteriskToken));
      switch (asteriskToken.Kind)
      {
        case SyntaxKind.AsteriskToken:
          break;
        default:
          throw new ArgumentException("asteriskToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.PointerType, elementType, asteriskToken, this.context, out hash);
      if (cached != null) return (PointerTypeSyntax)cached;

      var result = new PointerTypeSyntax(SyntaxKind.PointerType, elementType, asteriskToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public NullableTypeSyntax NullableType(TypeSyntax elementType, SyntaxToken questionToken)
    {
#if DEBUG
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
      if (questionToken == null)
        throw new ArgumentNullException(nameof(questionToken));
      switch (questionToken.Kind)
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException("questionToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NullableType, elementType, questionToken, this.context, out hash);
      if (cached != null) return (NullableTypeSyntax)cached;

      var result = new NullableTypeSyntax(SyntaxKind.NullableType, elementType, questionToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TupleTypeSyntax TupleType(SyntaxToken openParenToken, SeparatedSyntaxList<TupleElementSyntax> elements, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleType, openParenToken, elements.Node, closeParenToken, this.context, out hash);
      if (cached != null) return (TupleTypeSyntax)cached;

      var result = new TupleTypeSyntax(SyntaxKind.TupleType, openParenToken, elements.Node, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TupleElementSyntax TupleElement(TypeSyntax type, IdentifierNameSyntax name)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleElement, type, name, this.context, out hash);
      if (cached != null) return (TupleElementSyntax)cached;

      var result = new TupleElementSyntax(SyntaxKind.TupleElement, type, name, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public OmittedTypeArgumentSyntax OmittedTypeArgument(SyntaxToken omittedTypeArgumentToken)
    {
#if DEBUG
      if (omittedTypeArgumentToken == null)
        throw new ArgumentNullException(nameof(omittedTypeArgumentToken));
      switch (omittedTypeArgumentToken.Kind)
      {
        case SyntaxKind.OmittedTypeArgumentToken:
          break;
        default:
          throw new ArgumentException("omittedTypeArgumentToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OmittedTypeArgument, omittedTypeArgumentToken, this.context, out hash);
      if (cached != null) return (OmittedTypeArgumentSyntax)cached;

      var result = new OmittedTypeArgumentSyntax(SyntaxKind.OmittedTypeArgument, omittedTypeArgumentToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, this.context, out hash);
      if (cached != null) return (ParenthesizedExpressionSyntax)cached;

      var result = new ParenthesizedExpressionSyntax(SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TupleExpressionSyntax TupleExpression(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleExpression, openParenToken, arguments.Node, closeParenToken, this.context, out hash);
      if (cached != null) return (TupleExpressionSyntax)cached;

      var result = new TupleExpressionSyntax(SyntaxKind.TupleExpression, openParenToken, arguments.Node, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
    {
      switch (kind)
      {
        case SyntaxKind.UnaryPlusExpression:
        case SyntaxKind.UnaryMinusExpression:
        case SyntaxKind.BitwiseNotExpression:
        case SyntaxKind.LogicalNotExpression:
        case SyntaxKind.PreIncrementExpression:
        case SyntaxKind.PreDecrementExpression:
        case SyntaxKind.AddressOfExpression:
        case SyntaxKind.PointerIndirectionExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.AsteriskToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (operand == null)
        throw new ArgumentNullException(nameof(operand));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, operatorToken, operand, this.context, out hash);
      if (cached != null) return (PrefixUnaryExpressionSyntax)cached;

      var result = new PrefixUnaryExpressionSyntax(kind, operatorToken, operand, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AwaitExpressionSyntax AwaitExpression(SyntaxToken awaitKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (awaitKeyword == null)
        throw new ArgumentNullException(nameof(awaitKeyword));
      switch (awaitKeyword.Kind)
      {
        case SyntaxKind.AwaitKeyword:
          break;
        default:
          throw new ArgumentException("awaitKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AwaitExpression, awaitKeyword, expression, this.context, out hash);
      if (cached != null) return (AwaitExpressionSyntax)cached;

      var result = new AwaitExpressionSyntax(SyntaxKind.AwaitExpression, awaitKeyword, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken)
    {
      switch (kind)
      {
        case SyntaxKind.PostIncrementExpression:
        case SyntaxKind.PostDecrementExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (operand == null)
        throw new ArgumentNullException(nameof(operand));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, operand, operatorToken, this.context, out hash);
      if (cached != null) return (PostfixUnaryExpressionSyntax)cached;

      var result = new PostfixUnaryExpressionSyntax(kind, operand, operatorToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
    {
      switch (kind)
      {
        case SyntaxKind.SimpleMemberAccessExpression:
        case SyntaxKind.PointerMemberAccessExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.DotToken:
        case SyntaxKind.MinusGreaterThanToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, expression, operatorToken, name, this.context, out hash);
      if (cached != null) return (MemberAccessExpressionSyntax)cached;

      var result = new MemberAccessExpressionSyntax(kind, expression, operatorToken, name, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (whenNotNull == null)
        throw new ArgumentNullException(nameof(whenNotNull));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ConditionalAccessExpression, expression, operatorToken, whenNotNull, this.context, out hash);
      if (cached != null) return (ConditionalAccessExpressionSyntax)cached;

      var result = new ConditionalAccessExpressionSyntax(SyntaxKind.ConditionalAccessExpression, expression, operatorToken, whenNotNull, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public MemberBindingExpressionSyntax MemberBindingExpression(SyntaxToken operatorToken, SimpleNameSyntax name)
    {
#if DEBUG
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.MemberBindingExpression, operatorToken, name, this.context, out hash);
      if (cached != null) return (MemberBindingExpressionSyntax)cached;

      var result = new MemberBindingExpressionSyntax(SyntaxKind.MemberBindingExpression, operatorToken, name, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ElementBindingExpressionSyntax ElementBindingExpression(BracketedArgumentListSyntax argumentList)
    {
#if DEBUG
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ElementBindingExpression, argumentList, this.context, out hash);
      if (cached != null) return (ElementBindingExpressionSyntax)cached;

      var result = new ElementBindingExpressionSyntax(SyntaxKind.ElementBindingExpression, argumentList, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ImplicitElementAccessSyntax ImplicitElementAccess(BracketedArgumentListSyntax argumentList)
    {
#if DEBUG
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ImplicitElementAccess, argumentList, this.context, out hash);
      if (cached != null) return (ImplicitElementAccessSyntax)cached;

      var result = new ImplicitElementAccessSyntax(SyntaxKind.ImplicitElementAccess, argumentList, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
      switch (kind)
      {
        case SyntaxKind.AddExpression:
        case SyntaxKind.SubtractExpression:
        case SyntaxKind.MultiplyExpression:
        case SyntaxKind.DivideExpression:
        case SyntaxKind.ModuloExpression:
        case SyntaxKind.LeftShiftExpression:
        case SyntaxKind.RightShiftExpression:
        case SyntaxKind.LogicalOrExpression:
        case SyntaxKind.LogicalAndExpression:
        case SyntaxKind.BitwiseOrExpression:
        case SyntaxKind.BitwiseAndExpression:
        case SyntaxKind.ExclusiveOrExpression:
        case SyntaxKind.EqualsExpression:
        case SyntaxKind.NotEqualsExpression:
        case SyntaxKind.LessThanExpression:
        case SyntaxKind.LessThanOrEqualExpression:
        case SyntaxKind.GreaterThanExpression:
        case SyntaxKind.GreaterThanOrEqualExpression:
        case SyntaxKind.IsExpression:
        case SyntaxKind.AsExpression:
        case SyntaxKind.CoalesceExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarBarToken:
        case SyntaxKind.AmpersandAmpersandToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.IsKeyword:
        case SyntaxKind.AsKeyword:
        case SyntaxKind.QuestionQuestionToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, this.context, out hash);
      if (cached != null) return (BinaryExpressionSyntax)cached;

      var result = new BinaryExpressionSyntax(kind, left, operatorToken, right, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
      switch (kind)
      {
        case SyntaxKind.SimpleAssignmentExpression:
        case SyntaxKind.AddAssignmentExpression:
        case SyntaxKind.SubtractAssignmentExpression:
        case SyntaxKind.MultiplyAssignmentExpression:
        case SyntaxKind.DivideAssignmentExpression:
        case SyntaxKind.ModuloAssignmentExpression:
        case SyntaxKind.AndAssignmentExpression:
        case SyntaxKind.ExclusiveOrAssignmentExpression:
        case SyntaxKind.OrAssignmentExpression:
        case SyntaxKind.LeftShiftAssignmentExpression:
        case SyntaxKind.RightShiftAssignmentExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.EqualsToken:
        case SyntaxKind.PlusEqualsToken:
        case SyntaxKind.MinusEqualsToken:
        case SyntaxKind.AsteriskEqualsToken:
        case SyntaxKind.SlashEqualsToken:
        case SyntaxKind.PercentEqualsToken:
        case SyntaxKind.AmpersandEqualsToken:
        case SyntaxKind.CaretEqualsToken:
        case SyntaxKind.BarEqualsToken:
        case SyntaxKind.LessThanLessThanEqualsToken:
        case SyntaxKind.GreaterThanGreaterThanEqualsToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, this.context, out hash);
      if (cached != null) return (AssignmentExpressionSyntax)cached;

      var result = new AssignmentExpressionSyntax(kind, left, operatorToken, right, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
    {
#if DEBUG
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (questionToken == null)
        throw new ArgumentNullException(nameof(questionToken));
      switch (questionToken.Kind)
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException("questionToken");
      }
      if (whenTrue == null)
        throw new ArgumentNullException(nameof(whenTrue));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      if (whenFalse == null)
        throw new ArgumentNullException(nameof(whenFalse));
#endif

      return new ConditionalExpressionSyntax(SyntaxKind.ConditionalExpression, condition, questionToken, whenTrue, colonToken, whenFalse, this.context);
    }

    public ThisExpressionSyntax ThisExpression(SyntaxToken token)
    {
#if DEBUG
      if (token == null)
        throw new ArgumentNullException(nameof(token));
      switch (token.Kind)
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ThisExpression, token, this.context, out hash);
      if (cached != null) return (ThisExpressionSyntax)cached;

      var result = new ThisExpressionSyntax(SyntaxKind.ThisExpression, token, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public BaseExpressionSyntax BaseExpression(SyntaxToken token)
    {
#if DEBUG
      if (token == null)
        throw new ArgumentNullException(nameof(token));
      switch (token.Kind)
      {
        case SyntaxKind.BaseKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BaseExpression, token, this.context, out hash);
      if (cached != null) return (BaseExpressionSyntax)cached;

      var result = new BaseExpressionSyntax(SyntaxKind.BaseExpression, token, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public OriginalExpressionSyntax OriginalExpression(SyntaxToken token)
    {
#if DEBUG
      if (token == null)
        throw new ArgumentNullException(nameof(token));
      switch (token.Kind)
      {
        case SyntaxKind.OriginalKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OriginalExpression, token, this.context, out hash);
      if (cached != null) return (OriginalExpressionSyntax)cached;

      var result = new OriginalExpressionSyntax(SyntaxKind.OriginalExpression, token, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)
    {
      switch (kind)
      {
        case SyntaxKind.ArgListExpression:
        case SyntaxKind.NumericLiteralExpression:
        case SyntaxKind.StringLiteralExpression:
        case SyntaxKind.CharacterLiteralExpression:
        case SyntaxKind.TrueLiteralExpression:
        case SyntaxKind.FalseLiteralExpression:
        case SyntaxKind.NullLiteralExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (token == null)
        throw new ArgumentNullException(nameof(token));
      switch (token.Kind)
      {
        case SyntaxKind.ArgListKeyword:
        case SyntaxKind.NumericLiteralToken:
        case SyntaxKind.StringLiteralToken:
        case SyntaxKind.CharacterLiteralToken:
        case SyntaxKind.TrueKeyword:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.NullKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, token, this.context, out hash);
      if (cached != null) return (LiteralExpressionSyntax)cached;

      var result = new LiteralExpressionSyntax(kind, token, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public MakeRefExpressionSyntax MakeRefExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.MakeRefKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new MakeRefExpressionSyntax(SyntaxKind.MakeRefExpression, keyword, openParenToken, expression, closeParenToken, this.context);
    }

    public RefTypeExpressionSyntax RefTypeExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.RefTypeKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new RefTypeExpressionSyntax(SyntaxKind.RefTypeExpression, keyword, openParenToken, expression, closeParenToken, this.context);
    }

    public RefValueExpressionSyntax RefValueExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.RefValueKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (comma == null)
        throw new ArgumentNullException(nameof(comma));
      switch (comma.Kind)
      {
        case SyntaxKind.CommaToken:
          break;
        default:
          throw new ArgumentException("comma");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new RefValueExpressionSyntax(SyntaxKind.RefValueExpression, keyword, openParenToken, expression, comma, type, closeParenToken, this.context);
    }

    public CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedExpression:
        case SyntaxKind.UncheckedExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CheckedKeyword:
        case SyntaxKind.UncheckedKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new CheckedExpressionSyntax(kind, keyword, openParenToken, expression, closeParenToken, this.context);
    }

    public DefaultExpressionSyntax DefaultExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new DefaultExpressionSyntax(SyntaxKind.DefaultExpression, keyword, openParenToken, type, closeParenToken, this.context);
    }

    public TypeOfExpressionSyntax TypeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.TypeOfKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new TypeOfExpressionSyntax(SyntaxKind.TypeOfExpression, keyword, openParenToken, type, closeParenToken, this.context);
    }

    public SizeOfExpressionSyntax SizeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.SizeOfKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new SizeOfExpressionSyntax(SyntaxKind.SizeOfExpression, keyword, openParenToken, type, closeParenToken, this.context);
    }

    public InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression, ArgumentListSyntax argumentList)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InvocationExpression, expression, argumentList, this.context, out hash);
      if (cached != null) return (InvocationExpressionSyntax)cached;

      var result = new InvocationExpressionSyntax(SyntaxKind.InvocationExpression, expression, argumentList, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ElementAccessExpression, expression, argumentList, this.context, out hash);
      if (cached != null) return (ElementAccessExpressionSyntax)cached;

      var result = new ElementAccessExpressionSyntax(SyntaxKind.ElementAccessExpression, expression, argumentList, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken, this.context, out hash);
      if (cached != null) return (ArgumentListSyntax)cached;

      var result = new ArgumentListSyntax(SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public BracketedArgumentListSyntax BracketedArgumentList(SyntaxToken openBracketToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BracketedArgumentList, openBracketToken, arguments.Node, closeBracketToken, this.context, out hash);
      if (cached != null) return (BracketedArgumentListSyntax)cached;

      var result = new BracketedArgumentListSyntax(SyntaxKind.BracketedArgumentList, openBracketToken, arguments.Node, closeBracketToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ArgumentSyntax Argument(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (refOrOutKeyword != null)
      {
      switch (refOrOutKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refOrOutKeyword");
      }
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Argument, nameColon, refOrOutKeyword, expression, this.context, out hash);
      if (cached != null) return (ArgumentSyntax)cached;

      var result = new ArgumentSyntax(SyntaxKind.Argument, nameColon, refOrOutKeyword, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public NameColonSyntax NameColon(IdentifierNameSyntax name, SyntaxToken colonToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NameColon, name, colonToken, this.context, out hash);
      if (cached != null) return (NameColonSyntax)cached;

      var result = new NameColonSyntax(SyntaxKind.NameColon, name, colonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public CastExpressionSyntax CastExpression(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      return new CastExpressionSyntax(SyntaxKind.CastExpression, openParenToken, type, closeParenToken, expression, this.context);
    }

    public AnonymousMethodExpressionSyntax AnonymousMethodExpression(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body)
    {
#if DEBUG
      if (asyncKeyword != null)
      {
      switch (asyncKeyword.Kind)
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("asyncKeyword");
      }
      }
      if (delegateKeyword == null)
        throw new ArgumentNullException(nameof(delegateKeyword));
      switch (delegateKeyword.Kind)
      {
        case SyntaxKind.DelegateKeyword:
          break;
        default:
          throw new ArgumentException("delegateKeyword");
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      return new AnonymousMethodExpressionSyntax(SyntaxKind.AnonymousMethodExpression, asyncKeyword, delegateKeyword, parameterList, body, this.context);
    }

    public SimpleLambdaExpressionSyntax SimpleLambdaExpression(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, SyntaxToken refKeyword, CSharpSyntaxNode body)
    {
#if DEBUG
      if (asyncKeyword != null)
      {
      switch (asyncKeyword.Kind)
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("asyncKeyword");
      }
      }
      if (parameter == null)
        throw new ArgumentNullException(nameof(parameter));
      if (arrowToken == null)
        throw new ArgumentNullException(nameof(arrowToken));
      switch (arrowToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException("arrowToken");
      }
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      return new SimpleLambdaExpressionSyntax(SyntaxKind.SimpleLambdaExpression, asyncKeyword, parameter, arrowToken, refKeyword, body, this.context);
    }

    public ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, SyntaxToken refKeyword, CSharpSyntaxNode body)
    {
#if DEBUG
      if (asyncKeyword != null)
      {
      switch (asyncKeyword.Kind)
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("asyncKeyword");
      }
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (arrowToken == null)
        throw new ArgumentNullException(nameof(arrowToken));
      switch (arrowToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException("arrowToken");
      }
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      return new ParenthesizedLambdaExpressionSyntax(SyntaxKind.ParenthesizedLambdaExpression, asyncKeyword, parameterList, arrowToken, refKeyword, body, this.context);
    }

    public InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)
    {
      switch (kind)
      {
        case SyntaxKind.ObjectInitializerExpression:
        case SyntaxKind.CollectionInitializerExpression:
        case SyntaxKind.ArrayInitializerExpression:
        case SyntaxKind.ComplexElementInitializerExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, openBraceToken, expressions.Node, closeBraceToken, this.context, out hash);
      if (cached != null) return (InitializerExpressionSyntax)cached;

      var result = new InitializerExpressionSyntax(kind, openBraceToken, expressions.Node, closeBraceToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      return new ObjectCreationExpressionSyntax(SyntaxKind.ObjectCreationExpression, newKeyword, type, argumentList, initializer, this.context);
    }

    public AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(NameEqualsSyntax nameEquals, ExpressionSyntax expression)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AnonymousObjectMemberDeclarator, nameEquals, expression, this.context, out hash);
      if (cached != null) return (AnonymousObjectMemberDeclaratorSyntax)cached;

      var result = new AnonymousObjectMemberDeclaratorSyntax(SyntaxKind.AnonymousObjectMemberDeclarator, nameEquals, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      return new AnonymousObjectCreationExpressionSyntax(SyntaxKind.AnonymousObjectCreationExpression, newKeyword, openBraceToken, initializers.Node, closeBraceToken, this.context);
    }

    public ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayCreationExpression, newKeyword, type, initializer, this.context, out hash);
      if (cached != null) return (ArrayCreationExpressionSyntax)cached;

      var result = new ArrayCreationExpressionSyntax(SyntaxKind.ArrayCreationExpression, newKeyword, type, initializer, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxList<SyntaxToken> commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
      if (initializer == null)
        throw new ArgumentNullException(nameof(initializer));
#endif

      return new ImplicitArrayCreationExpressionSyntax(SyntaxKind.ImplicitArrayCreationExpression, newKeyword, openBracketToken, commas.Node, closeBracketToken, initializer, this.context);
    }

    public StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, TypeSyntax type)
    {
#if DEBUG
      if (stackAllocKeyword == null)
        throw new ArgumentNullException(nameof(stackAllocKeyword));
      switch (stackAllocKeyword.Kind)
      {
        case SyntaxKind.StackAllocKeyword:
          break;
        default:
          throw new ArgumentException("stackAllocKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.StackAllocArrayCreationExpression, stackAllocKeyword, type, this.context, out hash);
      if (cached != null) return (StackAllocArrayCreationExpressionSyntax)cached;

      var result = new StackAllocArrayCreationExpressionSyntax(SyntaxKind.StackAllocArrayCreationExpression, stackAllocKeyword, type, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public QueryExpressionSyntax QueryExpression(FromClauseSyntax fromClause, QueryBodySyntax body)
    {
#if DEBUG
      if (fromClause == null)
        throw new ArgumentNullException(nameof(fromClause));
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryExpression, fromClause, body, this.context, out hash);
      if (cached != null) return (QueryExpressionSyntax)cached;

      var result = new QueryExpressionSyntax(SyntaxKind.QueryExpression, fromClause, body, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public QueryBodySyntax QueryBody(SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
    {
#if DEBUG
      if (selectOrGroup == null)
        throw new ArgumentNullException(nameof(selectOrGroup));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryBody, clauses.Node, selectOrGroup, continuation, this.context, out hash);
      if (cached != null) return (QueryBodySyntax)cached;

      var result = new QueryBodySyntax(SyntaxKind.QueryBody, clauses.Node, selectOrGroup, continuation, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public FromClauseSyntax FromClause(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (fromKeyword == null)
        throw new ArgumentNullException(nameof(fromKeyword));
      switch (fromKeyword.Kind)
      {
        case SyntaxKind.FromKeyword:
          break;
        default:
          throw new ArgumentException("fromKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (inKeyword == null)
        throw new ArgumentNullException(nameof(inKeyword));
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException("inKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      return new FromClauseSyntax(SyntaxKind.FromClause, fromKeyword, type, identifier, inKeyword, expression, this.context);
    }

    public LetClauseSyntax LetClause(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
    {
#if DEBUG
      if (letKeyword == null)
        throw new ArgumentNullException(nameof(letKeyword));
      switch (letKeyword.Kind)
      {
        case SyntaxKind.LetKeyword:
          break;
        default:
          throw new ArgumentException("letKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      return new LetClauseSyntax(SyntaxKind.LetClause, letKeyword, identifier, equalsToken, expression, this.context);
    }

    public JoinClauseSyntax JoinClause(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
    {
#if DEBUG
      if (joinKeyword == null)
        throw new ArgumentNullException(nameof(joinKeyword));
      switch (joinKeyword.Kind)
      {
        case SyntaxKind.JoinKeyword:
          break;
        default:
          throw new ArgumentException("joinKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (inKeyword == null)
        throw new ArgumentNullException(nameof(inKeyword));
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException("inKeyword");
      }
      if (inExpression == null)
        throw new ArgumentNullException(nameof(inExpression));
      if (onKeyword == null)
        throw new ArgumentNullException(nameof(onKeyword));
      switch (onKeyword.Kind)
      {
        case SyntaxKind.OnKeyword:
          break;
        default:
          throw new ArgumentException("onKeyword");
      }
      if (leftExpression == null)
        throw new ArgumentNullException(nameof(leftExpression));
      if (equalsKeyword == null)
        throw new ArgumentNullException(nameof(equalsKeyword));
      switch (equalsKeyword.Kind)
      {
        case SyntaxKind.EqualsKeyword:
          break;
        default:
          throw new ArgumentException("equalsKeyword");
      }
      if (rightExpression == null)
        throw new ArgumentNullException(nameof(rightExpression));
#endif

      return new JoinClauseSyntax(SyntaxKind.JoinClause, joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into, this.context);
    }

    public JoinIntoClauseSyntax JoinIntoClause(SyntaxToken intoKeyword, SyntaxToken identifier)
    {
#if DEBUG
      if (intoKeyword == null)
        throw new ArgumentNullException(nameof(intoKeyword));
      switch (intoKeyword.Kind)
      {
        case SyntaxKind.IntoKeyword:
          break;
        default:
          throw new ArgumentException("intoKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.JoinIntoClause, intoKeyword, identifier, this.context, out hash);
      if (cached != null) return (JoinIntoClauseSyntax)cached;

      var result = new JoinIntoClauseSyntax(SyntaxKind.JoinIntoClause, intoKeyword, identifier, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public WhereClauseSyntax WhereClause(SyntaxToken whereKeyword, ExpressionSyntax condition)
    {
#if DEBUG
      if (whereKeyword == null)
        throw new ArgumentNullException(nameof(whereKeyword));
      switch (whereKeyword.Kind)
      {
        case SyntaxKind.WhereKeyword:
          break;
        default:
          throw new ArgumentException("whereKeyword");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.WhereClause, whereKeyword, condition, this.context, out hash);
      if (cached != null) return (WhereClauseSyntax)cached;

      var result = new WhereClauseSyntax(SyntaxKind.WhereClause, whereKeyword, condition, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public OrderByClauseSyntax OrderByClause(SyntaxToken orderByKeyword, SeparatedSyntaxList<OrderingSyntax> orderings)
    {
#if DEBUG
      if (orderByKeyword == null)
        throw new ArgumentNullException(nameof(orderByKeyword));
      switch (orderByKeyword.Kind)
      {
        case SyntaxKind.OrderByKeyword:
          break;
        default:
          throw new ArgumentException("orderByKeyword");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OrderByClause, orderByKeyword, orderings.Node, this.context, out hash);
      if (cached != null) return (OrderByClauseSyntax)cached;

      var result = new OrderByClauseSyntax(SyntaxKind.OrderByClause, orderByKeyword, orderings.Node, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
    {
      switch (kind)
      {
        case SyntaxKind.AscendingOrdering:
        case SyntaxKind.DescendingOrdering:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (ascendingOrDescendingKeyword != null)
      {
      switch (ascendingOrDescendingKeyword.Kind)
      {
        case SyntaxKind.AscendingKeyword:
        case SyntaxKind.DescendingKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("ascendingOrDescendingKeyword");
      }
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, expression, ascendingOrDescendingKeyword, this.context, out hash);
      if (cached != null) return (OrderingSyntax)cached;

      var result = new OrderingSyntax(kind, expression, ascendingOrDescendingKeyword, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public SelectClauseSyntax SelectClause(SyntaxToken selectKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (selectKeyword == null)
        throw new ArgumentNullException(nameof(selectKeyword));
      switch (selectKeyword.Kind)
      {
        case SyntaxKind.SelectKeyword:
          break;
        default:
          throw new ArgumentException("selectKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SelectClause, selectKeyword, expression, this.context, out hash);
      if (cached != null) return (SelectClauseSyntax)cached;

      var result = new SelectClauseSyntax(SyntaxKind.SelectClause, selectKeyword, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public GroupClauseSyntax GroupClause(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
    {
#if DEBUG
      if (groupKeyword == null)
        throw new ArgumentNullException(nameof(groupKeyword));
      switch (groupKeyword.Kind)
      {
        case SyntaxKind.GroupKeyword:
          break;
        default:
          throw new ArgumentException("groupKeyword");
      }
      if (groupExpression == null)
        throw new ArgumentNullException(nameof(groupExpression));
      if (byKeyword == null)
        throw new ArgumentNullException(nameof(byKeyword));
      switch (byKeyword.Kind)
      {
        case SyntaxKind.ByKeyword:
          break;
        default:
          throw new ArgumentException("byKeyword");
      }
      if (byExpression == null)
        throw new ArgumentNullException(nameof(byExpression));
#endif

      return new GroupClauseSyntax(SyntaxKind.GroupClause, groupKeyword, groupExpression, byKeyword, byExpression, this.context);
    }

    public QueryContinuationSyntax QueryContinuation(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
    {
#if DEBUG
      if (intoKeyword == null)
        throw new ArgumentNullException(nameof(intoKeyword));
      switch (intoKeyword.Kind)
      {
        case SyntaxKind.IntoKeyword:
          break;
        default:
          throw new ArgumentException("intoKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryContinuation, intoKeyword, identifier, body, this.context, out hash);
      if (cached != null) return (QueryContinuationSyntax)cached;

      var result = new QueryContinuationSyntax(SyntaxKind.QueryContinuation, intoKeyword, identifier, body, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public OmittedArraySizeExpressionSyntax OmittedArraySizeExpression(SyntaxToken omittedArraySizeExpressionToken)
    {
#if DEBUG
      if (omittedArraySizeExpressionToken == null)
        throw new ArgumentNullException(nameof(omittedArraySizeExpressionToken));
      switch (omittedArraySizeExpressionToken.Kind)
      {
        case SyntaxKind.OmittedArraySizeExpressionToken:
          break;
        default:
          throw new ArgumentException("omittedArraySizeExpressionToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OmittedArraySizeExpression, omittedArraySizeExpressionToken, this.context, out hash);
      if (cached != null) return (OmittedArraySizeExpressionSyntax)cached;

      var result = new OmittedArraySizeExpressionSyntax(SyntaxKind.OmittedArraySizeExpression, omittedArraySizeExpressionToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
    {
#if DEBUG
      if (stringStartToken == null)
        throw new ArgumentNullException(nameof(stringStartToken));
      switch (stringStartToken.Kind)
      {
        case SyntaxKind.InterpolatedStringStartToken:
        case SyntaxKind.InterpolatedVerbatimStringStartToken:
          break;
        default:
          throw new ArgumentException("stringStartToken");
      }
      if (stringEndToken == null)
        throw new ArgumentNullException(nameof(stringEndToken));
      switch (stringEndToken.Kind)
      {
        case SyntaxKind.InterpolatedStringEndToken:
          break;
        default:
          throw new ArgumentException("stringEndToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken, this.context, out hash);
      if (cached != null) return (InterpolatedStringExpressionSyntax)cached;

      var result = new InterpolatedStringExpressionSyntax(SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public IsPatternExpressionSyntax IsPatternExpression(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (isKeyword == null)
        throw new ArgumentNullException(nameof(isKeyword));
      switch (isKeyword.Kind)
      {
        case SyntaxKind.IsKeyword:
          break;
        default:
          throw new ArgumentException("isKeyword");
      }
      if (pattern == null)
        throw new ArgumentNullException(nameof(pattern));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IsPatternExpression, expression, isKeyword, pattern, this.context, out hash);
      if (cached != null) return (IsPatternExpressionSyntax)cached;

      var result = new IsPatternExpressionSyntax(SyntaxKind.IsPatternExpression, expression, isKeyword, pattern, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public WhenClauseSyntax WhenClause(SyntaxToken whenKeyword, ExpressionSyntax condition)
    {
#if DEBUG
      if (whenKeyword != null)
      {
      switch (whenKeyword.Kind)
      {
        case SyntaxKind.WhenKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("whenKeyword");
      }
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.WhenClause, whenKeyword, condition, this.context, out hash);
      if (cached != null) return (WhenClauseSyntax)cached;

      var result = new WhenClauseSyntax(SyntaxKind.WhenClause, whenKeyword, condition, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public DeclarationPatternSyntax DeclarationPattern(TypeSyntax type, SyntaxToken identifier)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DeclarationPattern, type, identifier, this.context, out hash);
      if (cached != null) return (DeclarationPatternSyntax)cached;

      var result = new DeclarationPatternSyntax(SyntaxKind.DeclarationPattern, type, identifier, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ConstantPatternSyntax ConstantPattern(ExpressionSyntax expression)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ConstantPattern, expression, this.context, out hash);
      if (cached != null) return (ConstantPatternSyntax)cached;

      var result = new ConstantPatternSyntax(SyntaxKind.ConstantPattern, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken)
    {
#if DEBUG
      if (textToken == null)
        throw new ArgumentNullException(nameof(textToken));
      switch (textToken.Kind)
      {
        case SyntaxKind.InterpolatedStringTextToken:
          break;
        default:
          throw new ArgumentException("textToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolatedStringText, textToken, this.context, out hash);
      if (cached != null) return (InterpolatedStringTextSyntax)cached;

      var result = new InterpolatedStringTextSyntax(SyntaxKind.InterpolatedStringText, textToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public InterpolationSyntax Interpolation(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      return new InterpolationSyntax(SyntaxKind.Interpolation, openBraceToken, expression, alignmentClause, formatClause, closeBraceToken, this.context);
    }

    public InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(SyntaxToken commaToken, ExpressionSyntax value)
    {
#if DEBUG
      if (commaToken == null)
        throw new ArgumentNullException(nameof(commaToken));
      if (value == null)
        throw new ArgumentNullException(nameof(value));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolationAlignmentClause, commaToken, value, this.context, out hash);
      if (cached != null) return (InterpolationAlignmentClauseSyntax)cached;

      var result = new InterpolationAlignmentClauseSyntax(SyntaxKind.InterpolationAlignmentClause, commaToken, value, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken, SyntaxToken formatStringToken)
    {
#if DEBUG
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      if (formatStringToken == null)
        throw new ArgumentNullException(nameof(formatStringToken));
      switch (formatStringToken.Kind)
      {
        case SyntaxKind.InterpolatedStringTextToken:
          break;
        default:
          throw new ArgumentException("formatStringToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken, this.context, out hash);
      if (cached != null) return (InterpolationFormatClauseSyntax)cached;

      var result = new InterpolationFormatClauseSyntax(SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public GlobalStatementSyntax GlobalStatement(StatementSyntax statement)
    {
#if DEBUG
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.GlobalStatement, statement, this.context, out hash);
      if (cached != null) return (GlobalStatementSyntax)cached;

      var result = new GlobalStatementSyntax(SyntaxKind.GlobalStatement, statement, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public BlockSyntax Block(SyntaxToken openBraceToken, SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Block, openBraceToken, statements.Node, closeBraceToken, this.context, out hash);
      if (cached != null) return (BlockSyntax)cached;

      var result = new BlockSyntax(SyntaxKind.Block, openBraceToken, statements.Node, closeBraceToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxList<SyntaxToken> modifiers, SyntaxToken refKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new LocalFunctionStatementSyntax(SyntaxKind.LocalFunctionStatement, modifiers.Node, refKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses.Node, body, expressionBody, semicolonToken, this.context);
    }

    public LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxList<SyntaxToken> modifiers, SyntaxToken refKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new LocalDeclarationStatementSyntax(SyntaxKind.LocalDeclarationStatement, modifiers.Node, refKeyword, declaration, semicolonToken, this.context);
    }

    public VariableDeconstructionDeclaratorSyntax VariableDeconstructionDeclarator(SyntaxToken openParenToken, SeparatedSyntaxList<VariableDeclarationSyntax> variables, SyntaxToken closeParenToken, SyntaxToken equalsToken, ExpressionSyntax value)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (equalsToken != null)
      {
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      }
#endif

      return new VariableDeconstructionDeclaratorSyntax(SyntaxKind.VariableDeconstructionDeclarator, openParenToken, variables.Node, closeParenToken, equalsToken, value, this.context);
    }

    public VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SeparatedSyntaxList<VariableDeclaratorSyntax> variables, VariableDeconstructionDeclaratorSyntax deconstruction)
    {
#if DEBUG
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.VariableDeclaration, type, variables.Node, deconstruction, this.context, out hash);
      if (cached != null) return (VariableDeclarationSyntax)cached;

      var result = new VariableDeclarationSyntax(SyntaxKind.VariableDeclaration, type, variables.Node, deconstruction, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.VariableDeclarator, identifier, argumentList, initializer, this.context, out hash);
      if (cached != null) return (VariableDeclaratorSyntax)cached;

      var result = new VariableDeclaratorSyntax(SyntaxKind.VariableDeclarator, identifier, argumentList, initializer, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public EqualsValueClauseSyntax EqualsValueClause(SyntaxToken equalsToken, SyntaxToken refKeyword, ExpressionSyntax value)
    {
#if DEBUG
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (value == null)
        throw new ArgumentNullException(nameof(value));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.EqualsValueClause, equalsToken, refKeyword, value, this.context, out hash);
      if (cached != null) return (EqualsValueClauseSyntax)cached;

      var result = new EqualsValueClauseSyntax(SyntaxKind.EqualsValueClause, equalsToken, refKeyword, value, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ExpressionStatement, expression, semicolonToken, this.context, out hash);
      if (cached != null) return (ExpressionStatementSyntax)cached;

      var result = new ExpressionStatementSyntax(SyntaxKind.ExpressionStatement, expression, semicolonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public EmptyStatementSyntax EmptyStatement(SyntaxToken semicolonToken)
    {
#if DEBUG
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.EmptyStatement, semicolonToken, this.context, out hash);
      if (cached != null) return (EmptyStatementSyntax)cached;

      var result = new EmptyStatementSyntax(SyntaxKind.EmptyStatement, semicolonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.LabeledStatement, identifier, colonToken, statement, this.context, out hash);
      if (cached != null) return (LabeledStatementSyntax)cached;

      var result = new LabeledStatementSyntax(SyntaxKind.LabeledStatement, identifier, colonToken, statement, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.GotoStatement:
        case SyntaxKind.GotoCaseStatement:
        case SyntaxKind.GotoDefaultStatement:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (gotoKeyword == null)
        throw new ArgumentNullException(nameof(gotoKeyword));
      switch (gotoKeyword.Kind)
      {
        case SyntaxKind.GotoKeyword:
          break;
        default:
          throw new ArgumentException("gotoKeyword");
      }
      if (caseOrDefaultKeyword != null)
      {
      switch (caseOrDefaultKeyword.Kind)
      {
        case SyntaxKind.CaseKeyword:
        case SyntaxKind.DefaultKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("caseOrDefaultKeyword");
      }
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new GotoStatementSyntax(kind, gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken, this.context);
    }

    public BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (breakKeyword == null)
        throw new ArgumentNullException(nameof(breakKeyword));
      switch (breakKeyword.Kind)
      {
        case SyntaxKind.BreakKeyword:
          break;
        default:
          throw new ArgumentException("breakKeyword");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BreakStatement, breakKeyword, semicolonToken, this.context, out hash);
      if (cached != null) return (BreakStatementSyntax)cached;

      var result = new BreakStatementSyntax(SyntaxKind.BreakStatement, breakKeyword, semicolonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ContinueStatementSyntax ContinueStatement(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (continueKeyword == null)
        throw new ArgumentNullException(nameof(continueKeyword));
      switch (continueKeyword.Kind)
      {
        case SyntaxKind.ContinueKeyword:
          break;
        default:
          throw new ArgumentException("continueKeyword");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ContinueStatement, continueKeyword, semicolonToken, this.context, out hash);
      if (cached != null) return (ContinueStatementSyntax)cached;

      var result = new ContinueStatementSyntax(SyntaxKind.ContinueStatement, continueKeyword, semicolonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, SyntaxToken refKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (returnKeyword == null)
        throw new ArgumentNullException(nameof(returnKeyword));
      switch (returnKeyword.Kind)
      {
        case SyntaxKind.ReturnKeyword:
          break;
        default:
          throw new ArgumentException("returnKeyword");
      }
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new ReturnStatementSyntax(SyntaxKind.ReturnStatement, returnKeyword, refKeyword, expression, semicolonToken, this.context);
    }

    public ThrowStatementSyntax ThrowStatement(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (throwKeyword == null)
        throw new ArgumentNullException(nameof(throwKeyword));
      switch (throwKeyword.Kind)
      {
        case SyntaxKind.ThrowKeyword:
          break;
        default:
          throw new ArgumentException("throwKeyword");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ThrowStatement, throwKeyword, expression, semicolonToken, this.context, out hash);
      if (cached != null) return (ThrowStatementSyntax)cached;

      var result = new ThrowStatementSyntax(SyntaxKind.ThrowStatement, throwKeyword, expression, semicolonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public YieldStatementSyntax YieldStatement(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.YieldReturnStatement:
        case SyntaxKind.YieldBreakStatement:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (yieldKeyword == null)
        throw new ArgumentNullException(nameof(yieldKeyword));
      switch (yieldKeyword.Kind)
      {
        case SyntaxKind.YieldKeyword:
          break;
        default:
          throw new ArgumentException("yieldKeyword");
      }
      if (returnOrBreakKeyword == null)
        throw new ArgumentNullException(nameof(returnOrBreakKeyword));
      switch (returnOrBreakKeyword.Kind)
      {
        case SyntaxKind.ReturnKeyword:
        case SyntaxKind.BreakKeyword:
          break;
        default:
          throw new ArgumentException("returnOrBreakKeyword");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new YieldStatementSyntax(kind, yieldKeyword, returnOrBreakKeyword, expression, semicolonToken, this.context);
    }

    public WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (whileKeyword == null)
        throw new ArgumentNullException(nameof(whileKeyword));
      switch (whileKeyword.Kind)
      {
        case SyntaxKind.WhileKeyword:
          break;
        default:
          throw new ArgumentException("whileKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new WhileStatementSyntax(SyntaxKind.WhileStatement, whileKeyword, openParenToken, condition, closeParenToken, statement, this.context);
    }

    public DoStatementSyntax DoStatement(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (doKeyword == null)
        throw new ArgumentNullException(nameof(doKeyword));
      switch (doKeyword.Kind)
      {
        case SyntaxKind.DoKeyword:
          break;
        default:
          throw new ArgumentException("doKeyword");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      if (whileKeyword == null)
        throw new ArgumentNullException(nameof(whileKeyword));
      switch (whileKeyword.Kind)
      {
        case SyntaxKind.WhileKeyword:
          break;
        default:
          throw new ArgumentException("whileKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new DoStatementSyntax(SyntaxKind.DoStatement, doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, this.context);
    }

    public ForStatementSyntax ForStatement(SyntaxToken forKeyword, SyntaxToken openParenToken, SyntaxToken refKeyword, VariableDeclarationSyntax declaration, SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (forKeyword == null)
        throw new ArgumentNullException(nameof(forKeyword));
      switch (forKeyword.Kind)
      {
        case SyntaxKind.ForKeyword:
          break;
        default:
          throw new ArgumentException("forKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (firstSemicolonToken == null)
        throw new ArgumentNullException(nameof(firstSemicolonToken));
      switch (firstSemicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("firstSemicolonToken");
      }
      if (secondSemicolonToken == null)
        throw new ArgumentNullException(nameof(secondSemicolonToken));
      switch (secondSemicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("secondSemicolonToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new ForStatementSyntax(SyntaxKind.ForStatement, forKeyword, openParenToken, refKeyword, declaration, initializers.Node, firstSemicolonToken, condition, secondSemicolonToken, incrementors.Node, closeParenToken, statement, this.context);
    }

    public ForEachStatementSyntax ForEachStatement(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, VariableDeclarationSyntax deconstructionVariables, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (forEachKeyword == null)
        throw new ArgumentNullException(nameof(forEachKeyword));
      switch (forEachKeyword.Kind)
      {
        case SyntaxKind.ForEachKeyword:
          break;
        default:
          throw new ArgumentException("forEachKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (identifier != null)
      {
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      }
      if (inKeyword == null)
        throw new ArgumentNullException(nameof(inKeyword));
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException("inKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new ForEachStatementSyntax(SyntaxKind.ForEachStatement, forEachKeyword, openParenToken, type, identifier, deconstructionVariables, inKeyword, expression, closeParenToken, statement, this.context);
    }

    public UsingStatementSyntax UsingStatement(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (usingKeyword == null)
        throw new ArgumentNullException(nameof(usingKeyword));
      switch (usingKeyword.Kind)
      {
        case SyntaxKind.UsingKeyword:
          break;
        default:
          throw new ArgumentException("usingKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new UsingStatementSyntax(SyntaxKind.UsingStatement, usingKeyword, openParenToken, declaration, expression, closeParenToken, statement, this.context);
    }

    public FixedStatementSyntax FixedStatement(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (fixedKeyword == null)
        throw new ArgumentNullException(nameof(fixedKeyword));
      switch (fixedKeyword.Kind)
      {
        case SyntaxKind.FixedKeyword:
          break;
        default:
          throw new ArgumentException("fixedKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new FixedStatementSyntax(SyntaxKind.FixedStatement, fixedKeyword, openParenToken, declaration, closeParenToken, statement, this.context);
    }

    public CheckedStatementSyntax CheckedStatement(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedStatement:
        case SyntaxKind.UncheckedStatement:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CheckedKeyword:
        case SyntaxKind.UncheckedKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, keyword, block, this.context, out hash);
      if (cached != null) return (CheckedStatementSyntax)cached;

      var result = new CheckedStatementSyntax(kind, keyword, block, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public UnsafeStatementSyntax UnsafeStatement(SyntaxToken unsafeKeyword, BlockSyntax block)
    {
#if DEBUG
      if (unsafeKeyword == null)
        throw new ArgumentNullException(nameof(unsafeKeyword));
      switch (unsafeKeyword.Kind)
      {
        case SyntaxKind.UnsafeKeyword:
          break;
        default:
          throw new ArgumentException("unsafeKeyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.UnsafeStatement, unsafeKeyword, block, this.context, out hash);
      if (cached != null) return (UnsafeStatementSyntax)cached;

      var result = new UnsafeStatementSyntax(SyntaxKind.UnsafeStatement, unsafeKeyword, block, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public LockStatementSyntax LockStatement(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (lockKeyword == null)
        throw new ArgumentNullException(nameof(lockKeyword));
      switch (lockKeyword.Kind)
      {
        case SyntaxKind.LockKeyword:
          break;
        default:
          throw new ArgumentException("lockKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new LockStatementSyntax(SyntaxKind.LockStatement, lockKeyword, openParenToken, expression, closeParenToken, statement, this.context);
    }

    public IfStatementSyntax IfStatement(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)
    {
#if DEBUG
      if (ifKeyword == null)
        throw new ArgumentNullException(nameof(ifKeyword));
      switch (ifKeyword.Kind)
      {
        case SyntaxKind.IfKeyword:
          break;
        default:
          throw new ArgumentException("ifKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new IfStatementSyntax(SyntaxKind.IfStatement, ifKeyword, openParenToken, condition, closeParenToken, statement, @else, this.context);
    }

    public ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StatementSyntax statement)
    {
#if DEBUG
      if (elseKeyword == null)
        throw new ArgumentNullException(nameof(elseKeyword));
      switch (elseKeyword.Kind)
      {
        case SyntaxKind.ElseKeyword:
          break;
        default:
          throw new ArgumentException("elseKeyword");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ElseClause, elseKeyword, statement, this.context, out hash);
      if (cached != null) return (ElseClauseSyntax)cached;

      var result = new ElseClauseSyntax(SyntaxKind.ElseClause, elseKeyword, statement, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public SwitchStatementSyntax SwitchStatement(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (switchKeyword == null)
        throw new ArgumentNullException(nameof(switchKeyword));
      switch (switchKeyword.Kind)
      {
        case SyntaxKind.SwitchKeyword:
          break;
        default:
          throw new ArgumentException("switchKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      return new SwitchStatementSyntax(SyntaxKind.SwitchStatement, switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections.Node, closeBraceToken, this.context);
    }

    public SwitchSectionSyntax SwitchSection(SyntaxList<SwitchLabelSyntax> labels, SyntaxList<StatementSyntax> statements)
    {
#if DEBUG
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SwitchSection, labels.Node, statements.Node, this.context, out hash);
      if (cached != null) return (SwitchSectionSyntax)cached;

      var result = new SwitchSectionSyntax(SyntaxKind.SwitchSection, labels.Node, statements.Node, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public CasePatternSwitchLabelSyntax CasePatternSwitchLabel(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CaseKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (pattern == null)
        throw new ArgumentNullException(nameof(pattern));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
#endif

      return new CasePatternSwitchLabelSyntax(SyntaxKind.CasePatternSwitchLabel, keyword, pattern, whenClause, colonToken, this.context);
    }

    public CaseSwitchLabelSyntax CaseSwitchLabel(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CaseKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (value == null)
        throw new ArgumentNullException(nameof(value));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CaseSwitchLabel, keyword, value, colonToken, this.context, out hash);
      if (cached != null) return (CaseSwitchLabelSyntax)cached;

      var result = new CaseSwitchLabelSyntax(SyntaxKind.CaseSwitchLabel, keyword, value, colonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken keyword, SyntaxToken colonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DefaultSwitchLabel, keyword, colonToken, this.context, out hash);
      if (cached != null) return (DefaultSwitchLabelSyntax)cached;

      var result = new DefaultSwitchLabelSyntax(SyntaxKind.DefaultSwitchLabel, keyword, colonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TryStatementSyntax TryStatement(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
    {
#if DEBUG
      if (tryKeyword == null)
        throw new ArgumentNullException(nameof(tryKeyword));
      switch (tryKeyword.Kind)
      {
        case SyntaxKind.TryKeyword:
          break;
        default:
          throw new ArgumentException("tryKeyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      return new TryStatementSyntax(SyntaxKind.TryStatement, tryKeyword, block, catches.Node, @finally, this.context);
    }

    public CatchClauseSyntax CatchClause(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)
    {
#if DEBUG
      if (catchKeyword == null)
        throw new ArgumentNullException(nameof(catchKeyword));
      switch (catchKeyword.Kind)
      {
        case SyntaxKind.CatchKeyword:
          break;
        default:
          throw new ArgumentException("catchKeyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      return new CatchClauseSyntax(SyntaxKind.CatchClause, catchKeyword, declaration, filter, block, this.context);
    }

    public CatchDeclarationSyntax CatchDeclaration(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier != null)
      {
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new CatchDeclarationSyntax(SyntaxKind.CatchDeclaration, openParenToken, type, identifier, closeParenToken, this.context);
    }

    public CatchFilterClauseSyntax CatchFilterClause(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (whenKeyword == null)
        throw new ArgumentNullException(nameof(whenKeyword));
      switch (whenKeyword.Kind)
      {
        case SyntaxKind.WhenKeyword:
          break;
        default:
          throw new ArgumentException("whenKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (filterExpression == null)
        throw new ArgumentNullException(nameof(filterExpression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new CatchFilterClauseSyntax(SyntaxKind.CatchFilterClause, whenKeyword, openParenToken, filterExpression, closeParenToken, this.context);
    }

    public FinallyClauseSyntax FinallyClause(SyntaxToken finallyKeyword, BlockSyntax block)
    {
#if DEBUG
      if (finallyKeyword == null)
        throw new ArgumentNullException(nameof(finallyKeyword));
      switch (finallyKeyword.Kind)
      {
        case SyntaxKind.FinallyKeyword:
          break;
        default:
          throw new ArgumentException("finallyKeyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.FinallyClause, finallyKeyword, block, this.context, out hash);
      if (cached != null) return (FinallyClauseSyntax)cached;

      var result = new FinallyClauseSyntax(SyntaxKind.FinallyClause, finallyKeyword, block, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public CompilationUnitSyntax CompilationUnit(SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)
    {
#if DEBUG
      if (endOfFileToken == null)
        throw new ArgumentNullException(nameof(endOfFileToken));
      switch (endOfFileToken.Kind)
      {
        case SyntaxKind.EndOfFileToken:
          break;
        default:
          throw new ArgumentException("endOfFileToken");
      }
#endif

      return new CompilationUnitSyntax(SyntaxKind.CompilationUnit, externs.Node, usings.Node, attributeLists.Node, members.Node, endOfFileToken, this.context);
    }

    public ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (externKeyword == null)
        throw new ArgumentNullException(nameof(externKeyword));
      switch (externKeyword.Kind)
      {
        case SyntaxKind.ExternKeyword:
          break;
        default:
          throw new ArgumentException("externKeyword");
      }
      if (aliasKeyword == null)
        throw new ArgumentNullException(nameof(aliasKeyword));
      switch (aliasKeyword.Kind)
      {
        case SyntaxKind.AliasKeyword:
          break;
        default:
          throw new ArgumentException("aliasKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new ExternAliasDirectiveSyntax(SyntaxKind.ExternAliasDirective, externKeyword, aliasKeyword, identifier, semicolonToken, this.context);
    }

    public UsingDirectiveSyntax UsingDirective(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (usingKeyword == null)
        throw new ArgumentNullException(nameof(usingKeyword));
      switch (usingKeyword.Kind)
      {
        case SyntaxKind.UsingKeyword:
          break;
        default:
          throw new ArgumentException("usingKeyword");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new UsingDirectiveSyntax(SyntaxKind.UsingDirective, usingKeyword, staticKeyword, alias, name, semicolonToken, this.context);
    }

    public NamespaceDeclarationSyntax NamespaceDeclaration(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (namespaceKeyword == null)
        throw new ArgumentNullException(nameof(namespaceKeyword));
      switch (namespaceKeyword.Kind)
      {
        case SyntaxKind.NamespaceKeyword:
          break;
        default:
          throw new ArgumentException("namespaceKeyword");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new NamespaceDeclarationSyntax(SyntaxKind.NamespaceDeclaration, namespaceKeyword, name, openBraceToken, externs.Node, usings.Node, members.Node, closeBraceToken, semicolonToken, this.context);
    }

    public AttributeListSyntax AttributeList(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      return new AttributeListSyntax(SyntaxKind.AttributeList, openBracketToken, target, attributes.Node, closeBracketToken, this.context);
    }

    public AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier, SyntaxToken colonToken)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeTargetSpecifier, identifier, colonToken, this.context, out hash);
      if (cached != null) return (AttributeTargetSpecifierSyntax)cached;

      var result = new AttributeTargetSpecifierSyntax(SyntaxKind.AttributeTargetSpecifier, identifier, colonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AttributeSyntax Attribute(NameSyntax name, AttributeArgumentListSyntax argumentList)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Attribute, name, argumentList, this.context, out hash);
      if (cached != null) return (AttributeSyntax)cached;

      var result = new AttributeSyntax(SyntaxKind.Attribute, name, argumentList, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AttributeArgumentListSyntax AttributeArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeArgumentList, openParenToken, arguments.Node, closeParenToken, this.context, out hash);
      if (cached != null) return (AttributeArgumentListSyntax)cached;

      var result = new AttributeArgumentListSyntax(SyntaxKind.AttributeArgumentList, openParenToken, arguments.Node, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeArgument, nameEquals, nameColon, expression, this.context, out hash);
      if (cached != null) return (AttributeArgumentSyntax)cached;

      var result = new AttributeArgumentSyntax(SyntaxKind.AttributeArgument, nameEquals, nameColon, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public NameEqualsSyntax NameEquals(IdentifierNameSyntax name, SyntaxToken equalsToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NameEquals, name, equalsToken, this.context, out hash);
      if (cached != null) return (NameEqualsSyntax)cached;

      var result = new NameEqualsSyntax(SyntaxKind.NameEquals, name, equalsToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeParameterList, lessThanToken, parameters.Node, greaterThanToken, this.context, out hash);
      if (cached != null) return (TypeParameterListSyntax)cached;

      var result = new TypeParameterListSyntax(SyntaxKind.TypeParameterList, lessThanToken, parameters.Node, greaterThanToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TypeParameterSyntax TypeParameter(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)
    {
#if DEBUG
      if (varianceKeyword != null)
      {
      switch (varianceKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("varianceKeyword");
      }
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeParameter, attributeLists.Node, varianceKeyword, identifier, this.context, out hash);
      if (cached != null) return (TypeParameterSyntax)cached;

      var result = new TypeParameterSyntax(SyntaxKind.TypeParameter, attributeLists.Node, varianceKeyword, identifier, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ClassDeclarationSyntax ClassDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.ClassKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new ClassDeclarationSyntax(SyntaxKind.ClassDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken, this.context);
    }

    public StructDeclarationSyntax StructDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.StructKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new StructDeclarationSyntax(SyntaxKind.StructDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken, this.context);
    }

    public InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.InterfaceKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new InterfaceDeclarationSyntax(SyntaxKind.InterfaceDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken, this.context);
    }

    public EnumDeclarationSyntax EnumDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (enumKeyword == null)
        throw new ArgumentNullException(nameof(enumKeyword));
      switch (enumKeyword.Kind)
      {
        case SyntaxKind.EnumKeyword:
          break;
        default:
          throw new ArgumentException("enumKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new EnumDeclarationSyntax(SyntaxKind.EnumDeclaration, attributeLists.Node, modifiers.Node, enumKeyword, identifier, baseList, openBraceToken, members.Node, closeBraceToken, semicolonToken, this.context);
    }

    public DelegateDeclarationSyntax DelegateDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken delegateKeyword, SyntaxToken refKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (delegateKeyword == null)
        throw new ArgumentNullException(nameof(delegateKeyword));
      switch (delegateKeyword.Kind)
      {
        case SyntaxKind.DelegateKeyword:
          break;
        default:
          throw new ArgumentException("delegateKeyword");
      }
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new DelegateDeclarationSyntax(SyntaxKind.DelegateDeclaration, attributeLists.Node, modifiers.Node, delegateKeyword, refKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses.Node, semicolonToken, this.context);
    }

    public EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.EnumMemberDeclaration, attributeLists.Node, identifier, equalsValue, this.context, out hash);
      if (cached != null) return (EnumMemberDeclarationSyntax)cached;

      var result = new EnumMemberDeclarationSyntax(SyntaxKind.EnumMemberDeclaration, attributeLists.Node, identifier, equalsValue, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public BaseListSyntax BaseList(SyntaxToken colonToken, SeparatedSyntaxList<BaseTypeSyntax> types)
    {
#if DEBUG
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BaseList, colonToken, types.Node, this.context, out hash);
      if (cached != null) return (BaseListSyntax)cached;

      var result = new BaseListSyntax(SyntaxKind.BaseList, colonToken, types.Node, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public SimpleBaseTypeSyntax SimpleBaseType(TypeSyntax type)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SimpleBaseType, type, this.context, out hash);
      if (cached != null) return (SimpleBaseTypeSyntax)cached;

      var result = new SimpleBaseTypeSyntax(SyntaxKind.SimpleBaseType, type, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
    {
#if DEBUG
      if (whereKeyword == null)
        throw new ArgumentNullException(nameof(whereKeyword));
      switch (whereKeyword.Kind)
      {
        case SyntaxKind.WhereKeyword:
          break;
        default:
          throw new ArgumentException("whereKeyword");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      return new TypeParameterConstraintClauseSyntax(SyntaxKind.TypeParameterConstraintClause, whereKeyword, name, colonToken, constraints.Node, this.context);
    }

    public ConstructorConstraintSyntax ConstructorConstraint(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ConstructorConstraint, newKeyword, openParenToken, closeParenToken, this.context, out hash);
      if (cached != null) return (ConstructorConstraintSyntax)cached;

      var result = new ConstructorConstraintSyntax(SyntaxKind.ConstructorConstraint, newKeyword, openParenToken, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind, SyntaxToken classOrStructKeyword)
    {
      switch (kind)
      {
        case SyntaxKind.ClassConstraint:
        case SyntaxKind.StructConstraint:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (classOrStructKeyword == null)
        throw new ArgumentNullException(nameof(classOrStructKeyword));
      switch (classOrStructKeyword.Kind)
      {
        case SyntaxKind.ClassKeyword:
        case SyntaxKind.StructKeyword:
          break;
        default:
          throw new ArgumentException("classOrStructKeyword");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, classOrStructKeyword, this.context, out hash);
      if (cached != null) return (ClassOrStructConstraintSyntax)cached;

      var result = new ClassOrStructConstraintSyntax(kind, classOrStructKeyword, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TypeConstraintSyntax TypeConstraint(TypeSyntax type)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeConstraint, type, this.context, out hash);
      if (cached != null) return (TypeConstraintSyntax)cached;

      var result = new TypeConstraintSyntax(SyntaxKind.TypeConstraint, type, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public FieldDeclarationSyntax FieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new FieldDeclarationSyntax(SyntaxKind.FieldDeclaration, attributeLists.Node, modifiers.Node, declaration, semicolonToken, this.context);
    }

    public EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (eventKeyword == null)
        throw new ArgumentNullException(nameof(eventKeyword));
      switch (eventKeyword.Kind)
      {
        case SyntaxKind.EventKeyword:
          break;
        default:
          throw new ArgumentException("eventKeyword");
      }
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new EventFieldDeclarationSyntax(SyntaxKind.EventFieldDeclaration, attributeLists.Node, modifiers.Node, eventKeyword, declaration, semicolonToken, this.context);
    }

    public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name, SyntaxToken dotToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (dotToken == null)
        throw new ArgumentNullException(nameof(dotToken));
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("dotToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ExplicitInterfaceSpecifier, name, dotToken, this.context, out hash);
      if (cached != null) return (ExplicitInterfaceSpecifierSyntax)cached;

      var result = new ExplicitInterfaceSpecifierSyntax(SyntaxKind.ExplicitInterfaceSpecifier, name, dotToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public MethodDeclarationSyntax MethodDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken refKeyword, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new MethodDeclarationSyntax(SyntaxKind.MethodDeclaration, attributeLists.Node, modifiers.Node, refKeyword, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses.Node, body, expressionBody, semicolonToken, this.context);
    }

    public OperatorDeclarationSyntax OperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.TrueKeyword:
        case SyntaxKind.IsKeyword:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new OperatorDeclarationSyntax(SyntaxKind.OperatorDeclaration, attributeLists.Node, modifiers.Node, returnType, operatorKeyword, operatorToken, parameterList, body, expressionBody, semicolonToken, this.context);
    }

    public ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (implicitOrExplicitKeyword == null)
        throw new ArgumentNullException(nameof(implicitOrExplicitKeyword));
      switch (implicitOrExplicitKeyword.Kind)
      {
        case SyntaxKind.ImplicitKeyword:
        case SyntaxKind.ExplicitKeyword:
          break;
        default:
          throw new ArgumentException("implicitOrExplicitKeyword");
      }
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new ConversionOperatorDeclarationSyntax(SyntaxKind.ConversionOperatorDeclaration, attributeLists.Node, modifiers.Node, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, expressionBody, semicolonToken, this.context);
    }

    public ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new ConstructorDeclarationSyntax(SyntaxKind.ConstructorDeclaration, attributeLists.Node, modifiers.Node, identifier, parameterList, initializer, body, semicolonToken, this.context);
    }

    public ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
    {
      switch (kind)
      {
        case SyntaxKind.BaseConstructorInitializer:
        case SyntaxKind.ThisConstructorInitializer:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      if (thisOrBaseKeyword == null)
        throw new ArgumentNullException(nameof(thisOrBaseKeyword));
      switch (thisOrBaseKeyword.Kind)
      {
        case SyntaxKind.BaseKeyword:
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("thisOrBaseKeyword");
      }
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, colonToken, thisOrBaseKeyword, argumentList, this.context, out hash);
      if (cached != null) return (ConstructorInitializerSyntax)cached;

      var result = new ConstructorInitializerSyntax(kind, colonToken, thisOrBaseKeyword, argumentList, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (tildeToken == null)
        throw new ArgumentNullException(nameof(tildeToken));
      switch (tildeToken.Kind)
      {
        case SyntaxKind.TildeToken:
          break;
        default:
          throw new ArgumentException("tildeToken");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new DestructorDeclarationSyntax(SyntaxKind.DestructorDeclaration, attributeLists.Node, modifiers.Node, tildeToken, identifier, parameterList, body, semicolonToken, this.context);
    }

    public PropertyDeclarationSyntax PropertyDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken refKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new PropertyDeclarationSyntax(SyntaxKind.PropertyDeclaration, attributeLists.Node, modifiers.Node, refKeyword, type, explicitInterfaceSpecifier, identifier, accessorList, expressionBody, initializer, semicolonToken, this.context);
    }

    public ArrowExpressionClauseSyntax ArrowExpressionClause(SyntaxToken arrowToken, SyntaxToken refKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (arrowToken == null)
        throw new ArgumentNullException(nameof(arrowToken));
      switch (arrowToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException("arrowToken");
      }
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrowExpressionClause, arrowToken, refKeyword, expression, this.context, out hash);
      if (cached != null) return (ArrowExpressionClauseSyntax)cached;

      var result = new ArrowExpressionClauseSyntax(SyntaxKind.ArrowExpressionClause, arrowToken, refKeyword, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public EventDeclarationSyntax EventDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
    {
#if DEBUG
      if (eventKeyword == null)
        throw new ArgumentNullException(nameof(eventKeyword));
      switch (eventKeyword.Kind)
      {
        case SyntaxKind.EventKeyword:
          break;
        default:
          throw new ArgumentException("eventKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (accessorList == null)
        throw new ArgumentNullException(nameof(accessorList));
#endif

      return new EventDeclarationSyntax(SyntaxKind.EventDeclaration, attributeLists.Node, modifiers.Node, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList, this.context);
    }

    public IndexerDeclarationSyntax IndexerDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken refKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (thisKeyword == null)
        throw new ArgumentNullException(nameof(thisKeyword));
      switch (thisKeyword.Kind)
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("thisKeyword");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new IndexerDeclarationSyntax(SyntaxKind.IndexerDeclaration, attributeLists.Node, modifiers.Node, refKeyword, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList, expressionBody, semicolonToken, this.context);
    }

    public AccessorListSyntax AccessorList(SyntaxToken openBraceToken, SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AccessorList, openBraceToken, accessors.Node, closeBraceToken, this.context, out hash);
      if (cached != null) return (AccessorListSyntax)cached;

      var result = new AccessorListSyntax(SyntaxKind.AccessorList, openBraceToken, accessors.Node, closeBraceToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.GetAccessorDeclaration:
        case SyntaxKind.SetAccessorDeclaration:
        case SyntaxKind.AddAccessorDeclaration:
        case SyntaxKind.RemoveAccessorDeclaration:
        case SyntaxKind.UnknownAccessorDeclaration:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.GetKeyword:
        case SyntaxKind.SetKeyword:
        case SyntaxKind.AddKeyword:
        case SyntaxKind.RemoveKeyword:
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new AccessorDeclarationSyntax(kind, attributeLists.Node, modifiers.Node, keyword, body, semicolonToken, this.context);
    }

    public ParameterListSyntax ParameterList(SyntaxToken openParenToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken, this.context, out hash);
      if (cached != null) return (ParameterListSyntax)cached;

      var result = new ParameterListSyntax(SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public BracketedParameterListSyntax BracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, this.context, out hash);
      if (cached != null) return (BracketedParameterListSyntax)cached;

      var result = new BracketedParameterListSyntax(SyntaxKind.BracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ParameterSyntax Parameter(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.ArgListKeyword:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      return new ParameterSyntax(SyntaxKind.Parameter, attributeLists.Node, modifiers.Node, type, identifier, @default, this.context);
    }

    public IncompleteMemberSyntax IncompleteMember(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken refKeyword, TypeSyntax type)
    {
#if DEBUG
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
#endif

      return new IncompleteMemberSyntax(SyntaxKind.IncompleteMember, attributeLists.Node, modifiers.Node, refKeyword, type, this.context);
    }

    public SkippedTokensTriviaSyntax SkippedTokensTrivia(SyntaxList<SyntaxToken> tokens)
    {
#if DEBUG
#endif

      return new SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, tokens.Node, this.context);
    }

    public DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment)
    {
      switch (kind)
      {
        case SyntaxKind.SingleLineDocumentationCommentTrivia:
        case SyntaxKind.MultiLineDocumentationCommentTrivia:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (endOfComment == null)
        throw new ArgumentNullException(nameof(endOfComment));
      switch (endOfComment.Kind)
      {
        case SyntaxKind.EndOfDocumentationCommentToken:
          break;
        default:
          throw new ArgumentException("endOfComment");
      }
#endif

      return new DocumentationCommentTriviaSyntax(kind, content.Node, endOfComment, this.context);
    }

    public TypeCrefSyntax TypeCref(TypeSyntax type)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeCref, type, this.context, out hash);
      if (cached != null) return (TypeCrefSyntax)cached;

      var result = new TypeCrefSyntax(SyntaxKind.TypeCref, type, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public QualifiedCrefSyntax QualifiedCref(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)
    {
#if DEBUG
      if (container == null)
        throw new ArgumentNullException(nameof(container));
      if (dotToken == null)
        throw new ArgumentNullException(nameof(dotToken));
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("dotToken");
      }
      if (member == null)
        throw new ArgumentNullException(nameof(member));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QualifiedCref, container, dotToken, member, this.context, out hash);
      if (cached != null) return (QualifiedCrefSyntax)cached;

      var result = new QualifiedCrefSyntax(SyntaxKind.QualifiedCref, container, dotToken, member, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public NameMemberCrefSyntax NameMemberCref(TypeSyntax name, CrefParameterListSyntax parameters)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NameMemberCref, name, parameters, this.context, out hash);
      if (cached != null) return (NameMemberCrefSyntax)cached;

      var result = new NameMemberCrefSyntax(SyntaxKind.NameMemberCref, name, parameters, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public IndexerMemberCrefSyntax IndexerMemberCref(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)
    {
#if DEBUG
      if (thisKeyword == null)
        throw new ArgumentNullException(nameof(thisKeyword));
      switch (thisKeyword.Kind)
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("thisKeyword");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IndexerMemberCref, thisKeyword, parameters, this.context, out hash);
      if (cached != null) return (IndexerMemberCrefSyntax)cached;

      var result = new IndexerMemberCrefSyntax(SyntaxKind.IndexerMemberCref, thisKeyword, parameters, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)
    {
#if DEBUG
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.TrueKeyword:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OperatorMemberCref, operatorKeyword, operatorToken, parameters, this.context, out hash);
      if (cached != null) return (OperatorMemberCrefSyntax)cached;

      var result = new OperatorMemberCrefSyntax(SyntaxKind.OperatorMemberCref, operatorKeyword, operatorToken, parameters, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters)
    {
#if DEBUG
      if (implicitOrExplicitKeyword == null)
        throw new ArgumentNullException(nameof(implicitOrExplicitKeyword));
      switch (implicitOrExplicitKeyword.Kind)
      {
        case SyntaxKind.ImplicitKeyword:
        case SyntaxKind.ExplicitKeyword:
          break;
        default:
          throw new ArgumentException("implicitOrExplicitKeyword");
      }
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      return new ConversionOperatorMemberCrefSyntax(SyntaxKind.ConversionOperatorMemberCref, implicitOrExplicitKeyword, operatorKeyword, type, parameters, this.context);
    }

    public CrefParameterListSyntax CrefParameterList(SyntaxToken openParenToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefParameterList, openParenToken, parameters.Node, closeParenToken, this.context, out hash);
      if (cached != null) return (CrefParameterListSyntax)cached;

      var result = new CrefParameterListSyntax(SyntaxKind.CrefParameterList, openParenToken, parameters.Node, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public CrefBracketedParameterListSyntax CrefBracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefBracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, this.context, out hash);
      if (cached != null) return (CrefBracketedParameterListSyntax)cached;

      var result = new CrefBracketedParameterListSyntax(SyntaxKind.CrefBracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public CrefParameterSyntax CrefParameter(SyntaxToken refOrOutKeyword, TypeSyntax type)
    {
#if DEBUG
      if (refOrOutKeyword != null)
      {
      switch (refOrOutKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refOrOutKeyword");
      }
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefParameter, refOrOutKeyword, type, this.context, out hash);
      if (cached != null) return (CrefParameterSyntax)cached;

      var result = new CrefParameterSyntax(SyntaxKind.CrefParameter, refOrOutKeyword, type, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
    {
#if DEBUG
      if (startTag == null)
        throw new ArgumentNullException(nameof(startTag));
      if (endTag == null)
        throw new ArgumentNullException(nameof(endTag));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElement, startTag, content.Node, endTag, this.context, out hash);
      if (cached != null) return (XmlElementSyntax)cached;

      var result = new XmlElementSyntax(SyntaxKind.XmlElement, startTag, content.Node, endTag, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      return new XmlElementStartTagSyntax(SyntaxKind.XmlElementStartTag, lessThanToken, name, attributes.Node, greaterThanToken, this.context);
    }

    public XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanSlashToken == null)
        throw new ArgumentNullException(nameof(lessThanSlashToken));
      switch (lessThanSlashToken.Kind)
      {
        case SyntaxKind.LessThanSlashToken:
          break;
        default:
          throw new ArgumentException("lessThanSlashToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken, this.context, out hash);
      if (cached != null) return (XmlElementEndTagSyntax)cached;

      var result = new XmlElementEndTagSyntax(SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (slashGreaterThanToken == null)
        throw new ArgumentNullException(nameof(slashGreaterThanToken));
      switch (slashGreaterThanToken.Kind)
      {
        case SyntaxKind.SlashGreaterThanToken:
          break;
        default:
          throw new ArgumentException("slashGreaterThanToken");
      }
#endif

      return new XmlEmptyElementSyntax(SyntaxKind.XmlEmptyElement, lessThanToken, name, attributes.Node, slashGreaterThanToken, this.context);
    }

    public XmlNameSyntax XmlName(XmlPrefixSyntax prefix, SyntaxToken localName)
    {
#if DEBUG
      if (localName == null)
        throw new ArgumentNullException(nameof(localName));
      switch (localName.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("localName");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlName, prefix, localName, this.context, out hash);
      if (cached != null) return (XmlNameSyntax)cached;

      var result = new XmlNameSyntax(SyntaxKind.XmlName, prefix, localName, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlPrefixSyntax XmlPrefix(SyntaxToken prefix, SyntaxToken colonToken)
    {
#if DEBUG
      if (prefix == null)
        throw new ArgumentNullException(nameof(prefix));
      switch (prefix.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("prefix");
      }
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlPrefix, prefix, colonToken, this.context, out hash);
      if (cached != null) return (XmlPrefixSyntax)cached;

      var result = new XmlPrefixSyntax(SyntaxKind.XmlPrefix, prefix, colonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxList<SyntaxToken> textTokens, SyntaxToken endQuoteToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (startQuoteToken == null)
        throw new ArgumentNullException(nameof(startQuoteToken));
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("startQuoteToken");
      }
      if (endQuoteToken == null)
        throw new ArgumentNullException(nameof(endQuoteToken));
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("endQuoteToken");
      }
#endif

      return new XmlTextAttributeSyntax(SyntaxKind.XmlTextAttribute, name, equalsToken, startQuoteToken, textTokens.Node, endQuoteToken, this.context);
    }

    public XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (startQuoteToken == null)
        throw new ArgumentNullException(nameof(startQuoteToken));
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("startQuoteToken");
      }
      if (cref == null)
        throw new ArgumentNullException(nameof(cref));
      if (endQuoteToken == null)
        throw new ArgumentNullException(nameof(endQuoteToken));
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("endQuoteToken");
      }
#endif

      return new XmlCrefAttributeSyntax(SyntaxKind.XmlCrefAttribute, name, equalsToken, startQuoteToken, cref, endQuoteToken, this.context);
    }

    public XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (startQuoteToken == null)
        throw new ArgumentNullException(nameof(startQuoteToken));
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("startQuoteToken");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      if (endQuoteToken == null)
        throw new ArgumentNullException(nameof(endQuoteToken));
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("endQuoteToken");
      }
#endif

      return new XmlNameAttributeSyntax(SyntaxKind.XmlNameAttribute, name, equalsToken, startQuoteToken, identifier, endQuoteToken, this.context);
    }

    public XmlTextSyntax XmlText(SyntaxList<SyntaxToken> textTokens)
    {
#if DEBUG
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlText, textTokens.Node, this.context, out hash);
      if (cached != null) return (XmlTextSyntax)cached;

      var result = new XmlTextSyntax(SyntaxKind.XmlText, textTokens.Node, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlCDataSectionSyntax XmlCDataSection(SyntaxToken startCDataToken, SyntaxList<SyntaxToken> textTokens, SyntaxToken endCDataToken)
    {
#if DEBUG
      if (startCDataToken == null)
        throw new ArgumentNullException(nameof(startCDataToken));
      switch (startCDataToken.Kind)
      {
        case SyntaxKind.XmlCDataStartToken:
          break;
        default:
          throw new ArgumentException("startCDataToken");
      }
      if (endCDataToken == null)
        throw new ArgumentNullException(nameof(endCDataToken));
      switch (endCDataToken.Kind)
      {
        case SyntaxKind.XmlCDataEndToken:
          break;
        default:
          throw new ArgumentException("endCDataToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken, this.context, out hash);
      if (cached != null) return (XmlCDataSectionSyntax)cached;

      var result = new XmlCDataSectionSyntax(SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxList<SyntaxToken> textTokens, SyntaxToken endProcessingInstructionToken)
    {
#if DEBUG
      if (startProcessingInstructionToken == null)
        throw new ArgumentNullException(nameof(startProcessingInstructionToken));
      switch (startProcessingInstructionToken.Kind)
      {
        case SyntaxKind.XmlProcessingInstructionStartToken:
          break;
        default:
          throw new ArgumentException("startProcessingInstructionToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (endProcessingInstructionToken == null)
        throw new ArgumentNullException(nameof(endProcessingInstructionToken));
      switch (endProcessingInstructionToken.Kind)
      {
        case SyntaxKind.XmlProcessingInstructionEndToken:
          break;
        default:
          throw new ArgumentException("endProcessingInstructionToken");
      }
#endif

      return new XmlProcessingInstructionSyntax(SyntaxKind.XmlProcessingInstruction, startProcessingInstructionToken, name, textTokens.Node, endProcessingInstructionToken, this.context);
    }

    public XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxList<SyntaxToken> textTokens, SyntaxToken minusMinusGreaterThanToken)
    {
#if DEBUG
      if (lessThanExclamationMinusMinusToken == null)
        throw new ArgumentNullException(nameof(lessThanExclamationMinusMinusToken));
      switch (lessThanExclamationMinusMinusToken.Kind)
      {
        case SyntaxKind.XmlCommentStartToken:
          break;
        default:
          throw new ArgumentException("lessThanExclamationMinusMinusToken");
      }
      if (minusMinusGreaterThanToken == null)
        throw new ArgumentNullException(nameof(minusMinusGreaterThanToken));
      switch (minusMinusGreaterThanToken.Kind)
      {
        case SyntaxKind.XmlCommentEndToken:
          break;
        default:
          throw new ArgumentException("minusMinusGreaterThanToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken, this.context, out hash);
      if (cached != null) return (XmlCommentSyntax)cached;

      var result = new XmlCommentSyntax(SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (ifKeyword == null)
        throw new ArgumentNullException(nameof(ifKeyword));
      switch (ifKeyword.Kind)
      {
        case SyntaxKind.IfKeyword:
          break;
        default:
          throw new ArgumentException("ifKeyword");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new IfDirectiveTriviaSyntax(SyntaxKind.IfDirectiveTrivia, hashToken, ifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue, this.context);
    }

    public ElifDirectiveTriviaSyntax ElifDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (elifKeyword == null)
        throw new ArgumentNullException(nameof(elifKeyword));
      switch (elifKeyword.Kind)
      {
        case SyntaxKind.ElifKeyword:
          break;
        default:
          throw new ArgumentException("elifKeyword");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ElifDirectiveTriviaSyntax(SyntaxKind.ElifDirectiveTrivia, hashToken, elifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue, this.context);
    }

    public ElseDirectiveTriviaSyntax ElseDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (elseKeyword == null)
        throw new ArgumentNullException(nameof(elseKeyword));
      switch (elseKeyword.Kind)
      {
        case SyntaxKind.ElseKeyword:
          break;
        default:
          throw new ArgumentException("elseKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ElseDirectiveTriviaSyntax(SyntaxKind.ElseDirectiveTrivia, hashToken, elseKeyword, endOfDirectiveToken, isActive, branchTaken, this.context);
    }

    public EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (endIfKeyword == null)
        throw new ArgumentNullException(nameof(endIfKeyword));
      switch (endIfKeyword.Kind)
      {
        case SyntaxKind.EndIfKeyword:
          break;
        default:
          throw new ArgumentException("endIfKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new EndIfDirectiveTriviaSyntax(SyntaxKind.EndIfDirectiveTrivia, hashToken, endIfKeyword, endOfDirectiveToken, isActive, this.context);
    }

    public RegionDirectiveTriviaSyntax RegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (regionKeyword == null)
        throw new ArgumentNullException(nameof(regionKeyword));
      switch (regionKeyword.Kind)
      {
        case SyntaxKind.RegionKeyword:
          break;
        default:
          throw new ArgumentException("regionKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new RegionDirectiveTriviaSyntax(SyntaxKind.RegionDirectiveTrivia, hashToken, regionKeyword, endOfDirectiveToken, isActive, this.context);
    }

    public EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (endRegionKeyword == null)
        throw new ArgumentNullException(nameof(endRegionKeyword));
      switch (endRegionKeyword.Kind)
      {
        case SyntaxKind.EndRegionKeyword:
          break;
        default:
          throw new ArgumentException("endRegionKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new EndRegionDirectiveTriviaSyntax(SyntaxKind.EndRegionDirectiveTrivia, hashToken, endRegionKeyword, endOfDirectiveToken, isActive, this.context);
    }

    public ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (errorKeyword == null)
        throw new ArgumentNullException(nameof(errorKeyword));
      switch (errorKeyword.Kind)
      {
        case SyntaxKind.ErrorKeyword:
          break;
        default:
          throw new ArgumentException("errorKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ErrorDirectiveTriviaSyntax(SyntaxKind.ErrorDirectiveTrivia, hashToken, errorKeyword, endOfDirectiveToken, isActive, this.context);
    }

    public WarningDirectiveTriviaSyntax WarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (warningKeyword == null)
        throw new ArgumentNullException(nameof(warningKeyword));
      switch (warningKeyword.Kind)
      {
        case SyntaxKind.WarningKeyword:
          break;
        default:
          throw new ArgumentException("warningKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new WarningDirectiveTriviaSyntax(SyntaxKind.WarningDirectiveTrivia, hashToken, warningKeyword, endOfDirectiveToken, isActive, this.context);
    }

    public BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new BadDirectiveTriviaSyntax(SyntaxKind.BadDirectiveTrivia, hashToken, identifier, endOfDirectiveToken, isActive, this.context);
    }

    public DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (defineKeyword == null)
        throw new ArgumentNullException(nameof(defineKeyword));
      switch (defineKeyword.Kind)
      {
        case SyntaxKind.DefineKeyword:
          break;
        default:
          throw new ArgumentException("defineKeyword");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (name.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("name");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new DefineDirectiveTriviaSyntax(SyntaxKind.DefineDirectiveTrivia, hashToken, defineKeyword, name, endOfDirectiveToken, isActive, this.context);
    }

    public UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (undefKeyword == null)
        throw new ArgumentNullException(nameof(undefKeyword));
      switch (undefKeyword.Kind)
      {
        case SyntaxKind.UndefKeyword:
          break;
        default:
          throw new ArgumentException("undefKeyword");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (name.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("name");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new UndefDirectiveTriviaSyntax(SyntaxKind.UndefDirectiveTrivia, hashToken, undefKeyword, name, endOfDirectiveToken, isActive, this.context);
    }

    public LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (lineKeyword == null)
        throw new ArgumentNullException(nameof(lineKeyword));
      switch (lineKeyword.Kind)
      {
        case SyntaxKind.LineKeyword:
          break;
        default:
          throw new ArgumentException("lineKeyword");
      }
      if (line == null)
        throw new ArgumentNullException(nameof(line));
      switch (line.Kind)
      {
        case SyntaxKind.NumericLiteralToken:
        case SyntaxKind.DefaultKeyword:
        case SyntaxKind.HiddenKeyword:
          break;
        default:
          throw new ArgumentException("line");
      }
      if (file != null)
      {
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("file");
      }
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new LineDirectiveTriviaSyntax(SyntaxKind.LineDirectiveTrivia, hashToken, lineKeyword, line, file, endOfDirectiveToken, isActive, this.context);
    }

    public PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (pragmaKeyword == null)
        throw new ArgumentNullException(nameof(pragmaKeyword));
      switch (pragmaKeyword.Kind)
      {
        case SyntaxKind.PragmaKeyword:
          break;
        default:
          throw new ArgumentException("pragmaKeyword");
      }
      if (warningKeyword == null)
        throw new ArgumentNullException(nameof(warningKeyword));
      switch (warningKeyword.Kind)
      {
        case SyntaxKind.WarningKeyword:
          break;
        default:
          throw new ArgumentException("warningKeyword");
      }
      if (disableOrRestoreKeyword == null)
        throw new ArgumentNullException(nameof(disableOrRestoreKeyword));
      switch (disableOrRestoreKeyword.Kind)
      {
        case SyntaxKind.DisableKeyword:
        case SyntaxKind.RestoreKeyword:
          break;
        default:
          throw new ArgumentException("disableOrRestoreKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new PragmaWarningDirectiveTriviaSyntax(SyntaxKind.PragmaWarningDirectiveTrivia, hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes.Node, endOfDirectiveToken, isActive, this.context);
    }

    public PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (pragmaKeyword == null)
        throw new ArgumentNullException(nameof(pragmaKeyword));
      switch (pragmaKeyword.Kind)
      {
        case SyntaxKind.PragmaKeyword:
          break;
        default:
          throw new ArgumentException("pragmaKeyword");
      }
      if (checksumKeyword == null)
        throw new ArgumentNullException(nameof(checksumKeyword));
      switch (checksumKeyword.Kind)
      {
        case SyntaxKind.ChecksumKeyword:
          break;
        default:
          throw new ArgumentException("checksumKeyword");
      }
      if (file == null)
        throw new ArgumentNullException(nameof(file));
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("file");
      }
      if (guid == null)
        throw new ArgumentNullException(nameof(guid));
      switch (guid.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("guid");
      }
      if (bytes == null)
        throw new ArgumentNullException(nameof(bytes));
      switch (bytes.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("bytes");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new PragmaChecksumDirectiveTriviaSyntax(SyntaxKind.PragmaChecksumDirectiveTrivia, hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, isActive, this.context);
    }

    public ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (referenceKeyword == null)
        throw new ArgumentNullException(nameof(referenceKeyword));
      switch (referenceKeyword.Kind)
      {
        case SyntaxKind.ReferenceKeyword:
          break;
        default:
          throw new ArgumentException("referenceKeyword");
      }
      if (file == null)
        throw new ArgumentNullException(nameof(file));
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("file");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ReferenceDirectiveTriviaSyntax(SyntaxKind.ReferenceDirectiveTrivia, hashToken, referenceKeyword, file, endOfDirectiveToken, isActive, this.context);
    }

    public LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (loadKeyword == null)
        throw new ArgumentNullException(nameof(loadKeyword));
      switch (loadKeyword.Kind)
      {
        case SyntaxKind.LoadKeyword:
          break;
        default:
          throw new ArgumentException("loadKeyword");
      }
      if (file == null)
        throw new ArgumentNullException(nameof(file));
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("file");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new LoadDirectiveTriviaSyntax(SyntaxKind.LoadDirectiveTrivia, hashToken, loadKeyword, file, endOfDirectiveToken, isActive, this.context);
    }

    public ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (exclamationToken == null)
        throw new ArgumentNullException(nameof(exclamationToken));
      switch (exclamationToken.Kind)
      {
        case SyntaxKind.ExclamationToken:
          break;
        default:
          throw new ArgumentException("exclamationToken");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ShebangDirectiveTriviaSyntax(SyntaxKind.ShebangDirectiveTrivia, hashToken, exclamationToken, endOfDirectiveToken, isActive, this.context);
    }
  }

  internal static partial class SyntaxFactory
  {
    public static IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.GlobalKeyword:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IdentifierName, identifier, out hash);
      if (cached != null) return (IdentifierNameSyntax)cached;

      var result = new IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static QualifiedNameSyntax QualifiedName(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
    {
#if DEBUG
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      if (dotToken == null)
        throw new ArgumentNullException(nameof(dotToken));
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("dotToken");
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QualifiedName, left, dotToken, right, out hash);
      if (cached != null) return (QualifiedNameSyntax)cached;

      var result = new QualifiedNameSyntax(SyntaxKind.QualifiedName, left, dotToken, right);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static GenericNameSyntax GenericName(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (typeArgumentList == null)
        throw new ArgumentNullException(nameof(typeArgumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.GenericName, identifier, typeArgumentList, out hash);
      if (cached != null) return (GenericNameSyntax)cached;

      var result = new GenericNameSyntax(SyntaxKind.GenericName, identifier, typeArgumentList);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken, out hash);
      if (cached != null) return (TypeArgumentListSyntax)cached;

      var result = new TypeArgumentListSyntax(SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
    {
#if DEBUG
      if (alias == null)
        throw new ArgumentNullException(nameof(alias));
      if (colonColonToken == null)
        throw new ArgumentNullException(nameof(colonColonToken));
      switch (colonColonToken.Kind)
      {
        case SyntaxKind.ColonColonToken:
          break;
        default:
          throw new ArgumentException("colonColonToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AliasQualifiedName, alias, colonColonToken, name, out hash);
      if (cached != null) return (AliasQualifiedNameSyntax)cached;

      var result = new AliasQualifiedNameSyntax(SyntaxKind.AliasQualifiedName, alias, colonColonToken, name);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static PredefinedTypeSyntax PredefinedType(SyntaxToken keyword)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.BoolKeyword:
        case SyntaxKind.ByteKeyword:
        case SyntaxKind.SByteKeyword:
        case SyntaxKind.IntKeyword:
        case SyntaxKind.UIntKeyword:
        case SyntaxKind.ShortKeyword:
        case SyntaxKind.UShortKeyword:
        case SyntaxKind.LongKeyword:
        case SyntaxKind.ULongKeyword:
        case SyntaxKind.FloatKeyword:
        case SyntaxKind.DoubleKeyword:
        case SyntaxKind.DecimalKeyword:
        case SyntaxKind.StringKeyword:
        case SyntaxKind.CharKeyword:
        case SyntaxKind.ObjectKeyword:
        case SyntaxKind.VoidKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.PredefinedType, keyword, out hash);
      if (cached != null) return (PredefinedTypeSyntax)cached;

      var result = new PredefinedTypeSyntax(SyntaxKind.PredefinedType, keyword);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ArrayTypeSyntax ArrayType(TypeSyntax elementType, SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
    {
#if DEBUG
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayType, elementType, rankSpecifiers.Node, out hash);
      if (cached != null) return (ArrayTypeSyntax)cached;

      var result = new ArrayTypeSyntax(SyntaxKind.ArrayType, elementType, rankSpecifiers.Node);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openBracketToken, SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayRankSpecifier, openBracketToken, sizes.Node, closeBracketToken, out hash);
      if (cached != null) return (ArrayRankSpecifierSyntax)cached;

      var result = new ArrayRankSpecifierSyntax(SyntaxKind.ArrayRankSpecifier, openBracketToken, sizes.Node, closeBracketToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static PointerTypeSyntax PointerType(TypeSyntax elementType, SyntaxToken asteriskToken)
    {
#if DEBUG
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
      if (asteriskToken == null)
        throw new ArgumentNullException(nameof(asteriskToken));
      switch (asteriskToken.Kind)
      {
        case SyntaxKind.AsteriskToken:
          break;
        default:
          throw new ArgumentException("asteriskToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.PointerType, elementType, asteriskToken, out hash);
      if (cached != null) return (PointerTypeSyntax)cached;

      var result = new PointerTypeSyntax(SyntaxKind.PointerType, elementType, asteriskToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static NullableTypeSyntax NullableType(TypeSyntax elementType, SyntaxToken questionToken)
    {
#if DEBUG
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
      if (questionToken == null)
        throw new ArgumentNullException(nameof(questionToken));
      switch (questionToken.Kind)
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException("questionToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NullableType, elementType, questionToken, out hash);
      if (cached != null) return (NullableTypeSyntax)cached;

      var result = new NullableTypeSyntax(SyntaxKind.NullableType, elementType, questionToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TupleTypeSyntax TupleType(SyntaxToken openParenToken, SeparatedSyntaxList<TupleElementSyntax> elements, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleType, openParenToken, elements.Node, closeParenToken, out hash);
      if (cached != null) return (TupleTypeSyntax)cached;

      var result = new TupleTypeSyntax(SyntaxKind.TupleType, openParenToken, elements.Node, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TupleElementSyntax TupleElement(TypeSyntax type, IdentifierNameSyntax name)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleElement, type, name, out hash);
      if (cached != null) return (TupleElementSyntax)cached;

      var result = new TupleElementSyntax(SyntaxKind.TupleElement, type, name);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static OmittedTypeArgumentSyntax OmittedTypeArgument(SyntaxToken omittedTypeArgumentToken)
    {
#if DEBUG
      if (omittedTypeArgumentToken == null)
        throw new ArgumentNullException(nameof(omittedTypeArgumentToken));
      switch (omittedTypeArgumentToken.Kind)
      {
        case SyntaxKind.OmittedTypeArgumentToken:
          break;
        default:
          throw new ArgumentException("omittedTypeArgumentToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OmittedTypeArgument, omittedTypeArgumentToken, out hash);
      if (cached != null) return (OmittedTypeArgumentSyntax)cached;

      var result = new OmittedTypeArgumentSyntax(SyntaxKind.OmittedTypeArgument, omittedTypeArgumentToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, out hash);
      if (cached != null) return (ParenthesizedExpressionSyntax)cached;

      var result = new ParenthesizedExpressionSyntax(SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TupleExpressionSyntax TupleExpression(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleExpression, openParenToken, arguments.Node, closeParenToken, out hash);
      if (cached != null) return (TupleExpressionSyntax)cached;

      var result = new TupleExpressionSyntax(SyntaxKind.TupleExpression, openParenToken, arguments.Node, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
    {
      switch (kind)
      {
        case SyntaxKind.UnaryPlusExpression:
        case SyntaxKind.UnaryMinusExpression:
        case SyntaxKind.BitwiseNotExpression:
        case SyntaxKind.LogicalNotExpression:
        case SyntaxKind.PreIncrementExpression:
        case SyntaxKind.PreDecrementExpression:
        case SyntaxKind.AddressOfExpression:
        case SyntaxKind.PointerIndirectionExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.AsteriskToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (operand == null)
        throw new ArgumentNullException(nameof(operand));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, operatorToken, operand, out hash);
      if (cached != null) return (PrefixUnaryExpressionSyntax)cached;

      var result = new PrefixUnaryExpressionSyntax(kind, operatorToken, operand);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AwaitExpressionSyntax AwaitExpression(SyntaxToken awaitKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (awaitKeyword == null)
        throw new ArgumentNullException(nameof(awaitKeyword));
      switch (awaitKeyword.Kind)
      {
        case SyntaxKind.AwaitKeyword:
          break;
        default:
          throw new ArgumentException("awaitKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AwaitExpression, awaitKeyword, expression, out hash);
      if (cached != null) return (AwaitExpressionSyntax)cached;

      var result = new AwaitExpressionSyntax(SyntaxKind.AwaitExpression, awaitKeyword, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken)
    {
      switch (kind)
      {
        case SyntaxKind.PostIncrementExpression:
        case SyntaxKind.PostDecrementExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (operand == null)
        throw new ArgumentNullException(nameof(operand));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, operand, operatorToken, out hash);
      if (cached != null) return (PostfixUnaryExpressionSyntax)cached;

      var result = new PostfixUnaryExpressionSyntax(kind, operand, operatorToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
    {
      switch (kind)
      {
        case SyntaxKind.SimpleMemberAccessExpression:
        case SyntaxKind.PointerMemberAccessExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.DotToken:
        case SyntaxKind.MinusGreaterThanToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, expression, operatorToken, name, out hash);
      if (cached != null) return (MemberAccessExpressionSyntax)cached;

      var result = new MemberAccessExpressionSyntax(kind, expression, operatorToken, name);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (whenNotNull == null)
        throw new ArgumentNullException(nameof(whenNotNull));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ConditionalAccessExpression, expression, operatorToken, whenNotNull, out hash);
      if (cached != null) return (ConditionalAccessExpressionSyntax)cached;

      var result = new ConditionalAccessExpressionSyntax(SyntaxKind.ConditionalAccessExpression, expression, operatorToken, whenNotNull);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static MemberBindingExpressionSyntax MemberBindingExpression(SyntaxToken operatorToken, SimpleNameSyntax name)
    {
#if DEBUG
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.MemberBindingExpression, operatorToken, name, out hash);
      if (cached != null) return (MemberBindingExpressionSyntax)cached;

      var result = new MemberBindingExpressionSyntax(SyntaxKind.MemberBindingExpression, operatorToken, name);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ElementBindingExpressionSyntax ElementBindingExpression(BracketedArgumentListSyntax argumentList)
    {
#if DEBUG
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ElementBindingExpression, argumentList, out hash);
      if (cached != null) return (ElementBindingExpressionSyntax)cached;

      var result = new ElementBindingExpressionSyntax(SyntaxKind.ElementBindingExpression, argumentList);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ImplicitElementAccessSyntax ImplicitElementAccess(BracketedArgumentListSyntax argumentList)
    {
#if DEBUG
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ImplicitElementAccess, argumentList, out hash);
      if (cached != null) return (ImplicitElementAccessSyntax)cached;

      var result = new ImplicitElementAccessSyntax(SyntaxKind.ImplicitElementAccess, argumentList);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
      switch (kind)
      {
        case SyntaxKind.AddExpression:
        case SyntaxKind.SubtractExpression:
        case SyntaxKind.MultiplyExpression:
        case SyntaxKind.DivideExpression:
        case SyntaxKind.ModuloExpression:
        case SyntaxKind.LeftShiftExpression:
        case SyntaxKind.RightShiftExpression:
        case SyntaxKind.LogicalOrExpression:
        case SyntaxKind.LogicalAndExpression:
        case SyntaxKind.BitwiseOrExpression:
        case SyntaxKind.BitwiseAndExpression:
        case SyntaxKind.ExclusiveOrExpression:
        case SyntaxKind.EqualsExpression:
        case SyntaxKind.NotEqualsExpression:
        case SyntaxKind.LessThanExpression:
        case SyntaxKind.LessThanOrEqualExpression:
        case SyntaxKind.GreaterThanExpression:
        case SyntaxKind.GreaterThanOrEqualExpression:
        case SyntaxKind.IsExpression:
        case SyntaxKind.AsExpression:
        case SyntaxKind.CoalesceExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarBarToken:
        case SyntaxKind.AmpersandAmpersandToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.IsKeyword:
        case SyntaxKind.AsKeyword:
        case SyntaxKind.QuestionQuestionToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, out hash);
      if (cached != null) return (BinaryExpressionSyntax)cached;

      var result = new BinaryExpressionSyntax(kind, left, operatorToken, right);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
      switch (kind)
      {
        case SyntaxKind.SimpleAssignmentExpression:
        case SyntaxKind.AddAssignmentExpression:
        case SyntaxKind.SubtractAssignmentExpression:
        case SyntaxKind.MultiplyAssignmentExpression:
        case SyntaxKind.DivideAssignmentExpression:
        case SyntaxKind.ModuloAssignmentExpression:
        case SyntaxKind.AndAssignmentExpression:
        case SyntaxKind.ExclusiveOrAssignmentExpression:
        case SyntaxKind.OrAssignmentExpression:
        case SyntaxKind.LeftShiftAssignmentExpression:
        case SyntaxKind.RightShiftAssignmentExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.EqualsToken:
        case SyntaxKind.PlusEqualsToken:
        case SyntaxKind.MinusEqualsToken:
        case SyntaxKind.AsteriskEqualsToken:
        case SyntaxKind.SlashEqualsToken:
        case SyntaxKind.PercentEqualsToken:
        case SyntaxKind.AmpersandEqualsToken:
        case SyntaxKind.CaretEqualsToken:
        case SyntaxKind.BarEqualsToken:
        case SyntaxKind.LessThanLessThanEqualsToken:
        case SyntaxKind.GreaterThanGreaterThanEqualsToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, out hash);
      if (cached != null) return (AssignmentExpressionSyntax)cached;

      var result = new AssignmentExpressionSyntax(kind, left, operatorToken, right);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
    {
#if DEBUG
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (questionToken == null)
        throw new ArgumentNullException(nameof(questionToken));
      switch (questionToken.Kind)
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException("questionToken");
      }
      if (whenTrue == null)
        throw new ArgumentNullException(nameof(whenTrue));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      if (whenFalse == null)
        throw new ArgumentNullException(nameof(whenFalse));
#endif

      return new ConditionalExpressionSyntax(SyntaxKind.ConditionalExpression, condition, questionToken, whenTrue, colonToken, whenFalse);
    }

    public static ThisExpressionSyntax ThisExpression(SyntaxToken token)
    {
#if DEBUG
      if (token == null)
        throw new ArgumentNullException(nameof(token));
      switch (token.Kind)
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ThisExpression, token, out hash);
      if (cached != null) return (ThisExpressionSyntax)cached;

      var result = new ThisExpressionSyntax(SyntaxKind.ThisExpression, token);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static BaseExpressionSyntax BaseExpression(SyntaxToken token)
    {
#if DEBUG
      if (token == null)
        throw new ArgumentNullException(nameof(token));
      switch (token.Kind)
      {
        case SyntaxKind.BaseKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BaseExpression, token, out hash);
      if (cached != null) return (BaseExpressionSyntax)cached;

      var result = new BaseExpressionSyntax(SyntaxKind.BaseExpression, token);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static OriginalExpressionSyntax OriginalExpression(SyntaxToken token)
    {
#if DEBUG
      if (token == null)
        throw new ArgumentNullException(nameof(token));
      switch (token.Kind)
      {
        case SyntaxKind.OriginalKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OriginalExpression, token, out hash);
      if (cached != null) return (OriginalExpressionSyntax)cached;

      var result = new OriginalExpressionSyntax(SyntaxKind.OriginalExpression, token);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)
    {
      switch (kind)
      {
        case SyntaxKind.ArgListExpression:
        case SyntaxKind.NumericLiteralExpression:
        case SyntaxKind.StringLiteralExpression:
        case SyntaxKind.CharacterLiteralExpression:
        case SyntaxKind.TrueLiteralExpression:
        case SyntaxKind.FalseLiteralExpression:
        case SyntaxKind.NullLiteralExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (token == null)
        throw new ArgumentNullException(nameof(token));
      switch (token.Kind)
      {
        case SyntaxKind.ArgListKeyword:
        case SyntaxKind.NumericLiteralToken:
        case SyntaxKind.StringLiteralToken:
        case SyntaxKind.CharacterLiteralToken:
        case SyntaxKind.TrueKeyword:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.NullKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, token, out hash);
      if (cached != null) return (LiteralExpressionSyntax)cached;

      var result = new LiteralExpressionSyntax(kind, token);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static MakeRefExpressionSyntax MakeRefExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.MakeRefKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new MakeRefExpressionSyntax(SyntaxKind.MakeRefExpression, keyword, openParenToken, expression, closeParenToken);
    }

    public static RefTypeExpressionSyntax RefTypeExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.RefTypeKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new RefTypeExpressionSyntax(SyntaxKind.RefTypeExpression, keyword, openParenToken, expression, closeParenToken);
    }

    public static RefValueExpressionSyntax RefValueExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.RefValueKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (comma == null)
        throw new ArgumentNullException(nameof(comma));
      switch (comma.Kind)
      {
        case SyntaxKind.CommaToken:
          break;
        default:
          throw new ArgumentException("comma");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new RefValueExpressionSyntax(SyntaxKind.RefValueExpression, keyword, openParenToken, expression, comma, type, closeParenToken);
    }

    public static CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedExpression:
        case SyntaxKind.UncheckedExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CheckedKeyword:
        case SyntaxKind.UncheckedKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new CheckedExpressionSyntax(kind, keyword, openParenToken, expression, closeParenToken);
    }

    public static DefaultExpressionSyntax DefaultExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new DefaultExpressionSyntax(SyntaxKind.DefaultExpression, keyword, openParenToken, type, closeParenToken);
    }

    public static TypeOfExpressionSyntax TypeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.TypeOfKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new TypeOfExpressionSyntax(SyntaxKind.TypeOfExpression, keyword, openParenToken, type, closeParenToken);
    }

    public static SizeOfExpressionSyntax SizeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.SizeOfKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new SizeOfExpressionSyntax(SyntaxKind.SizeOfExpression, keyword, openParenToken, type, closeParenToken);
    }

    public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression, ArgumentListSyntax argumentList)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InvocationExpression, expression, argumentList, out hash);
      if (cached != null) return (InvocationExpressionSyntax)cached;

      var result = new InvocationExpressionSyntax(SyntaxKind.InvocationExpression, expression, argumentList);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ElementAccessExpression, expression, argumentList, out hash);
      if (cached != null) return (ElementAccessExpressionSyntax)cached;

      var result = new ElementAccessExpressionSyntax(SyntaxKind.ElementAccessExpression, expression, argumentList);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken, out hash);
      if (cached != null) return (ArgumentListSyntax)cached;

      var result = new ArgumentListSyntax(SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static BracketedArgumentListSyntax BracketedArgumentList(SyntaxToken openBracketToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BracketedArgumentList, openBracketToken, arguments.Node, closeBracketToken, out hash);
      if (cached != null) return (BracketedArgumentListSyntax)cached;

      var result = new BracketedArgumentListSyntax(SyntaxKind.BracketedArgumentList, openBracketToken, arguments.Node, closeBracketToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ArgumentSyntax Argument(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (refOrOutKeyword != null)
      {
      switch (refOrOutKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refOrOutKeyword");
      }
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Argument, nameColon, refOrOutKeyword, expression, out hash);
      if (cached != null) return (ArgumentSyntax)cached;

      var result = new ArgumentSyntax(SyntaxKind.Argument, nameColon, refOrOutKeyword, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static NameColonSyntax NameColon(IdentifierNameSyntax name, SyntaxToken colonToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NameColon, name, colonToken, out hash);
      if (cached != null) return (NameColonSyntax)cached;

      var result = new NameColonSyntax(SyntaxKind.NameColon, name, colonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static CastExpressionSyntax CastExpression(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      return new CastExpressionSyntax(SyntaxKind.CastExpression, openParenToken, type, closeParenToken, expression);
    }

    public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body)
    {
#if DEBUG
      if (asyncKeyword != null)
      {
      switch (asyncKeyword.Kind)
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("asyncKeyword");
      }
      }
      if (delegateKeyword == null)
        throw new ArgumentNullException(nameof(delegateKeyword));
      switch (delegateKeyword.Kind)
      {
        case SyntaxKind.DelegateKeyword:
          break;
        default:
          throw new ArgumentException("delegateKeyword");
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      return new AnonymousMethodExpressionSyntax(SyntaxKind.AnonymousMethodExpression, asyncKeyword, delegateKeyword, parameterList, body);
    }

    public static SimpleLambdaExpressionSyntax SimpleLambdaExpression(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, SyntaxToken refKeyword, CSharpSyntaxNode body)
    {
#if DEBUG
      if (asyncKeyword != null)
      {
      switch (asyncKeyword.Kind)
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("asyncKeyword");
      }
      }
      if (parameter == null)
        throw new ArgumentNullException(nameof(parameter));
      if (arrowToken == null)
        throw new ArgumentNullException(nameof(arrowToken));
      switch (arrowToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException("arrowToken");
      }
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      return new SimpleLambdaExpressionSyntax(SyntaxKind.SimpleLambdaExpression, asyncKeyword, parameter, arrowToken, refKeyword, body);
    }

    public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, SyntaxToken refKeyword, CSharpSyntaxNode body)
    {
#if DEBUG
      if (asyncKeyword != null)
      {
      switch (asyncKeyword.Kind)
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("asyncKeyword");
      }
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (arrowToken == null)
        throw new ArgumentNullException(nameof(arrowToken));
      switch (arrowToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException("arrowToken");
      }
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      return new ParenthesizedLambdaExpressionSyntax(SyntaxKind.ParenthesizedLambdaExpression, asyncKeyword, parameterList, arrowToken, refKeyword, body);
    }

    public static InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)
    {
      switch (kind)
      {
        case SyntaxKind.ObjectInitializerExpression:
        case SyntaxKind.CollectionInitializerExpression:
        case SyntaxKind.ArrayInitializerExpression:
        case SyntaxKind.ComplexElementInitializerExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, openBraceToken, expressions.Node, closeBraceToken, out hash);
      if (cached != null) return (InitializerExpressionSyntax)cached;

      var result = new InitializerExpressionSyntax(kind, openBraceToken, expressions.Node, closeBraceToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      return new ObjectCreationExpressionSyntax(SyntaxKind.ObjectCreationExpression, newKeyword, type, argumentList, initializer);
    }

    public static AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(NameEqualsSyntax nameEquals, ExpressionSyntax expression)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AnonymousObjectMemberDeclarator, nameEquals, expression, out hash);
      if (cached != null) return (AnonymousObjectMemberDeclaratorSyntax)cached;

      var result = new AnonymousObjectMemberDeclaratorSyntax(SyntaxKind.AnonymousObjectMemberDeclarator, nameEquals, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      return new AnonymousObjectCreationExpressionSyntax(SyntaxKind.AnonymousObjectCreationExpression, newKeyword, openBraceToken, initializers.Node, closeBraceToken);
    }

    public static ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayCreationExpression, newKeyword, type, initializer, out hash);
      if (cached != null) return (ArrayCreationExpressionSyntax)cached;

      var result = new ArrayCreationExpressionSyntax(SyntaxKind.ArrayCreationExpression, newKeyword, type, initializer);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxList<SyntaxToken> commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
      if (initializer == null)
        throw new ArgumentNullException(nameof(initializer));
#endif

      return new ImplicitArrayCreationExpressionSyntax(SyntaxKind.ImplicitArrayCreationExpression, newKeyword, openBracketToken, commas.Node, closeBracketToken, initializer);
    }

    public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, TypeSyntax type)
    {
#if DEBUG
      if (stackAllocKeyword == null)
        throw new ArgumentNullException(nameof(stackAllocKeyword));
      switch (stackAllocKeyword.Kind)
      {
        case SyntaxKind.StackAllocKeyword:
          break;
        default:
          throw new ArgumentException("stackAllocKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.StackAllocArrayCreationExpression, stackAllocKeyword, type, out hash);
      if (cached != null) return (StackAllocArrayCreationExpressionSyntax)cached;

      var result = new StackAllocArrayCreationExpressionSyntax(SyntaxKind.StackAllocArrayCreationExpression, stackAllocKeyword, type);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static QueryExpressionSyntax QueryExpression(FromClauseSyntax fromClause, QueryBodySyntax body)
    {
#if DEBUG
      if (fromClause == null)
        throw new ArgumentNullException(nameof(fromClause));
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryExpression, fromClause, body, out hash);
      if (cached != null) return (QueryExpressionSyntax)cached;

      var result = new QueryExpressionSyntax(SyntaxKind.QueryExpression, fromClause, body);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static QueryBodySyntax QueryBody(SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
    {
#if DEBUG
      if (selectOrGroup == null)
        throw new ArgumentNullException(nameof(selectOrGroup));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryBody, clauses.Node, selectOrGroup, continuation, out hash);
      if (cached != null) return (QueryBodySyntax)cached;

      var result = new QueryBodySyntax(SyntaxKind.QueryBody, clauses.Node, selectOrGroup, continuation);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static FromClauseSyntax FromClause(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (fromKeyword == null)
        throw new ArgumentNullException(nameof(fromKeyword));
      switch (fromKeyword.Kind)
      {
        case SyntaxKind.FromKeyword:
          break;
        default:
          throw new ArgumentException("fromKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (inKeyword == null)
        throw new ArgumentNullException(nameof(inKeyword));
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException("inKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      return new FromClauseSyntax(SyntaxKind.FromClause, fromKeyword, type, identifier, inKeyword, expression);
    }

    public static LetClauseSyntax LetClause(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
    {
#if DEBUG
      if (letKeyword == null)
        throw new ArgumentNullException(nameof(letKeyword));
      switch (letKeyword.Kind)
      {
        case SyntaxKind.LetKeyword:
          break;
        default:
          throw new ArgumentException("letKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      return new LetClauseSyntax(SyntaxKind.LetClause, letKeyword, identifier, equalsToken, expression);
    }

    public static JoinClauseSyntax JoinClause(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
    {
#if DEBUG
      if (joinKeyword == null)
        throw new ArgumentNullException(nameof(joinKeyword));
      switch (joinKeyword.Kind)
      {
        case SyntaxKind.JoinKeyword:
          break;
        default:
          throw new ArgumentException("joinKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (inKeyword == null)
        throw new ArgumentNullException(nameof(inKeyword));
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException("inKeyword");
      }
      if (inExpression == null)
        throw new ArgumentNullException(nameof(inExpression));
      if (onKeyword == null)
        throw new ArgumentNullException(nameof(onKeyword));
      switch (onKeyword.Kind)
      {
        case SyntaxKind.OnKeyword:
          break;
        default:
          throw new ArgumentException("onKeyword");
      }
      if (leftExpression == null)
        throw new ArgumentNullException(nameof(leftExpression));
      if (equalsKeyword == null)
        throw new ArgumentNullException(nameof(equalsKeyword));
      switch (equalsKeyword.Kind)
      {
        case SyntaxKind.EqualsKeyword:
          break;
        default:
          throw new ArgumentException("equalsKeyword");
      }
      if (rightExpression == null)
        throw new ArgumentNullException(nameof(rightExpression));
#endif

      return new JoinClauseSyntax(SyntaxKind.JoinClause, joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into);
    }

    public static JoinIntoClauseSyntax JoinIntoClause(SyntaxToken intoKeyword, SyntaxToken identifier)
    {
#if DEBUG
      if (intoKeyword == null)
        throw new ArgumentNullException(nameof(intoKeyword));
      switch (intoKeyword.Kind)
      {
        case SyntaxKind.IntoKeyword:
          break;
        default:
          throw new ArgumentException("intoKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.JoinIntoClause, intoKeyword, identifier, out hash);
      if (cached != null) return (JoinIntoClauseSyntax)cached;

      var result = new JoinIntoClauseSyntax(SyntaxKind.JoinIntoClause, intoKeyword, identifier);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static WhereClauseSyntax WhereClause(SyntaxToken whereKeyword, ExpressionSyntax condition)
    {
#if DEBUG
      if (whereKeyword == null)
        throw new ArgumentNullException(nameof(whereKeyword));
      switch (whereKeyword.Kind)
      {
        case SyntaxKind.WhereKeyword:
          break;
        default:
          throw new ArgumentException("whereKeyword");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.WhereClause, whereKeyword, condition, out hash);
      if (cached != null) return (WhereClauseSyntax)cached;

      var result = new WhereClauseSyntax(SyntaxKind.WhereClause, whereKeyword, condition);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static OrderByClauseSyntax OrderByClause(SyntaxToken orderByKeyword, SeparatedSyntaxList<OrderingSyntax> orderings)
    {
#if DEBUG
      if (orderByKeyword == null)
        throw new ArgumentNullException(nameof(orderByKeyword));
      switch (orderByKeyword.Kind)
      {
        case SyntaxKind.OrderByKeyword:
          break;
        default:
          throw new ArgumentException("orderByKeyword");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OrderByClause, orderByKeyword, orderings.Node, out hash);
      if (cached != null) return (OrderByClauseSyntax)cached;

      var result = new OrderByClauseSyntax(SyntaxKind.OrderByClause, orderByKeyword, orderings.Node);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
    {
      switch (kind)
      {
        case SyntaxKind.AscendingOrdering:
        case SyntaxKind.DescendingOrdering:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (ascendingOrDescendingKeyword != null)
      {
      switch (ascendingOrDescendingKeyword.Kind)
      {
        case SyntaxKind.AscendingKeyword:
        case SyntaxKind.DescendingKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("ascendingOrDescendingKeyword");
      }
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, expression, ascendingOrDescendingKeyword, out hash);
      if (cached != null) return (OrderingSyntax)cached;

      var result = new OrderingSyntax(kind, expression, ascendingOrDescendingKeyword);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static SelectClauseSyntax SelectClause(SyntaxToken selectKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (selectKeyword == null)
        throw new ArgumentNullException(nameof(selectKeyword));
      switch (selectKeyword.Kind)
      {
        case SyntaxKind.SelectKeyword:
          break;
        default:
          throw new ArgumentException("selectKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SelectClause, selectKeyword, expression, out hash);
      if (cached != null) return (SelectClauseSyntax)cached;

      var result = new SelectClauseSyntax(SyntaxKind.SelectClause, selectKeyword, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static GroupClauseSyntax GroupClause(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
    {
#if DEBUG
      if (groupKeyword == null)
        throw new ArgumentNullException(nameof(groupKeyword));
      switch (groupKeyword.Kind)
      {
        case SyntaxKind.GroupKeyword:
          break;
        default:
          throw new ArgumentException("groupKeyword");
      }
      if (groupExpression == null)
        throw new ArgumentNullException(nameof(groupExpression));
      if (byKeyword == null)
        throw new ArgumentNullException(nameof(byKeyword));
      switch (byKeyword.Kind)
      {
        case SyntaxKind.ByKeyword:
          break;
        default:
          throw new ArgumentException("byKeyword");
      }
      if (byExpression == null)
        throw new ArgumentNullException(nameof(byExpression));
#endif

      return new GroupClauseSyntax(SyntaxKind.GroupClause, groupKeyword, groupExpression, byKeyword, byExpression);
    }

    public static QueryContinuationSyntax QueryContinuation(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
    {
#if DEBUG
      if (intoKeyword == null)
        throw new ArgumentNullException(nameof(intoKeyword));
      switch (intoKeyword.Kind)
      {
        case SyntaxKind.IntoKeyword:
          break;
        default:
          throw new ArgumentException("intoKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryContinuation, intoKeyword, identifier, body, out hash);
      if (cached != null) return (QueryContinuationSyntax)cached;

      var result = new QueryContinuationSyntax(SyntaxKind.QueryContinuation, intoKeyword, identifier, body);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static OmittedArraySizeExpressionSyntax OmittedArraySizeExpression(SyntaxToken omittedArraySizeExpressionToken)
    {
#if DEBUG
      if (omittedArraySizeExpressionToken == null)
        throw new ArgumentNullException(nameof(omittedArraySizeExpressionToken));
      switch (omittedArraySizeExpressionToken.Kind)
      {
        case SyntaxKind.OmittedArraySizeExpressionToken:
          break;
        default:
          throw new ArgumentException("omittedArraySizeExpressionToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OmittedArraySizeExpression, omittedArraySizeExpressionToken, out hash);
      if (cached != null) return (OmittedArraySizeExpressionSyntax)cached;

      var result = new OmittedArraySizeExpressionSyntax(SyntaxKind.OmittedArraySizeExpression, omittedArraySizeExpressionToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
    {
#if DEBUG
      if (stringStartToken == null)
        throw new ArgumentNullException(nameof(stringStartToken));
      switch (stringStartToken.Kind)
      {
        case SyntaxKind.InterpolatedStringStartToken:
        case SyntaxKind.InterpolatedVerbatimStringStartToken:
          break;
        default:
          throw new ArgumentException("stringStartToken");
      }
      if (stringEndToken == null)
        throw new ArgumentNullException(nameof(stringEndToken));
      switch (stringEndToken.Kind)
      {
        case SyntaxKind.InterpolatedStringEndToken:
          break;
        default:
          throw new ArgumentException("stringEndToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken, out hash);
      if (cached != null) return (InterpolatedStringExpressionSyntax)cached;

      var result = new InterpolatedStringExpressionSyntax(SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static IsPatternExpressionSyntax IsPatternExpression(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (isKeyword == null)
        throw new ArgumentNullException(nameof(isKeyword));
      switch (isKeyword.Kind)
      {
        case SyntaxKind.IsKeyword:
          break;
        default:
          throw new ArgumentException("isKeyword");
      }
      if (pattern == null)
        throw new ArgumentNullException(nameof(pattern));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IsPatternExpression, expression, isKeyword, pattern, out hash);
      if (cached != null) return (IsPatternExpressionSyntax)cached;

      var result = new IsPatternExpressionSyntax(SyntaxKind.IsPatternExpression, expression, isKeyword, pattern);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static WhenClauseSyntax WhenClause(SyntaxToken whenKeyword, ExpressionSyntax condition)
    {
#if DEBUG
      if (whenKeyword != null)
      {
      switch (whenKeyword.Kind)
      {
        case SyntaxKind.WhenKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("whenKeyword");
      }
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.WhenClause, whenKeyword, condition, out hash);
      if (cached != null) return (WhenClauseSyntax)cached;

      var result = new WhenClauseSyntax(SyntaxKind.WhenClause, whenKeyword, condition);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static DeclarationPatternSyntax DeclarationPattern(TypeSyntax type, SyntaxToken identifier)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DeclarationPattern, type, identifier, out hash);
      if (cached != null) return (DeclarationPatternSyntax)cached;

      var result = new DeclarationPatternSyntax(SyntaxKind.DeclarationPattern, type, identifier);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ConstantPatternSyntax ConstantPattern(ExpressionSyntax expression)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ConstantPattern, expression, out hash);
      if (cached != null) return (ConstantPatternSyntax)cached;

      var result = new ConstantPatternSyntax(SyntaxKind.ConstantPattern, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken)
    {
#if DEBUG
      if (textToken == null)
        throw new ArgumentNullException(nameof(textToken));
      switch (textToken.Kind)
      {
        case SyntaxKind.InterpolatedStringTextToken:
          break;
        default:
          throw new ArgumentException("textToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolatedStringText, textToken, out hash);
      if (cached != null) return (InterpolatedStringTextSyntax)cached;

      var result = new InterpolatedStringTextSyntax(SyntaxKind.InterpolatedStringText, textToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static InterpolationSyntax Interpolation(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      return new InterpolationSyntax(SyntaxKind.Interpolation, openBraceToken, expression, alignmentClause, formatClause, closeBraceToken);
    }

    public static InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(SyntaxToken commaToken, ExpressionSyntax value)
    {
#if DEBUG
      if (commaToken == null)
        throw new ArgumentNullException(nameof(commaToken));
      if (value == null)
        throw new ArgumentNullException(nameof(value));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolationAlignmentClause, commaToken, value, out hash);
      if (cached != null) return (InterpolationAlignmentClauseSyntax)cached;

      var result = new InterpolationAlignmentClauseSyntax(SyntaxKind.InterpolationAlignmentClause, commaToken, value);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken, SyntaxToken formatStringToken)
    {
#if DEBUG
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      if (formatStringToken == null)
        throw new ArgumentNullException(nameof(formatStringToken));
      switch (formatStringToken.Kind)
      {
        case SyntaxKind.InterpolatedStringTextToken:
          break;
        default:
          throw new ArgumentException("formatStringToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken, out hash);
      if (cached != null) return (InterpolationFormatClauseSyntax)cached;

      var result = new InterpolationFormatClauseSyntax(SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static GlobalStatementSyntax GlobalStatement(StatementSyntax statement)
    {
#if DEBUG
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.GlobalStatement, statement, out hash);
      if (cached != null) return (GlobalStatementSyntax)cached;

      var result = new GlobalStatementSyntax(SyntaxKind.GlobalStatement, statement);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static BlockSyntax Block(SyntaxToken openBraceToken, SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Block, openBraceToken, statements.Node, closeBraceToken, out hash);
      if (cached != null) return (BlockSyntax)cached;

      var result = new BlockSyntax(SyntaxKind.Block, openBraceToken, statements.Node, closeBraceToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxList<SyntaxToken> modifiers, SyntaxToken refKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new LocalFunctionStatementSyntax(SyntaxKind.LocalFunctionStatement, modifiers.Node, refKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses.Node, body, expressionBody, semicolonToken);
    }

    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxList<SyntaxToken> modifiers, SyntaxToken refKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new LocalDeclarationStatementSyntax(SyntaxKind.LocalDeclarationStatement, modifiers.Node, refKeyword, declaration, semicolonToken);
    }

    public static VariableDeconstructionDeclaratorSyntax VariableDeconstructionDeclarator(SyntaxToken openParenToken, SeparatedSyntaxList<VariableDeclarationSyntax> variables, SyntaxToken closeParenToken, SyntaxToken equalsToken, ExpressionSyntax value)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (equalsToken != null)
      {
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      }
#endif

      return new VariableDeconstructionDeclaratorSyntax(SyntaxKind.VariableDeconstructionDeclarator, openParenToken, variables.Node, closeParenToken, equalsToken, value);
    }

    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SeparatedSyntaxList<VariableDeclaratorSyntax> variables, VariableDeconstructionDeclaratorSyntax deconstruction)
    {
#if DEBUG
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.VariableDeclaration, type, variables.Node, deconstruction, out hash);
      if (cached != null) return (VariableDeclarationSyntax)cached;

      var result = new VariableDeclarationSyntax(SyntaxKind.VariableDeclaration, type, variables.Node, deconstruction);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.VariableDeclarator, identifier, argumentList, initializer, out hash);
      if (cached != null) return (VariableDeclaratorSyntax)cached;

      var result = new VariableDeclaratorSyntax(SyntaxKind.VariableDeclarator, identifier, argumentList, initializer);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static EqualsValueClauseSyntax EqualsValueClause(SyntaxToken equalsToken, SyntaxToken refKeyword, ExpressionSyntax value)
    {
#if DEBUG
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (value == null)
        throw new ArgumentNullException(nameof(value));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.EqualsValueClause, equalsToken, refKeyword, value, out hash);
      if (cached != null) return (EqualsValueClauseSyntax)cached;

      var result = new EqualsValueClauseSyntax(SyntaxKind.EqualsValueClause, equalsToken, refKeyword, value);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ExpressionStatement, expression, semicolonToken, out hash);
      if (cached != null) return (ExpressionStatementSyntax)cached;

      var result = new ExpressionStatementSyntax(SyntaxKind.ExpressionStatement, expression, semicolonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static EmptyStatementSyntax EmptyStatement(SyntaxToken semicolonToken)
    {
#if DEBUG
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.EmptyStatement, semicolonToken, out hash);
      if (cached != null) return (EmptyStatementSyntax)cached;

      var result = new EmptyStatementSyntax(SyntaxKind.EmptyStatement, semicolonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.LabeledStatement, identifier, colonToken, statement, out hash);
      if (cached != null) return (LabeledStatementSyntax)cached;

      var result = new LabeledStatementSyntax(SyntaxKind.LabeledStatement, identifier, colonToken, statement);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.GotoStatement:
        case SyntaxKind.GotoCaseStatement:
        case SyntaxKind.GotoDefaultStatement:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (gotoKeyword == null)
        throw new ArgumentNullException(nameof(gotoKeyword));
      switch (gotoKeyword.Kind)
      {
        case SyntaxKind.GotoKeyword:
          break;
        default:
          throw new ArgumentException("gotoKeyword");
      }
      if (caseOrDefaultKeyword != null)
      {
      switch (caseOrDefaultKeyword.Kind)
      {
        case SyntaxKind.CaseKeyword:
        case SyntaxKind.DefaultKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("caseOrDefaultKeyword");
      }
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new GotoStatementSyntax(kind, gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
    }

    public static BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (breakKeyword == null)
        throw new ArgumentNullException(nameof(breakKeyword));
      switch (breakKeyword.Kind)
      {
        case SyntaxKind.BreakKeyword:
          break;
        default:
          throw new ArgumentException("breakKeyword");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BreakStatement, breakKeyword, semicolonToken, out hash);
      if (cached != null) return (BreakStatementSyntax)cached;

      var result = new BreakStatementSyntax(SyntaxKind.BreakStatement, breakKeyword, semicolonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ContinueStatementSyntax ContinueStatement(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (continueKeyword == null)
        throw new ArgumentNullException(nameof(continueKeyword));
      switch (continueKeyword.Kind)
      {
        case SyntaxKind.ContinueKeyword:
          break;
        default:
          throw new ArgumentException("continueKeyword");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ContinueStatement, continueKeyword, semicolonToken, out hash);
      if (cached != null) return (ContinueStatementSyntax)cached;

      var result = new ContinueStatementSyntax(SyntaxKind.ContinueStatement, continueKeyword, semicolonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, SyntaxToken refKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (returnKeyword == null)
        throw new ArgumentNullException(nameof(returnKeyword));
      switch (returnKeyword.Kind)
      {
        case SyntaxKind.ReturnKeyword:
          break;
        default:
          throw new ArgumentException("returnKeyword");
      }
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new ReturnStatementSyntax(SyntaxKind.ReturnStatement, returnKeyword, refKeyword, expression, semicolonToken);
    }

    public static ThrowStatementSyntax ThrowStatement(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (throwKeyword == null)
        throw new ArgumentNullException(nameof(throwKeyword));
      switch (throwKeyword.Kind)
      {
        case SyntaxKind.ThrowKeyword:
          break;
        default:
          throw new ArgumentException("throwKeyword");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ThrowStatement, throwKeyword, expression, semicolonToken, out hash);
      if (cached != null) return (ThrowStatementSyntax)cached;

      var result = new ThrowStatementSyntax(SyntaxKind.ThrowStatement, throwKeyword, expression, semicolonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static YieldStatementSyntax YieldStatement(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.YieldReturnStatement:
        case SyntaxKind.YieldBreakStatement:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (yieldKeyword == null)
        throw new ArgumentNullException(nameof(yieldKeyword));
      switch (yieldKeyword.Kind)
      {
        case SyntaxKind.YieldKeyword:
          break;
        default:
          throw new ArgumentException("yieldKeyword");
      }
      if (returnOrBreakKeyword == null)
        throw new ArgumentNullException(nameof(returnOrBreakKeyword));
      switch (returnOrBreakKeyword.Kind)
      {
        case SyntaxKind.ReturnKeyword:
        case SyntaxKind.BreakKeyword:
          break;
        default:
          throw new ArgumentException("returnOrBreakKeyword");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new YieldStatementSyntax(kind, yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
    }

    public static WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (whileKeyword == null)
        throw new ArgumentNullException(nameof(whileKeyword));
      switch (whileKeyword.Kind)
      {
        case SyntaxKind.WhileKeyword:
          break;
        default:
          throw new ArgumentException("whileKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new WhileStatementSyntax(SyntaxKind.WhileStatement, whileKeyword, openParenToken, condition, closeParenToken, statement);
    }

    public static DoStatementSyntax DoStatement(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (doKeyword == null)
        throw new ArgumentNullException(nameof(doKeyword));
      switch (doKeyword.Kind)
      {
        case SyntaxKind.DoKeyword:
          break;
        default:
          throw new ArgumentException("doKeyword");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      if (whileKeyword == null)
        throw new ArgumentNullException(nameof(whileKeyword));
      switch (whileKeyword.Kind)
      {
        case SyntaxKind.WhileKeyword:
          break;
        default:
          throw new ArgumentException("whileKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new DoStatementSyntax(SyntaxKind.DoStatement, doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
    }

    public static ForStatementSyntax ForStatement(SyntaxToken forKeyword, SyntaxToken openParenToken, SyntaxToken refKeyword, VariableDeclarationSyntax declaration, SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (forKeyword == null)
        throw new ArgumentNullException(nameof(forKeyword));
      switch (forKeyword.Kind)
      {
        case SyntaxKind.ForKeyword:
          break;
        default:
          throw new ArgumentException("forKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (firstSemicolonToken == null)
        throw new ArgumentNullException(nameof(firstSemicolonToken));
      switch (firstSemicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("firstSemicolonToken");
      }
      if (secondSemicolonToken == null)
        throw new ArgumentNullException(nameof(secondSemicolonToken));
      switch (secondSemicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("secondSemicolonToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new ForStatementSyntax(SyntaxKind.ForStatement, forKeyword, openParenToken, refKeyword, declaration, initializers.Node, firstSemicolonToken, condition, secondSemicolonToken, incrementors.Node, closeParenToken, statement);
    }

    public static ForEachStatementSyntax ForEachStatement(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, VariableDeclarationSyntax deconstructionVariables, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (forEachKeyword == null)
        throw new ArgumentNullException(nameof(forEachKeyword));
      switch (forEachKeyword.Kind)
      {
        case SyntaxKind.ForEachKeyword:
          break;
        default:
          throw new ArgumentException("forEachKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (identifier != null)
      {
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      }
      if (inKeyword == null)
        throw new ArgumentNullException(nameof(inKeyword));
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException("inKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new ForEachStatementSyntax(SyntaxKind.ForEachStatement, forEachKeyword, openParenToken, type, identifier, deconstructionVariables, inKeyword, expression, closeParenToken, statement);
    }

    public static UsingStatementSyntax UsingStatement(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (usingKeyword == null)
        throw new ArgumentNullException(nameof(usingKeyword));
      switch (usingKeyword.Kind)
      {
        case SyntaxKind.UsingKeyword:
          break;
        default:
          throw new ArgumentException("usingKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new UsingStatementSyntax(SyntaxKind.UsingStatement, usingKeyword, openParenToken, declaration, expression, closeParenToken, statement);
    }

    public static FixedStatementSyntax FixedStatement(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (fixedKeyword == null)
        throw new ArgumentNullException(nameof(fixedKeyword));
      switch (fixedKeyword.Kind)
      {
        case SyntaxKind.FixedKeyword:
          break;
        default:
          throw new ArgumentException("fixedKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new FixedStatementSyntax(SyntaxKind.FixedStatement, fixedKeyword, openParenToken, declaration, closeParenToken, statement);
    }

    public static CheckedStatementSyntax CheckedStatement(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedStatement:
        case SyntaxKind.UncheckedStatement:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CheckedKeyword:
        case SyntaxKind.UncheckedKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, keyword, block, out hash);
      if (cached != null) return (CheckedStatementSyntax)cached;

      var result = new CheckedStatementSyntax(kind, keyword, block);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static UnsafeStatementSyntax UnsafeStatement(SyntaxToken unsafeKeyword, BlockSyntax block)
    {
#if DEBUG
      if (unsafeKeyword == null)
        throw new ArgumentNullException(nameof(unsafeKeyword));
      switch (unsafeKeyword.Kind)
      {
        case SyntaxKind.UnsafeKeyword:
          break;
        default:
          throw new ArgumentException("unsafeKeyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.UnsafeStatement, unsafeKeyword, block, out hash);
      if (cached != null) return (UnsafeStatementSyntax)cached;

      var result = new UnsafeStatementSyntax(SyntaxKind.UnsafeStatement, unsafeKeyword, block);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static LockStatementSyntax LockStatement(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (lockKeyword == null)
        throw new ArgumentNullException(nameof(lockKeyword));
      switch (lockKeyword.Kind)
      {
        case SyntaxKind.LockKeyword:
          break;
        default:
          throw new ArgumentException("lockKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new LockStatementSyntax(SyntaxKind.LockStatement, lockKeyword, openParenToken, expression, closeParenToken, statement);
    }

    public static IfStatementSyntax IfStatement(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)
    {
#if DEBUG
      if (ifKeyword == null)
        throw new ArgumentNullException(nameof(ifKeyword));
      switch (ifKeyword.Kind)
      {
        case SyntaxKind.IfKeyword:
          break;
        default:
          throw new ArgumentException("ifKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new IfStatementSyntax(SyntaxKind.IfStatement, ifKeyword, openParenToken, condition, closeParenToken, statement, @else);
    }

    public static ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StatementSyntax statement)
    {
#if DEBUG
      if (elseKeyword == null)
        throw new ArgumentNullException(nameof(elseKeyword));
      switch (elseKeyword.Kind)
      {
        case SyntaxKind.ElseKeyword:
          break;
        default:
          throw new ArgumentException("elseKeyword");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ElseClause, elseKeyword, statement, out hash);
      if (cached != null) return (ElseClauseSyntax)cached;

      var result = new ElseClauseSyntax(SyntaxKind.ElseClause, elseKeyword, statement);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static SwitchStatementSyntax SwitchStatement(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (switchKeyword == null)
        throw new ArgumentNullException(nameof(switchKeyword));
      switch (switchKeyword.Kind)
      {
        case SyntaxKind.SwitchKeyword:
          break;
        default:
          throw new ArgumentException("switchKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      return new SwitchStatementSyntax(SyntaxKind.SwitchStatement, switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections.Node, closeBraceToken);
    }

    public static SwitchSectionSyntax SwitchSection(SyntaxList<SwitchLabelSyntax> labels, SyntaxList<StatementSyntax> statements)
    {
#if DEBUG
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SwitchSection, labels.Node, statements.Node, out hash);
      if (cached != null) return (SwitchSectionSyntax)cached;

      var result = new SwitchSectionSyntax(SyntaxKind.SwitchSection, labels.Node, statements.Node);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static CasePatternSwitchLabelSyntax CasePatternSwitchLabel(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CaseKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (pattern == null)
        throw new ArgumentNullException(nameof(pattern));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
#endif

      return new CasePatternSwitchLabelSyntax(SyntaxKind.CasePatternSwitchLabel, keyword, pattern, whenClause, colonToken);
    }

    public static CaseSwitchLabelSyntax CaseSwitchLabel(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CaseKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (value == null)
        throw new ArgumentNullException(nameof(value));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CaseSwitchLabel, keyword, value, colonToken, out hash);
      if (cached != null) return (CaseSwitchLabelSyntax)cached;

      var result = new CaseSwitchLabelSyntax(SyntaxKind.CaseSwitchLabel, keyword, value, colonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken keyword, SyntaxToken colonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DefaultSwitchLabel, keyword, colonToken, out hash);
      if (cached != null) return (DefaultSwitchLabelSyntax)cached;

      var result = new DefaultSwitchLabelSyntax(SyntaxKind.DefaultSwitchLabel, keyword, colonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TryStatementSyntax TryStatement(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
    {
#if DEBUG
      if (tryKeyword == null)
        throw new ArgumentNullException(nameof(tryKeyword));
      switch (tryKeyword.Kind)
      {
        case SyntaxKind.TryKeyword:
          break;
        default:
          throw new ArgumentException("tryKeyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      return new TryStatementSyntax(SyntaxKind.TryStatement, tryKeyword, block, catches.Node, @finally);
    }

    public static CatchClauseSyntax CatchClause(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)
    {
#if DEBUG
      if (catchKeyword == null)
        throw new ArgumentNullException(nameof(catchKeyword));
      switch (catchKeyword.Kind)
      {
        case SyntaxKind.CatchKeyword:
          break;
        default:
          throw new ArgumentException("catchKeyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      return new CatchClauseSyntax(SyntaxKind.CatchClause, catchKeyword, declaration, filter, block);
    }

    public static CatchDeclarationSyntax CatchDeclaration(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier != null)
      {
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new CatchDeclarationSyntax(SyntaxKind.CatchDeclaration, openParenToken, type, identifier, closeParenToken);
    }

    public static CatchFilterClauseSyntax CatchFilterClause(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (whenKeyword == null)
        throw new ArgumentNullException(nameof(whenKeyword));
      switch (whenKeyword.Kind)
      {
        case SyntaxKind.WhenKeyword:
          break;
        default:
          throw new ArgumentException("whenKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (filterExpression == null)
        throw new ArgumentNullException(nameof(filterExpression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new CatchFilterClauseSyntax(SyntaxKind.CatchFilterClause, whenKeyword, openParenToken, filterExpression, closeParenToken);
    }

    public static FinallyClauseSyntax FinallyClause(SyntaxToken finallyKeyword, BlockSyntax block)
    {
#if DEBUG
      if (finallyKeyword == null)
        throw new ArgumentNullException(nameof(finallyKeyword));
      switch (finallyKeyword.Kind)
      {
        case SyntaxKind.FinallyKeyword:
          break;
        default:
          throw new ArgumentException("finallyKeyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.FinallyClause, finallyKeyword, block, out hash);
      if (cached != null) return (FinallyClauseSyntax)cached;

      var result = new FinallyClauseSyntax(SyntaxKind.FinallyClause, finallyKeyword, block);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static CompilationUnitSyntax CompilationUnit(SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)
    {
#if DEBUG
      if (endOfFileToken == null)
        throw new ArgumentNullException(nameof(endOfFileToken));
      switch (endOfFileToken.Kind)
      {
        case SyntaxKind.EndOfFileToken:
          break;
        default:
          throw new ArgumentException("endOfFileToken");
      }
#endif

      return new CompilationUnitSyntax(SyntaxKind.CompilationUnit, externs.Node, usings.Node, attributeLists.Node, members.Node, endOfFileToken);
    }

    public static ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (externKeyword == null)
        throw new ArgumentNullException(nameof(externKeyword));
      switch (externKeyword.Kind)
      {
        case SyntaxKind.ExternKeyword:
          break;
        default:
          throw new ArgumentException("externKeyword");
      }
      if (aliasKeyword == null)
        throw new ArgumentNullException(nameof(aliasKeyword));
      switch (aliasKeyword.Kind)
      {
        case SyntaxKind.AliasKeyword:
          break;
        default:
          throw new ArgumentException("aliasKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new ExternAliasDirectiveSyntax(SyntaxKind.ExternAliasDirective, externKeyword, aliasKeyword, identifier, semicolonToken);
    }

    public static UsingDirectiveSyntax UsingDirective(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (usingKeyword == null)
        throw new ArgumentNullException(nameof(usingKeyword));
      switch (usingKeyword.Kind)
      {
        case SyntaxKind.UsingKeyword:
          break;
        default:
          throw new ArgumentException("usingKeyword");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new UsingDirectiveSyntax(SyntaxKind.UsingDirective, usingKeyword, staticKeyword, alias, name, semicolonToken);
    }

    public static NamespaceDeclarationSyntax NamespaceDeclaration(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (namespaceKeyword == null)
        throw new ArgumentNullException(nameof(namespaceKeyword));
      switch (namespaceKeyword.Kind)
      {
        case SyntaxKind.NamespaceKeyword:
          break;
        default:
          throw new ArgumentException("namespaceKeyword");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new NamespaceDeclarationSyntax(SyntaxKind.NamespaceDeclaration, namespaceKeyword, name, openBraceToken, externs.Node, usings.Node, members.Node, closeBraceToken, semicolonToken);
    }

    public static AttributeListSyntax AttributeList(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      return new AttributeListSyntax(SyntaxKind.AttributeList, openBracketToken, target, attributes.Node, closeBracketToken);
    }

    public static AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier, SyntaxToken colonToken)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeTargetSpecifier, identifier, colonToken, out hash);
      if (cached != null) return (AttributeTargetSpecifierSyntax)cached;

      var result = new AttributeTargetSpecifierSyntax(SyntaxKind.AttributeTargetSpecifier, identifier, colonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AttributeSyntax Attribute(NameSyntax name, AttributeArgumentListSyntax argumentList)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Attribute, name, argumentList, out hash);
      if (cached != null) return (AttributeSyntax)cached;

      var result = new AttributeSyntax(SyntaxKind.Attribute, name, argumentList);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AttributeArgumentListSyntax AttributeArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeArgumentList, openParenToken, arguments.Node, closeParenToken, out hash);
      if (cached != null) return (AttributeArgumentListSyntax)cached;

      var result = new AttributeArgumentListSyntax(SyntaxKind.AttributeArgumentList, openParenToken, arguments.Node, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeArgument, nameEquals, nameColon, expression, out hash);
      if (cached != null) return (AttributeArgumentSyntax)cached;

      var result = new AttributeArgumentSyntax(SyntaxKind.AttributeArgument, nameEquals, nameColon, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static NameEqualsSyntax NameEquals(IdentifierNameSyntax name, SyntaxToken equalsToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NameEquals, name, equalsToken, out hash);
      if (cached != null) return (NameEqualsSyntax)cached;

      var result = new NameEqualsSyntax(SyntaxKind.NameEquals, name, equalsToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeParameterList, lessThanToken, parameters.Node, greaterThanToken, out hash);
      if (cached != null) return (TypeParameterListSyntax)cached;

      var result = new TypeParameterListSyntax(SyntaxKind.TypeParameterList, lessThanToken, parameters.Node, greaterThanToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TypeParameterSyntax TypeParameter(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)
    {
#if DEBUG
      if (varianceKeyword != null)
      {
      switch (varianceKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("varianceKeyword");
      }
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeParameter, attributeLists.Node, varianceKeyword, identifier, out hash);
      if (cached != null) return (TypeParameterSyntax)cached;

      var result = new TypeParameterSyntax(SyntaxKind.TypeParameter, attributeLists.Node, varianceKeyword, identifier);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ClassDeclarationSyntax ClassDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.ClassKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new ClassDeclarationSyntax(SyntaxKind.ClassDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken);
    }

    public static StructDeclarationSyntax StructDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.StructKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new StructDeclarationSyntax(SyntaxKind.StructDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken);
    }

    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.InterfaceKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new InterfaceDeclarationSyntax(SyntaxKind.InterfaceDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken);
    }

    public static EnumDeclarationSyntax EnumDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (enumKeyword == null)
        throw new ArgumentNullException(nameof(enumKeyword));
      switch (enumKeyword.Kind)
      {
        case SyntaxKind.EnumKeyword:
          break;
        default:
          throw new ArgumentException("enumKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new EnumDeclarationSyntax(SyntaxKind.EnumDeclaration, attributeLists.Node, modifiers.Node, enumKeyword, identifier, baseList, openBraceToken, members.Node, closeBraceToken, semicolonToken);
    }

    public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken delegateKeyword, SyntaxToken refKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (delegateKeyword == null)
        throw new ArgumentNullException(nameof(delegateKeyword));
      switch (delegateKeyword.Kind)
      {
        case SyntaxKind.DelegateKeyword:
          break;
        default:
          throw new ArgumentException("delegateKeyword");
      }
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new DelegateDeclarationSyntax(SyntaxKind.DelegateDeclaration, attributeLists.Node, modifiers.Node, delegateKeyword, refKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses.Node, semicolonToken);
    }

    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.EnumMemberDeclaration, attributeLists.Node, identifier, equalsValue, out hash);
      if (cached != null) return (EnumMemberDeclarationSyntax)cached;

      var result = new EnumMemberDeclarationSyntax(SyntaxKind.EnumMemberDeclaration, attributeLists.Node, identifier, equalsValue);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static BaseListSyntax BaseList(SyntaxToken colonToken, SeparatedSyntaxList<BaseTypeSyntax> types)
    {
#if DEBUG
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BaseList, colonToken, types.Node, out hash);
      if (cached != null) return (BaseListSyntax)cached;

      var result = new BaseListSyntax(SyntaxKind.BaseList, colonToken, types.Node);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static SimpleBaseTypeSyntax SimpleBaseType(TypeSyntax type)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SimpleBaseType, type, out hash);
      if (cached != null) return (SimpleBaseTypeSyntax)cached;

      var result = new SimpleBaseTypeSyntax(SyntaxKind.SimpleBaseType, type);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
    {
#if DEBUG
      if (whereKeyword == null)
        throw new ArgumentNullException(nameof(whereKeyword));
      switch (whereKeyword.Kind)
      {
        case SyntaxKind.WhereKeyword:
          break;
        default:
          throw new ArgumentException("whereKeyword");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      return new TypeParameterConstraintClauseSyntax(SyntaxKind.TypeParameterConstraintClause, whereKeyword, name, colonToken, constraints.Node);
    }

    public static ConstructorConstraintSyntax ConstructorConstraint(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ConstructorConstraint, newKeyword, openParenToken, closeParenToken, out hash);
      if (cached != null) return (ConstructorConstraintSyntax)cached;

      var result = new ConstructorConstraintSyntax(SyntaxKind.ConstructorConstraint, newKeyword, openParenToken, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind, SyntaxToken classOrStructKeyword)
    {
      switch (kind)
      {
        case SyntaxKind.ClassConstraint:
        case SyntaxKind.StructConstraint:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (classOrStructKeyword == null)
        throw new ArgumentNullException(nameof(classOrStructKeyword));
      switch (classOrStructKeyword.Kind)
      {
        case SyntaxKind.ClassKeyword:
        case SyntaxKind.StructKeyword:
          break;
        default:
          throw new ArgumentException("classOrStructKeyword");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, classOrStructKeyword, out hash);
      if (cached != null) return (ClassOrStructConstraintSyntax)cached;

      var result = new ClassOrStructConstraintSyntax(kind, classOrStructKeyword);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TypeConstraintSyntax TypeConstraint(TypeSyntax type)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeConstraint, type, out hash);
      if (cached != null) return (TypeConstraintSyntax)cached;

      var result = new TypeConstraintSyntax(SyntaxKind.TypeConstraint, type);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static FieldDeclarationSyntax FieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new FieldDeclarationSyntax(SyntaxKind.FieldDeclaration, attributeLists.Node, modifiers.Node, declaration, semicolonToken);
    }

    public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (eventKeyword == null)
        throw new ArgumentNullException(nameof(eventKeyword));
      switch (eventKeyword.Kind)
      {
        case SyntaxKind.EventKeyword:
          break;
        default:
          throw new ArgumentException("eventKeyword");
      }
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new EventFieldDeclarationSyntax(SyntaxKind.EventFieldDeclaration, attributeLists.Node, modifiers.Node, eventKeyword, declaration, semicolonToken);
    }

    public static ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name, SyntaxToken dotToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (dotToken == null)
        throw new ArgumentNullException(nameof(dotToken));
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("dotToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ExplicitInterfaceSpecifier, name, dotToken, out hash);
      if (cached != null) return (ExplicitInterfaceSpecifierSyntax)cached;

      var result = new ExplicitInterfaceSpecifierSyntax(SyntaxKind.ExplicitInterfaceSpecifier, name, dotToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static MethodDeclarationSyntax MethodDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken refKeyword, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new MethodDeclarationSyntax(SyntaxKind.MethodDeclaration, attributeLists.Node, modifiers.Node, refKeyword, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses.Node, body, expressionBody, semicolonToken);
    }

    public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.TrueKeyword:
        case SyntaxKind.IsKeyword:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new OperatorDeclarationSyntax(SyntaxKind.OperatorDeclaration, attributeLists.Node, modifiers.Node, returnType, operatorKeyword, operatorToken, parameterList, body, expressionBody, semicolonToken);
    }

    public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (implicitOrExplicitKeyword == null)
        throw new ArgumentNullException(nameof(implicitOrExplicitKeyword));
      switch (implicitOrExplicitKeyword.Kind)
      {
        case SyntaxKind.ImplicitKeyword:
        case SyntaxKind.ExplicitKeyword:
          break;
        default:
          throw new ArgumentException("implicitOrExplicitKeyword");
      }
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new ConversionOperatorDeclarationSyntax(SyntaxKind.ConversionOperatorDeclaration, attributeLists.Node, modifiers.Node, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, expressionBody, semicolonToken);
    }

    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new ConstructorDeclarationSyntax(SyntaxKind.ConstructorDeclaration, attributeLists.Node, modifiers.Node, identifier, parameterList, initializer, body, semicolonToken);
    }

    public static ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
    {
      switch (kind)
      {
        case SyntaxKind.BaseConstructorInitializer:
        case SyntaxKind.ThisConstructorInitializer:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      if (thisOrBaseKeyword == null)
        throw new ArgumentNullException(nameof(thisOrBaseKeyword));
      switch (thisOrBaseKeyword.Kind)
      {
        case SyntaxKind.BaseKeyword:
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("thisOrBaseKeyword");
      }
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, colonToken, thisOrBaseKeyword, argumentList, out hash);
      if (cached != null) return (ConstructorInitializerSyntax)cached;

      var result = new ConstructorInitializerSyntax(kind, colonToken, thisOrBaseKeyword, argumentList);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (tildeToken == null)
        throw new ArgumentNullException(nameof(tildeToken));
      switch (tildeToken.Kind)
      {
        case SyntaxKind.TildeToken:
          break;
        default:
          throw new ArgumentException("tildeToken");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new DestructorDeclarationSyntax(SyntaxKind.DestructorDeclaration, attributeLists.Node, modifiers.Node, tildeToken, identifier, parameterList, body, semicolonToken);
    }

    public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken refKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new PropertyDeclarationSyntax(SyntaxKind.PropertyDeclaration, attributeLists.Node, modifiers.Node, refKeyword, type, explicitInterfaceSpecifier, identifier, accessorList, expressionBody, initializer, semicolonToken);
    }

    public static ArrowExpressionClauseSyntax ArrowExpressionClause(SyntaxToken arrowToken, SyntaxToken refKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (arrowToken == null)
        throw new ArgumentNullException(nameof(arrowToken));
      switch (arrowToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException("arrowToken");
      }
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrowExpressionClause, arrowToken, refKeyword, expression, out hash);
      if (cached != null) return (ArrowExpressionClauseSyntax)cached;

      var result = new ArrowExpressionClauseSyntax(SyntaxKind.ArrowExpressionClause, arrowToken, refKeyword, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static EventDeclarationSyntax EventDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
    {
#if DEBUG
      if (eventKeyword == null)
        throw new ArgumentNullException(nameof(eventKeyword));
      switch (eventKeyword.Kind)
      {
        case SyntaxKind.EventKeyword:
          break;
        default:
          throw new ArgumentException("eventKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (accessorList == null)
        throw new ArgumentNullException(nameof(accessorList));
#endif

      return new EventDeclarationSyntax(SyntaxKind.EventDeclaration, attributeLists.Node, modifiers.Node, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList);
    }

    public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken refKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (thisKeyword == null)
        throw new ArgumentNullException(nameof(thisKeyword));
      switch (thisKeyword.Kind)
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("thisKeyword");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new IndexerDeclarationSyntax(SyntaxKind.IndexerDeclaration, attributeLists.Node, modifiers.Node, refKeyword, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList, expressionBody, semicolonToken);
    }

    public static AccessorListSyntax AccessorList(SyntaxToken openBraceToken, SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AccessorList, openBraceToken, accessors.Node, closeBraceToken, out hash);
      if (cached != null) return (AccessorListSyntax)cached;

      var result = new AccessorListSyntax(SyntaxKind.AccessorList, openBraceToken, accessors.Node, closeBraceToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.GetAccessorDeclaration:
        case SyntaxKind.SetAccessorDeclaration:
        case SyntaxKind.AddAccessorDeclaration:
        case SyntaxKind.RemoveAccessorDeclaration:
        case SyntaxKind.UnknownAccessorDeclaration:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.GetKeyword:
        case SyntaxKind.SetKeyword:
        case SyntaxKind.AddKeyword:
        case SyntaxKind.RemoveKeyword:
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new AccessorDeclarationSyntax(kind, attributeLists.Node, modifiers.Node, keyword, body, semicolonToken);
    }

    public static ParameterListSyntax ParameterList(SyntaxToken openParenToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken, out hash);
      if (cached != null) return (ParameterListSyntax)cached;

      var result = new ParameterListSyntax(SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static BracketedParameterListSyntax BracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, out hash);
      if (cached != null) return (BracketedParameterListSyntax)cached;

      var result = new BracketedParameterListSyntax(SyntaxKind.BracketedParameterList, openBracketToken, parameters.Node, closeBracketToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ParameterSyntax Parameter(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.ArgListKeyword:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      return new ParameterSyntax(SyntaxKind.Parameter, attributeLists.Node, modifiers.Node, type, identifier, @default);
    }

    public static IncompleteMemberSyntax IncompleteMember(SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<SyntaxToken> modifiers, SyntaxToken refKeyword, TypeSyntax type)
    {
#if DEBUG
      if (refKeyword != null)
      {
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      }
#endif

      return new IncompleteMemberSyntax(SyntaxKind.IncompleteMember, attributeLists.Node, modifiers.Node, refKeyword, type);
    }

    public static SkippedTokensTriviaSyntax SkippedTokensTrivia(SyntaxList<SyntaxToken> tokens)
    {
#if DEBUG
#endif

      return new SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, tokens.Node);
    }

    public static DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment)
    {
      switch (kind)
      {
        case SyntaxKind.SingleLineDocumentationCommentTrivia:
        case SyntaxKind.MultiLineDocumentationCommentTrivia:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (endOfComment == null)
        throw new ArgumentNullException(nameof(endOfComment));
      switch (endOfComment.Kind)
      {
        case SyntaxKind.EndOfDocumentationCommentToken:
          break;
        default:
          throw new ArgumentException("endOfComment");
      }
#endif

      return new DocumentationCommentTriviaSyntax(kind, content.Node, endOfComment);
    }

    public static TypeCrefSyntax TypeCref(TypeSyntax type)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeCref, type, out hash);
      if (cached != null) return (TypeCrefSyntax)cached;

      var result = new TypeCrefSyntax(SyntaxKind.TypeCref, type);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static QualifiedCrefSyntax QualifiedCref(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)
    {
#if DEBUG
      if (container == null)
        throw new ArgumentNullException(nameof(container));
      if (dotToken == null)
        throw new ArgumentNullException(nameof(dotToken));
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("dotToken");
      }
      if (member == null)
        throw new ArgumentNullException(nameof(member));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QualifiedCref, container, dotToken, member, out hash);
      if (cached != null) return (QualifiedCrefSyntax)cached;

      var result = new QualifiedCrefSyntax(SyntaxKind.QualifiedCref, container, dotToken, member);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static NameMemberCrefSyntax NameMemberCref(TypeSyntax name, CrefParameterListSyntax parameters)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NameMemberCref, name, parameters, out hash);
      if (cached != null) return (NameMemberCrefSyntax)cached;

      var result = new NameMemberCrefSyntax(SyntaxKind.NameMemberCref, name, parameters);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static IndexerMemberCrefSyntax IndexerMemberCref(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)
    {
#if DEBUG
      if (thisKeyword == null)
        throw new ArgumentNullException(nameof(thisKeyword));
      switch (thisKeyword.Kind)
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("thisKeyword");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IndexerMemberCref, thisKeyword, parameters, out hash);
      if (cached != null) return (IndexerMemberCrefSyntax)cached;

      var result = new IndexerMemberCrefSyntax(SyntaxKind.IndexerMemberCref, thisKeyword, parameters);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)
    {
#if DEBUG
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.TrueKeyword:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OperatorMemberCref, operatorKeyword, operatorToken, parameters, out hash);
      if (cached != null) return (OperatorMemberCrefSyntax)cached;

      var result = new OperatorMemberCrefSyntax(SyntaxKind.OperatorMemberCref, operatorKeyword, operatorToken, parameters);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters)
    {
#if DEBUG
      if (implicitOrExplicitKeyword == null)
        throw new ArgumentNullException(nameof(implicitOrExplicitKeyword));
      switch (implicitOrExplicitKeyword.Kind)
      {
        case SyntaxKind.ImplicitKeyword:
        case SyntaxKind.ExplicitKeyword:
          break;
        default:
          throw new ArgumentException("implicitOrExplicitKeyword");
      }
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      return new ConversionOperatorMemberCrefSyntax(SyntaxKind.ConversionOperatorMemberCref, implicitOrExplicitKeyword, operatorKeyword, type, parameters);
    }

    public static CrefParameterListSyntax CrefParameterList(SyntaxToken openParenToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefParameterList, openParenToken, parameters.Node, closeParenToken, out hash);
      if (cached != null) return (CrefParameterListSyntax)cached;

      var result = new CrefParameterListSyntax(SyntaxKind.CrefParameterList, openParenToken, parameters.Node, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static CrefBracketedParameterListSyntax CrefBracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefBracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, out hash);
      if (cached != null) return (CrefBracketedParameterListSyntax)cached;

      var result = new CrefBracketedParameterListSyntax(SyntaxKind.CrefBracketedParameterList, openBracketToken, parameters.Node, closeBracketToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static CrefParameterSyntax CrefParameter(SyntaxToken refOrOutKeyword, TypeSyntax type)
    {
#if DEBUG
      if (refOrOutKeyword != null)
      {
      switch (refOrOutKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refOrOutKeyword");
      }
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefParameter, refOrOutKeyword, type, out hash);
      if (cached != null) return (CrefParameterSyntax)cached;

      var result = new CrefParameterSyntax(SyntaxKind.CrefParameter, refOrOutKeyword, type);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
    {
#if DEBUG
      if (startTag == null)
        throw new ArgumentNullException(nameof(startTag));
      if (endTag == null)
        throw new ArgumentNullException(nameof(endTag));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElement, startTag, content.Node, endTag, out hash);
      if (cached != null) return (XmlElementSyntax)cached;

      var result = new XmlElementSyntax(SyntaxKind.XmlElement, startTag, content.Node, endTag);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      return new XmlElementStartTagSyntax(SyntaxKind.XmlElementStartTag, lessThanToken, name, attributes.Node, greaterThanToken);
    }

    public static XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanSlashToken == null)
        throw new ArgumentNullException(nameof(lessThanSlashToken));
      switch (lessThanSlashToken.Kind)
      {
        case SyntaxKind.LessThanSlashToken:
          break;
        default:
          throw new ArgumentException("lessThanSlashToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken, out hash);
      if (cached != null) return (XmlElementEndTagSyntax)cached;

      var result = new XmlElementEndTagSyntax(SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (slashGreaterThanToken == null)
        throw new ArgumentNullException(nameof(slashGreaterThanToken));
      switch (slashGreaterThanToken.Kind)
      {
        case SyntaxKind.SlashGreaterThanToken:
          break;
        default:
          throw new ArgumentException("slashGreaterThanToken");
      }
#endif

      return new XmlEmptyElementSyntax(SyntaxKind.XmlEmptyElement, lessThanToken, name, attributes.Node, slashGreaterThanToken);
    }

    public static XmlNameSyntax XmlName(XmlPrefixSyntax prefix, SyntaxToken localName)
    {
#if DEBUG
      if (localName == null)
        throw new ArgumentNullException(nameof(localName));
      switch (localName.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("localName");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlName, prefix, localName, out hash);
      if (cached != null) return (XmlNameSyntax)cached;

      var result = new XmlNameSyntax(SyntaxKind.XmlName, prefix, localName);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlPrefixSyntax XmlPrefix(SyntaxToken prefix, SyntaxToken colonToken)
    {
#if DEBUG
      if (prefix == null)
        throw new ArgumentNullException(nameof(prefix));
      switch (prefix.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("prefix");
      }
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlPrefix, prefix, colonToken, out hash);
      if (cached != null) return (XmlPrefixSyntax)cached;

      var result = new XmlPrefixSyntax(SyntaxKind.XmlPrefix, prefix, colonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxList<SyntaxToken> textTokens, SyntaxToken endQuoteToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (startQuoteToken == null)
        throw new ArgumentNullException(nameof(startQuoteToken));
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("startQuoteToken");
      }
      if (endQuoteToken == null)
        throw new ArgumentNullException(nameof(endQuoteToken));
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("endQuoteToken");
      }
#endif

      return new XmlTextAttributeSyntax(SyntaxKind.XmlTextAttribute, name, equalsToken, startQuoteToken, textTokens.Node, endQuoteToken);
    }

    public static XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (startQuoteToken == null)
        throw new ArgumentNullException(nameof(startQuoteToken));
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("startQuoteToken");
      }
      if (cref == null)
        throw new ArgumentNullException(nameof(cref));
      if (endQuoteToken == null)
        throw new ArgumentNullException(nameof(endQuoteToken));
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("endQuoteToken");
      }
#endif

      return new XmlCrefAttributeSyntax(SyntaxKind.XmlCrefAttribute, name, equalsToken, startQuoteToken, cref, endQuoteToken);
    }

    public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (startQuoteToken == null)
        throw new ArgumentNullException(nameof(startQuoteToken));
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("startQuoteToken");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      if (endQuoteToken == null)
        throw new ArgumentNullException(nameof(endQuoteToken));
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("endQuoteToken");
      }
#endif

      return new XmlNameAttributeSyntax(SyntaxKind.XmlNameAttribute, name, equalsToken, startQuoteToken, identifier, endQuoteToken);
    }

    public static XmlTextSyntax XmlText(SyntaxList<SyntaxToken> textTokens)
    {
#if DEBUG
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlText, textTokens.Node, out hash);
      if (cached != null) return (XmlTextSyntax)cached;

      var result = new XmlTextSyntax(SyntaxKind.XmlText, textTokens.Node);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlCDataSectionSyntax XmlCDataSection(SyntaxToken startCDataToken, SyntaxList<SyntaxToken> textTokens, SyntaxToken endCDataToken)
    {
#if DEBUG
      if (startCDataToken == null)
        throw new ArgumentNullException(nameof(startCDataToken));
      switch (startCDataToken.Kind)
      {
        case SyntaxKind.XmlCDataStartToken:
          break;
        default:
          throw new ArgumentException("startCDataToken");
      }
      if (endCDataToken == null)
        throw new ArgumentNullException(nameof(endCDataToken));
      switch (endCDataToken.Kind)
      {
        case SyntaxKind.XmlCDataEndToken:
          break;
        default:
          throw new ArgumentException("endCDataToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken, out hash);
      if (cached != null) return (XmlCDataSectionSyntax)cached;

      var result = new XmlCDataSectionSyntax(SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxList<SyntaxToken> textTokens, SyntaxToken endProcessingInstructionToken)
    {
#if DEBUG
      if (startProcessingInstructionToken == null)
        throw new ArgumentNullException(nameof(startProcessingInstructionToken));
      switch (startProcessingInstructionToken.Kind)
      {
        case SyntaxKind.XmlProcessingInstructionStartToken:
          break;
        default:
          throw new ArgumentException("startProcessingInstructionToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (endProcessingInstructionToken == null)
        throw new ArgumentNullException(nameof(endProcessingInstructionToken));
      switch (endProcessingInstructionToken.Kind)
      {
        case SyntaxKind.XmlProcessingInstructionEndToken:
          break;
        default:
          throw new ArgumentException("endProcessingInstructionToken");
      }
#endif

      return new XmlProcessingInstructionSyntax(SyntaxKind.XmlProcessingInstruction, startProcessingInstructionToken, name, textTokens.Node, endProcessingInstructionToken);
    }

    public static XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxList<SyntaxToken> textTokens, SyntaxToken minusMinusGreaterThanToken)
    {
#if DEBUG
      if (lessThanExclamationMinusMinusToken == null)
        throw new ArgumentNullException(nameof(lessThanExclamationMinusMinusToken));
      switch (lessThanExclamationMinusMinusToken.Kind)
      {
        case SyntaxKind.XmlCommentStartToken:
          break;
        default:
          throw new ArgumentException("lessThanExclamationMinusMinusToken");
      }
      if (minusMinusGreaterThanToken == null)
        throw new ArgumentNullException(nameof(minusMinusGreaterThanToken));
      switch (minusMinusGreaterThanToken.Kind)
      {
        case SyntaxKind.XmlCommentEndToken:
          break;
        default:
          throw new ArgumentException("minusMinusGreaterThanToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken, out hash);
      if (cached != null) return (XmlCommentSyntax)cached;

      var result = new XmlCommentSyntax(SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (ifKeyword == null)
        throw new ArgumentNullException(nameof(ifKeyword));
      switch (ifKeyword.Kind)
      {
        case SyntaxKind.IfKeyword:
          break;
        default:
          throw new ArgumentException("ifKeyword");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new IfDirectiveTriviaSyntax(SyntaxKind.IfDirectiveTrivia, hashToken, ifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
    }

    public static ElifDirectiveTriviaSyntax ElifDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (elifKeyword == null)
        throw new ArgumentNullException(nameof(elifKeyword));
      switch (elifKeyword.Kind)
      {
        case SyntaxKind.ElifKeyword:
          break;
        default:
          throw new ArgumentException("elifKeyword");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ElifDirectiveTriviaSyntax(SyntaxKind.ElifDirectiveTrivia, hashToken, elifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
    }

    public static ElseDirectiveTriviaSyntax ElseDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (elseKeyword == null)
        throw new ArgumentNullException(nameof(elseKeyword));
      switch (elseKeyword.Kind)
      {
        case SyntaxKind.ElseKeyword:
          break;
        default:
          throw new ArgumentException("elseKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ElseDirectiveTriviaSyntax(SyntaxKind.ElseDirectiveTrivia, hashToken, elseKeyword, endOfDirectiveToken, isActive, branchTaken);
    }

    public static EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (endIfKeyword == null)
        throw new ArgumentNullException(nameof(endIfKeyword));
      switch (endIfKeyword.Kind)
      {
        case SyntaxKind.EndIfKeyword:
          break;
        default:
          throw new ArgumentException("endIfKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new EndIfDirectiveTriviaSyntax(SyntaxKind.EndIfDirectiveTrivia, hashToken, endIfKeyword, endOfDirectiveToken, isActive);
    }

    public static RegionDirectiveTriviaSyntax RegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (regionKeyword == null)
        throw new ArgumentNullException(nameof(regionKeyword));
      switch (regionKeyword.Kind)
      {
        case SyntaxKind.RegionKeyword:
          break;
        default:
          throw new ArgumentException("regionKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new RegionDirectiveTriviaSyntax(SyntaxKind.RegionDirectiveTrivia, hashToken, regionKeyword, endOfDirectiveToken, isActive);
    }

    public static EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (endRegionKeyword == null)
        throw new ArgumentNullException(nameof(endRegionKeyword));
      switch (endRegionKeyword.Kind)
      {
        case SyntaxKind.EndRegionKeyword:
          break;
        default:
          throw new ArgumentException("endRegionKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new EndRegionDirectiveTriviaSyntax(SyntaxKind.EndRegionDirectiveTrivia, hashToken, endRegionKeyword, endOfDirectiveToken, isActive);
    }

    public static ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (errorKeyword == null)
        throw new ArgumentNullException(nameof(errorKeyword));
      switch (errorKeyword.Kind)
      {
        case SyntaxKind.ErrorKeyword:
          break;
        default:
          throw new ArgumentException("errorKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ErrorDirectiveTriviaSyntax(SyntaxKind.ErrorDirectiveTrivia, hashToken, errorKeyword, endOfDirectiveToken, isActive);
    }

    public static WarningDirectiveTriviaSyntax WarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (warningKeyword == null)
        throw new ArgumentNullException(nameof(warningKeyword));
      switch (warningKeyword.Kind)
      {
        case SyntaxKind.WarningKeyword:
          break;
        default:
          throw new ArgumentException("warningKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new WarningDirectiveTriviaSyntax(SyntaxKind.WarningDirectiveTrivia, hashToken, warningKeyword, endOfDirectiveToken, isActive);
    }

    public static BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new BadDirectiveTriviaSyntax(SyntaxKind.BadDirectiveTrivia, hashToken, identifier, endOfDirectiveToken, isActive);
    }

    public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (defineKeyword == null)
        throw new ArgumentNullException(nameof(defineKeyword));
      switch (defineKeyword.Kind)
      {
        case SyntaxKind.DefineKeyword:
          break;
        default:
          throw new ArgumentException("defineKeyword");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (name.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("name");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new DefineDirectiveTriviaSyntax(SyntaxKind.DefineDirectiveTrivia, hashToken, defineKeyword, name, endOfDirectiveToken, isActive);
    }

    public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (undefKeyword == null)
        throw new ArgumentNullException(nameof(undefKeyword));
      switch (undefKeyword.Kind)
      {
        case SyntaxKind.UndefKeyword:
          break;
        default:
          throw new ArgumentException("undefKeyword");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (name.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("name");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new UndefDirectiveTriviaSyntax(SyntaxKind.UndefDirectiveTrivia, hashToken, undefKeyword, name, endOfDirectiveToken, isActive);
    }

    public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (lineKeyword == null)
        throw new ArgumentNullException(nameof(lineKeyword));
      switch (lineKeyword.Kind)
      {
        case SyntaxKind.LineKeyword:
          break;
        default:
          throw new ArgumentException("lineKeyword");
      }
      if (line == null)
        throw new ArgumentNullException(nameof(line));
      switch (line.Kind)
      {
        case SyntaxKind.NumericLiteralToken:
        case SyntaxKind.DefaultKeyword:
        case SyntaxKind.HiddenKeyword:
          break;
        default:
          throw new ArgumentException("line");
      }
      if (file != null)
      {
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("file");
      }
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new LineDirectiveTriviaSyntax(SyntaxKind.LineDirectiveTrivia, hashToken, lineKeyword, line, file, endOfDirectiveToken, isActive);
    }

    public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (pragmaKeyword == null)
        throw new ArgumentNullException(nameof(pragmaKeyword));
      switch (pragmaKeyword.Kind)
      {
        case SyntaxKind.PragmaKeyword:
          break;
        default:
          throw new ArgumentException("pragmaKeyword");
      }
      if (warningKeyword == null)
        throw new ArgumentNullException(nameof(warningKeyword));
      switch (warningKeyword.Kind)
      {
        case SyntaxKind.WarningKeyword:
          break;
        default:
          throw new ArgumentException("warningKeyword");
      }
      if (disableOrRestoreKeyword == null)
        throw new ArgumentNullException(nameof(disableOrRestoreKeyword));
      switch (disableOrRestoreKeyword.Kind)
      {
        case SyntaxKind.DisableKeyword:
        case SyntaxKind.RestoreKeyword:
          break;
        default:
          throw new ArgumentException("disableOrRestoreKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new PragmaWarningDirectiveTriviaSyntax(SyntaxKind.PragmaWarningDirectiveTrivia, hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes.Node, endOfDirectiveToken, isActive);
    }

    public static PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (pragmaKeyword == null)
        throw new ArgumentNullException(nameof(pragmaKeyword));
      switch (pragmaKeyword.Kind)
      {
        case SyntaxKind.PragmaKeyword:
          break;
        default:
          throw new ArgumentException("pragmaKeyword");
      }
      if (checksumKeyword == null)
        throw new ArgumentNullException(nameof(checksumKeyword));
      switch (checksumKeyword.Kind)
      {
        case SyntaxKind.ChecksumKeyword:
          break;
        default:
          throw new ArgumentException("checksumKeyword");
      }
      if (file == null)
        throw new ArgumentNullException(nameof(file));
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("file");
      }
      if (guid == null)
        throw new ArgumentNullException(nameof(guid));
      switch (guid.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("guid");
      }
      if (bytes == null)
        throw new ArgumentNullException(nameof(bytes));
      switch (bytes.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("bytes");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new PragmaChecksumDirectiveTriviaSyntax(SyntaxKind.PragmaChecksumDirectiveTrivia, hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, isActive);
    }

    public static ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (referenceKeyword == null)
        throw new ArgumentNullException(nameof(referenceKeyword));
      switch (referenceKeyword.Kind)
      {
        case SyntaxKind.ReferenceKeyword:
          break;
        default:
          throw new ArgumentException("referenceKeyword");
      }
      if (file == null)
        throw new ArgumentNullException(nameof(file));
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("file");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ReferenceDirectiveTriviaSyntax(SyntaxKind.ReferenceDirectiveTrivia, hashToken, referenceKeyword, file, endOfDirectiveToken, isActive);
    }

    public static LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (loadKeyword == null)
        throw new ArgumentNullException(nameof(loadKeyword));
      switch (loadKeyword.Kind)
      {
        case SyntaxKind.LoadKeyword:
          break;
        default:
          throw new ArgumentException("loadKeyword");
      }
      if (file == null)
        throw new ArgumentNullException(nameof(file));
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("file");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new LoadDirectiveTriviaSyntax(SyntaxKind.LoadDirectiveTrivia, hashToken, loadKeyword, file, endOfDirectiveToken, isActive);
    }

    public static ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (exclamationToken == null)
        throw new ArgumentNullException(nameof(exclamationToken));
      switch (exclamationToken.Kind)
      {
        case SyntaxKind.ExclamationToken:
          break;
        default:
          throw new ArgumentException("exclamationToken");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ShebangDirectiveTriviaSyntax(SyntaxKind.ShebangDirectiveTrivia, hashToken, exclamationToken, endOfDirectiveToken, isActive);
    }

    internal static IEnumerable<Type> GetNodeTypes()
    {
        return new Type[] {
           typeof(IdentifierNameSyntax),
           typeof(QualifiedNameSyntax),
           typeof(GenericNameSyntax),
           typeof(TypeArgumentListSyntax),
           typeof(AliasQualifiedNameSyntax),
           typeof(PredefinedTypeSyntax),
           typeof(ArrayTypeSyntax),
           typeof(ArrayRankSpecifierSyntax),
           typeof(PointerTypeSyntax),
           typeof(NullableTypeSyntax),
           typeof(TupleTypeSyntax),
           typeof(TupleElementSyntax),
           typeof(OmittedTypeArgumentSyntax),
           typeof(ParenthesizedExpressionSyntax),
           typeof(TupleExpressionSyntax),
           typeof(PrefixUnaryExpressionSyntax),
           typeof(AwaitExpressionSyntax),
           typeof(PostfixUnaryExpressionSyntax),
           typeof(MemberAccessExpressionSyntax),
           typeof(ConditionalAccessExpressionSyntax),
           typeof(MemberBindingExpressionSyntax),
           typeof(ElementBindingExpressionSyntax),
           typeof(ImplicitElementAccessSyntax),
           typeof(BinaryExpressionSyntax),
           typeof(AssignmentExpressionSyntax),
           typeof(ConditionalExpressionSyntax),
           typeof(ThisExpressionSyntax),
           typeof(BaseExpressionSyntax),
           typeof(OriginalExpressionSyntax),
           typeof(LiteralExpressionSyntax),
           typeof(MakeRefExpressionSyntax),
           typeof(RefTypeExpressionSyntax),
           typeof(RefValueExpressionSyntax),
           typeof(CheckedExpressionSyntax),
           typeof(DefaultExpressionSyntax),
           typeof(TypeOfExpressionSyntax),
           typeof(SizeOfExpressionSyntax),
           typeof(InvocationExpressionSyntax),
           typeof(ElementAccessExpressionSyntax),
           typeof(ArgumentListSyntax),
           typeof(BracketedArgumentListSyntax),
           typeof(ArgumentSyntax),
           typeof(NameColonSyntax),
           typeof(CastExpressionSyntax),
           typeof(AnonymousMethodExpressionSyntax),
           typeof(SimpleLambdaExpressionSyntax),
           typeof(ParenthesizedLambdaExpressionSyntax),
           typeof(InitializerExpressionSyntax),
           typeof(ObjectCreationExpressionSyntax),
           typeof(AnonymousObjectMemberDeclaratorSyntax),
           typeof(AnonymousObjectCreationExpressionSyntax),
           typeof(ArrayCreationExpressionSyntax),
           typeof(ImplicitArrayCreationExpressionSyntax),
           typeof(StackAllocArrayCreationExpressionSyntax),
           typeof(QueryExpressionSyntax),
           typeof(QueryBodySyntax),
           typeof(FromClauseSyntax),
           typeof(LetClauseSyntax),
           typeof(JoinClauseSyntax),
           typeof(JoinIntoClauseSyntax),
           typeof(WhereClauseSyntax),
           typeof(OrderByClauseSyntax),
           typeof(OrderingSyntax),
           typeof(SelectClauseSyntax),
           typeof(GroupClauseSyntax),
           typeof(QueryContinuationSyntax),
           typeof(OmittedArraySizeExpressionSyntax),
           typeof(InterpolatedStringExpressionSyntax),
           typeof(IsPatternExpressionSyntax),
           typeof(WhenClauseSyntax),
           typeof(DeclarationPatternSyntax),
           typeof(ConstantPatternSyntax),
           typeof(InterpolatedStringTextSyntax),
           typeof(InterpolationSyntax),
           typeof(InterpolationAlignmentClauseSyntax),
           typeof(InterpolationFormatClauseSyntax),
           typeof(GlobalStatementSyntax),
           typeof(BlockSyntax),
           typeof(LocalFunctionStatementSyntax),
           typeof(LocalDeclarationStatementSyntax),
           typeof(VariableDeconstructionDeclaratorSyntax),
           typeof(VariableDeclarationSyntax),
           typeof(VariableDeclaratorSyntax),
           typeof(EqualsValueClauseSyntax),
           typeof(ExpressionStatementSyntax),
           typeof(EmptyStatementSyntax),
           typeof(LabeledStatementSyntax),
           typeof(GotoStatementSyntax),
           typeof(BreakStatementSyntax),
           typeof(ContinueStatementSyntax),
           typeof(ReturnStatementSyntax),
           typeof(ThrowStatementSyntax),
           typeof(YieldStatementSyntax),
           typeof(WhileStatementSyntax),
           typeof(DoStatementSyntax),
           typeof(ForStatementSyntax),
           typeof(ForEachStatementSyntax),
           typeof(UsingStatementSyntax),
           typeof(FixedStatementSyntax),
           typeof(CheckedStatementSyntax),
           typeof(UnsafeStatementSyntax),
           typeof(LockStatementSyntax),
           typeof(IfStatementSyntax),
           typeof(ElseClauseSyntax),
           typeof(SwitchStatementSyntax),
           typeof(SwitchSectionSyntax),
           typeof(CasePatternSwitchLabelSyntax),
           typeof(CaseSwitchLabelSyntax),
           typeof(DefaultSwitchLabelSyntax),
           typeof(TryStatementSyntax),
           typeof(CatchClauseSyntax),
           typeof(CatchDeclarationSyntax),
           typeof(CatchFilterClauseSyntax),
           typeof(FinallyClauseSyntax),
           typeof(CompilationUnitSyntax),
           typeof(ExternAliasDirectiveSyntax),
           typeof(UsingDirectiveSyntax),
           typeof(NamespaceDeclarationSyntax),
           typeof(AttributeListSyntax),
           typeof(AttributeTargetSpecifierSyntax),
           typeof(AttributeSyntax),
           typeof(AttributeArgumentListSyntax),
           typeof(AttributeArgumentSyntax),
           typeof(NameEqualsSyntax),
           typeof(TypeParameterListSyntax),
           typeof(TypeParameterSyntax),
           typeof(ClassDeclarationSyntax),
           typeof(StructDeclarationSyntax),
           typeof(InterfaceDeclarationSyntax),
           typeof(EnumDeclarationSyntax),
           typeof(DelegateDeclarationSyntax),
           typeof(EnumMemberDeclarationSyntax),
           typeof(BaseListSyntax),
           typeof(SimpleBaseTypeSyntax),
           typeof(TypeParameterConstraintClauseSyntax),
           typeof(ConstructorConstraintSyntax),
           typeof(ClassOrStructConstraintSyntax),
           typeof(TypeConstraintSyntax),
           typeof(FieldDeclarationSyntax),
           typeof(EventFieldDeclarationSyntax),
           typeof(ExplicitInterfaceSpecifierSyntax),
           typeof(MethodDeclarationSyntax),
           typeof(OperatorDeclarationSyntax),
           typeof(ConversionOperatorDeclarationSyntax),
           typeof(ConstructorDeclarationSyntax),
           typeof(ConstructorInitializerSyntax),
           typeof(DestructorDeclarationSyntax),
           typeof(PropertyDeclarationSyntax),
           typeof(ArrowExpressionClauseSyntax),
           typeof(EventDeclarationSyntax),
           typeof(IndexerDeclarationSyntax),
           typeof(AccessorListSyntax),
           typeof(AccessorDeclarationSyntax),
           typeof(ParameterListSyntax),
           typeof(BracketedParameterListSyntax),
           typeof(ParameterSyntax),
           typeof(IncompleteMemberSyntax),
           typeof(SkippedTokensTriviaSyntax),
           typeof(DocumentationCommentTriviaSyntax),
           typeof(TypeCrefSyntax),
           typeof(QualifiedCrefSyntax),
           typeof(NameMemberCrefSyntax),
           typeof(IndexerMemberCrefSyntax),
           typeof(OperatorMemberCrefSyntax),
           typeof(ConversionOperatorMemberCrefSyntax),
           typeof(CrefParameterListSyntax),
           typeof(CrefBracketedParameterListSyntax),
           typeof(CrefParameterSyntax),
           typeof(XmlElementSyntax),
           typeof(XmlElementStartTagSyntax),
           typeof(XmlElementEndTagSyntax),
           typeof(XmlEmptyElementSyntax),
           typeof(XmlNameSyntax),
           typeof(XmlPrefixSyntax),
           typeof(XmlTextAttributeSyntax),
           typeof(XmlCrefAttributeSyntax),
           typeof(XmlNameAttributeSyntax),
           typeof(XmlTextSyntax),
           typeof(XmlCDataSectionSyntax),
           typeof(XmlProcessingInstructionSyntax),
           typeof(XmlCommentSyntax),
           typeof(IfDirectiveTriviaSyntax),
           typeof(ElifDirectiveTriviaSyntax),
           typeof(ElseDirectiveTriviaSyntax),
           typeof(EndIfDirectiveTriviaSyntax),
           typeof(RegionDirectiveTriviaSyntax),
           typeof(EndRegionDirectiveTriviaSyntax),
           typeof(ErrorDirectiveTriviaSyntax),
           typeof(WarningDirectiveTriviaSyntax),
           typeof(BadDirectiveTriviaSyntax),
           typeof(DefineDirectiveTriviaSyntax),
           typeof(UndefDirectiveTriviaSyntax),
           typeof(LineDirectiveTriviaSyntax),
           typeof(PragmaWarningDirectiveTriviaSyntax),
           typeof(PragmaChecksumDirectiveTriviaSyntax),
           typeof(ReferenceDirectiveTriviaSyntax),
           typeof(LoadDirectiveTriviaSyntax),
           typeof(ShebangDirectiveTriviaSyntax)
        };
    }
  }
}

namespace Microsoft.CodeAnalysis.CSharp.Syntax
{
  /// <summary>Provides the base class from which the classes that represent name syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class NameSyntax : TypeSyntax
  {
    internal NameSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  /// <summary>Provides the base class from which the classes that represent simple name syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class SimpleNameSyntax : NameSyntax
  {
    internal SimpleNameSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the identifier of the simple name.</summary>
    public abstract SyntaxToken Identifier { get; }
  }

  /// <summary>Class which represents the syntax node for identifier name.</summary>
  public sealed partial class IdentifierNameSyntax : SimpleNameSyntax
  {
    internal IdentifierNameSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
    public override SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IdentifierNameSyntax)this.Green).identifier, this.Position, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIdentifierName(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIdentifierName(this);
    }

    public IdentifierNameSyntax Update(SyntaxToken identifier)
    {
        if (identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.IdentifierName(identifier);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public IdentifierNameSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(identifier);
    }
  }

  /// <summary>Class which represents the syntax node for qualified name.</summary>
  public sealed partial class QualifiedNameSyntax : NameSyntax
  {
    private NameSyntax left;
    private SimpleNameSyntax right;

    internal QualifiedNameSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>NameSyntax node representing the name on the left side of the dot token of the qualified name.</summary>
    public NameSyntax Left 
    {
        get
        {
            return this.GetRedAtZero(ref this.left);
        }
    }

    /// <summary>SyntaxToken representing the dot.</summary>
    public SyntaxToken DotToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QualifiedNameSyntax)this.Green).dotToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>SimpleNameSyntax node representing the name on the right side of the dot token of the qualified name.</summary>
    public SimpleNameSyntax Right 
    {
        get
        {
            return this.GetRed(ref this.right, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.left);
            case 2: return this.GetRed(ref this.right, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.left;
            case 2: return this.right;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQualifiedName(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitQualifiedName(this);
    }

    public QualifiedNameSyntax Update(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
    {
        if (left != this.Left || dotToken != this.DotToken || right != this.Right)
        {
            var newNode = SyntaxFactory.QualifiedName(left, dotToken, right);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public QualifiedNameSyntax WithLeft(NameSyntax left)
    {
        return this.Update(left, this.DotToken, this.Right);
    }

    public QualifiedNameSyntax WithDotToken(SyntaxToken dotToken)
    {
        return this.Update(this.Left, dotToken, this.Right);
    }

    public QualifiedNameSyntax WithRight(SimpleNameSyntax right)
    {
        return this.Update(this.Left, this.DotToken, right);
    }
  }

  /// <summary>Class which represents the syntax node for generic name.</summary>
  public sealed partial class GenericNameSyntax : SimpleNameSyntax
  {
    private TypeArgumentListSyntax typeArgumentList;

    internal GenericNameSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the name of the identifier of the generic name.</summary>
    public override SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GenericNameSyntax)this.Green).identifier, this.Position, 0); }
    }

    /// <summary>TypeArgumentListSyntax node representing the list of type arguments of the generic name.</summary>
    public TypeArgumentListSyntax TypeArgumentList 
    {
        get
        {
            return this.GetRed(ref this.typeArgumentList, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.typeArgumentList, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.typeArgumentList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGenericName(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitGenericName(this);
    }

    public GenericNameSyntax Update(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
    {
        if (identifier != this.Identifier || typeArgumentList != this.TypeArgumentList)
        {
            var newNode = SyntaxFactory.GenericName(identifier, typeArgumentList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public GenericNameSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(identifier, this.TypeArgumentList);
    }

    public GenericNameSyntax WithTypeArgumentList(TypeArgumentListSyntax typeArgumentList)
    {
        return this.Update(this.Identifier, typeArgumentList);
    }

    public GenericNameSyntax AddTypeArgumentListArguments(params TypeSyntax[] items)
    {
        return this.WithTypeArgumentList(this.TypeArgumentList.WithArguments(this.TypeArgumentList.Arguments.AddRange(items)));
    }
  }

  /// <summary>Class which represents the syntax node for type argument list.</summary>
  public sealed partial class TypeArgumentListSyntax : CSharpSyntaxNode
  {
    private SyntaxNode arguments;

    internal TypeArgumentListSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing less than.</summary>
    public SyntaxToken LessThanToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeArgumentListSyntax)this.Green).lessThanToken, this.Position, 0); }
    }

    /// <summary>SeparatedSyntaxList of TypeSyntax node representing the type arguments.</summary>
    public SeparatedSyntaxList<TypeSyntax> Arguments 
    {
        get
        {
            var red = this.GetRed(ref this.arguments, 1);
            if (red != null)
                return new SeparatedSyntaxList<TypeSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<TypeSyntax>);
        }
    }

    /// <summary>SyntaxToken representing greater than.</summary>
    public SyntaxToken GreaterThanToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeArgumentListSyntax)this.Green).greaterThanToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.arguments, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.arguments;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeArgumentList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeArgumentList(this);
    }

    public TypeArgumentListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || arguments != this.Arguments || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = SyntaxFactory.TypeArgumentList(lessThanToken, arguments, greaterThanToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TypeArgumentListSyntax WithLessThanToken(SyntaxToken lessThanToken)
    {
        return this.Update(lessThanToken, this.Arguments, this.GreaterThanToken);
    }

    public TypeArgumentListSyntax WithArguments(SeparatedSyntaxList<TypeSyntax> arguments)
    {
        return this.Update(this.LessThanToken, arguments, this.GreaterThanToken);
    }

    public TypeArgumentListSyntax WithGreaterThanToken(SyntaxToken greaterThanToken)
    {
        return this.Update(this.LessThanToken, this.Arguments, greaterThanToken);
    }

    public TypeArgumentListSyntax AddArguments(params TypeSyntax[] items)
    {
        return this.WithArguments(this.Arguments.AddRange(items));
    }
  }

  /// <summary>Class which represents the syntax node for alias qualified name.</summary>
  public sealed partial class AliasQualifiedNameSyntax : NameSyntax
  {
    private IdentifierNameSyntax alias;
    private SimpleNameSyntax name;

    internal AliasQualifiedNameSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>IdentifierNameSyntax node representing the name of the alias</summary>
    public IdentifierNameSyntax Alias 
    {
        get
        {
            return this.GetRedAtZero(ref this.alias);
        }
    }

    /// <summary>SyntaxToken representing colon colon.</summary>
    public SyntaxToken ColonColonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AliasQualifiedNameSyntax)this.Green).colonColonToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>SimpleNameSyntax node representing the name that is being alias qualified.</summary>
    public SimpleNameSyntax Name 
    {
        get
        {
            return this.GetRed(ref this.name, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.alias);
            case 2: return this.GetRed(ref this.name, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.alias;
            case 2: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAliasQualifiedName(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAliasQualifiedName(this);
    }

    public AliasQualifiedNameSyntax Update(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
    {
        if (alias != this.Alias || colonColonToken != this.ColonColonToken || name != this.Name)
        {
            var newNode = SyntaxFactory.AliasQualifiedName(alias, colonColonToken, name);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AliasQualifiedNameSyntax WithAlias(IdentifierNameSyntax alias)
    {
        return this.Update(alias, this.ColonColonToken, this.Name);
    }

    public AliasQualifiedNameSyntax WithColonColonToken(SyntaxToken colonColonToken)
    {
        return this.Update(this.Alias, colonColonToken, this.Name);
    }

    public AliasQualifiedNameSyntax WithName(SimpleNameSyntax name)
    {
        return this.Update(this.Alias, this.ColonColonToken, name);
    }
  }

  /// <summary>Provides the base class from which the classes that represent type syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class TypeSyntax : ExpressionSyntax
  {
    internal TypeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  /// <summary>Class which represents the syntax node for predefined types.</summary>
  public sealed partial class PredefinedTypeSyntax : TypeSyntax
  {
    internal PredefinedTypeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken which represents the keyword corresponding to the predefined type.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PredefinedTypeSyntax)this.Green).keyword, this.Position, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPredefinedType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPredefinedType(this);
    }

    public PredefinedTypeSyntax Update(SyntaxToken keyword)
    {
        if (keyword != this.Keyword)
        {
            var newNode = SyntaxFactory.PredefinedType(keyword);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public PredefinedTypeSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword);
    }
  }

  /// <summary>Class which represents the syntax node for the array type.</summary>
  public sealed partial class ArrayTypeSyntax : TypeSyntax
  {
    private TypeSyntax elementType;
    private CSharpSyntaxNode rankSpecifiers;

    internal ArrayTypeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>TypeSyntax node representing the type of the element of the array.</summary>
    public TypeSyntax ElementType 
    {
        get
        {
            return this.GetRedAtZero(ref this.elementType);
        }
    }

    /// <summary>SyntaxList of ArrayRankSpecifierSyntax nodes representing the list of rank specifiers for the array.</summary>
    public SyntaxList<ArrayRankSpecifierSyntax> RankSpecifiers 
    {
        get
        {
            return new SyntaxList<ArrayRankSpecifierSyntax>(this.GetRed(ref this.rankSpecifiers, 1));
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.elementType);
            case 1: return this.GetRed(ref this.rankSpecifiers, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.elementType;
            case 1: return this.rankSpecifiers;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArrayType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArrayType(this);
    }

    public ArrayTypeSyntax Update(TypeSyntax elementType, SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
    {
        if (elementType != this.ElementType || rankSpecifiers != this.RankSpecifiers)
        {
            var newNode = SyntaxFactory.ArrayType(elementType, rankSpecifiers);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ArrayTypeSyntax WithElementType(TypeSyntax elementType)
    {
        return this.Update(elementType, this.RankSpecifiers);
    }

    public ArrayTypeSyntax WithRankSpecifiers(SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
    {
        return this.Update(this.ElementType, rankSpecifiers);
    }

    public ArrayTypeSyntax AddRankSpecifiers(params ArrayRankSpecifierSyntax[] items)
    {
        return this.WithRankSpecifiers(this.RankSpecifiers.AddRange(items));
    }
  }

  public sealed partial class ArrayRankSpecifierSyntax : CSharpSyntaxNode
  {
    private SyntaxNode sizes;

    internal ArrayRankSpecifierSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken OpenBracketToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayRankSpecifierSyntax)this.Green).openBracketToken, this.Position, 0); }
    }

    public SeparatedSyntaxList<ExpressionSyntax> Sizes 
    {
        get
        {
            var red = this.GetRed(ref this.sizes, 1);
            if (red != null)
                return new SeparatedSyntaxList<ExpressionSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<ExpressionSyntax>);
        }
    }

    public SyntaxToken CloseBracketToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayRankSpecifierSyntax)this.Green).closeBracketToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.sizes, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.sizes;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArrayRankSpecifier(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArrayRankSpecifier(this);
    }

    public ArrayRankSpecifierSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || sizes != this.Sizes || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.ArrayRankSpecifier(openBracketToken, sizes, closeBracketToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ArrayRankSpecifierSyntax WithOpenBracketToken(SyntaxToken openBracketToken)
    {
        return this.Update(openBracketToken, this.Sizes, this.CloseBracketToken);
    }

    public ArrayRankSpecifierSyntax WithSizes(SeparatedSyntaxList<ExpressionSyntax> sizes)
    {
        return this.Update(this.OpenBracketToken, sizes, this.CloseBracketToken);
    }

    public ArrayRankSpecifierSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)
    {
        return this.Update(this.OpenBracketToken, this.Sizes, closeBracketToken);
    }

    public ArrayRankSpecifierSyntax AddSizes(params ExpressionSyntax[] items)
    {
        return this.WithSizes(this.Sizes.AddRange(items));
    }
  }

  /// <summary>Class which represents the syntax node for pointer type.</summary>
  public sealed partial class PointerTypeSyntax : TypeSyntax
  {
    private TypeSyntax elementType;

    internal PointerTypeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>TypeSyntax node that represents the element type of the pointer.</summary>
    public TypeSyntax ElementType 
    {
        get
        {
            return this.GetRedAtZero(ref this.elementType);
        }
    }

    /// <summary>SyntaxToken representing the asterisk.</summary>
    public SyntaxToken AsteriskToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PointerTypeSyntax)this.Green).asteriskToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.elementType);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.elementType;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPointerType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPointerType(this);
    }

    public PointerTypeSyntax Update(TypeSyntax elementType, SyntaxToken asteriskToken)
    {
        if (elementType != this.ElementType || asteriskToken != this.AsteriskToken)
        {
            var newNode = SyntaxFactory.PointerType(elementType, asteriskToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public PointerTypeSyntax WithElementType(TypeSyntax elementType)
    {
        return this.Update(elementType, this.AsteriskToken);
    }

    public PointerTypeSyntax WithAsteriskToken(SyntaxToken asteriskToken)
    {
        return this.Update(this.ElementType, asteriskToken);
    }
  }

  /// <summary>Class which represents the syntax node for a nullable type.</summary>
  public sealed partial class NullableTypeSyntax : TypeSyntax
  {
    private TypeSyntax elementType;

    internal NullableTypeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>TypeSyntax node representing the type of the element.</summary>
    public TypeSyntax ElementType 
    {
        get
        {
            return this.GetRedAtZero(ref this.elementType);
        }
    }

    /// <summary>SyntaxToken representing the question mark.</summary>
    public SyntaxToken QuestionToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NullableTypeSyntax)this.Green).questionToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.elementType);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.elementType;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNullableType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitNullableType(this);
    }

    public NullableTypeSyntax Update(TypeSyntax elementType, SyntaxToken questionToken)
    {
        if (elementType != this.ElementType || questionToken != this.QuestionToken)
        {
            var newNode = SyntaxFactory.NullableType(elementType, questionToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public NullableTypeSyntax WithElementType(TypeSyntax elementType)
    {
        return this.Update(elementType, this.QuestionToken);
    }

    public NullableTypeSyntax WithQuestionToken(SyntaxToken questionToken)
    {
        return this.Update(this.ElementType, questionToken);
    }
  }

  /// <summary>Class which represents the syntax node for tuple type.</summary>
  public sealed partial class TupleTypeSyntax : TypeSyntax
  {
    private SyntaxNode elements;

    internal TupleTypeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TupleTypeSyntax)this.Green).openParenToken, this.Position, 0); }
    }

    public SeparatedSyntaxList<TupleElementSyntax> Elements 
    {
        get
        {
            var red = this.GetRed(ref this.elements, 1);
            if (red != null)
                return new SeparatedSyntaxList<TupleElementSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<TupleElementSyntax>);
        }
    }

    /// <summary>SyntaxToken representing the close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TupleTypeSyntax)this.Green).closeParenToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.elements, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.elements;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTupleType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTupleType(this);
    }

    public TupleTypeSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<TupleElementSyntax> elements, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || elements != this.Elements || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.TupleType(openParenToken, elements, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TupleTypeSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Elements, this.CloseParenToken);
    }

    public TupleTypeSyntax WithElements(SeparatedSyntaxList<TupleElementSyntax> elements)
    {
        return this.Update(this.OpenParenToken, elements, this.CloseParenToken);
    }

    public TupleTypeSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Elements, closeParenToken);
    }

    public TupleTypeSyntax AddElements(params TupleElementSyntax[] items)
    {
        return this.WithElements(this.Elements.AddRange(items));
    }
  }

  /// <summary>Tuple type element.</summary>
  public sealed partial class TupleElementSyntax : CSharpSyntaxNode
  {
    private TypeSyntax type;
    private IdentifierNameSyntax name;

    internal TupleElementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the type of the tuple element.</summary>
    public TypeSyntax Type 
    {
        get
        {
            return this.GetRedAtZero(ref this.type);
        }
    }

    /// <summary>Gets the name of the tuple element.</summary>
    public IdentifierNameSyntax Name 
    {
        get
        {
            return this.GetRed(ref this.name, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.type);
            case 1: return this.GetRed(ref this.name, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            case 1: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTupleElement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTupleElement(this);
    }

    public TupleElementSyntax Update(TypeSyntax type, IdentifierNameSyntax name)
    {
        if (type != this.Type || name != this.Name)
        {
            var newNode = SyntaxFactory.TupleElement(type, name);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TupleElementSyntax WithType(TypeSyntax type)
    {
        return this.Update(type, this.Name);
    }

    public TupleElementSyntax WithName(IdentifierNameSyntax name)
    {
        return this.Update(this.Type, name);
    }
  }

  /// <summary>Class which represents a placeholder in the type argument list of an unbound generic type.</summary>
  public sealed partial class OmittedTypeArgumentSyntax : TypeSyntax
  {
    internal OmittedTypeArgumentSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the omitted type argument.</summary>
    public SyntaxToken OmittedTypeArgumentToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OmittedTypeArgumentSyntax)this.Green).omittedTypeArgumentToken, this.Position, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOmittedTypeArgument(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOmittedTypeArgument(this);
    }

    public OmittedTypeArgumentSyntax Update(SyntaxToken omittedTypeArgumentToken)
    {
        if (omittedTypeArgumentToken != this.OmittedTypeArgumentToken)
        {
            var newNode = SyntaxFactory.OmittedTypeArgument(omittedTypeArgumentToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public OmittedTypeArgumentSyntax WithOmittedTypeArgumentToken(SyntaxToken omittedTypeArgumentToken)
    {
        return this.Update(omittedTypeArgumentToken);
    }
  }

  /// <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class ExpressionSyntax : CSharpSyntaxNode
  {
    internal ExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  /// <summary>Class which represents the syntax node for parenthesized expression.</summary>
  public sealed partial class ParenthesizedExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;

    internal ParenthesizedExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedExpressionSyntax)this.Green).openParenToken, this.Position, 0); }
    }

    /// <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 1);
        }
    }

    /// <summary>SyntaxToken representing the close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedExpressionSyntax)this.Green).closeParenToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.expression, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParenthesizedExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitParenthesizedExpression(this);
    }

    public ParenthesizedExpressionSyntax Update(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.ParenthesizedExpression(openParenToken, expression, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ParenthesizedExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Expression, this.CloseParenToken);
    }

    public ParenthesizedExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.OpenParenToken, expression, this.CloseParenToken);
    }

    public ParenthesizedExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Expression, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for tuple expression.</summary>
  public sealed partial class TupleExpressionSyntax : ExpressionSyntax
  {
    private SyntaxNode arguments;

    internal TupleExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TupleExpressionSyntax)this.Green).openParenToken, this.Position, 0); }
    }

    /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
    public SeparatedSyntaxList<ArgumentSyntax> Arguments 
    {
        get
        {
            var red = this.GetRed(ref this.arguments, 1);
            if (red != null)
                return new SeparatedSyntaxList<ArgumentSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<ArgumentSyntax>);
        }
    }

    /// <summary>SyntaxToken representing the close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TupleExpressionSyntax)this.Green).closeParenToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.arguments, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.arguments;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTupleExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTupleExpression(this);
    }

    public TupleExpressionSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.TupleExpression(openParenToken, arguments, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TupleExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Arguments, this.CloseParenToken);
    }

    public TupleExpressionSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments)
    {
        return this.Update(this.OpenParenToken, arguments, this.CloseParenToken);
    }

    public TupleExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Arguments, closeParenToken);
    }

    public TupleExpressionSyntax AddArguments(params ArgumentSyntax[] items)
    {
        return this.WithArguments(this.Arguments.AddRange(items));
    }
  }

  /// <summary>Class which represents the syntax node for prefix unary expression.</summary>
  public sealed partial class PrefixUnaryExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax operand;

    internal PrefixUnaryExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the kind of the operator of the prefix unary expression.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PrefixUnaryExpressionSyntax)this.Green).operatorToken, this.Position, 0); }
    }

    /// <summary>ExpressionSyntax representing the operand of the prefix unary expression.</summary>
    public ExpressionSyntax Operand 
    {
        get
        {
            return this.GetRed(ref this.operand, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.operand, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.operand;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPrefixUnaryExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPrefixUnaryExpression(this);
    }

    public PrefixUnaryExpressionSyntax Update(SyntaxToken operatorToken, ExpressionSyntax operand)
    {
        if (operatorToken != this.OperatorToken || operand != this.Operand)
        {
            var newNode = SyntaxFactory.PrefixUnaryExpression(this.Kind(), operatorToken, operand);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public PrefixUnaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(operatorToken, this.Operand);
    }

    public PrefixUnaryExpressionSyntax WithOperand(ExpressionSyntax operand)
    {
        return this.Update(this.OperatorToken, operand);
    }
  }

  /// <summary>Class which represents the syntax node for an "await" expression.</summary>
  public sealed partial class AwaitExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;

    internal AwaitExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the kind "await" keyword.</summary>
    public SyntaxToken AwaitKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AwaitExpressionSyntax)this.Green).awaitKeyword, this.Position, 0); }
    }

    /// <summary>ExpressionSyntax representing the operand of the "await" operator.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.expression, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAwaitExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAwaitExpression(this);
    }

    public AwaitExpressionSyntax Update(SyntaxToken awaitKeyword, ExpressionSyntax expression)
    {
        if (awaitKeyword != this.AwaitKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.AwaitExpression(awaitKeyword, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AwaitExpressionSyntax WithAwaitKeyword(SyntaxToken awaitKeyword)
    {
        return this.Update(awaitKeyword, this.Expression);
    }

    public AwaitExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.AwaitKeyword, expression);
    }
  }

  /// <summary>Class which represents the syntax node for postfix unary expression.</summary>
  public sealed partial class PostfixUnaryExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax operand;

    internal PostfixUnaryExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>ExpressionSyntax representing the operand of the postfix unary expression.</summary>
    public ExpressionSyntax Operand 
    {
        get
        {
            return this.GetRedAtZero(ref this.operand);
        }
    }

    /// <summary>SyntaxToken representing the kind of the operator of the postfix unary expression.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PostfixUnaryExpressionSyntax)this.Green).operatorToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.operand);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.operand;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPostfixUnaryExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPostfixUnaryExpression(this);
    }

    public PostfixUnaryExpressionSyntax Update(ExpressionSyntax operand, SyntaxToken operatorToken)
    {
        if (operand != this.Operand || operatorToken != this.OperatorToken)
        {
            var newNode = SyntaxFactory.PostfixUnaryExpression(this.Kind(), operand, operatorToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public PostfixUnaryExpressionSyntax WithOperand(ExpressionSyntax operand)
    {
        return this.Update(operand, this.OperatorToken);
    }

    public PostfixUnaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(this.Operand, operatorToken);
    }
  }

  /// <summary>Class which represents the syntax node for member access expression.</summary>
  public sealed partial class MemberAccessExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;
    private SimpleNameSyntax name;

    internal MemberAccessExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the object that the member belongs to.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRedAtZero(ref this.expression);
        }
    }

    /// <summary>SyntaxToken representing the kind of the operator in the member access expression.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberAccessExpressionSyntax)this.Green).operatorToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>SimpleNameSyntax node representing the member being accessed.</summary>
    public SimpleNameSyntax Name 
    {
        get
        {
            return this.GetRed(ref this.name, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.expression);
            case 2: return this.GetRed(ref this.name, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 2: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitMemberAccessExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitMemberAccessExpression(this);
    }

    public MemberAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
    {
        if (expression != this.Expression || operatorToken != this.OperatorToken || name != this.Name)
        {
            var newNode = SyntaxFactory.MemberAccessExpression(this.Kind(), expression, operatorToken, name);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public MemberAccessExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(expression, this.OperatorToken, this.Name);
    }

    public MemberAccessExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(this.Expression, operatorToken, this.Name);
    }

    public MemberAccessExpressionSyntax WithName(SimpleNameSyntax name)
    {
        return this.Update(this.Expression, this.OperatorToken, name);
    }
  }

  /// <summary>Class which represents the syntax node for conditional access expression.</summary>
  public sealed partial class ConditionalAccessExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;
    private ExpressionSyntax whenNotNull;

    internal ConditionalAccessExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the object conditionally accessed.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRedAtZero(ref this.expression);
        }
    }

    /// <summary>SyntaxToken representing the question mark.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalAccessExpressionSyntax)this.Green).operatorToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>ExpressionSyntax node representing the access expression to be executed when the object is not null.</summary>
    public ExpressionSyntax WhenNotNull 
    {
        get
        {
            return this.GetRed(ref this.whenNotNull, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.expression);
            case 2: return this.GetRed(ref this.whenNotNull, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 2: return this.whenNotNull;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConditionalAccessExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConditionalAccessExpression(this);
    }

    public ConditionalAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)
    {
        if (expression != this.Expression || operatorToken != this.OperatorToken || whenNotNull != this.WhenNotNull)
        {
            var newNode = SyntaxFactory.ConditionalAccessExpression(expression, operatorToken, whenNotNull);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ConditionalAccessExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(expression, this.OperatorToken, this.WhenNotNull);
    }

    public ConditionalAccessExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(this.Expression, operatorToken, this.WhenNotNull);
    }

    public ConditionalAccessExpressionSyntax WithWhenNotNull(ExpressionSyntax whenNotNull)
    {
        return this.Update(this.Expression, this.OperatorToken, whenNotNull);
    }
  }

  /// <summary>Class which represents the syntax node for member binding expression.</summary>
  public sealed partial class MemberBindingExpressionSyntax : ExpressionSyntax
  {
    private SimpleNameSyntax name;

    internal MemberBindingExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing dot.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberBindingExpressionSyntax)this.Green).operatorToken, this.Position, 0); }
    }

    /// <summary>SimpleNameSyntax node representing the member being bound to.</summary>
    public SimpleNameSyntax Name 
    {
        get
        {
            return this.GetRed(ref this.name, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.name, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitMemberBindingExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitMemberBindingExpression(this);
    }

    public MemberBindingExpressionSyntax Update(SyntaxToken operatorToken, SimpleNameSyntax name)
    {
        if (operatorToken != this.OperatorToken || name != this.Name)
        {
            var newNode = SyntaxFactory.MemberBindingExpression(operatorToken, name);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public MemberBindingExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(operatorToken, this.Name);
    }

    public MemberBindingExpressionSyntax WithName(SimpleNameSyntax name)
    {
        return this.Update(this.OperatorToken, name);
    }
  }

  /// <summary>Class which represents the syntax node for element binding expression.</summary>
  public sealed partial class ElementBindingExpressionSyntax : ExpressionSyntax
  {
    private BracketedArgumentListSyntax argumentList;

    internal ElementBindingExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>BracketedArgumentListSyntax node representing the list of arguments of the element binding expression.</summary>
    public BracketedArgumentListSyntax ArgumentList 
    {
        get
        {
            return this.GetRedAtZero(ref this.argumentList);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.argumentList);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.argumentList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElementBindingExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitElementBindingExpression(this);
    }

    public ElementBindingExpressionSyntax Update(BracketedArgumentListSyntax argumentList)
    {
        if (argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.ElementBindingExpression(argumentList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ElementBindingExpressionSyntax WithArgumentList(BracketedArgumentListSyntax argumentList)
    {
        return this.Update(argumentList);
    }

    public ElementBindingExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items)
    {
        return this.WithArgumentList(this.ArgumentList.WithArguments(this.ArgumentList.Arguments.AddRange(items)));
    }
  }

  /// <summary>Class which represents the syntax node for implicit element access expression.</summary>
  public sealed partial class ImplicitElementAccessSyntax : ExpressionSyntax
  {
    private BracketedArgumentListSyntax argumentList;

    internal ImplicitElementAccessSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>BracketedArgumentListSyntax node representing the list of arguments of the implicit element access expression.</summary>
    public BracketedArgumentListSyntax ArgumentList 
    {
        get
        {
            return this.GetRedAtZero(ref this.argumentList);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.argumentList);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.argumentList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitImplicitElementAccess(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitImplicitElementAccess(this);
    }

    public ImplicitElementAccessSyntax Update(BracketedArgumentListSyntax argumentList)
    {
        if (argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.ImplicitElementAccess(argumentList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ImplicitElementAccessSyntax WithArgumentList(BracketedArgumentListSyntax argumentList)
    {
        return this.Update(argumentList);
    }

    public ImplicitElementAccessSyntax AddArgumentListArguments(params ArgumentSyntax[] items)
    {
        return this.WithArgumentList(this.ArgumentList.WithArguments(this.ArgumentList.Arguments.AddRange(items)));
    }
  }

  /// <summary>Class which represents an expression that has a binary operator.</summary>
  public sealed partial class BinaryExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax left;
    private ExpressionSyntax right;

    internal BinaryExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
    public ExpressionSyntax Left 
    {
        get
        {
            return this.GetRedAtZero(ref this.left);
        }
    }

    /// <summary>SyntaxToken representing the operator of the binary expression.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BinaryExpressionSyntax)this.Green).operatorToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>ExpressionSyntax node representing the expression on the right of the binary operator.</summary>
    public ExpressionSyntax Right 
    {
        get
        {
            return this.GetRed(ref this.right, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.left);
            case 2: return this.GetRed(ref this.right, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.left;
            case 2: return this.right;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBinaryExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBinaryExpression(this);
    }

    public BinaryExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
        if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
        {
            var newNode = SyntaxFactory.BinaryExpression(this.Kind(), left, operatorToken, right);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public BinaryExpressionSyntax WithLeft(ExpressionSyntax left)
    {
        return this.Update(left, this.OperatorToken, this.Right);
    }

    public BinaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(this.Left, operatorToken, this.Right);
    }

    public BinaryExpressionSyntax WithRight(ExpressionSyntax right)
    {
        return this.Update(this.Left, this.OperatorToken, right);
    }
  }

  /// <summary>Class which represents an expression that has an assignment operator.</summary>
  public sealed partial class AssignmentExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax left;
    private ExpressionSyntax right;

    internal AssignmentExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the expression on the left of the assignment operator.</summary>
    public ExpressionSyntax Left 
    {
        get
        {
            return this.GetRedAtZero(ref this.left);
        }
    }

    /// <summary>SyntaxToken representing the operator of the assignment expression.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AssignmentExpressionSyntax)this.Green).operatorToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>ExpressionSyntax node representing the expression on the right of the assignment operator.</summary>
    public ExpressionSyntax Right 
    {
        get
        {
            return this.GetRed(ref this.right, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.left);
            case 2: return this.GetRed(ref this.right, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.left;
            case 2: return this.right;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAssignmentExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAssignmentExpression(this);
    }

    public AssignmentExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
        if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
        {
            var newNode = SyntaxFactory.AssignmentExpression(this.Kind(), left, operatorToken, right);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AssignmentExpressionSyntax WithLeft(ExpressionSyntax left)
    {
        return this.Update(left, this.OperatorToken, this.Right);
    }

    public AssignmentExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(this.Left, operatorToken, this.Right);
    }

    public AssignmentExpressionSyntax WithRight(ExpressionSyntax right)
    {
        return this.Update(this.Left, this.OperatorToken, right);
    }
  }

  /// <summary>Class which represents the syntax node for conditional expression.</summary>
  public sealed partial class ConditionalExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax condition;
    private ExpressionSyntax whenTrue;
    private ExpressionSyntax whenFalse;

    internal ConditionalExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the condition of the conditional expression.</summary>
    public ExpressionSyntax Condition 
    {
        get
        {
            return this.GetRedAtZero(ref this.condition);
        }
    }

    /// <summary>SyntaxToken representing the question mark.</summary>
    public SyntaxToken QuestionToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalExpressionSyntax)this.Green).questionToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>ExpressionSyntax node representing the expression to be executed when the condition is true.</summary>
    public ExpressionSyntax WhenTrue 
    {
        get
        {
            return this.GetRed(ref this.whenTrue, 2);
        }
    }

    /// <summary>SyntaxToken representing the colon.</summary>
    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalExpressionSyntax)this.Green).colonToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    /// <summary>ExpressionSyntax node representing the expression to be executed when the condition is false.</summary>
    public ExpressionSyntax WhenFalse 
    {
        get
        {
            return this.GetRed(ref this.whenFalse, 4);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.condition);
            case 2: return this.GetRed(ref this.whenTrue, 2);
            case 4: return this.GetRed(ref this.whenFalse, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.condition;
            case 2: return this.whenTrue;
            case 4: return this.whenFalse;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConditionalExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConditionalExpression(this);
    }

    public ConditionalExpressionSyntax Update(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
    {
        if (condition != this.Condition || questionToken != this.QuestionToken || whenTrue != this.WhenTrue || colonToken != this.ColonToken || whenFalse != this.WhenFalse)
        {
            var newNode = SyntaxFactory.ConditionalExpression(condition, questionToken, whenTrue, colonToken, whenFalse);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ConditionalExpressionSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(condition, this.QuestionToken, this.WhenTrue, this.ColonToken, this.WhenFalse);
    }

    public ConditionalExpressionSyntax WithQuestionToken(SyntaxToken questionToken)
    {
        return this.Update(this.Condition, questionToken, this.WhenTrue, this.ColonToken, this.WhenFalse);
    }

    public ConditionalExpressionSyntax WithWhenTrue(ExpressionSyntax whenTrue)
    {
        return this.Update(this.Condition, this.QuestionToken, whenTrue, this.ColonToken, this.WhenFalse);
    }

    public ConditionalExpressionSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.Condition, this.QuestionToken, this.WhenTrue, colonToken, this.WhenFalse);
    }

    public ConditionalExpressionSyntax WithWhenFalse(ExpressionSyntax whenFalse)
    {
        return this.Update(this.Condition, this.QuestionToken, this.WhenTrue, this.ColonToken, whenFalse);
    }
  }

  /// <summary>Provides the base class from which the classes that represent instance expression syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class InstanceExpressionSyntax : ExpressionSyntax
  {
    internal InstanceExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  /// <summary>Class which represents the syntax node for a this expression.</summary>
  public sealed partial class ThisExpressionSyntax : InstanceExpressionSyntax
  {
    internal ThisExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the this keyword.</summary>
    public SyntaxToken Token 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ThisExpressionSyntax)this.Green).token, this.Position, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitThisExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitThisExpression(this);
    }

    public ThisExpressionSyntax Update(SyntaxToken token)
    {
        if (token != this.Token)
        {
            var newNode = SyntaxFactory.ThisExpression(token);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ThisExpressionSyntax WithToken(SyntaxToken token)
    {
        return this.Update(token);
    }
  }

  /// <summary>Class which represents the syntax node for a base expression.</summary>
  public sealed partial class BaseExpressionSyntax : InstanceExpressionSyntax
  {
    internal BaseExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the base keyword.</summary>
    public SyntaxToken Token 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseExpressionSyntax)this.Green).token, this.Position, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBaseExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBaseExpression(this);
    }

    public BaseExpressionSyntax Update(SyntaxToken token)
    {
        if (token != this.Token)
        {
            var newNode = SyntaxFactory.BaseExpression(token);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public BaseExpressionSyntax WithToken(SyntaxToken token)
    {
        return this.Update(token);
    }
  }

  /// <summary>Class which represents the syntax node for an original expression.</summary>
  public sealed partial class OriginalExpressionSyntax : InstanceExpressionSyntax
  {
    internal OriginalExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the original keyword.</summary>
    public SyntaxToken Token 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OriginalExpressionSyntax)this.Green).token, this.Position, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOriginalExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOriginalExpression(this);
    }

    public OriginalExpressionSyntax Update(SyntaxToken token)
    {
        if (token != this.Token)
        {
            var newNode = SyntaxFactory.OriginalExpression(token);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public OriginalExpressionSyntax WithToken(SyntaxToken token)
    {
        return this.Update(token);
    }
  }

  /// <summary>Class which represents the syntax node for a literal expression.</summary>
  public sealed partial class LiteralExpressionSyntax : ExpressionSyntax
  {
    internal LiteralExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
    public SyntaxToken Token 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LiteralExpressionSyntax)this.Green).token, this.Position, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLiteralExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLiteralExpression(this);
    }

    public LiteralExpressionSyntax Update(SyntaxToken token)
    {
        if (token != this.Token)
        {
            var newNode = SyntaxFactory.LiteralExpression(this.Kind(), token);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public LiteralExpressionSyntax WithToken(SyntaxToken token)
    {
        return this.Update(token);
    }
  }

  /// <summary>Class which represents the syntax node for MakeRef expression.</summary>
  public sealed partial class MakeRefExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;

    internal MakeRefExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the MakeRefKeyword.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MakeRefExpressionSyntax)this.Green).keyword, this.Position, 0); }
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MakeRefExpressionSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Argument of the primary function.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 2);
        }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MakeRefExpressionSyntax)this.Green).closeParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitMakeRefExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitMakeRefExpression(this);
    }

    public MakeRefExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.MakeRefExpression(keyword, openParenToken, expression, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public MakeRefExpressionSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.OpenParenToken, this.Expression, this.CloseParenToken);
    }

    public MakeRefExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.Keyword, openParenToken, this.Expression, this.CloseParenToken);
    }

    public MakeRefExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.Keyword, this.OpenParenToken, expression, this.CloseParenToken);
    }

    public MakeRefExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Expression, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for RefType expression.</summary>
  public sealed partial class RefTypeExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;

    internal RefTypeExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the RefTypeKeyword.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefTypeExpressionSyntax)this.Green).keyword, this.Position, 0); }
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefTypeExpressionSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Argument of the primary function.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 2);
        }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefTypeExpressionSyntax)this.Green).closeParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRefTypeExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitRefTypeExpression(this);
    }

    public RefTypeExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.RefTypeExpression(keyword, openParenToken, expression, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public RefTypeExpressionSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.OpenParenToken, this.Expression, this.CloseParenToken);
    }

    public RefTypeExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.Keyword, openParenToken, this.Expression, this.CloseParenToken);
    }

    public RefTypeExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.Keyword, this.OpenParenToken, expression, this.CloseParenToken);
    }

    public RefTypeExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Expression, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for RefValue expression.</summary>
  public sealed partial class RefValueExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;
    private TypeSyntax type;

    internal RefValueExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the RefValueKeyword.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefValueExpressionSyntax)this.Green).keyword, this.Position, 0); }
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefValueExpressionSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Typed reference expression.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 2);
        }
    }

    /// <summary>Comma separating the arguments.</summary>
    public SyntaxToken Comma 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefValueExpressionSyntax)this.Green).comma, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    /// <summary>The type of the value.</summary>
    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 4);
        }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefValueExpressionSyntax)this.Green).closeParenToken, this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            case 4: return this.GetRed(ref this.type, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            case 4: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRefValueExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitRefValueExpression(this);
    }

    public RefValueExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || comma != this.Comma || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.RefValueExpression(keyword, openParenToken, expression, comma, type, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public RefValueExpressionSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.OpenParenToken, this.Expression, this.Comma, this.Type, this.CloseParenToken);
    }

    public RefValueExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.Keyword, openParenToken, this.Expression, this.Comma, this.Type, this.CloseParenToken);
    }

    public RefValueExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.Keyword, this.OpenParenToken, expression, this.Comma, this.Type, this.CloseParenToken);
    }

    public RefValueExpressionSyntax WithComma(SyntaxToken comma)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Expression, comma, this.Type, this.CloseParenToken);
    }

    public RefValueExpressionSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Expression, this.Comma, type, this.CloseParenToken);
    }

    public RefValueExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Expression, this.Comma, this.Type, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for Checked or Unchecked expression.</summary>
  public sealed partial class CheckedExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;

    internal CheckedExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the checked or unchecked keyword.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CheckedExpressionSyntax)this.Green).keyword, this.Position, 0); }
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CheckedExpressionSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Argument of the primary function.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 2);
        }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CheckedExpressionSyntax)this.Green).closeParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCheckedExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCheckedExpression(this);
    }

    public CheckedExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.CheckedExpression(this.Kind(), keyword, openParenToken, expression, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CheckedExpressionSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.OpenParenToken, this.Expression, this.CloseParenToken);
    }

    public CheckedExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.Keyword, openParenToken, this.Expression, this.CloseParenToken);
    }

    public CheckedExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.Keyword, this.OpenParenToken, expression, this.CloseParenToken);
    }

    public CheckedExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Expression, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for Default expression.</summary>
  public sealed partial class DefaultExpressionSyntax : ExpressionSyntax
  {
    private TypeSyntax type;

    internal DefaultExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the DefaultKeyword.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefaultExpressionSyntax)this.Green).keyword, this.Position, 0); }
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefaultExpressionSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Argument of the primary function.</summary>
    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 2);
        }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefaultExpressionSyntax)this.Green).closeParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.type, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDefaultExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDefaultExpression(this);
    }

    public DefaultExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.DefaultExpression(keyword, openParenToken, type, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public DefaultExpressionSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.OpenParenToken, this.Type, this.CloseParenToken);
    }

    public DefaultExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.Keyword, openParenToken, this.Type, this.CloseParenToken);
    }

    public DefaultExpressionSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.Keyword, this.OpenParenToken, type, this.CloseParenToken);
    }

    public DefaultExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Type, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for TypeOf expression.</summary>
  public sealed partial class TypeOfExpressionSyntax : ExpressionSyntax
  {
    private TypeSyntax type;

    internal TypeOfExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the TypeOfKeyword.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeOfExpressionSyntax)this.Green).keyword, this.Position, 0); }
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeOfExpressionSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>The expression to return type of.</summary>
    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 2);
        }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeOfExpressionSyntax)this.Green).closeParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.type, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeOfExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeOfExpression(this);
    }

    public TypeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.TypeOfExpression(keyword, openParenToken, type, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TypeOfExpressionSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.OpenParenToken, this.Type, this.CloseParenToken);
    }

    public TypeOfExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.Keyword, openParenToken, this.Type, this.CloseParenToken);
    }

    public TypeOfExpressionSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.Keyword, this.OpenParenToken, type, this.CloseParenToken);
    }

    public TypeOfExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Type, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for SizeOf expression.</summary>
  public sealed partial class SizeOfExpressionSyntax : ExpressionSyntax
  {
    private TypeSyntax type;

    internal SizeOfExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the SizeOfKeyword.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SizeOfExpressionSyntax)this.Green).keyword, this.Position, 0); }
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SizeOfExpressionSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Argument of the primary function.</summary>
    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 2);
        }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SizeOfExpressionSyntax)this.Green).closeParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.type, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSizeOfExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSizeOfExpression(this);
    }

    public SizeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.SizeOfExpression(keyword, openParenToken, type, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public SizeOfExpressionSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.OpenParenToken, this.Type, this.CloseParenToken);
    }

    public SizeOfExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.Keyword, openParenToken, this.Type, this.CloseParenToken);
    }

    public SizeOfExpressionSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.Keyword, this.OpenParenToken, type, this.CloseParenToken);
    }

    public SizeOfExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Type, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for invocation expression.</summary>
  public sealed partial class InvocationExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;
    private ArgumentListSyntax argumentList;

    internal InvocationExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the expression part of the invocation.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRedAtZero(ref this.expression);
        }
    }

    /// <summary>ArgumentListSyntax node representing the list of arguments of the invocation expression.</summary>
    public ArgumentListSyntax ArgumentList 
    {
        get
        {
            return this.GetRed(ref this.argumentList, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.expression);
            case 1: return this.GetRed(ref this.argumentList, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.argumentList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInvocationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInvocationExpression(this);
    }

    public InvocationExpressionSyntax Update(ExpressionSyntax expression, ArgumentListSyntax argumentList)
    {
        if (expression != this.Expression || argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.InvocationExpression(expression, argumentList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public InvocationExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(expression, this.ArgumentList);
    }

    public InvocationExpressionSyntax WithArgumentList(ArgumentListSyntax argumentList)
    {
        return this.Update(this.Expression, argumentList);
    }

    public InvocationExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items)
    {
        return this.WithArgumentList(this.ArgumentList.WithArguments(this.ArgumentList.Arguments.AddRange(items)));
    }
  }

  /// <summary>Class which represents the syntax node for element access expression.</summary>
  public sealed partial class ElementAccessExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;
    private BracketedArgumentListSyntax argumentList;

    internal ElementAccessExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the expression which is accessing the element.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRedAtZero(ref this.expression);
        }
    }

    /// <summary>BracketedArgumentListSyntax node representing the list of arguments of the element access expression.</summary>
    public BracketedArgumentListSyntax ArgumentList 
    {
        get
        {
            return this.GetRed(ref this.argumentList, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.expression);
            case 1: return this.GetRed(ref this.argumentList, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.argumentList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElementAccessExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitElementAccessExpression(this);
    }

    public ElementAccessExpressionSyntax Update(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
    {
        if (expression != this.Expression || argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.ElementAccessExpression(expression, argumentList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ElementAccessExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(expression, this.ArgumentList);
    }

    public ElementAccessExpressionSyntax WithArgumentList(BracketedArgumentListSyntax argumentList)
    {
        return this.Update(this.Expression, argumentList);
    }

    public ElementAccessExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items)
    {
        return this.WithArgumentList(this.ArgumentList.WithArguments(this.ArgumentList.Arguments.AddRange(items)));
    }
  }

  /// <summary>Provides the base class from which the classes that represent argument list syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class BaseArgumentListSyntax : CSharpSyntaxNode
  {
    internal BaseArgumentListSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>SeparatedSyntaxList of ArgumentSyntax nodes representing the list of arguments.</summary>
    public abstract SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }
  }

  /// <summary>Class which represents the syntax node for the list of arguments.</summary>
  public sealed partial class ArgumentListSyntax : BaseArgumentListSyntax
  {
    private SyntaxNode arguments;

    internal ArgumentListSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentListSyntax)this.Green).openParenToken, this.Position, 0); }
    }

    /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
    public override SeparatedSyntaxList<ArgumentSyntax> Arguments 
    {
        get
        {
            var red = this.GetRed(ref this.arguments, 1);
            if (red != null)
                return new SeparatedSyntaxList<ArgumentSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<ArgumentSyntax>);
        }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentListSyntax)this.Green).closeParenToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.arguments, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.arguments;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArgumentList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArgumentList(this);
    }

    public ArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.ArgumentList(openParenToken, arguments, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ArgumentListSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Arguments, this.CloseParenToken);
    }

    public ArgumentListSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments)
    {
        return this.Update(this.OpenParenToken, arguments, this.CloseParenToken);
    }

    public ArgumentListSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Arguments, closeParenToken);
    }

    public ArgumentListSyntax AddArguments(params ArgumentSyntax[] items)
    {
        return this.WithArguments(this.Arguments.AddRange(items));
    }
  }

  /// <summary>Class which represents the syntax node for bracketed argument list.</summary>
  public sealed partial class BracketedArgumentListSyntax : BaseArgumentListSyntax
  {
    private SyntaxNode arguments;

    internal BracketedArgumentListSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing open bracket.</summary>
    public SyntaxToken OpenBracketToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedArgumentListSyntax)this.Green).openBracketToken, this.Position, 0); }
    }

    /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
    public override SeparatedSyntaxList<ArgumentSyntax> Arguments 
    {
        get
        {
            var red = this.GetRed(ref this.arguments, 1);
            if (red != null)
                return new SeparatedSyntaxList<ArgumentSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<ArgumentSyntax>);
        }
    }

    /// <summary>SyntaxToken representing close bracket.</summary>
    public SyntaxToken CloseBracketToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedArgumentListSyntax)this.Green).closeBracketToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.arguments, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.arguments;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBracketedArgumentList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBracketedArgumentList(this);
    }

    public BracketedArgumentListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || arguments != this.Arguments || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.BracketedArgumentList(openBracketToken, arguments, closeBracketToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public BracketedArgumentListSyntax WithOpenBracketToken(SyntaxToken openBracketToken)
    {
        return this.Update(openBracketToken, this.Arguments, this.CloseBracketToken);
    }

    public BracketedArgumentListSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments)
    {
        return this.Update(this.OpenBracketToken, arguments, this.CloseBracketToken);
    }

    public BracketedArgumentListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)
    {
        return this.Update(this.OpenBracketToken, this.Arguments, closeBracketToken);
    }

    public BracketedArgumentListSyntax AddArguments(params ArgumentSyntax[] items)
    {
        return this.WithArguments(this.Arguments.AddRange(items));
    }
  }

  /// <summary>Class which represents the syntax node for argument.</summary>
  public sealed partial class ArgumentSyntax : CSharpSyntaxNode
  {
    private NameColonSyntax nameColon;
    private ExpressionSyntax expression;

    internal ArgumentSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>NameColonSyntax node representing the optional name arguments.</summary>
    public NameColonSyntax NameColon 
    {
        get
        {
            return this.GetRedAtZero(ref this.nameColon);
        }
    }

    /// <summary>SyntaxToken representing the optional ref or out keyword.</summary>
    public SyntaxToken RefOrOutKeyword 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentSyntax)this.Green).refOrOutKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxToken);
        }
    }

    /// <summary>ExpressionSyntax node representing the argument.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.nameColon);
            case 2: return this.GetRed(ref this.expression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nameColon;
            case 2: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArgument(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArgument(this);
    }

    public ArgumentSyntax Update(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression)
    {
        if (nameColon != this.NameColon || refOrOutKeyword != this.RefOrOutKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.Argument(nameColon, refOrOutKeyword, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ArgumentSyntax WithNameColon(NameColonSyntax nameColon)
    {
        return this.Update(nameColon, this.RefOrOutKeyword, this.Expression);
    }

    public ArgumentSyntax WithRefOrOutKeyword(SyntaxToken refOrOutKeyword)
    {
        return this.Update(this.NameColon, refOrOutKeyword, this.Expression);
    }

    public ArgumentSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.NameColon, this.RefOrOutKeyword, expression);
    }
  }

  /// <summary>Class which represents the syntax node for name colon syntax.</summary>
  public sealed partial class NameColonSyntax : CSharpSyntaxNode
  {
    private IdentifierNameSyntax name;

    internal NameColonSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>IdentifierNameSyntax representing the identifier name.</summary>
    public IdentifierNameSyntax Name 
    {
        get
        {
            return this.GetRedAtZero(ref this.name);
        }
    }

    /// <summary>SyntaxToken representing colon.</summary>
    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameColonSyntax)this.Green).colonToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.name);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNameColon(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitNameColon(this);
    }

    public NameColonSyntax Update(IdentifierNameSyntax name, SyntaxToken colonToken)
    {
        if (name != this.Name || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.NameColon(name, colonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public NameColonSyntax WithName(IdentifierNameSyntax name)
    {
        return this.Update(name, this.ColonToken);
    }

    public NameColonSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.Name, colonToken);
    }
  }

  /// <summary>Class which represents the syntax node for cast expression.</summary>
  public sealed partial class CastExpressionSyntax : ExpressionSyntax
  {
    private TypeSyntax type;
    private ExpressionSyntax expression;

    internal CastExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CastExpressionSyntax)this.Green).openParenToken, this.Position, 0); }
    }

    /// <summary>TypeSyntax node representing the type the expression is being casted to.</summary>
    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 1);
        }
    }

    /// <summary>SyntaxToken representing the close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CastExpressionSyntax)this.Green).closeParenToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>ExpressionSyntax node representing the expression that is being casted.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 3);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.type, 1);
            case 3: return this.GetRed(ref this.expression, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.type;
            case 3: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCastExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCastExpression(this);
    }

    public CastExpressionSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
    {
        if (openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken || expression != this.Expression)
        {
            var newNode = SyntaxFactory.CastExpression(openParenToken, type, closeParenToken, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CastExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Type, this.CloseParenToken, this.Expression);
    }

    public CastExpressionSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.OpenParenToken, type, this.CloseParenToken, this.Expression);
    }

    public CastExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Type, closeParenToken, this.Expression);
    }

    public CastExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.OpenParenToken, this.Type, this.CloseParenToken, expression);
    }
  }

  /// <summary>Provides the base class from which the classes that represent anonymous function expressions are derived.</summary>
  public abstract partial class AnonymousFunctionExpressionSyntax : ExpressionSyntax
  {
    internal AnonymousFunctionExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>Gets the "async" token.</summary>
    public abstract SyntaxToken AsyncKeyword { get; }

    /// <summary>ExpressionSyntax or BlockSyntax representing the body of the lambda expression.</summary>
    public abstract CSharpSyntaxNode Body { get; }
  }

  /// <summary>Class which represents the syntax node for anonymous method expression.</summary>
  public sealed partial class AnonymousMethodExpressionSyntax : AnonymousFunctionExpressionSyntax
  {
    private ParameterListSyntax parameterList;
    private CSharpSyntaxNode body;

    internal AnonymousMethodExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the "async" token.</summary>
    public override SyntaxToken AsyncKeyword 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousMethodExpressionSyntax)this.Green).asyncKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.Position, 0);

            return default(SyntaxToken);
        }
    }

    /// <summary>SyntaxToken representing the delegate keyword.</summary>
    public SyntaxToken DelegateKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousMethodExpressionSyntax)this.Green).delegateKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>List of parameters of the anonymous method expression, or null if there no parameters are specified.</summary>
    public ParameterListSyntax ParameterList 
    {
        get
        {
            return this.GetRed(ref this.parameterList, 2);
        }
    }

    /// <summary>BlockSyntax node representing the body of the anonymous method.</summary>
    public override CSharpSyntaxNode Body 
    {
        get
        {
            return this.GetRed(ref this.body, 3);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.parameterList, 2);
            case 3: return this.GetRed(ref this.body, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.parameterList;
            case 3: return this.body;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAnonymousMethodExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAnonymousMethodExpression(this);
    }

    public AnonymousMethodExpressionSyntax Update(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body)
    {
        if (asyncKeyword != this.AsyncKeyword || delegateKeyword != this.DelegateKeyword || parameterList != this.ParameterList || body != this.Body)
        {
            var newNode = SyntaxFactory.AnonymousMethodExpression(asyncKeyword, delegateKeyword, parameterList, body);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AnonymousMethodExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword)
    {
        return this.Update(asyncKeyword, this.DelegateKeyword, this.ParameterList, this.Body);
    }

    public AnonymousMethodExpressionSyntax WithDelegateKeyword(SyntaxToken delegateKeyword)
    {
        return this.Update(this.AsyncKeyword, delegateKeyword, this.ParameterList, this.Body);
    }

    public AnonymousMethodExpressionSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.AsyncKeyword, this.DelegateKeyword, parameterList, this.Body);
    }

    public AnonymousMethodExpressionSyntax WithBody(CSharpSyntaxNode body)
    {
        return this.Update(this.AsyncKeyword, this.DelegateKeyword, this.ParameterList, body);
    }

    public AnonymousMethodExpressionSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        var parameterList = this.ParameterList ?? SyntaxFactory.ParameterList();
        return this.WithParameterList(parameterList.WithParameters(parameterList.Parameters.AddRange(items)));
    }
  }

  /// <summary>Provides the base class from which the classes that represent lambda expressions are derived.</summary>
  public abstract partial class LambdaExpressionSyntax : AnonymousFunctionExpressionSyntax
  {
    internal LambdaExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing equals greater than.</summary>
    public abstract SyntaxToken ArrowToken { get; }
  }

  /// <summary>Class which represents the syntax node for a simple lambda expression.</summary>
  public sealed partial class SimpleLambdaExpressionSyntax : LambdaExpressionSyntax
  {
    private ParameterSyntax parameter;
    private CSharpSyntaxNode body;

    internal SimpleLambdaExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the "async" token.</summary>
    public override SyntaxToken AsyncKeyword 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleLambdaExpressionSyntax)this.Green).asyncKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.Position, 0);

            return default(SyntaxToken);
        }
    }

    /// <summary>ParameterSyntax node representing the parameter of the lambda expression.</summary>
    public ParameterSyntax Parameter 
    {
        get
        {
            return this.GetRed(ref this.parameter, 1);
        }
    }

    /// <summary>SyntaxToken representing equals greater than.</summary>
    public override SyntaxToken ArrowToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleLambdaExpressionSyntax)this.Green).arrowToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>SyntaxToken representing the "ref" keyword if present.</summary>
    public SyntaxToken RefKeyword 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleLambdaExpressionSyntax)this.Green).refKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(3), this.GetChildIndex(3));

            return default(SyntaxToken);
        }
    }

    /// <summary>SyntaxNode representing the body of the lambda expression.</summary>
    public override CSharpSyntaxNode Body 
    {
        get
        {
            return this.GetRed(ref this.body, 4);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.parameter, 1);
            case 4: return this.GetRed(ref this.body, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.parameter;
            case 4: return this.body;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSimpleLambdaExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSimpleLambdaExpression(this);
    }

    public SimpleLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, SyntaxToken refKeyword, CSharpSyntaxNode body)
    {
        if (asyncKeyword != this.AsyncKeyword || parameter != this.Parameter || arrowToken != this.ArrowToken || refKeyword != this.RefKeyword || body != this.Body)
        {
            var newNode = SyntaxFactory.SimpleLambdaExpression(asyncKeyword, parameter, arrowToken, refKeyword, body);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public SimpleLambdaExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword)
    {
        return this.Update(asyncKeyword, this.Parameter, this.ArrowToken, this.RefKeyword, this.Body);
    }

    public SimpleLambdaExpressionSyntax WithParameter(ParameterSyntax parameter)
    {
        return this.Update(this.AsyncKeyword, parameter, this.ArrowToken, this.RefKeyword, this.Body);
    }

    public SimpleLambdaExpressionSyntax WithArrowToken(SyntaxToken arrowToken)
    {
        return this.Update(this.AsyncKeyword, this.Parameter, arrowToken, this.RefKeyword, this.Body);
    }

    public SimpleLambdaExpressionSyntax WithRefKeyword(SyntaxToken refKeyword)
    {
        return this.Update(this.AsyncKeyword, this.Parameter, this.ArrowToken, refKeyword, this.Body);
    }

    public SimpleLambdaExpressionSyntax WithBody(CSharpSyntaxNode body)
    {
        return this.Update(this.AsyncKeyword, this.Parameter, this.ArrowToken, this.RefKeyword, body);
    }

    public SimpleLambdaExpressionSyntax AddParameterAttributeLists(params AttributeListSyntax[] items)
    {
        return this.WithParameter(this.Parameter.WithAttributeLists(this.Parameter.AttributeLists.AddRange(items)));
    }

    public SimpleLambdaExpressionSyntax AddParameterModifiers(params SyntaxToken[] items)
    {
        return this.WithParameter(this.Parameter.WithModifiers(this.Parameter.Modifiers.AddRange(items)));
    }
  }

  /// <summary>Class which represents the syntax node for parenthesized lambda expression.</summary>
  public sealed partial class ParenthesizedLambdaExpressionSyntax : LambdaExpressionSyntax
  {
    private ParameterListSyntax parameterList;
    private CSharpSyntaxNode body;

    internal ParenthesizedLambdaExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the "async" token.</summary>
    public override SyntaxToken AsyncKeyword 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedLambdaExpressionSyntax)this.Green).asyncKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.Position, 0);

            return default(SyntaxToken);
        }
    }

    /// <summary>ParameterListSyntax node representing the list of parameters for the lambda expression.</summary>
    public ParameterListSyntax ParameterList 
    {
        get
        {
            return this.GetRed(ref this.parameterList, 1);
        }
    }

    /// <summary>SyntaxToken representing equals greater than.</summary>
    public override SyntaxToken ArrowToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedLambdaExpressionSyntax)this.Green).arrowToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>SyntaxToken representing the "ref" keyword if present.</summary>
    public SyntaxToken RefKeyword 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedLambdaExpressionSyntax)this.Green).refKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(3), this.GetChildIndex(3));

            return default(SyntaxToken);
        }
    }

    /// <summary>SyntaxNode representing the body of the lambda expression.</summary>
    public override CSharpSyntaxNode Body 
    {
        get
        {
            return this.GetRed(ref this.body, 4);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.parameterList, 1);
            case 4: return this.GetRed(ref this.body, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.parameterList;
            case 4: return this.body;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParenthesizedLambdaExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitParenthesizedLambdaExpression(this);
    }

    public ParenthesizedLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, SyntaxToken refKeyword, CSharpSyntaxNode body)
    {
        if (asyncKeyword != this.AsyncKeyword || parameterList != this.ParameterList || arrowToken != this.ArrowToken || refKeyword != this.RefKeyword || body != this.Body)
        {
            var newNode = SyntaxFactory.ParenthesizedLambdaExpression(asyncKeyword, parameterList, arrowToken, refKeyword, body);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ParenthesizedLambdaExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword)
    {
        return this.Update(asyncKeyword, this.ParameterList, this.ArrowToken, this.RefKeyword, this.Body);
    }

    public ParenthesizedLambdaExpressionSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.AsyncKeyword, parameterList, this.ArrowToken, this.RefKeyword, this.Body);
    }

    public ParenthesizedLambdaExpressionSyntax WithArrowToken(SyntaxToken arrowToken)
    {
        return this.Update(this.AsyncKeyword, this.ParameterList, arrowToken, this.RefKeyword, this.Body);
    }

    public ParenthesizedLambdaExpressionSyntax WithRefKeyword(SyntaxToken refKeyword)
    {
        return this.Update(this.AsyncKeyword, this.ParameterList, this.ArrowToken, refKeyword, this.Body);
    }

    public ParenthesizedLambdaExpressionSyntax WithBody(CSharpSyntaxNode body)
    {
        return this.Update(this.AsyncKeyword, this.ParameterList, this.ArrowToken, this.RefKeyword, body);
    }

    public ParenthesizedLambdaExpressionSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.AddRange(items)));
    }
  }

  /// <summary>Class which represents the syntax node for initializer expression.</summary>
  public sealed partial class InitializerExpressionSyntax : ExpressionSyntax
  {
    private SyntaxNode expressions;

    internal InitializerExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the open brace.</summary>
    public SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InitializerExpressionSyntax)this.Green).openBraceToken, this.Position, 0); }
    }

    /// <summary>SeparatedSyntaxList of ExpressionSyntax representing the list of expressions in the initializer expression.</summary>
    public SeparatedSyntaxList<ExpressionSyntax> Expressions 
    {
        get
        {
            var red = this.GetRed(ref this.expressions, 1);
            if (red != null)
                return new SeparatedSyntaxList<ExpressionSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<ExpressionSyntax>);
        }
    }

    /// <summary>SyntaxToken representing the close brace.</summary>
    public SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InitializerExpressionSyntax)this.Green).closeBraceToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.expressions, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.expressions;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInitializerExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInitializerExpression(this);
    }

    public InitializerExpressionSyntax Update(SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || expressions != this.Expressions || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.InitializerExpression(this.Kind(), openBraceToken, expressions, closeBraceToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public InitializerExpressionSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(openBraceToken, this.Expressions, this.CloseBraceToken);
    }

    public InitializerExpressionSyntax WithExpressions(SeparatedSyntaxList<ExpressionSyntax> expressions)
    {
        return this.Update(this.OpenBraceToken, expressions, this.CloseBraceToken);
    }

    public InitializerExpressionSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.OpenBraceToken, this.Expressions, closeBraceToken);
    }

    public InitializerExpressionSyntax AddExpressions(params ExpressionSyntax[] items)
    {
        return this.WithExpressions(this.Expressions.AddRange(items));
    }
  }

  /// <summary>Class which represents the syntax node for object creation expression.</summary>
  public sealed partial class ObjectCreationExpressionSyntax : ExpressionSyntax
  {
    private TypeSyntax type;
    private ArgumentListSyntax argumentList;
    private InitializerExpressionSyntax initializer;

    internal ObjectCreationExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ObjectCreationExpressionSyntax)this.Green).newKeyword, this.Position, 0); }
    }

    /// <summary>TypeSyntax representing the type of the object being created.</summary>
    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 1);
        }
    }

    /// <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
    public ArgumentListSyntax ArgumentList 
    {
        get
        {
            return this.GetRed(ref this.argumentList, 2);
        }
    }

    /// <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
    public InitializerExpressionSyntax Initializer 
    {
        get
        {
            return this.GetRed(ref this.initializer, 3);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.type, 1);
            case 2: return this.GetRed(ref this.argumentList, 2);
            case 3: return this.GetRed(ref this.initializer, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.type;
            case 2: return this.argumentList;
            case 3: return this.initializer;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitObjectCreationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitObjectCreationExpression(this);
    }

    public ObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
    {
        if (newKeyword != this.NewKeyword || type != this.Type || argumentList != this.ArgumentList || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.ObjectCreationExpression(newKeyword, type, argumentList, initializer);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ObjectCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword)
    {
        return this.Update(newKeyword, this.Type, this.ArgumentList, this.Initializer);
    }

    public ObjectCreationExpressionSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.NewKeyword, type, this.ArgumentList, this.Initializer);
    }

    public ObjectCreationExpressionSyntax WithArgumentList(ArgumentListSyntax argumentList)
    {
        return this.Update(this.NewKeyword, this.Type, argumentList, this.Initializer);
    }

    public ObjectCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer)
    {
        return this.Update(this.NewKeyword, this.Type, this.ArgumentList, initializer);
    }

    public ObjectCreationExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items)
    {
        var argumentList = this.ArgumentList ?? SyntaxFactory.ArgumentList();
        return this.WithArgumentList(argumentList.WithArguments(argumentList.Arguments.AddRange(items)));
    }
  }

  public sealed partial class AnonymousObjectMemberDeclaratorSyntax : CSharpSyntaxNode
  {
    private NameEqualsSyntax nameEquals;
    private ExpressionSyntax expression;

    internal AnonymousObjectMemberDeclaratorSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>NameEqualsSyntax representing the optional name of the member being initialized.</summary>
    public NameEqualsSyntax NameEquals 
    {
        get
        {
            return this.GetRedAtZero(ref this.nameEquals);
        }
    }

    /// <summary>ExpressionSyntax representing the value the member is initialized with.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.nameEquals);
            case 1: return this.GetRed(ref this.expression, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nameEquals;
            case 1: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAnonymousObjectMemberDeclarator(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAnonymousObjectMemberDeclarator(this);
    }

    public AnonymousObjectMemberDeclaratorSyntax Update(NameEqualsSyntax nameEquals, ExpressionSyntax expression)
    {
        if (nameEquals != this.NameEquals || expression != this.Expression)
        {
            var newNode = SyntaxFactory.AnonymousObjectMemberDeclarator(nameEquals, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AnonymousObjectMemberDeclaratorSyntax WithNameEquals(NameEqualsSyntax nameEquals)
    {
        return this.Update(nameEquals, this.Expression);
    }

    public AnonymousObjectMemberDeclaratorSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.NameEquals, expression);
    }
  }

  /// <summary>Class which represents the syntax node for anonymous object creation expression.</summary>
  public sealed partial class AnonymousObjectCreationExpressionSyntax : ExpressionSyntax
  {
    private SyntaxNode initializers;

    internal AnonymousObjectCreationExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousObjectCreationExpressionSyntax)this.Green).newKeyword, this.Position, 0); }
    }

    /// <summary>SyntaxToken representing the open brace.</summary>
    public SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousObjectCreationExpressionSyntax)this.Green).openBraceToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>SeparatedSyntaxList of AnonymousObjectMemberDeclaratorSyntax representing the list of object member initializers.</summary>
    public SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> Initializers 
    {
        get
        {
            var red = this.GetRed(ref this.initializers, 2);
            if (red != null)
                return new SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax>(red, this.GetChildIndex(2));

            return default(SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax>);
        }
    }

    /// <summary>SyntaxToken representing the close brace.</summary>
    public SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousObjectCreationExpressionSyntax)this.Green).closeBraceToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.initializers, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.initializers;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAnonymousObjectCreationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAnonymousObjectCreationExpression(this);
    }

    public AnonymousObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)
    {
        if (newKeyword != this.NewKeyword || openBraceToken != this.OpenBraceToken || initializers != this.Initializers || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.AnonymousObjectCreationExpression(newKeyword, openBraceToken, initializers, closeBraceToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AnonymousObjectCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword)
    {
        return this.Update(newKeyword, this.OpenBraceToken, this.Initializers, this.CloseBraceToken);
    }

    public AnonymousObjectCreationExpressionSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(this.NewKeyword, openBraceToken, this.Initializers, this.CloseBraceToken);
    }

    public AnonymousObjectCreationExpressionSyntax WithInitializers(SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers)
    {
        return this.Update(this.NewKeyword, this.OpenBraceToken, initializers, this.CloseBraceToken);
    }

    public AnonymousObjectCreationExpressionSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.NewKeyword, this.OpenBraceToken, this.Initializers, closeBraceToken);
    }

    public AnonymousObjectCreationExpressionSyntax AddInitializers(params AnonymousObjectMemberDeclaratorSyntax[] items)
    {
        return this.WithInitializers(this.Initializers.AddRange(items));
    }
  }

  /// <summary>Class which represents the syntax node for array creation expression.</summary>
  public sealed partial class ArrayCreationExpressionSyntax : ExpressionSyntax
  {
    private ArrayTypeSyntax type;
    private InitializerExpressionSyntax initializer;

    internal ArrayCreationExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayCreationExpressionSyntax)this.Green).newKeyword, this.Position, 0); }
    }

    /// <summary>ArrayTypeSyntax node representing the type of the array.</summary>
    public ArrayTypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 1);
        }
    }

    /// <summary>InitializerExpressionSyntax node representing the initializer of the array creation expression.</summary>
    public InitializerExpressionSyntax Initializer 
    {
        get
        {
            return this.GetRed(ref this.initializer, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.type, 1);
            case 2: return this.GetRed(ref this.initializer, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.type;
            case 2: return this.initializer;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArrayCreationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArrayCreationExpression(this);
    }

    public ArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
    {
        if (newKeyword != this.NewKeyword || type != this.Type || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.ArrayCreationExpression(newKeyword, type, initializer);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ArrayCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword)
    {
        return this.Update(newKeyword, this.Type, this.Initializer);
    }

    public ArrayCreationExpressionSyntax WithType(ArrayTypeSyntax type)
    {
        return this.Update(this.NewKeyword, type, this.Initializer);
    }

    public ArrayCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer)
    {
        return this.Update(this.NewKeyword, this.Type, initializer);
    }

    public ArrayCreationExpressionSyntax AddTypeRankSpecifiers(params ArrayRankSpecifierSyntax[] items)
    {
        return this.WithType(this.Type.WithRankSpecifiers(this.Type.RankSpecifiers.AddRange(items)));
    }
  }

  /// <summary>Class which represents the syntax node for implicit array creation expression.</summary>
  public sealed partial class ImplicitArrayCreationExpressionSyntax : ExpressionSyntax
  {
    private InitializerExpressionSyntax initializer;

    internal ImplicitArrayCreationExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitArrayCreationExpressionSyntax)this.Green).newKeyword, this.Position, 0); }
    }

    /// <summary>SyntaxToken representing the open bracket.</summary>
    public SyntaxToken OpenBracketToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitArrayCreationExpressionSyntax)this.Green).openBracketToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>SyntaxList of SyntaxToken representing the commas in the implicit array creation expression.</summary>
    public SyntaxTokenList Commas 
    {
        get
        {
            var slot = this.Green.GetSlot(2);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(2), this.GetChildIndex(2));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>SyntaxToken representing the close bracket.</summary>
    public SyntaxToken CloseBracketToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitArrayCreationExpressionSyntax)this.Green).closeBracketToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    /// <summary>InitializerExpressionSyntax representing the initializer expression of the implicit array creation expression.</summary>
    public InitializerExpressionSyntax Initializer 
    {
        get
        {
            return this.GetRed(ref this.initializer, 4);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 4: return this.GetRed(ref this.initializer, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 4: return this.initializer;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitImplicitArrayCreationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitImplicitArrayCreationExpression(this);
    }

    public ImplicitArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxTokenList commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
    {
        if (newKeyword != this.NewKeyword || openBracketToken != this.OpenBracketToken || commas != this.Commas || closeBracketToken != this.CloseBracketToken || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.ImplicitArrayCreationExpression(newKeyword, openBracketToken, commas, closeBracketToken, initializer);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ImplicitArrayCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword)
    {
        return this.Update(newKeyword, this.OpenBracketToken, this.Commas, this.CloseBracketToken, this.Initializer);
    }

    public ImplicitArrayCreationExpressionSyntax WithOpenBracketToken(SyntaxToken openBracketToken)
    {
        return this.Update(this.NewKeyword, openBracketToken, this.Commas, this.CloseBracketToken, this.Initializer);
    }

    public ImplicitArrayCreationExpressionSyntax WithCommas(SyntaxTokenList commas)
    {
        return this.Update(this.NewKeyword, this.OpenBracketToken, commas, this.CloseBracketToken, this.Initializer);
    }

    public ImplicitArrayCreationExpressionSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)
    {
        return this.Update(this.NewKeyword, this.OpenBracketToken, this.Commas, closeBracketToken, this.Initializer);
    }

    public ImplicitArrayCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer)
    {
        return this.Update(this.NewKeyword, this.OpenBracketToken, this.Commas, this.CloseBracketToken, initializer);
    }

    public ImplicitArrayCreationExpressionSyntax AddCommas(params SyntaxToken[] items)
    {
        return this.WithCommas(this.Commas.AddRange(items));
    }

    public ImplicitArrayCreationExpressionSyntax AddInitializerExpressions(params ExpressionSyntax[] items)
    {
        return this.WithInitializer(this.Initializer.WithExpressions(this.Initializer.Expressions.AddRange(items)));
    }
  }

  /// <summary>Class which represents the syntax node for stackalloc array creation expression.</summary>
  public sealed partial class StackAllocArrayCreationExpressionSyntax : ExpressionSyntax
  {
    private TypeSyntax type;

    internal StackAllocArrayCreationExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the stackalloc keyword.</summary>
    public SyntaxToken StackAllocKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StackAllocArrayCreationExpressionSyntax)this.Green).stackAllocKeyword, this.Position, 0); }
    }

    /// <summary>TypeSyntax node representing the type of the stackalloc array.</summary>
    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.type, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitStackAllocArrayCreationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitStackAllocArrayCreationExpression(this);
    }

    public StackAllocArrayCreationExpressionSyntax Update(SyntaxToken stackAllocKeyword, TypeSyntax type)
    {
        if (stackAllocKeyword != this.StackAllocKeyword || type != this.Type)
        {
            var newNode = SyntaxFactory.StackAllocArrayCreationExpression(stackAllocKeyword, type);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public StackAllocArrayCreationExpressionSyntax WithStackAllocKeyword(SyntaxToken stackAllocKeyword)
    {
        return this.Update(stackAllocKeyword, this.Type);
    }

    public StackAllocArrayCreationExpressionSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.StackAllocKeyword, type);
    }
  }

  public abstract partial class QueryClauseSyntax : CSharpSyntaxNode
  {
    internal QueryClauseSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  public abstract partial class SelectOrGroupClauseSyntax : CSharpSyntaxNode
  {
    internal SelectOrGroupClauseSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  public sealed partial class QueryExpressionSyntax : ExpressionSyntax
  {
    private FromClauseSyntax fromClause;
    private QueryBodySyntax body;

    internal QueryExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public FromClauseSyntax FromClause 
    {
        get
        {
            return this.GetRedAtZero(ref this.fromClause);
        }
    }

    public QueryBodySyntax Body 
    {
        get
        {
            return this.GetRed(ref this.body, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.fromClause);
            case 1: return this.GetRed(ref this.body, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.fromClause;
            case 1: return this.body;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQueryExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitQueryExpression(this);
    }

    public QueryExpressionSyntax Update(FromClauseSyntax fromClause, QueryBodySyntax body)
    {
        if (fromClause != this.FromClause || body != this.Body)
        {
            var newNode = SyntaxFactory.QueryExpression(fromClause, body);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public QueryExpressionSyntax WithFromClause(FromClauseSyntax fromClause)
    {
        return this.Update(fromClause, this.Body);
    }

    public QueryExpressionSyntax WithBody(QueryBodySyntax body)
    {
        return this.Update(this.FromClause, body);
    }

    public QueryExpressionSyntax AddBodyClauses(params QueryClauseSyntax[] items)
    {
        return this.WithBody(this.Body.WithClauses(this.Body.Clauses.AddRange(items)));
    }
  }

  public sealed partial class QueryBodySyntax : CSharpSyntaxNode
  {
    private CSharpSyntaxNode clauses;
    private SelectOrGroupClauseSyntax selectOrGroup;
    private QueryContinuationSyntax continuation;

    internal QueryBodySyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxList<QueryClauseSyntax> Clauses 
    {
        get
        {
            return new SyntaxList<QueryClauseSyntax>(this.GetRed(ref this.clauses, 0));
        }
    }

    public SelectOrGroupClauseSyntax SelectOrGroup 
    {
        get
        {
            return this.GetRed(ref this.selectOrGroup, 1);
        }
    }

    public QueryContinuationSyntax Continuation 
    {
        get
        {
            return this.GetRed(ref this.continuation, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.clauses);
            case 1: return this.GetRed(ref this.selectOrGroup, 1);
            case 2: return this.GetRed(ref this.continuation, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.clauses;
            case 1: return this.selectOrGroup;
            case 2: return this.continuation;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQueryBody(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitQueryBody(this);
    }

    public QueryBodySyntax Update(SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
    {
        if (clauses != this.Clauses || selectOrGroup != this.SelectOrGroup || continuation != this.Continuation)
        {
            var newNode = SyntaxFactory.QueryBody(clauses, selectOrGroup, continuation);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public QueryBodySyntax WithClauses(SyntaxList<QueryClauseSyntax> clauses)
    {
        return this.Update(clauses, this.SelectOrGroup, this.Continuation);
    }

    public QueryBodySyntax WithSelectOrGroup(SelectOrGroupClauseSyntax selectOrGroup)
    {
        return this.Update(this.Clauses, selectOrGroup, this.Continuation);
    }

    public QueryBodySyntax WithContinuation(QueryContinuationSyntax continuation)
    {
        return this.Update(this.Clauses, this.SelectOrGroup, continuation);
    }

    public QueryBodySyntax AddClauses(params QueryClauseSyntax[] items)
    {
        return this.WithClauses(this.Clauses.AddRange(items));
    }
  }

  public sealed partial class FromClauseSyntax : QueryClauseSyntax
  {
    private TypeSyntax type;
    private ExpressionSyntax expression;

    internal FromClauseSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken FromKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FromClauseSyntax)this.Green).fromKeyword, this.Position, 0); }
    }

    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 1);
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FromClauseSyntax)this.Green).identifier, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxToken InKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FromClauseSyntax)this.Green).inKeyword, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 4);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.type, 1);
            case 4: return this.GetRed(ref this.expression, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.type;
            case 4: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFromClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitFromClause(this);
    }

    public FromClauseSyntax Update(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
    {
        if (fromKeyword != this.FromKeyword || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.FromClause(fromKeyword, type, identifier, inKeyword, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public FromClauseSyntax WithFromKeyword(SyntaxToken fromKeyword)
    {
        return this.Update(fromKeyword, this.Type, this.Identifier, this.InKeyword, this.Expression);
    }

    public FromClauseSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.FromKeyword, type, this.Identifier, this.InKeyword, this.Expression);
    }

    public FromClauseSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.FromKeyword, this.Type, identifier, this.InKeyword, this.Expression);
    }

    public FromClauseSyntax WithInKeyword(SyntaxToken inKeyword)
    {
        return this.Update(this.FromKeyword, this.Type, this.Identifier, inKeyword, this.Expression);
    }

    public FromClauseSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.FromKeyword, this.Type, this.Identifier, this.InKeyword, expression);
    }
  }

  public sealed partial class LetClauseSyntax : QueryClauseSyntax
  {
    private ExpressionSyntax expression;

    internal LetClauseSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken LetKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LetClauseSyntax)this.Green).letKeyword, this.Position, 0); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LetClauseSyntax)this.Green).identifier, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken EqualsToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LetClauseSyntax)this.Green).equalsToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 3);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 3: return this.GetRed(ref this.expression, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 3: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLetClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLetClause(this);
    }

    public LetClauseSyntax Update(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
    {
        if (letKeyword != this.LetKeyword || identifier != this.Identifier || equalsToken != this.EqualsToken || expression != this.Expression)
        {
            var newNode = SyntaxFactory.LetClause(letKeyword, identifier, equalsToken, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public LetClauseSyntax WithLetKeyword(SyntaxToken letKeyword)
    {
        return this.Update(letKeyword, this.Identifier, this.EqualsToken, this.Expression);
    }

    public LetClauseSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.LetKeyword, identifier, this.EqualsToken, this.Expression);
    }

    public LetClauseSyntax WithEqualsToken(SyntaxToken equalsToken)
    {
        return this.Update(this.LetKeyword, this.Identifier, equalsToken, this.Expression);
    }

    public LetClauseSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.LetKeyword, this.Identifier, this.EqualsToken, expression);
    }
  }

  public sealed partial class JoinClauseSyntax : QueryClauseSyntax
  {
    private TypeSyntax type;
    private ExpressionSyntax inExpression;
    private ExpressionSyntax leftExpression;
    private ExpressionSyntax rightExpression;
    private JoinIntoClauseSyntax into;

    internal JoinClauseSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken JoinKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.JoinClauseSyntax)this.Green).joinKeyword, this.Position, 0); }
    }

    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 1);
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.JoinClauseSyntax)this.Green).identifier, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxToken InKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.JoinClauseSyntax)this.Green).inKeyword, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public ExpressionSyntax InExpression 
    {
        get
        {
            return this.GetRed(ref this.inExpression, 4);
        }
    }

    public SyntaxToken OnKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.JoinClauseSyntax)this.Green).onKeyword, this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    public ExpressionSyntax LeftExpression 
    {
        get
        {
            return this.GetRed(ref this.leftExpression, 6);
        }
    }

    public SyntaxToken EqualsKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.JoinClauseSyntax)this.Green).equalsKeyword, this.GetChildPosition(7), this.GetChildIndex(7)); }
    }

    public ExpressionSyntax RightExpression 
    {
        get
        {
            return this.GetRed(ref this.rightExpression, 8);
        }
    }

    public JoinIntoClauseSyntax Into 
    {
        get
        {
            return this.GetRed(ref this.into, 9);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.type, 1);
            case 4: return this.GetRed(ref this.inExpression, 4);
            case 6: return this.GetRed(ref this.leftExpression, 6);
            case 8: return this.GetRed(ref this.rightExpression, 8);
            case 9: return this.GetRed(ref this.into, 9);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.type;
            case 4: return this.inExpression;
            case 6: return this.leftExpression;
            case 8: return this.rightExpression;
            case 9: return this.into;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitJoinClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitJoinClause(this);
    }

    public JoinClauseSyntax Update(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
    {
        if (joinKeyword != this.JoinKeyword || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || inExpression != this.InExpression || onKeyword != this.OnKeyword || leftExpression != this.LeftExpression || equalsKeyword != this.EqualsKeyword || rightExpression != this.RightExpression || into != this.Into)
        {
            var newNode = SyntaxFactory.JoinClause(joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public JoinClauseSyntax WithJoinKeyword(SyntaxToken joinKeyword)
    {
        return this.Update(joinKeyword, this.Type, this.Identifier, this.InKeyword, this.InExpression, this.OnKeyword, this.LeftExpression, this.EqualsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.JoinKeyword, type, this.Identifier, this.InKeyword, this.InExpression, this.OnKeyword, this.LeftExpression, this.EqualsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.JoinKeyword, this.Type, identifier, this.InKeyword, this.InExpression, this.OnKeyword, this.LeftExpression, this.EqualsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithInKeyword(SyntaxToken inKeyword)
    {
        return this.Update(this.JoinKeyword, this.Type, this.Identifier, inKeyword, this.InExpression, this.OnKeyword, this.LeftExpression, this.EqualsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithInExpression(ExpressionSyntax inExpression)
    {
        return this.Update(this.JoinKeyword, this.Type, this.Identifier, this.InKeyword, inExpression, this.OnKeyword, this.LeftExpression, this.EqualsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithOnKeyword(SyntaxToken onKeyword)
    {
        return this.Update(this.JoinKeyword, this.Type, this.Identifier, this.InKeyword, this.InExpression, onKeyword, this.LeftExpression, this.EqualsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithLeftExpression(ExpressionSyntax leftExpression)
    {
        return this.Update(this.JoinKeyword, this.Type, this.Identifier, this.InKeyword, this.InExpression, this.OnKeyword, leftExpression, this.EqualsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithEqualsKeyword(SyntaxToken equalsKeyword)
    {
        return this.Update(this.JoinKeyword, this.Type, this.Identifier, this.InKeyword, this.InExpression, this.OnKeyword, this.LeftExpression, equalsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithRightExpression(ExpressionSyntax rightExpression)
    {
        return this.Update(this.JoinKeyword, this.Type, this.Identifier, this.InKeyword, this.InExpression, this.OnKeyword, this.LeftExpression, this.EqualsKeyword, rightExpression, this.Into);
    }

    public JoinClauseSyntax WithInto(JoinIntoClauseSyntax into)
    {
        return this.Update(this.JoinKeyword, this.Type, this.Identifier, this.InKeyword, this.InExpression, this.OnKeyword, this.LeftExpression, this.EqualsKeyword, this.RightExpression, into);
    }
  }

  public sealed partial class JoinIntoClauseSyntax : CSharpSyntaxNode
  {
    internal JoinIntoClauseSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken IntoKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.JoinIntoClauseSyntax)this.Green).intoKeyword, this.Position, 0); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.JoinIntoClauseSyntax)this.Green).identifier, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitJoinIntoClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitJoinIntoClause(this);
    }

    public JoinIntoClauseSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier)
    {
        if (intoKeyword != this.IntoKeyword || identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.JoinIntoClause(intoKeyword, identifier);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public JoinIntoClauseSyntax WithIntoKeyword(SyntaxToken intoKeyword)
    {
        return this.Update(intoKeyword, this.Identifier);
    }

    public JoinIntoClauseSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.IntoKeyword, identifier);
    }
  }

  public sealed partial class WhereClauseSyntax : QueryClauseSyntax
  {
    private ExpressionSyntax condition;

    internal WhereClauseSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken WhereKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.WhereClauseSyntax)this.Green).whereKeyword, this.Position, 0); }
    }

    public ExpressionSyntax Condition 
    {
        get
        {
            return this.GetRed(ref this.condition, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.condition, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.condition;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitWhereClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitWhereClause(this);
    }

    public WhereClauseSyntax Update(SyntaxToken whereKeyword, ExpressionSyntax condition)
    {
        if (whereKeyword != this.WhereKeyword || condition != this.Condition)
        {
            var newNode = SyntaxFactory.WhereClause(whereKeyword, condition);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public WhereClauseSyntax WithWhereKeyword(SyntaxToken whereKeyword)
    {
        return this.Update(whereKeyword, this.Condition);
    }

    public WhereClauseSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.WhereKeyword, condition);
    }
  }

  public sealed partial class OrderByClauseSyntax : QueryClauseSyntax
  {
    private SyntaxNode orderings;

    internal OrderByClauseSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken OrderByKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OrderByClauseSyntax)this.Green).orderByKeyword, this.Position, 0); }
    }

    public SeparatedSyntaxList<OrderingSyntax> Orderings 
    {
        get
        {
            var red = this.GetRed(ref this.orderings, 1);
            if (red != null)
                return new SeparatedSyntaxList<OrderingSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<OrderingSyntax>);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.orderings, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.orderings;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOrderByClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOrderByClause(this);
    }

    public OrderByClauseSyntax Update(SyntaxToken orderByKeyword, SeparatedSyntaxList<OrderingSyntax> orderings)
    {
        if (orderByKeyword != this.OrderByKeyword || orderings != this.Orderings)
        {
            var newNode = SyntaxFactory.OrderByClause(orderByKeyword, orderings);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public OrderByClauseSyntax WithOrderByKeyword(SyntaxToken orderByKeyword)
    {
        return this.Update(orderByKeyword, this.Orderings);
    }

    public OrderByClauseSyntax WithOrderings(SeparatedSyntaxList<OrderingSyntax> orderings)
    {
        return this.Update(this.OrderByKeyword, orderings);
    }

    public OrderByClauseSyntax AddOrderings(params OrderingSyntax[] items)
    {
        return this.WithOrderings(this.Orderings.AddRange(items));
    }
  }

  public sealed partial class OrderingSyntax : CSharpSyntaxNode
  {
    private ExpressionSyntax expression;

    internal OrderingSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRedAtZero(ref this.expression);
        }
    }

    public SyntaxToken AscendingOrDescendingKeyword 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OrderingSyntax)this.Green).ascendingOrDescendingKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.expression);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOrdering(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOrdering(this);
    }

    public OrderingSyntax Update(ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
    {
        if (expression != this.Expression || ascendingOrDescendingKeyword != this.AscendingOrDescendingKeyword)
        {
            var newNode = SyntaxFactory.Ordering(this.Kind(), expression, ascendingOrDescendingKeyword);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public OrderingSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(expression, this.AscendingOrDescendingKeyword);
    }

    public OrderingSyntax WithAscendingOrDescendingKeyword(SyntaxToken ascendingOrDescendingKeyword)
    {
        return this.Update(this.Expression, ascendingOrDescendingKeyword);
    }
  }

  public sealed partial class SelectClauseSyntax : SelectOrGroupClauseSyntax
  {
    private ExpressionSyntax expression;

    internal SelectClauseSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken SelectKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SelectClauseSyntax)this.Green).selectKeyword, this.Position, 0); }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.expression, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSelectClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSelectClause(this);
    }

    public SelectClauseSyntax Update(SyntaxToken selectKeyword, ExpressionSyntax expression)
    {
        if (selectKeyword != this.SelectKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.SelectClause(selectKeyword, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public SelectClauseSyntax WithSelectKeyword(SyntaxToken selectKeyword)
    {
        return this.Update(selectKeyword, this.Expression);
    }

    public SelectClauseSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.SelectKeyword, expression);
    }
  }

  public sealed partial class GroupClauseSyntax : SelectOrGroupClauseSyntax
  {
    private ExpressionSyntax groupExpression;
    private ExpressionSyntax byExpression;

    internal GroupClauseSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken GroupKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GroupClauseSyntax)this.Green).groupKeyword, this.Position, 0); }
    }

    public ExpressionSyntax GroupExpression 
    {
        get
        {
            return this.GetRed(ref this.groupExpression, 1);
        }
    }

    public SyntaxToken ByKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GroupClauseSyntax)this.Green).byKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public ExpressionSyntax ByExpression 
    {
        get
        {
            return this.GetRed(ref this.byExpression, 3);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.groupExpression, 1);
            case 3: return this.GetRed(ref this.byExpression, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.groupExpression;
            case 3: return this.byExpression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGroupClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitGroupClause(this);
    }

    public GroupClauseSyntax Update(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
    {
        if (groupKeyword != this.GroupKeyword || groupExpression != this.GroupExpression || byKeyword != this.ByKeyword || byExpression != this.ByExpression)
        {
            var newNode = SyntaxFactory.GroupClause(groupKeyword, groupExpression, byKeyword, byExpression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public GroupClauseSyntax WithGroupKeyword(SyntaxToken groupKeyword)
    {
        return this.Update(groupKeyword, this.GroupExpression, this.ByKeyword, this.ByExpression);
    }

    public GroupClauseSyntax WithGroupExpression(ExpressionSyntax groupExpression)
    {
        return this.Update(this.GroupKeyword, groupExpression, this.ByKeyword, this.ByExpression);
    }

    public GroupClauseSyntax WithByKeyword(SyntaxToken byKeyword)
    {
        return this.Update(this.GroupKeyword, this.GroupExpression, byKeyword, this.ByExpression);
    }

    public GroupClauseSyntax WithByExpression(ExpressionSyntax byExpression)
    {
        return this.Update(this.GroupKeyword, this.GroupExpression, this.ByKeyword, byExpression);
    }
  }

  public sealed partial class QueryContinuationSyntax : CSharpSyntaxNode
  {
    private QueryBodySyntax body;

    internal QueryContinuationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken IntoKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QueryContinuationSyntax)this.Green).intoKeyword, this.Position, 0); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QueryContinuationSyntax)this.Green).identifier, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public QueryBodySyntax Body 
    {
        get
        {
            return this.GetRed(ref this.body, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.body, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.body;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQueryContinuation(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitQueryContinuation(this);
    }

    public QueryContinuationSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
    {
        if (intoKeyword != this.IntoKeyword || identifier != this.Identifier || body != this.Body)
        {
            var newNode = SyntaxFactory.QueryContinuation(intoKeyword, identifier, body);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public QueryContinuationSyntax WithIntoKeyword(SyntaxToken intoKeyword)
    {
        return this.Update(intoKeyword, this.Identifier, this.Body);
    }

    public QueryContinuationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.IntoKeyword, identifier, this.Body);
    }

    public QueryContinuationSyntax WithBody(QueryBodySyntax body)
    {
        return this.Update(this.IntoKeyword, this.Identifier, body);
    }

    public QueryContinuationSyntax AddBodyClauses(params QueryClauseSyntax[] items)
    {
        return this.WithBody(this.Body.WithClauses(this.Body.Clauses.AddRange(items)));
    }
  }

  /// <summary>Class which represents a placeholder in an array size list.</summary>
  public sealed partial class OmittedArraySizeExpressionSyntax : ExpressionSyntax
  {
    internal OmittedArraySizeExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the omitted array size expression.</summary>
    public SyntaxToken OmittedArraySizeExpressionToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OmittedArraySizeExpressionSyntax)this.Green).omittedArraySizeExpressionToken, this.Position, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOmittedArraySizeExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOmittedArraySizeExpression(this);
    }

    public OmittedArraySizeExpressionSyntax Update(SyntaxToken omittedArraySizeExpressionToken)
    {
        if (omittedArraySizeExpressionToken != this.OmittedArraySizeExpressionToken)
        {
            var newNode = SyntaxFactory.OmittedArraySizeExpression(omittedArraySizeExpressionToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public OmittedArraySizeExpressionSyntax WithOmittedArraySizeExpressionToken(SyntaxToken omittedArraySizeExpressionToken)
    {
        return this.Update(omittedArraySizeExpressionToken);
    }
  }

  public sealed partial class InterpolatedStringExpressionSyntax : ExpressionSyntax
  {
    private CSharpSyntaxNode contents;

    internal InterpolatedStringExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>The first part of an interpolated string, $" or $@"</summary>
    public SyntaxToken StringStartToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolatedStringExpressionSyntax)this.Green).stringStartToken, this.Position, 0); }
    }

    /// <summary>List of parts of the interpolated string, each one is either a literal part or an interpolation.</summary>
    public SyntaxList<InterpolatedStringContentSyntax> Contents 
    {
        get
        {
            return new SyntaxList<InterpolatedStringContentSyntax>(this.GetRed(ref this.contents, 1));
        }
    }

    /// <summary>The closing quote of the interpolated string.</summary>
    public SyntaxToken StringEndToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolatedStringExpressionSyntax)this.Green).stringEndToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.contents, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.contents;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterpolatedStringExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterpolatedStringExpression(this);
    }

    public InterpolatedStringExpressionSyntax Update(SyntaxToken stringStartToken, SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
    {
        if (stringStartToken != this.StringStartToken || contents != this.Contents || stringEndToken != this.StringEndToken)
        {
            var newNode = SyntaxFactory.InterpolatedStringExpression(stringStartToken, contents, stringEndToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public InterpolatedStringExpressionSyntax WithStringStartToken(SyntaxToken stringStartToken)
    {
        return this.Update(stringStartToken, this.Contents, this.StringEndToken);
    }

    public InterpolatedStringExpressionSyntax WithContents(SyntaxList<InterpolatedStringContentSyntax> contents)
    {
        return this.Update(this.StringStartToken, contents, this.StringEndToken);
    }

    public InterpolatedStringExpressionSyntax WithStringEndToken(SyntaxToken stringEndToken)
    {
        return this.Update(this.StringStartToken, this.Contents, stringEndToken);
    }

    public InterpolatedStringExpressionSyntax AddContents(params InterpolatedStringContentSyntax[] items)
    {
        return this.WithContents(this.Contents.AddRange(items));
    }
  }

  /// <summary>Class which represents a simple pattern-maching expresion using the "is" keyword.</summary>
  public sealed partial class IsPatternExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;
    private PatternSyntax pattern;

    internal IsPatternExpressionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the expression on the left of the "is" operator.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRedAtZero(ref this.expression);
        }
    }

    public SyntaxToken IsKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IsPatternExpressionSyntax)this.Green).isKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>PatternSyntax node representing the pattern on the right of the "is" operator.</summary>
    public PatternSyntax Pattern 
    {
        get
        {
            return this.GetRed(ref this.pattern, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.expression);
            case 2: return this.GetRed(ref this.pattern, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 2: return this.pattern;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIsPatternExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIsPatternExpression(this);
    }

    public IsPatternExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)
    {
        if (expression != this.Expression || isKeyword != this.IsKeyword || pattern != this.Pattern)
        {
            var newNode = SyntaxFactory.IsPatternExpression(expression, isKeyword, pattern);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public IsPatternExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(expression, this.IsKeyword, this.Pattern);
    }

    public IsPatternExpressionSyntax WithIsKeyword(SyntaxToken isKeyword)
    {
        return this.Update(this.Expression, isKeyword, this.Pattern);
    }

    public IsPatternExpressionSyntax WithPattern(PatternSyntax pattern)
    {
        return this.Update(this.Expression, this.IsKeyword, pattern);
    }
  }

  public sealed partial class WhenClauseSyntax : CSharpSyntaxNode
  {
    private ExpressionSyntax condition;

    internal WhenClauseSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken WhenKeyword 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.WhenClauseSyntax)this.Green).whenKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.Position, 0);

            return default(SyntaxToken);
        }
    }

    public ExpressionSyntax Condition 
    {
        get
        {
            return this.GetRed(ref this.condition, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.condition, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.condition;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitWhenClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitWhenClause(this);
    }

    public WhenClauseSyntax Update(SyntaxToken whenKeyword, ExpressionSyntax condition)
    {
        if (whenKeyword != this.WhenKeyword || condition != this.Condition)
        {
            var newNode = SyntaxFactory.WhenClause(whenKeyword, condition);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public WhenClauseSyntax WithWhenKeyword(SyntaxToken whenKeyword)
    {
        return this.Update(whenKeyword, this.Condition);
    }

    public WhenClauseSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.WhenKeyword, condition);
    }
  }

  public abstract partial class PatternSyntax : CSharpSyntaxNode
  {
    internal PatternSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  public sealed partial class DeclarationPatternSyntax : PatternSyntax
  {
    private TypeSyntax type;

    internal DeclarationPatternSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public TypeSyntax Type 
    {
        get
        {
            return this.GetRedAtZero(ref this.type);
        }
    }

    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DeclarationPatternSyntax)this.Green).identifier, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.type);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDeclarationPattern(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDeclarationPattern(this);
    }

    public DeclarationPatternSyntax Update(TypeSyntax type, SyntaxToken identifier)
    {
        if (type != this.Type || identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.DeclarationPattern(type, identifier);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public DeclarationPatternSyntax WithType(TypeSyntax type)
    {
        return this.Update(type, this.Identifier);
    }

    public DeclarationPatternSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.Type, identifier);
    }
  }

  public sealed partial class ConstantPatternSyntax : PatternSyntax
  {
    private ExpressionSyntax expression;

    internal ConstantPatternSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the constant expression.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRedAtZero(ref this.expression);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.expression);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstantPattern(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConstantPattern(this);
    }

    public ConstantPatternSyntax Update(ExpressionSyntax expression)
    {
        if (expression != this.Expression)
        {
            var newNode = SyntaxFactory.ConstantPattern(expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ConstantPatternSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(expression);
    }
  }

  public abstract partial class InterpolatedStringContentSyntax : CSharpSyntaxNode
  {
    internal InterpolatedStringContentSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  public sealed partial class InterpolatedStringTextSyntax : InterpolatedStringContentSyntax
  {
    internal InterpolatedStringTextSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>The text contents of a part of the interpolated string.</summary>
    public SyntaxToken TextToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolatedStringTextSyntax)this.Green).textToken, this.Position, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterpolatedStringText(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterpolatedStringText(this);
    }

    public InterpolatedStringTextSyntax Update(SyntaxToken textToken)
    {
        if (textToken != this.TextToken)
        {
            var newNode = SyntaxFactory.InterpolatedStringText(textToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public InterpolatedStringTextSyntax WithTextToken(SyntaxToken textToken)
    {
        return this.Update(textToken);
    }
  }

  public sealed partial class InterpolationSyntax : InterpolatedStringContentSyntax
  {
    private ExpressionSyntax expression;
    private InterpolationAlignmentClauseSyntax alignmentClause;
    private InterpolationFormatClauseSyntax formatClause;

    internal InterpolationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolationSyntax)this.Green).openBraceToken, this.Position, 0); }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 1);
        }
    }

    public InterpolationAlignmentClauseSyntax AlignmentClause 
    {
        get
        {
            return this.GetRed(ref this.alignmentClause, 2);
        }
    }

    public InterpolationFormatClauseSyntax FormatClause 
    {
        get
        {
            return this.GetRed(ref this.formatClause, 3);
        }
    }

    public SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolationSyntax)this.Green).closeBraceToken, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.expression, 1);
            case 2: return this.GetRed(ref this.alignmentClause, 2);
            case 3: return this.GetRed(ref this.formatClause, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.expression;
            case 2: return this.alignmentClause;
            case 3: return this.formatClause;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterpolation(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterpolation(this);
    }

    public InterpolationSyntax Update(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || expression != this.Expression || alignmentClause != this.AlignmentClause || formatClause != this.FormatClause || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.Interpolation(openBraceToken, expression, alignmentClause, formatClause, closeBraceToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public InterpolationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(openBraceToken, this.Expression, this.AlignmentClause, this.FormatClause, this.CloseBraceToken);
    }

    public InterpolationSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.OpenBraceToken, expression, this.AlignmentClause, this.FormatClause, this.CloseBraceToken);
    }

    public InterpolationSyntax WithAlignmentClause(InterpolationAlignmentClauseSyntax alignmentClause)
    {
        return this.Update(this.OpenBraceToken, this.Expression, alignmentClause, this.FormatClause, this.CloseBraceToken);
    }

    public InterpolationSyntax WithFormatClause(InterpolationFormatClauseSyntax formatClause)
    {
        return this.Update(this.OpenBraceToken, this.Expression, this.AlignmentClause, formatClause, this.CloseBraceToken);
    }

    public InterpolationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.OpenBraceToken, this.Expression, this.AlignmentClause, this.FormatClause, closeBraceToken);
    }
  }

  public sealed partial class InterpolationAlignmentClauseSyntax : CSharpSyntaxNode
  {
    private ExpressionSyntax value;

    internal InterpolationAlignmentClauseSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken CommaToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolationAlignmentClauseSyntax)this.Green).commaToken, this.Position, 0); }
    }

    public ExpressionSyntax Value 
    {
        get
        {
            return this.GetRed(ref this.value, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.value, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.value;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterpolationAlignmentClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterpolationAlignmentClause(this);
    }

    public InterpolationAlignmentClauseSyntax Update(SyntaxToken commaToken, ExpressionSyntax value)
    {
        if (commaToken != this.CommaToken || value != this.Value)
        {
            var newNode = SyntaxFactory.InterpolationAlignmentClause(commaToken, value);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public InterpolationAlignmentClauseSyntax WithCommaToken(SyntaxToken commaToken)
    {
        return this.Update(commaToken, this.Value);
    }

    public InterpolationAlignmentClauseSyntax WithValue(ExpressionSyntax value)
    {
        return this.Update(this.CommaToken, value);
    }
  }

  public sealed partial class InterpolationFormatClauseSyntax : CSharpSyntaxNode
  {
    internal InterpolationFormatClauseSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolationFormatClauseSyntax)this.Green).colonToken, this.Position, 0); }
    }

    /// <summary>The text contents of the format specifier for an interpolation.</summary>
    public SyntaxToken FormatStringToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolationFormatClauseSyntax)this.Green).formatStringToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterpolationFormatClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterpolationFormatClause(this);
    }

    public InterpolationFormatClauseSyntax Update(SyntaxToken colonToken, SyntaxToken formatStringToken)
    {
        if (colonToken != this.ColonToken || formatStringToken != this.FormatStringToken)
        {
            var newNode = SyntaxFactory.InterpolationFormatClause(colonToken, formatStringToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public InterpolationFormatClauseSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(colonToken, this.FormatStringToken);
    }

    public InterpolationFormatClauseSyntax WithFormatStringToken(SyntaxToken formatStringToken)
    {
        return this.Update(this.ColonToken, formatStringToken);
    }
  }

  public sealed partial class GlobalStatementSyntax : MemberDeclarationSyntax
  {
    private StatementSyntax statement;

    internal GlobalStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public StatementSyntax Statement 
    {
        get
        {
            return this.GetRedAtZero(ref this.statement);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.statement);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGlobalStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitGlobalStatement(this);
    }

    public GlobalStatementSyntax Update(StatementSyntax statement)
    {
        if (statement != this.Statement)
        {
            var newNode = SyntaxFactory.GlobalStatement(statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public GlobalStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(statement);
    }
  }

  /// <summary>Represents the base class for all statements syntax classes.</summary>
  public abstract partial class StatementSyntax : CSharpSyntaxNode
  {
    internal StatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  public sealed partial class BlockSyntax : StatementSyntax
  {
    private CSharpSyntaxNode statements;

    internal BlockSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)this.Green).openBraceToken, this.Position, 0); }
    }

    public SyntaxList<StatementSyntax> Statements 
    {
        get
        {
            return new SyntaxList<StatementSyntax>(this.GetRed(ref this.statements, 1));
        }
    }

    public SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)this.Green).closeBraceToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.statements, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.statements;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBlock(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBlock(this);
    }

    public BlockSyntax Update(SyntaxToken openBraceToken, SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || statements != this.Statements || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.Block(openBraceToken, statements, closeBraceToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public BlockSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(openBraceToken, this.Statements, this.CloseBraceToken);
    }

    public BlockSyntax WithStatements(SyntaxList<StatementSyntax> statements)
    {
        return this.Update(this.OpenBraceToken, statements, this.CloseBraceToken);
    }

    public BlockSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.OpenBraceToken, this.Statements, closeBraceToken);
    }

    public BlockSyntax AddStatements(params StatementSyntax[] items)
    {
        return this.WithStatements(this.Statements.AddRange(items));
    }
  }

  public sealed partial class LocalFunctionStatementSyntax : StatementSyntax
  {
    private TypeSyntax returnType;
    private TypeParameterListSyntax typeParameterList;
    private ParameterListSyntax parameterList;
    private CSharpSyntaxNode constraintClauses;
    private BlockSyntax body;
    private ArrowExpressionClauseSyntax expressionBody;

    internal LocalFunctionStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(0);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.Position, 0);

            return default(SyntaxTokenList);
        }
    }

    public SyntaxToken RefKeyword 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LocalFunctionStatementSyntax)this.Green).refKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxToken);
        }
    }

    public TypeSyntax ReturnType 
    {
        get
        {
            return this.GetRed(ref this.returnType, 2);
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LocalFunctionStatementSyntax)this.Green).identifier, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public TypeParameterListSyntax TypeParameterList 
    {
        get
        {
            return this.GetRed(ref this.typeParameterList, 4);
        }
    }

    public ParameterListSyntax ParameterList 
    {
        get
        {
            return this.GetRed(ref this.parameterList, 5);
        }
    }

    public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses 
    {
        get
        {
            return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.GetRed(ref this.constraintClauses, 6));
        }
    }

    public BlockSyntax Body 
    {
        get
        {
            return this.GetRed(ref this.body, 7);
        }
    }

    public ArrowExpressionClauseSyntax ExpressionBody 
    {
        get
        {
            return this.GetRed(ref this.expressionBody, 8);
        }
    }

    /// <summary>Gets the optional semicolon token.</summary>
    public SyntaxToken SemicolonToken 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LocalFunctionStatementSyntax)this.Green).semicolonToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(9), this.GetChildIndex(9));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.returnType, 2);
            case 4: return this.GetRed(ref this.typeParameterList, 4);
            case 5: return this.GetRed(ref this.parameterList, 5);
            case 6: return this.GetRed(ref this.constraintClauses, 6);
            case 7: return this.GetRed(ref this.body, 7);
            case 8: return this.GetRed(ref this.expressionBody, 8);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.returnType;
            case 4: return this.typeParameterList;
            case 5: return this.parameterList;
            case 6: return this.constraintClauses;
            case 7: return this.body;
            case 8: return this.expressionBody;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLocalFunctionStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLocalFunctionStatement(this);
    }

    public LocalFunctionStatementSyntax Update(SyntaxTokenList modifiers, SyntaxToken refKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (modifiers != this.Modifiers || refKeyword != this.RefKeyword || returnType != this.ReturnType || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || constraintClauses != this.ConstraintClauses || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.LocalFunctionStatement(modifiers, refKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public LocalFunctionStatementSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(modifiers, this.RefKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public LocalFunctionStatementSyntax WithRefKeyword(SyntaxToken refKeyword)
    {
        return this.Update(this.Modifiers, refKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public LocalFunctionStatementSyntax WithReturnType(TypeSyntax returnType)
    {
        return this.Update(this.Modifiers, this.RefKeyword, returnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public LocalFunctionStatementSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.Modifiers, this.RefKeyword, this.ReturnType, identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public LocalFunctionStatementSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)
    {
        return this.Update(this.Modifiers, this.RefKeyword, this.ReturnType, this.Identifier, typeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public LocalFunctionStatementSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.Modifiers, this.RefKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, parameterList, this.ConstraintClauses, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public LocalFunctionStatementSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)
    {
        return this.Update(this.Modifiers, this.RefKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, constraintClauses, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public LocalFunctionStatementSyntax WithBody(BlockSyntax body)
    {
        return this.Update(this.Modifiers, this.RefKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, body, this.ExpressionBody, this.SemicolonToken);
    }

    public LocalFunctionStatementSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)
    {
        return this.Update(this.Modifiers, this.RefKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, expressionBody, this.SemicolonToken);
    }

    public LocalFunctionStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.Modifiers, this.RefKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.ExpressionBody, semicolonToken);
    }

    public LocalFunctionStatementSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }

    public LocalFunctionStatementSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)
    {
        var typeParameterList = this.TypeParameterList ?? SyntaxFactory.TypeParameterList();
        return this.WithTypeParameterList(typeParameterList.WithParameters(typeParameterList.Parameters.AddRange(items)));
    }

    public LocalFunctionStatementSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.AddRange(items)));
    }

    public LocalFunctionStatementSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)
    {
        return this.WithConstraintClauses(this.ConstraintClauses.AddRange(items));
    }

    public LocalFunctionStatementSyntax AddBodyStatements(params StatementSyntax[] items)
    {
        var body = this.Body ?? SyntaxFactory.Block();
        return this.WithBody(body.WithStatements(body.Statements.AddRange(items)));
    }
  }

  public sealed partial class LocalDeclarationStatementSyntax : StatementSyntax
  {
    private VariableDeclarationSyntax declaration;

    internal LocalDeclarationStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the modifier list.</summary>
    public SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(0);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.Position, 0);

            return default(SyntaxTokenList);
        }
    }

    public SyntaxToken RefKeyword 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LocalDeclarationStatementSyntax)this.Green).refKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxToken);
        }
    }

    public VariableDeclarationSyntax Declaration 
    {
        get
        {
            return this.GetRed(ref this.declaration, 2);
        }
    }

    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LocalDeclarationStatementSyntax)this.Green).semicolonToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.declaration, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.declaration;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLocalDeclarationStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLocalDeclarationStatement(this);
    }

    public LocalDeclarationStatementSyntax Update(SyntaxTokenList modifiers, SyntaxToken refKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
        if (modifiers != this.Modifiers || refKeyword != this.RefKeyword || declaration != this.Declaration || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.LocalDeclarationStatement(modifiers, refKeyword, declaration, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public LocalDeclarationStatementSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(modifiers, this.RefKeyword, this.Declaration, this.SemicolonToken);
    }

    public LocalDeclarationStatementSyntax WithRefKeyword(SyntaxToken refKeyword)
    {
        return this.Update(this.Modifiers, refKeyword, this.Declaration, this.SemicolonToken);
    }

    public LocalDeclarationStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration)
    {
        return this.Update(this.Modifiers, this.RefKeyword, declaration, this.SemicolonToken);
    }

    public LocalDeclarationStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.Modifiers, this.RefKeyword, this.Declaration, semicolonToken);
    }

    public LocalDeclarationStatementSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }

    public LocalDeclarationStatementSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items)
    {
        return this.WithDeclaration(this.Declaration.WithVariables(this.Declaration.Variables.AddRange(items)));
    }
  }

  public sealed partial class VariableDeconstructionDeclaratorSyntax : CSharpSyntaxNode
  {
    private SyntaxNode variables;
    private ExpressionSyntax value;

    internal VariableDeconstructionDeclaratorSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeconstructionDeclaratorSyntax)this.Green).openParenToken, this.Position, 0); }
    }

    public SeparatedSyntaxList<VariableDeclarationSyntax> Variables 
    {
        get
        {
            var red = this.GetRed(ref this.variables, 1);
            if (red != null)
                return new SeparatedSyntaxList<VariableDeclarationSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<VariableDeclarationSyntax>);
        }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeconstructionDeclaratorSyntax)this.Green).closeParenToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxToken EqualsToken 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeconstructionDeclaratorSyntax)this.Green).equalsToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(3), this.GetChildIndex(3));

            return default(SyntaxToken);
        }
    }

    public ExpressionSyntax Value 
    {
        get
        {
            return this.GetRed(ref this.value, 4);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.variables, 1);
            case 4: return this.GetRed(ref this.value, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.variables;
            case 4: return this.value;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitVariableDeconstructionDeclarator(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitVariableDeconstructionDeclarator(this);
    }

    public VariableDeconstructionDeclaratorSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<VariableDeclarationSyntax> variables, SyntaxToken closeParenToken, SyntaxToken equalsToken, ExpressionSyntax value)
    {
        if (openParenToken != this.OpenParenToken || variables != this.Variables || closeParenToken != this.CloseParenToken || equalsToken != this.EqualsToken || value != this.Value)
        {
            var newNode = SyntaxFactory.VariableDeconstructionDeclarator(openParenToken, variables, closeParenToken, equalsToken, value);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public VariableDeconstructionDeclaratorSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Variables, this.CloseParenToken, this.EqualsToken, this.Value);
    }

    public VariableDeconstructionDeclaratorSyntax WithVariables(SeparatedSyntaxList<VariableDeclarationSyntax> variables)
    {
        return this.Update(this.OpenParenToken, variables, this.CloseParenToken, this.EqualsToken, this.Value);
    }

    public VariableDeconstructionDeclaratorSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Variables, closeParenToken, this.EqualsToken, this.Value);
    }

    public VariableDeconstructionDeclaratorSyntax WithEqualsToken(SyntaxToken equalsToken)
    {
        return this.Update(this.OpenParenToken, this.Variables, this.CloseParenToken, equalsToken, this.Value);
    }

    public VariableDeconstructionDeclaratorSyntax WithValue(ExpressionSyntax value)
    {
        return this.Update(this.OpenParenToken, this.Variables, this.CloseParenToken, this.EqualsToken, value);
    }

    public VariableDeconstructionDeclaratorSyntax AddVariables(params VariableDeclarationSyntax[] items)
    {
        return this.WithVariables(this.Variables.AddRange(items));
    }
  }

  public sealed partial class VariableDeclarationSyntax : CSharpSyntaxNode
  {
    private TypeSyntax type;
    private SyntaxNode variables;
    private VariableDeconstructionDeclaratorSyntax deconstruction;

    internal VariableDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public TypeSyntax Type 
    {
        get
        {
            return this.GetRedAtZero(ref this.type);
        }
    }

    public SeparatedSyntaxList<VariableDeclaratorSyntax> Variables 
    {
        get
        {
            var red = this.GetRed(ref this.variables, 1);
            if (red != null)
                return new SeparatedSyntaxList<VariableDeclaratorSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<VariableDeclaratorSyntax>);
        }
    }

    public VariableDeconstructionDeclaratorSyntax Deconstruction 
    {
        get
        {
            return this.GetRed(ref this.deconstruction, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.type);
            case 1: return this.GetRed(ref this.variables, 1);
            case 2: return this.GetRed(ref this.deconstruction, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            case 1: return this.variables;
            case 2: return this.deconstruction;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitVariableDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitVariableDeclaration(this);
    }

    public VariableDeclarationSyntax Update(TypeSyntax type, SeparatedSyntaxList<VariableDeclaratorSyntax> variables, VariableDeconstructionDeclaratorSyntax deconstruction)
    {
        if (type != this.Type || variables != this.Variables || deconstruction != this.Deconstruction)
        {
            var newNode = SyntaxFactory.VariableDeclaration(type, variables, deconstruction);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public VariableDeclarationSyntax WithType(TypeSyntax type)
    {
        return this.Update(type, this.Variables, this.Deconstruction);
    }

    public VariableDeclarationSyntax WithVariables(SeparatedSyntaxList<VariableDeclaratorSyntax> variables)
    {
        return this.Update(this.Type, variables, this.Deconstruction);
    }

    public VariableDeclarationSyntax WithDeconstruction(VariableDeconstructionDeclaratorSyntax deconstruction)
    {
        return this.Update(this.Type, this.Variables, deconstruction);
    }

    public VariableDeclarationSyntax AddVariables(params VariableDeclaratorSyntax[] items)
    {
        return this.WithVariables(this.Variables.AddRange(items));
    }

    public VariableDeclarationSyntax AddDeconstructionVariables(params VariableDeclarationSyntax[] items)
    {
        var deconstruction = this.Deconstruction ?? SyntaxFactory.VariableDeconstructionDeclarator();
        return this.WithDeconstruction(deconstruction.WithVariables(deconstruction.Variables.AddRange(items)));
    }
  }

  public sealed partial class VariableDeclaratorSyntax : CSharpSyntaxNode
  {
    private BracketedArgumentListSyntax argumentList;
    private EqualsValueClauseSyntax initializer;

    internal VariableDeclaratorSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeclaratorSyntax)this.Green).identifier, this.Position, 0); }
    }

    public BracketedArgumentListSyntax ArgumentList 
    {
        get
        {
            return this.GetRed(ref this.argumentList, 1);
        }
    }

    public EqualsValueClauseSyntax Initializer 
    {
        get
        {
            return this.GetRed(ref this.initializer, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.argumentList, 1);
            case 2: return this.GetRed(ref this.initializer, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.argumentList;
            case 2: return this.initializer;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitVariableDeclarator(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitVariableDeclarator(this);
    }

    public VariableDeclaratorSyntax Update(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
    {
        if (identifier != this.Identifier || argumentList != this.ArgumentList || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.VariableDeclarator(identifier, argumentList, initializer);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public VariableDeclaratorSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(identifier, this.ArgumentList, this.Initializer);
    }

    public VariableDeclaratorSyntax WithArgumentList(BracketedArgumentListSyntax argumentList)
    {
        return this.Update(this.Identifier, argumentList, this.Initializer);
    }

    public VariableDeclaratorSyntax WithInitializer(EqualsValueClauseSyntax initializer)
    {
        return this.Update(this.Identifier, this.ArgumentList, initializer);
    }

    public VariableDeclaratorSyntax AddArgumentListArguments(params ArgumentSyntax[] items)
    {
        var argumentList = this.ArgumentList ?? SyntaxFactory.BracketedArgumentList();
        return this.WithArgumentList(argumentList.WithArguments(argumentList.Arguments.AddRange(items)));
    }
  }

  public sealed partial class EqualsValueClauseSyntax : CSharpSyntaxNode
  {
    private ExpressionSyntax value;

    internal EqualsValueClauseSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken EqualsToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EqualsValueClauseSyntax)this.Green).equalsToken, this.Position, 0); }
    }

    public SyntaxToken RefKeyword 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EqualsValueClauseSyntax)this.Green).refKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxToken);
        }
    }

    public ExpressionSyntax Value 
    {
        get
        {
            return this.GetRed(ref this.value, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.value, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.value;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEqualsValueClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEqualsValueClause(this);
    }

    public EqualsValueClauseSyntax Update(SyntaxToken equalsToken, SyntaxToken refKeyword, ExpressionSyntax value)
    {
        if (equalsToken != this.EqualsToken || refKeyword != this.RefKeyword || value != this.Value)
        {
            var newNode = SyntaxFactory.EqualsValueClause(equalsToken, refKeyword, value);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public EqualsValueClauseSyntax WithEqualsToken(SyntaxToken equalsToken)
    {
        return this.Update(equalsToken, this.RefKeyword, this.Value);
    }

    public EqualsValueClauseSyntax WithRefKeyword(SyntaxToken refKeyword)
    {
        return this.Update(this.EqualsToken, refKeyword, this.Value);
    }

    public EqualsValueClauseSyntax WithValue(ExpressionSyntax value)
    {
        return this.Update(this.EqualsToken, this.RefKeyword, value);
    }
  }

  public sealed partial class ExpressionStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax expression;

    internal ExpressionStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRedAtZero(ref this.expression);
        }
    }

    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionStatementSyntax)this.Green).semicolonToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.expression);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitExpressionStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitExpressionStatement(this);
    }

    public ExpressionStatementSyntax Update(ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ExpressionStatement(expression, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ExpressionStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(expression, this.SemicolonToken);
    }

    public ExpressionStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.Expression, semicolonToken);
    }
  }

  public sealed partial class EmptyStatementSyntax : StatementSyntax
  {
    internal EmptyStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EmptyStatementSyntax)this.Green).semicolonToken, this.Position, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEmptyStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEmptyStatement(this);
    }

    public EmptyStatementSyntax Update(SyntaxToken semicolonToken)
    {
        if (semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.EmptyStatement(semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public EmptyStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(semicolonToken);
    }
  }

  /// <summary>Represents a labeled statement syntax.</summary>
  public sealed partial class LabeledStatementSyntax : StatementSyntax
  {
    private StatementSyntax statement;

    internal LabeledStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LabeledStatementSyntax)this.Green).identifier, this.Position, 0); }
    }

    /// <summary>Gets a SyntaxToken that represents the colon succeeding the statement's label.</summary>
    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LabeledStatementSyntax)this.Green).colonToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public StatementSyntax Statement 
    {
        get
        {
            return this.GetRed(ref this.statement, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.statement, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLabeledStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLabeledStatement(this);
    }

    public LabeledStatementSyntax Update(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
    {
        if (identifier != this.Identifier || colonToken != this.ColonToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.LabeledStatement(identifier, colonToken, statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public LabeledStatementSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(identifier, this.ColonToken, this.Statement);
    }

    public LabeledStatementSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.Identifier, colonToken, this.Statement);
    }

    public LabeledStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.Identifier, this.ColonToken, statement);
    }
  }

  /// <summary>
  /// Represents a goto statement syntax
  /// </summary>
  public sealed partial class GotoStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax expression;

    internal GotoStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the goto keyword.
    /// </summary>
    public SyntaxToken GotoKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GotoStatementSyntax)this.Green).gotoKeyword, this.Position, 0); }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the case or default keywords if any exists.
    /// </summary>
    public SyntaxToken CaseOrDefaultKeyword 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GotoStatementSyntax)this.Green).caseOrDefaultKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxToken);
        }
    }

    /// <summary>
    /// Gets a constant expression for a goto case statement.
    /// </summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 2);
        }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the semi-colon at the end of the statement.
    /// </summary>
    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GotoStatementSyntax)this.Green).semicolonToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGotoStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitGotoStatement(this);
    }

    public GotoStatementSyntax Update(SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (gotoKeyword != this.GotoKeyword || caseOrDefaultKeyword != this.CaseOrDefaultKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.GotoStatement(this.Kind(), gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public GotoStatementSyntax WithGotoKeyword(SyntaxToken gotoKeyword)
    {
        return this.Update(gotoKeyword, this.CaseOrDefaultKeyword, this.Expression, this.SemicolonToken);
    }

    public GotoStatementSyntax WithCaseOrDefaultKeyword(SyntaxToken caseOrDefaultKeyword)
    {
        return this.Update(this.GotoKeyword, caseOrDefaultKeyword, this.Expression, this.SemicolonToken);
    }

    public GotoStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.GotoKeyword, this.CaseOrDefaultKeyword, expression, this.SemicolonToken);
    }

    public GotoStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.GotoKeyword, this.CaseOrDefaultKeyword, this.Expression, semicolonToken);
    }
  }

  public sealed partial class BreakStatementSyntax : StatementSyntax
  {
    internal BreakStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken BreakKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BreakStatementSyntax)this.Green).breakKeyword, this.Position, 0); }
    }

    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BreakStatementSyntax)this.Green).semicolonToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBreakStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBreakStatement(this);
    }

    public BreakStatementSyntax Update(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
    {
        if (breakKeyword != this.BreakKeyword || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.BreakStatement(breakKeyword, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public BreakStatementSyntax WithBreakKeyword(SyntaxToken breakKeyword)
    {
        return this.Update(breakKeyword, this.SemicolonToken);
    }

    public BreakStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.BreakKeyword, semicolonToken);
    }
  }

  public sealed partial class ContinueStatementSyntax : StatementSyntax
  {
    internal ContinueStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken ContinueKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ContinueStatementSyntax)this.Green).continueKeyword, this.Position, 0); }
    }

    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ContinueStatementSyntax)this.Green).semicolonToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitContinueStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitContinueStatement(this);
    }

    public ContinueStatementSyntax Update(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
    {
        if (continueKeyword != this.ContinueKeyword || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ContinueStatement(continueKeyword, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ContinueStatementSyntax WithContinueKeyword(SyntaxToken continueKeyword)
    {
        return this.Update(continueKeyword, this.SemicolonToken);
    }

    public ContinueStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.ContinueKeyword, semicolonToken);
    }
  }

  public sealed partial class ReturnStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax expression;

    internal ReturnStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken ReturnKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ReturnStatementSyntax)this.Green).returnKeyword, this.Position, 0); }
    }

    public SyntaxToken RefKeyword 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ReturnStatementSyntax)this.Green).refKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxToken);
        }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 2);
        }
    }

    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ReturnStatementSyntax)this.Green).semicolonToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitReturnStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitReturnStatement(this);
    }

    public ReturnStatementSyntax Update(SyntaxToken returnKeyword, SyntaxToken refKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (returnKeyword != this.ReturnKeyword || refKeyword != this.RefKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ReturnStatement(returnKeyword, refKeyword, expression, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ReturnStatementSyntax WithReturnKeyword(SyntaxToken returnKeyword)
    {
        return this.Update(returnKeyword, this.RefKeyword, this.Expression, this.SemicolonToken);
    }

    public ReturnStatementSyntax WithRefKeyword(SyntaxToken refKeyword)
    {
        return this.Update(this.ReturnKeyword, refKeyword, this.Expression, this.SemicolonToken);
    }

    public ReturnStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.ReturnKeyword, this.RefKeyword, expression, this.SemicolonToken);
    }

    public ReturnStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.ReturnKeyword, this.RefKeyword, this.Expression, semicolonToken);
    }
  }

  public sealed partial class ThrowStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax expression;

    internal ThrowStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken ThrowKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ThrowStatementSyntax)this.Green).throwKeyword, this.Position, 0); }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 1);
        }
    }

    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ThrowStatementSyntax)this.Green).semicolonToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.expression, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitThrowStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitThrowStatement(this);
    }

    public ThrowStatementSyntax Update(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (throwKeyword != this.ThrowKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ThrowStatement(throwKeyword, expression, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ThrowStatementSyntax WithThrowKeyword(SyntaxToken throwKeyword)
    {
        return this.Update(throwKeyword, this.Expression, this.SemicolonToken);
    }

    public ThrowStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.ThrowKeyword, expression, this.SemicolonToken);
    }

    public ThrowStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.ThrowKeyword, this.Expression, semicolonToken);
    }
  }

  public sealed partial class YieldStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax expression;

    internal YieldStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken YieldKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.YieldStatementSyntax)this.Green).yieldKeyword, this.Position, 0); }
    }

    public SyntaxToken ReturnOrBreakKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.YieldStatementSyntax)this.Green).returnOrBreakKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 2);
        }
    }

    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.YieldStatementSyntax)this.Green).semicolonToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitYieldStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitYieldStatement(this);
    }

    public YieldStatementSyntax Update(SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (yieldKeyword != this.YieldKeyword || returnOrBreakKeyword != this.ReturnOrBreakKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.YieldStatement(this.Kind(), yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public YieldStatementSyntax WithYieldKeyword(SyntaxToken yieldKeyword)
    {
        return this.Update(yieldKeyword, this.ReturnOrBreakKeyword, this.Expression, this.SemicolonToken);
    }

    public YieldStatementSyntax WithReturnOrBreakKeyword(SyntaxToken returnOrBreakKeyword)
    {
        return this.Update(this.YieldKeyword, returnOrBreakKeyword, this.Expression, this.SemicolonToken);
    }

    public YieldStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.YieldKeyword, this.ReturnOrBreakKeyword, expression, this.SemicolonToken);
    }

    public YieldStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.YieldKeyword, this.ReturnOrBreakKeyword, this.Expression, semicolonToken);
    }
  }

  public sealed partial class WhileStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax condition;
    private StatementSyntax statement;

    internal WhileStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken WhileKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.WhileStatementSyntax)this.Green).whileKeyword, this.Position, 0); }
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.WhileStatementSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public ExpressionSyntax Condition 
    {
        get
        {
            return this.GetRed(ref this.condition, 2);
        }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.WhileStatementSyntax)this.Green).closeParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public StatementSyntax Statement 
    {
        get
        {
            return this.GetRed(ref this.statement, 4);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.condition, 2);
            case 4: return this.GetRed(ref this.statement, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.condition;
            case 4: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitWhileStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitWhileStatement(this);
    }

    public WhileStatementSyntax Update(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (whileKeyword != this.WhileKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.WhileStatement(whileKeyword, openParenToken, condition, closeParenToken, statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public WhileStatementSyntax WithWhileKeyword(SyntaxToken whileKeyword)
    {
        return this.Update(whileKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, this.Statement);
    }

    public WhileStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.WhileKeyword, openParenToken, this.Condition, this.CloseParenToken, this.Statement);
    }

    public WhileStatementSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.WhileKeyword, this.OpenParenToken, condition, this.CloseParenToken, this.Statement);
    }

    public WhileStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.WhileKeyword, this.OpenParenToken, this.Condition, closeParenToken, this.Statement);
    }

    public WhileStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.WhileKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, statement);
    }
  }

  public sealed partial class DoStatementSyntax : StatementSyntax
  {
    private StatementSyntax statement;
    private ExpressionSyntax condition;

    internal DoStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken DoKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DoStatementSyntax)this.Green).doKeyword, this.Position, 0); }
    }

    public StatementSyntax Statement 
    {
        get
        {
            return this.GetRed(ref this.statement, 1);
        }
    }

    public SyntaxToken WhileKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DoStatementSyntax)this.Green).whileKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DoStatementSyntax)this.Green).openParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public ExpressionSyntax Condition 
    {
        get
        {
            return this.GetRed(ref this.condition, 4);
        }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DoStatementSyntax)this.Green).closeParenToken, this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DoStatementSyntax)this.Green).semicolonToken, this.GetChildPosition(6), this.GetChildIndex(6)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.statement, 1);
            case 4: return this.GetRed(ref this.condition, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.statement;
            case 4: return this.condition;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDoStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDoStatement(this);
    }

    public DoStatementSyntax Update(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
    {
        if (doKeyword != this.DoKeyword || statement != this.Statement || whileKeyword != this.WhileKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.DoStatement(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public DoStatementSyntax WithDoKeyword(SyntaxToken doKeyword)
    {
        return this.Update(doKeyword, this.Statement, this.WhileKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, this.SemicolonToken);
    }

    public DoStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.DoKeyword, statement, this.WhileKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, this.SemicolonToken);
    }

    public DoStatementSyntax WithWhileKeyword(SyntaxToken whileKeyword)
    {
        return this.Update(this.DoKeyword, this.Statement, whileKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, this.SemicolonToken);
    }

    public DoStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.DoKeyword, this.Statement, this.WhileKeyword, openParenToken, this.Condition, this.CloseParenToken, this.SemicolonToken);
    }

    public DoStatementSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.DoKeyword, this.Statement, this.WhileKeyword, this.OpenParenToken, condition, this.CloseParenToken, this.SemicolonToken);
    }

    public DoStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.DoKeyword, this.Statement, this.WhileKeyword, this.OpenParenToken, this.Condition, closeParenToken, this.SemicolonToken);
    }

    public DoStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.DoKeyword, this.Statement, this.WhileKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, semicolonToken);
    }
  }

  public sealed partial class ForStatementSyntax : StatementSyntax
  {
    private VariableDeclarationSyntax declaration;
    private SyntaxNode initializers;
    private ExpressionSyntax condition;
    private SyntaxNode incrementors;
    private StatementSyntax statement;

    internal ForStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken ForKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ForStatementSyntax)this.Green).forKeyword, this.Position, 0); }
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ForStatementSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken RefKeyword 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ForStatementSyntax)this.Green).refKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(2), this.GetChildIndex(2));

            return default(SyntaxToken);
        }
    }

    public VariableDeclarationSyntax Declaration 
    {
        get
        {
            return this.GetRed(ref this.declaration, 3);
        }
    }

    public SeparatedSyntaxList<ExpressionSyntax> Initializers 
    {
        get
        {
            var red = this.GetRed(ref this.initializers, 4);
            if (red != null)
                return new SeparatedSyntaxList<ExpressionSyntax>(red, this.GetChildIndex(4));

            return default(SeparatedSyntaxList<ExpressionSyntax>);
        }
    }

    public SyntaxToken FirstSemicolonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ForStatementSyntax)this.Green).firstSemicolonToken, this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    public ExpressionSyntax Condition 
    {
        get
        {
            return this.GetRed(ref this.condition, 6);
        }
    }

    public SyntaxToken SecondSemicolonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ForStatementSyntax)this.Green).secondSemicolonToken, this.GetChildPosition(7), this.GetChildIndex(7)); }
    }

    public SeparatedSyntaxList<ExpressionSyntax> Incrementors 
    {
        get
        {
            var red = this.GetRed(ref this.incrementors, 8);
            if (red != null)
                return new SeparatedSyntaxList<ExpressionSyntax>(red, this.GetChildIndex(8));

            return default(SeparatedSyntaxList<ExpressionSyntax>);
        }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ForStatementSyntax)this.Green).closeParenToken, this.GetChildPosition(9), this.GetChildIndex(9)); }
    }

    public StatementSyntax Statement 
    {
        get
        {
            return this.GetRed(ref this.statement, 10);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 3: return this.GetRed(ref this.declaration, 3);
            case 4: return this.GetRed(ref this.initializers, 4);
            case 6: return this.GetRed(ref this.condition, 6);
            case 8: return this.GetRed(ref this.incrementors, 8);
            case 10: return this.GetRed(ref this.statement, 10);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 3: return this.declaration;
            case 4: return this.initializers;
            case 6: return this.condition;
            case 8: return this.incrementors;
            case 10: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitForStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitForStatement(this);
    }

    public ForStatementSyntax Update(SyntaxToken forKeyword, SyntaxToken openParenToken, SyntaxToken refKeyword, VariableDeclarationSyntax declaration, SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (forKeyword != this.ForKeyword || openParenToken != this.OpenParenToken || refKeyword != this.RefKeyword || declaration != this.Declaration || initializers != this.Initializers || firstSemicolonToken != this.FirstSemicolonToken || condition != this.Condition || secondSemicolonToken != this.SecondSemicolonToken || incrementors != this.Incrementors || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.ForStatement(forKeyword, openParenToken, refKeyword, declaration, initializers, firstSemicolonToken, condition, secondSemicolonToken, incrementors, closeParenToken, statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ForStatementSyntax WithForKeyword(SyntaxToken forKeyword)
    {
        return this.Update(forKeyword, this.OpenParenToken, this.RefKeyword, this.Declaration, this.Initializers, this.FirstSemicolonToken, this.Condition, this.SecondSemicolonToken, this.Incrementors, this.CloseParenToken, this.Statement);
    }

    public ForStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.ForKeyword, openParenToken, this.RefKeyword, this.Declaration, this.Initializers, this.FirstSemicolonToken, this.Condition, this.SecondSemicolonToken, this.Incrementors, this.CloseParenToken, this.Statement);
    }

    public ForStatementSyntax WithRefKeyword(SyntaxToken refKeyword)
    {
        return this.Update(this.ForKeyword, this.OpenParenToken, refKeyword, this.Declaration, this.Initializers, this.FirstSemicolonToken, this.Condition, this.SecondSemicolonToken, this.Incrementors, this.CloseParenToken, this.Statement);
    }

    public ForStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration)
    {
        return this.Update(this.ForKeyword, this.OpenParenToken, this.RefKeyword, declaration, this.Initializers, this.FirstSemicolonToken, this.Condition, this.SecondSemicolonToken, this.Incrementors, this.CloseParenToken, this.Statement);
    }

    public ForStatementSyntax WithInitializers(SeparatedSyntaxList<ExpressionSyntax> initializers)
    {
        return this.Update(this.ForKeyword, this.OpenParenToken, this.RefKeyword, this.Declaration, initializers, this.FirstSemicolonToken, this.Condition, this.SecondSemicolonToken, this.Incrementors, this.CloseParenToken, this.Statement);
    }

    public ForStatementSyntax WithFirstSemicolonToken(SyntaxToken firstSemicolonToken)
    {
        return this.Update(this.ForKeyword, this.OpenParenToken, this.RefKeyword, this.Declaration, this.Initializers, firstSemicolonToken, this.Condition, this.SecondSemicolonToken, this.Incrementors, this.CloseParenToken, this.Statement);
    }

    public ForStatementSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.ForKeyword, this.OpenParenToken, this.RefKeyword, this.Declaration, this.Initializers, this.FirstSemicolonToken, condition, this.SecondSemicolonToken, this.Incrementors, this.CloseParenToken, this.Statement);
    }

    public ForStatementSyntax WithSecondSemicolonToken(SyntaxToken secondSemicolonToken)
    {
        return this.Update(this.ForKeyword, this.OpenParenToken, this.RefKeyword, this.Declaration, this.Initializers, this.FirstSemicolonToken, this.Condition, secondSemicolonToken, this.Incrementors, this.CloseParenToken, this.Statement);
    }

    public ForStatementSyntax WithIncrementors(SeparatedSyntaxList<ExpressionSyntax> incrementors)
    {
        return this.Update(this.ForKeyword, this.OpenParenToken, this.RefKeyword, this.Declaration, this.Initializers, this.FirstSemicolonToken, this.Condition, this.SecondSemicolonToken, incrementors, this.CloseParenToken, this.Statement);
    }

    public ForStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.ForKeyword, this.OpenParenToken, this.RefKeyword, this.Declaration, this.Initializers, this.FirstSemicolonToken, this.Condition, this.SecondSemicolonToken, this.Incrementors, closeParenToken, this.Statement);
    }

    public ForStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.ForKeyword, this.OpenParenToken, this.RefKeyword, this.Declaration, this.Initializers, this.FirstSemicolonToken, this.Condition, this.SecondSemicolonToken, this.Incrementors, this.CloseParenToken, statement);
    }

    public ForStatementSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items)
    {
        var declaration = this.Declaration ?? SyntaxFactory.VariableDeclaration();
        return this.WithDeclaration(declaration.WithVariables(declaration.Variables.AddRange(items)));
    }

    public ForStatementSyntax AddInitializers(params ExpressionSyntax[] items)
    {
        return this.WithInitializers(this.Initializers.AddRange(items));
    }

    public ForStatementSyntax AddIncrementors(params ExpressionSyntax[] items)
    {
        return this.WithIncrementors(this.Incrementors.AddRange(items));
    }
  }

  public sealed partial class ForEachStatementSyntax : StatementSyntax
  {
    private TypeSyntax type;
    private VariableDeclarationSyntax deconstructionVariables;
    private ExpressionSyntax expression;
    private StatementSyntax statement;

    internal ForEachStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken ForEachKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ForEachStatementSyntax)this.Green).forEachKeyword, this.Position, 0); }
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ForEachStatementSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 2);
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ForEachStatementSyntax)this.Green).identifier;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(3), this.GetChildIndex(3));

            return default(SyntaxToken);
        }
    }

    public VariableDeclarationSyntax DeconstructionVariables 
    {
        get
        {
            return this.GetRed(ref this.deconstructionVariables, 4);
        }
    }

    public SyntaxToken InKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ForEachStatementSyntax)this.Green).inKeyword, this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 6);
        }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ForEachStatementSyntax)this.Green).closeParenToken, this.GetChildPosition(7), this.GetChildIndex(7)); }
    }

    public StatementSyntax Statement 
    {
        get
        {
            return this.GetRed(ref this.statement, 8);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.type, 2);
            case 4: return this.GetRed(ref this.deconstructionVariables, 4);
            case 6: return this.GetRed(ref this.expression, 6);
            case 8: return this.GetRed(ref this.statement, 8);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.type;
            case 4: return this.deconstructionVariables;
            case 6: return this.expression;
            case 8: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitForEachStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitForEachStatement(this);
    }

    public ForEachStatementSyntax Update(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, VariableDeclarationSyntax deconstructionVariables, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (forEachKeyword != this.ForEachKeyword || openParenToken != this.OpenParenToken || type != this.Type || identifier != this.Identifier || deconstructionVariables != this.DeconstructionVariables || inKeyword != this.InKeyword || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.ForEachStatement(forEachKeyword, openParenToken, type, identifier, deconstructionVariables, inKeyword, expression, closeParenToken, statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ForEachStatementSyntax WithForEachKeyword(SyntaxToken forEachKeyword)
    {
        return this.Update(forEachKeyword, this.OpenParenToken, this.Type, this.Identifier, this.DeconstructionVariables, this.InKeyword, this.Expression, this.CloseParenToken, this.Statement);
    }

    public ForEachStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.ForEachKeyword, openParenToken, this.Type, this.Identifier, this.DeconstructionVariables, this.InKeyword, this.Expression, this.CloseParenToken, this.Statement);
    }

    public ForEachStatementSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.ForEachKeyword, this.OpenParenToken, type, this.Identifier, this.DeconstructionVariables, this.InKeyword, this.Expression, this.CloseParenToken, this.Statement);
    }

    public ForEachStatementSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.ForEachKeyword, this.OpenParenToken, this.Type, identifier, this.DeconstructionVariables, this.InKeyword, this.Expression, this.CloseParenToken, this.Statement);
    }

    public ForEachStatementSyntax WithDeconstructionVariables(VariableDeclarationSyntax deconstructionVariables)
    {
        return this.Update(this.ForEachKeyword, this.OpenParenToken, this.Type, this.Identifier, deconstructionVariables, this.InKeyword, this.Expression, this.CloseParenToken, this.Statement);
    }

    public ForEachStatementSyntax WithInKeyword(SyntaxToken inKeyword)
    {
        return this.Update(this.ForEachKeyword, this.OpenParenToken, this.Type, this.Identifier, this.DeconstructionVariables, inKeyword, this.Expression, this.CloseParenToken, this.Statement);
    }

    public ForEachStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.ForEachKeyword, this.OpenParenToken, this.Type, this.Identifier, this.DeconstructionVariables, this.InKeyword, expression, this.CloseParenToken, this.Statement);
    }

    public ForEachStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.ForEachKeyword, this.OpenParenToken, this.Type, this.Identifier, this.DeconstructionVariables, this.InKeyword, this.Expression, closeParenToken, this.Statement);
    }

    public ForEachStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.ForEachKeyword, this.OpenParenToken, this.Type, this.Identifier, this.DeconstructionVariables, this.InKeyword, this.Expression, this.CloseParenToken, statement);
    }

    public ForEachStatementSyntax AddDeconstructionVariablesVariables(params VariableDeclaratorSyntax[] items)
    {
        var deconstructionVariables = this.DeconstructionVariables ?? SyntaxFactory.VariableDeclaration();
        return this.WithDeconstructionVariables(deconstructionVariables.WithVariables(deconstructionVariables.Variables.AddRange(items)));
    }
  }

  public sealed partial class UsingStatementSyntax : StatementSyntax
  {
    private VariableDeclarationSyntax declaration;
    private ExpressionSyntax expression;
    private StatementSyntax statement;

    internal UsingStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken UsingKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.UsingStatementSyntax)this.Green).usingKeyword, this.Position, 0); }
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.UsingStatementSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public VariableDeclarationSyntax Declaration 
    {
        get
        {
            return this.GetRed(ref this.declaration, 2);
        }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 3);
        }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.UsingStatementSyntax)this.Green).closeParenToken, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    public StatementSyntax Statement 
    {
        get
        {
            return this.GetRed(ref this.statement, 5);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.declaration, 2);
            case 3: return this.GetRed(ref this.expression, 3);
            case 5: return this.GetRed(ref this.statement, 5);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.declaration;
            case 3: return this.expression;
            case 5: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitUsingStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitUsingStatement(this);
    }

    public UsingStatementSyntax Update(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (usingKeyword != this.UsingKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.UsingStatement(usingKeyword, openParenToken, declaration, expression, closeParenToken, statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public UsingStatementSyntax WithUsingKeyword(SyntaxToken usingKeyword)
    {
        return this.Update(usingKeyword, this.OpenParenToken, this.Declaration, this.Expression, this.CloseParenToken, this.Statement);
    }

    public UsingStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.UsingKeyword, openParenToken, this.Declaration, this.Expression, this.CloseParenToken, this.Statement);
    }

    public UsingStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration)
    {
        return this.Update(this.UsingKeyword, this.OpenParenToken, declaration, this.Expression, this.CloseParenToken, this.Statement);
    }

    public UsingStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.UsingKeyword, this.OpenParenToken, this.Declaration, expression, this.CloseParenToken, this.Statement);
    }

    public UsingStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.UsingKeyword, this.OpenParenToken, this.Declaration, this.Expression, closeParenToken, this.Statement);
    }

    public UsingStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.UsingKeyword, this.OpenParenToken, this.Declaration, this.Expression, this.CloseParenToken, statement);
    }

    public UsingStatementSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items)
    {
        var declaration = this.Declaration ?? SyntaxFactory.VariableDeclaration();
        return this.WithDeclaration(declaration.WithVariables(declaration.Variables.AddRange(items)));
    }
  }

  public sealed partial class FixedStatementSyntax : StatementSyntax
  {
    private VariableDeclarationSyntax declaration;
    private StatementSyntax statement;

    internal FixedStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken FixedKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FixedStatementSyntax)this.Green).fixedKeyword, this.Position, 0); }
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FixedStatementSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public VariableDeclarationSyntax Declaration 
    {
        get
        {
            return this.GetRed(ref this.declaration, 2);
        }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FixedStatementSyntax)this.Green).closeParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public StatementSyntax Statement 
    {
        get
        {
            return this.GetRed(ref this.statement, 4);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.declaration, 2);
            case 4: return this.GetRed(ref this.statement, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.declaration;
            case 4: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFixedStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitFixedStatement(this);
    }

    public FixedStatementSyntax Update(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (fixedKeyword != this.FixedKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.FixedStatement(fixedKeyword, openParenToken, declaration, closeParenToken, statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public FixedStatementSyntax WithFixedKeyword(SyntaxToken fixedKeyword)
    {
        return this.Update(fixedKeyword, this.OpenParenToken, this.Declaration, this.CloseParenToken, this.Statement);
    }

    public FixedStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.FixedKeyword, openParenToken, this.Declaration, this.CloseParenToken, this.Statement);
    }

    public FixedStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration)
    {
        return this.Update(this.FixedKeyword, this.OpenParenToken, declaration, this.CloseParenToken, this.Statement);
    }

    public FixedStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.FixedKeyword, this.OpenParenToken, this.Declaration, closeParenToken, this.Statement);
    }

    public FixedStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.FixedKeyword, this.OpenParenToken, this.Declaration, this.CloseParenToken, statement);
    }

    public FixedStatementSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items)
    {
        return this.WithDeclaration(this.Declaration.WithVariables(this.Declaration.Variables.AddRange(items)));
    }
  }

  public sealed partial class CheckedStatementSyntax : StatementSyntax
  {
    private BlockSyntax block;

    internal CheckedStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CheckedStatementSyntax)this.Green).keyword, this.Position, 0); }
    }

    public BlockSyntax Block 
    {
        get
        {
            return this.GetRed(ref this.block, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.block, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.block;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCheckedStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCheckedStatement(this);
    }

    public CheckedStatementSyntax Update(SyntaxToken keyword, BlockSyntax block)
    {
        if (keyword != this.Keyword || block != this.Block)
        {
            var newNode = SyntaxFactory.CheckedStatement(this.Kind(), keyword, block);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CheckedStatementSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.Block);
    }

    public CheckedStatementSyntax WithBlock(BlockSyntax block)
    {
        return this.Update(this.Keyword, block);
    }

    public CheckedStatementSyntax AddBlockStatements(params StatementSyntax[] items)
    {
        return this.WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }
  }

  public sealed partial class UnsafeStatementSyntax : StatementSyntax
  {
    private BlockSyntax block;

    internal UnsafeStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken UnsafeKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.UnsafeStatementSyntax)this.Green).unsafeKeyword, this.Position, 0); }
    }

    public BlockSyntax Block 
    {
        get
        {
            return this.GetRed(ref this.block, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.block, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.block;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitUnsafeStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitUnsafeStatement(this);
    }

    public UnsafeStatementSyntax Update(SyntaxToken unsafeKeyword, BlockSyntax block)
    {
        if (unsafeKeyword != this.UnsafeKeyword || block != this.Block)
        {
            var newNode = SyntaxFactory.UnsafeStatement(unsafeKeyword, block);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public UnsafeStatementSyntax WithUnsafeKeyword(SyntaxToken unsafeKeyword)
    {
        return this.Update(unsafeKeyword, this.Block);
    }

    public UnsafeStatementSyntax WithBlock(BlockSyntax block)
    {
        return this.Update(this.UnsafeKeyword, block);
    }

    public UnsafeStatementSyntax AddBlockStatements(params StatementSyntax[] items)
    {
        return this.WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }
  }

  public sealed partial class LockStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax expression;
    private StatementSyntax statement;

    internal LockStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken LockKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LockStatementSyntax)this.Green).lockKeyword, this.Position, 0); }
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LockStatementSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 2);
        }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LockStatementSyntax)this.Green).closeParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public StatementSyntax Statement 
    {
        get
        {
            return this.GetRed(ref this.statement, 4);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            case 4: return this.GetRed(ref this.statement, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            case 4: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLockStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLockStatement(this);
    }

    public LockStatementSyntax Update(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (lockKeyword != this.LockKeyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.LockStatement(lockKeyword, openParenToken, expression, closeParenToken, statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public LockStatementSyntax WithLockKeyword(SyntaxToken lockKeyword)
    {
        return this.Update(lockKeyword, this.OpenParenToken, this.Expression, this.CloseParenToken, this.Statement);
    }

    public LockStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.LockKeyword, openParenToken, this.Expression, this.CloseParenToken, this.Statement);
    }

    public LockStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.LockKeyword, this.OpenParenToken, expression, this.CloseParenToken, this.Statement);
    }

    public LockStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.LockKeyword, this.OpenParenToken, this.Expression, closeParenToken, this.Statement);
    }

    public LockStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.LockKeyword, this.OpenParenToken, this.Expression, this.CloseParenToken, statement);
    }
  }

  /// <summary>
  /// Represents an if statement syntax.
  /// </summary>
  public sealed partial class IfStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax condition;
    private StatementSyntax statement;
    private ElseClauseSyntax @else;

    internal IfStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the if keyword.
    /// </summary>
    public SyntaxToken IfKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfStatementSyntax)this.Green).ifKeyword, this.Position, 0); }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the open parenthesis before the if statement's condition expression.
    /// </summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfStatementSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>
    /// Gets an ExpressionSyntax that represents the condition of the if statement.
    /// </summary>
    public ExpressionSyntax Condition 
    {
        get
        {
            return this.GetRed(ref this.condition, 2);
        }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the close parenthesis after the if statement's condition expression.
    /// </summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfStatementSyntax)this.Green).closeParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    /// <summary>
    /// Gets a StatementSyntax the represents the statement to be executed when the condition is true.
    /// </summary>
    public StatementSyntax Statement 
    {
        get
        {
            return this.GetRed(ref this.statement, 4);
        }
    }

    /// <summary>
    /// Gets an ElseClauseSyntax that represents the statement to be executed when the condition is false if such statement exists.
    /// </summary>
    public ElseClauseSyntax Else 
    {
        get
        {
            return this.GetRed(ref this.@else, 5);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.condition, 2);
            case 4: return this.GetRed(ref this.statement, 4);
            case 5: return this.GetRed(ref this.@else, 5);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.condition;
            case 4: return this.statement;
            case 5: return this.@else;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIfStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIfStatement(this);
    }

    public IfStatementSyntax Update(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)
    {
        if (ifKeyword != this.IfKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || statement != this.Statement || @else != this.Else)
        {
            var newNode = SyntaxFactory.IfStatement(ifKeyword, openParenToken, condition, closeParenToken, statement, @else);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public IfStatementSyntax WithIfKeyword(SyntaxToken ifKeyword)
    {
        return this.Update(ifKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, this.Statement, this.Else);
    }

    public IfStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.IfKeyword, openParenToken, this.Condition, this.CloseParenToken, this.Statement, this.Else);
    }

    public IfStatementSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.IfKeyword, this.OpenParenToken, condition, this.CloseParenToken, this.Statement, this.Else);
    }

    public IfStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.IfKeyword, this.OpenParenToken, this.Condition, closeParenToken, this.Statement, this.Else);
    }

    public IfStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.IfKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, statement, this.Else);
    }

    public IfStatementSyntax WithElse(ElseClauseSyntax @else)
    {
        return this.Update(this.IfKeyword, this.OpenParenToken, this.Condition, this.CloseParenToken, this.Statement, @else);
    }
  }

  /// <summary>Represents an else statement syntax.</summary>
  public sealed partial class ElseClauseSyntax : CSharpSyntaxNode
  {
    private StatementSyntax statement;

    internal ElseClauseSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>
    /// Gets a syntax token
    /// </summary>
    public SyntaxToken ElseKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElseClauseSyntax)this.Green).elseKeyword, this.Position, 0); }
    }

    public StatementSyntax Statement 
    {
        get
        {
            return this.GetRed(ref this.statement, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.statement, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElseClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitElseClause(this);
    }

    public ElseClauseSyntax Update(SyntaxToken elseKeyword, StatementSyntax statement)
    {
        if (elseKeyword != this.ElseKeyword || statement != this.Statement)
        {
            var newNode = SyntaxFactory.ElseClause(elseKeyword, statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ElseClauseSyntax WithElseKeyword(SyntaxToken elseKeyword)
    {
        return this.Update(elseKeyword, this.Statement);
    }

    public ElseClauseSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.ElseKeyword, statement);
    }
  }

  /// <summary>Represents a switch statement syntax.</summary>
  public sealed partial class SwitchStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax expression;
    private CSharpSyntaxNode sections;

    internal SwitchStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the switch keyword.
    /// </summary>
    public SyntaxToken SwitchKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchStatementSyntax)this.Green).switchKeyword, this.Position, 0); }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the open parenthesis preceding the switch expression.
    /// </summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchStatementSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>
    /// Gets an ExpressionSyntax representing the expression of the switch statement.
    /// </summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 2);
        }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the close parenthesis succeeding the switch expression.
    /// </summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchStatementSyntax)this.Green).closeParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the open braces preceding the switch sections.
    /// </summary>
    public SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchStatementSyntax)this.Green).openBraceToken, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    /// <summary>
    /// Gets a SyntaxList of SwitchSectionSyntax's that represents the switch sections of the switch statement.
    /// </summary>
    public SyntaxList<SwitchSectionSyntax> Sections 
    {
        get
        {
            return new SyntaxList<SwitchSectionSyntax>(this.GetRed(ref this.sections, 5));
        }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the open braces succeeding the switch sections.
    /// </summary>
    public SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchStatementSyntax)this.Green).closeBraceToken, this.GetChildPosition(6), this.GetChildIndex(6)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            case 5: return this.GetRed(ref this.sections, 5);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            case 5: return this.sections;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSwitchStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSwitchStatement(this);
    }

    public SwitchStatementSyntax Update(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)
    {
        if (switchKeyword != this.SwitchKeyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken || openBraceToken != this.OpenBraceToken || sections != this.Sections || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.SwitchStatement(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections, closeBraceToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public SwitchStatementSyntax WithSwitchKeyword(SyntaxToken switchKeyword)
    {
        return this.Update(switchKeyword, this.OpenParenToken, this.Expression, this.CloseParenToken, this.OpenBraceToken, this.Sections, this.CloseBraceToken);
    }

    public SwitchStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.SwitchKeyword, openParenToken, this.Expression, this.CloseParenToken, this.OpenBraceToken, this.Sections, this.CloseBraceToken);
    }

    public SwitchStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.SwitchKeyword, this.OpenParenToken, expression, this.CloseParenToken, this.OpenBraceToken, this.Sections, this.CloseBraceToken);
    }

    public SwitchStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.SwitchKeyword, this.OpenParenToken, this.Expression, closeParenToken, this.OpenBraceToken, this.Sections, this.CloseBraceToken);
    }

    public SwitchStatementSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(this.SwitchKeyword, this.OpenParenToken, this.Expression, this.CloseParenToken, openBraceToken, this.Sections, this.CloseBraceToken);
    }

    public SwitchStatementSyntax WithSections(SyntaxList<SwitchSectionSyntax> sections)
    {
        return this.Update(this.SwitchKeyword, this.OpenParenToken, this.Expression, this.CloseParenToken, this.OpenBraceToken, sections, this.CloseBraceToken);
    }

    public SwitchStatementSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.SwitchKeyword, this.OpenParenToken, this.Expression, this.CloseParenToken, this.OpenBraceToken, this.Sections, closeBraceToken);
    }

    public SwitchStatementSyntax AddSections(params SwitchSectionSyntax[] items)
    {
        return this.WithSections(this.Sections.AddRange(items));
    }
  }

  /// <summary>Represents a switch section syntax of a switch statement.</summary>
  public sealed partial class SwitchSectionSyntax : CSharpSyntaxNode
  {
    private CSharpSyntaxNode labels;
    private CSharpSyntaxNode statements;

    internal SwitchSectionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>
    /// Gets a SyntaxList of SwitchLabelSyntax's the represents the possible labels that control can transfer to within the section.
    /// </summary>
    public SyntaxList<SwitchLabelSyntax> Labels 
    {
        get
        {
            return new SyntaxList<SwitchLabelSyntax>(this.GetRed(ref this.labels, 0));
        }
    }

    /// <summary>
    /// Gets a SyntaxList of StatementSyntax's the represents the statements to be executed when control transfer to a label the belongs to the section.
    /// </summary>
    public SyntaxList<StatementSyntax> Statements 
    {
        get
        {
            return new SyntaxList<StatementSyntax>(this.GetRed(ref this.statements, 1));
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.labels);
            case 1: return this.GetRed(ref this.statements, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.labels;
            case 1: return this.statements;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSwitchSection(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSwitchSection(this);
    }

    public SwitchSectionSyntax Update(SyntaxList<SwitchLabelSyntax> labels, SyntaxList<StatementSyntax> statements)
    {
        if (labels != this.Labels || statements != this.Statements)
        {
            var newNode = SyntaxFactory.SwitchSection(labels, statements);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public SwitchSectionSyntax WithLabels(SyntaxList<SwitchLabelSyntax> labels)
    {
        return this.Update(labels, this.Statements);
    }

    public SwitchSectionSyntax WithStatements(SyntaxList<StatementSyntax> statements)
    {
        return this.Update(this.Labels, statements);
    }

    public SwitchSectionSyntax AddLabels(params SwitchLabelSyntax[] items)
    {
        return this.WithLabels(this.Labels.AddRange(items));
    }

    public SwitchSectionSyntax AddStatements(params StatementSyntax[] items)
    {
        return this.WithStatements(this.Statements.AddRange(items));
    }
  }

  /// <summary>Represents a switch label within a switch statement.</summary>
  public abstract partial class SwitchLabelSyntax : CSharpSyntaxNode
  {
    internal SwitchLabelSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>
    /// Gets a SyntaxToken that represents a case or default keywords that belongs to a switch label.
    /// </summary>
    public abstract SyntaxToken Keyword { get; }

    /// <summary>
    /// Gets a SyntaxToken that represents the colon that terminates the switch label.
    /// </summary>
    public abstract SyntaxToken ColonToken { get; }
  }

  /// <summary>Represents a case label within a switch statement.</summary>
  public sealed partial class CasePatternSwitchLabelSyntax : SwitchLabelSyntax
  {
    private PatternSyntax pattern;
    private WhenClauseSyntax whenClause;

    internal CasePatternSwitchLabelSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the case keyword token.</summary>
    public override SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CasePatternSwitchLabelSyntax)this.Green).keyword, this.Position, 0); }
    }

    /// <summary>
    /// Gets a PatternSyntax that represents the pattern that gets matched for the case label.
    /// </summary>
    public PatternSyntax Pattern 
    {
        get
        {
            return this.GetRed(ref this.pattern, 1);
        }
    }

    public WhenClauseSyntax WhenClause 
    {
        get
        {
            return this.GetRed(ref this.whenClause, 2);
        }
    }

    public override SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CasePatternSwitchLabelSyntax)this.Green).colonToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.pattern, 1);
            case 2: return this.GetRed(ref this.whenClause, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.pattern;
            case 2: return this.whenClause;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCasePatternSwitchLabel(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCasePatternSwitchLabel(this);
    }

    public CasePatternSwitchLabelSyntax Update(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)
    {
        if (keyword != this.Keyword || pattern != this.Pattern || whenClause != this.WhenClause || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.CasePatternSwitchLabel(keyword, pattern, whenClause, colonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CasePatternSwitchLabelSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.Pattern, this.WhenClause, this.ColonToken);
    }

    public CasePatternSwitchLabelSyntax WithPattern(PatternSyntax pattern)
    {
        return this.Update(this.Keyword, pattern, this.WhenClause, this.ColonToken);
    }

    public CasePatternSwitchLabelSyntax WithWhenClause(WhenClauseSyntax whenClause)
    {
        return this.Update(this.Keyword, this.Pattern, whenClause, this.ColonToken);
    }

    public CasePatternSwitchLabelSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.Keyword, this.Pattern, this.WhenClause, colonToken);
    }
  }

  /// <summary>Represents a case label within a switch statement.</summary>
  public sealed partial class CaseSwitchLabelSyntax : SwitchLabelSyntax
  {
    private ExpressionSyntax value;

    internal CaseSwitchLabelSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the case keyword token.</summary>
    public override SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CaseSwitchLabelSyntax)this.Green).keyword, this.Position, 0); }
    }

    /// <summary>
    /// Gets an ExpressionSyntax that represents the constant expression that gets matched for the case label.
    /// </summary>
    public ExpressionSyntax Value 
    {
        get
        {
            return this.GetRed(ref this.value, 1);
        }
    }

    public override SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CaseSwitchLabelSyntax)this.Green).colonToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.value, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.value;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCaseSwitchLabel(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCaseSwitchLabel(this);
    }

    public CaseSwitchLabelSyntax Update(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)
    {
        if (keyword != this.Keyword || value != this.Value || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.CaseSwitchLabel(keyword, value, colonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CaseSwitchLabelSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.Value, this.ColonToken);
    }

    public CaseSwitchLabelSyntax WithValue(ExpressionSyntax value)
    {
        return this.Update(this.Keyword, value, this.ColonToken);
    }

    public CaseSwitchLabelSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.Keyword, this.Value, colonToken);
    }
  }

  /// <summary>Represents a default label within a switch statement.</summary>
  public sealed partial class DefaultSwitchLabelSyntax : SwitchLabelSyntax
  {
    internal DefaultSwitchLabelSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the default keyword token.</summary>
    public override SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefaultSwitchLabelSyntax)this.Green).keyword, this.Position, 0); }
    }

    public override SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefaultSwitchLabelSyntax)this.Green).colonToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDefaultSwitchLabel(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDefaultSwitchLabel(this);
    }

    public DefaultSwitchLabelSyntax Update(SyntaxToken keyword, SyntaxToken colonToken)
    {
        if (keyword != this.Keyword || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.DefaultSwitchLabel(keyword, colonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public DefaultSwitchLabelSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.ColonToken);
    }

    public DefaultSwitchLabelSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.Keyword, colonToken);
    }
  }

  public sealed partial class TryStatementSyntax : StatementSyntax
  {
    private BlockSyntax block;
    private CSharpSyntaxNode catches;
    private FinallyClauseSyntax @finally;

    internal TryStatementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken TryKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TryStatementSyntax)this.Green).tryKeyword, this.Position, 0); }
    }

    public BlockSyntax Block 
    {
        get
        {
            return this.GetRed(ref this.block, 1);
        }
    }

    public SyntaxList<CatchClauseSyntax> Catches 
    {
        get
        {
            return new SyntaxList<CatchClauseSyntax>(this.GetRed(ref this.catches, 2));
        }
    }

    public FinallyClauseSyntax Finally 
    {
        get
        {
            return this.GetRed(ref this.@finally, 3);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.block, 1);
            case 2: return this.GetRed(ref this.catches, 2);
            case 3: return this.GetRed(ref this.@finally, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.block;
            case 2: return this.catches;
            case 3: return this.@finally;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTryStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTryStatement(this);
    }

    public TryStatementSyntax Update(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
    {
        if (tryKeyword != this.TryKeyword || block != this.Block || catches != this.Catches || @finally != this.Finally)
        {
            var newNode = SyntaxFactory.TryStatement(tryKeyword, block, catches, @finally);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TryStatementSyntax WithTryKeyword(SyntaxToken tryKeyword)
    {
        return this.Update(tryKeyword, this.Block, this.Catches, this.Finally);
    }

    public TryStatementSyntax WithBlock(BlockSyntax block)
    {
        return this.Update(this.TryKeyword, block, this.Catches, this.Finally);
    }

    public TryStatementSyntax WithCatches(SyntaxList<CatchClauseSyntax> catches)
    {
        return this.Update(this.TryKeyword, this.Block, catches, this.Finally);
    }

    public TryStatementSyntax WithFinally(FinallyClauseSyntax @finally)
    {
        return this.Update(this.TryKeyword, this.Block, this.Catches, @finally);
    }

    public TryStatementSyntax AddBlockStatements(params StatementSyntax[] items)
    {
        return this.WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    public TryStatementSyntax AddCatches(params CatchClauseSyntax[] items)
    {
        return this.WithCatches(this.Catches.AddRange(items));
    }
  }

  public sealed partial class CatchClauseSyntax : CSharpSyntaxNode
  {
    private CatchDeclarationSyntax declaration;
    private CatchFilterClauseSyntax filter;
    private BlockSyntax block;

    internal CatchClauseSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken CatchKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CatchClauseSyntax)this.Green).catchKeyword, this.Position, 0); }
    }

    public CatchDeclarationSyntax Declaration 
    {
        get
        {
            return this.GetRed(ref this.declaration, 1);
        }
    }

    public CatchFilterClauseSyntax Filter 
    {
        get
        {
            return this.GetRed(ref this.filter, 2);
        }
    }

    public BlockSyntax Block 
    {
        get
        {
            return this.GetRed(ref this.block, 3);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.declaration, 1);
            case 2: return this.GetRed(ref this.filter, 2);
            case 3: return this.GetRed(ref this.block, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.declaration;
            case 2: return this.filter;
            case 3: return this.block;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCatchClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCatchClause(this);
    }

    public CatchClauseSyntax Update(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)
    {
        if (catchKeyword != this.CatchKeyword || declaration != this.Declaration || filter != this.Filter || block != this.Block)
        {
            var newNode = SyntaxFactory.CatchClause(catchKeyword, declaration, filter, block);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CatchClauseSyntax WithCatchKeyword(SyntaxToken catchKeyword)
    {
        return this.Update(catchKeyword, this.Declaration, this.Filter, this.Block);
    }

    public CatchClauseSyntax WithDeclaration(CatchDeclarationSyntax declaration)
    {
        return this.Update(this.CatchKeyword, declaration, this.Filter, this.Block);
    }

    public CatchClauseSyntax WithFilter(CatchFilterClauseSyntax filter)
    {
        return this.Update(this.CatchKeyword, this.Declaration, filter, this.Block);
    }

    public CatchClauseSyntax WithBlock(BlockSyntax block)
    {
        return this.Update(this.CatchKeyword, this.Declaration, this.Filter, block);
    }

    public CatchClauseSyntax AddBlockStatements(params StatementSyntax[] items)
    {
        return this.WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }
  }

  public sealed partial class CatchDeclarationSyntax : CSharpSyntaxNode
  {
    private TypeSyntax type;

    internal CatchDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CatchDeclarationSyntax)this.Green).openParenToken, this.Position, 0); }
    }

    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 1);
        }
    }

    public SyntaxToken Identifier 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CatchDeclarationSyntax)this.Green).identifier;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(2), this.GetChildIndex(2));

            return default(SyntaxToken);
        }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CatchDeclarationSyntax)this.Green).closeParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.type, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCatchDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCatchDeclaration(this);
    }

    public CatchDeclarationSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || type != this.Type || identifier != this.Identifier || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.CatchDeclaration(openParenToken, type, identifier, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CatchDeclarationSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Type, this.Identifier, this.CloseParenToken);
    }

    public CatchDeclarationSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.OpenParenToken, type, this.Identifier, this.CloseParenToken);
    }

    public CatchDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.OpenParenToken, this.Type, identifier, this.CloseParenToken);
    }

    public CatchDeclarationSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Type, this.Identifier, closeParenToken);
    }
  }

  public sealed partial class CatchFilterClauseSyntax : CSharpSyntaxNode
  {
    private ExpressionSyntax filterExpression;

    internal CatchFilterClauseSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken WhenKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CatchFilterClauseSyntax)this.Green).whenKeyword, this.Position, 0); }
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CatchFilterClauseSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public ExpressionSyntax FilterExpression 
    {
        get
        {
            return this.GetRed(ref this.filterExpression, 2);
        }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CatchFilterClauseSyntax)this.Green).closeParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.filterExpression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.filterExpression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCatchFilterClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCatchFilterClause(this);
    }

    public CatchFilterClauseSyntax Update(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)
    {
        if (whenKeyword != this.WhenKeyword || openParenToken != this.OpenParenToken || filterExpression != this.FilterExpression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.CatchFilterClause(whenKeyword, openParenToken, filterExpression, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CatchFilterClauseSyntax WithWhenKeyword(SyntaxToken whenKeyword)
    {
        return this.Update(whenKeyword, this.OpenParenToken, this.FilterExpression, this.CloseParenToken);
    }

    public CatchFilterClauseSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.WhenKeyword, openParenToken, this.FilterExpression, this.CloseParenToken);
    }

    public CatchFilterClauseSyntax WithFilterExpression(ExpressionSyntax filterExpression)
    {
        return this.Update(this.WhenKeyword, this.OpenParenToken, filterExpression, this.CloseParenToken);
    }

    public CatchFilterClauseSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.WhenKeyword, this.OpenParenToken, this.FilterExpression, closeParenToken);
    }
  }

  public sealed partial class FinallyClauseSyntax : CSharpSyntaxNode
  {
    private BlockSyntax block;

    internal FinallyClauseSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken FinallyKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FinallyClauseSyntax)this.Green).finallyKeyword, this.Position, 0); }
    }

    public BlockSyntax Block 
    {
        get
        {
            return this.GetRed(ref this.block, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.block, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.block;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFinallyClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitFinallyClause(this);
    }

    public FinallyClauseSyntax Update(SyntaxToken finallyKeyword, BlockSyntax block)
    {
        if (finallyKeyword != this.FinallyKeyword || block != this.Block)
        {
            var newNode = SyntaxFactory.FinallyClause(finallyKeyword, block);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public FinallyClauseSyntax WithFinallyKeyword(SyntaxToken finallyKeyword)
    {
        return this.Update(finallyKeyword, this.Block);
    }

    public FinallyClauseSyntax WithBlock(BlockSyntax block)
    {
        return this.Update(this.FinallyKeyword, block);
    }

    public FinallyClauseSyntax AddBlockStatements(params StatementSyntax[] items)
    {
        return this.WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }
  }

  public sealed partial class CompilationUnitSyntax : CSharpSyntaxNode
  {
    private CSharpSyntaxNode externs;
    private CSharpSyntaxNode usings;
    private CSharpSyntaxNode attributeLists;
    private CSharpSyntaxNode members;

    internal CompilationUnitSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxList<ExternAliasDirectiveSyntax> Externs 
    {
        get
        {
            return new SyntaxList<ExternAliasDirectiveSyntax>(this.GetRed(ref this.externs, 0));
        }
    }

    public SyntaxList<UsingDirectiveSyntax> Usings 
    {
        get
        {
            return new SyntaxList<UsingDirectiveSyntax>(this.GetRed(ref this.usings, 1));
        }
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeListSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeListSyntax>(this.GetRed(ref this.attributeLists, 2));
        }
    }

    public SyntaxList<MemberDeclarationSyntax> Members 
    {
        get
        {
            return new SyntaxList<MemberDeclarationSyntax>(this.GetRed(ref this.members, 3));
        }
    }

    public SyntaxToken EndOfFileToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CompilationUnitSyntax)this.Green).endOfFileToken, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.externs);
            case 1: return this.GetRed(ref this.usings, 1);
            case 2: return this.GetRed(ref this.attributeLists, 2);
            case 3: return this.GetRed(ref this.members, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.externs;
            case 1: return this.usings;
            case 2: return this.attributeLists;
            case 3: return this.members;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCompilationUnit(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCompilationUnit(this);
    }

    public CompilationUnitSyntax Update(SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)
    {
        if (externs != this.Externs || usings != this.Usings || attributeLists != this.AttributeLists || members != this.Members || endOfFileToken != this.EndOfFileToken)
        {
            var newNode = SyntaxFactory.CompilationUnit(externs, usings, attributeLists, members, endOfFileToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CompilationUnitSyntax WithExterns(SyntaxList<ExternAliasDirectiveSyntax> externs)
    {
        return this.Update(externs, this.Usings, this.AttributeLists, this.Members, this.EndOfFileToken);
    }

    public CompilationUnitSyntax WithUsings(SyntaxList<UsingDirectiveSyntax> usings)
    {
        return this.Update(this.Externs, usings, this.AttributeLists, this.Members, this.EndOfFileToken);
    }

    public CompilationUnitSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)
    {
        return this.Update(this.Externs, this.Usings, attributeLists, this.Members, this.EndOfFileToken);
    }

    public CompilationUnitSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members)
    {
        return this.Update(this.Externs, this.Usings, this.AttributeLists, members, this.EndOfFileToken);
    }

    public CompilationUnitSyntax WithEndOfFileToken(SyntaxToken endOfFileToken)
    {
        return this.Update(this.Externs, this.Usings, this.AttributeLists, this.Members, endOfFileToken);
    }

    public CompilationUnitSyntax AddExterns(params ExternAliasDirectiveSyntax[] items)
    {
        return this.WithExterns(this.Externs.AddRange(items));
    }

    public CompilationUnitSyntax AddUsings(params UsingDirectiveSyntax[] items)
    {
        return this.WithUsings(this.Usings.AddRange(items));
    }

    public CompilationUnitSyntax AddAttributeLists(params AttributeListSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    public CompilationUnitSyntax AddMembers(params MemberDeclarationSyntax[] items)
    {
        return this.WithMembers(this.Members.AddRange(items));
    }
  }

  /// <summary>
  /// Represents an ExternAlias directive syntax, e.g. "extern alias MyAlias;" with specifying "/r:MyAlias=SomeAssembly.dll " on the compiler command line.
  /// </summary>
  public sealed partial class ExternAliasDirectiveSyntax : CSharpSyntaxNode
  {
    internal ExternAliasDirectiveSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the extern keyword.</summary>
    public SyntaxToken ExternKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExternAliasDirectiveSyntax)this.Green).externKeyword, this.Position, 0); }
    }

    /// <summary>SyntaxToken representing the alias keyword.</summary>
    public SyntaxToken AliasKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExternAliasDirectiveSyntax)this.Green).aliasKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExternAliasDirectiveSyntax)this.Green).identifier, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>SyntaxToken representing the semicolon token.</summary>
    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExternAliasDirectiveSyntax)this.Green).semicolonToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitExternAliasDirective(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitExternAliasDirective(this);
    }

    public ExternAliasDirectiveSyntax Update(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
    {
        if (externKeyword != this.ExternKeyword || aliasKeyword != this.AliasKeyword || identifier != this.Identifier || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ExternAliasDirective(externKeyword, aliasKeyword, identifier, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ExternAliasDirectiveSyntax WithExternKeyword(SyntaxToken externKeyword)
    {
        return this.Update(externKeyword, this.AliasKeyword, this.Identifier, this.SemicolonToken);
    }

    public ExternAliasDirectiveSyntax WithAliasKeyword(SyntaxToken aliasKeyword)
    {
        return this.Update(this.ExternKeyword, aliasKeyword, this.Identifier, this.SemicolonToken);
    }

    public ExternAliasDirectiveSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.ExternKeyword, this.AliasKeyword, identifier, this.SemicolonToken);
    }

    public ExternAliasDirectiveSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.ExternKeyword, this.AliasKeyword, this.Identifier, semicolonToken);
    }
  }

  public sealed partial class UsingDirectiveSyntax : CSharpSyntaxNode
  {
    private NameEqualsSyntax alias;
    private NameSyntax name;

    internal UsingDirectiveSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken UsingKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.UsingDirectiveSyntax)this.Green).usingKeyword, this.Position, 0); }
    }

    public SyntaxToken StaticKeyword 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.UsingDirectiveSyntax)this.Green).staticKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxToken);
        }
    }

    public NameEqualsSyntax Alias 
    {
        get
        {
            return this.GetRed(ref this.alias, 2);
        }
    }

    public NameSyntax Name 
    {
        get
        {
            return this.GetRed(ref this.name, 3);
        }
    }

    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.UsingDirectiveSyntax)this.Green).semicolonToken, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.alias, 2);
            case 3: return this.GetRed(ref this.name, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.alias;
            case 3: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitUsingDirective(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitUsingDirective(this);
    }

    public UsingDirectiveSyntax Update(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)
    {
        if (usingKeyword != this.UsingKeyword || staticKeyword != this.StaticKeyword || alias != this.Alias || name != this.Name || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.UsingDirective(usingKeyword, staticKeyword, alias, name, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public UsingDirectiveSyntax WithUsingKeyword(SyntaxToken usingKeyword)
    {
        return this.Update(usingKeyword, this.StaticKeyword, this.Alias, this.Name, this.SemicolonToken);
    }

    public UsingDirectiveSyntax WithStaticKeyword(SyntaxToken staticKeyword)
    {
        return this.Update(this.UsingKeyword, staticKeyword, this.Alias, this.Name, this.SemicolonToken);
    }

    public UsingDirectiveSyntax WithAlias(NameEqualsSyntax alias)
    {
        return this.Update(this.UsingKeyword, this.StaticKeyword, alias, this.Name, this.SemicolonToken);
    }

    public UsingDirectiveSyntax WithName(NameSyntax name)
    {
        return this.Update(this.UsingKeyword, this.StaticKeyword, this.Alias, name, this.SemicolonToken);
    }

    public UsingDirectiveSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.UsingKeyword, this.StaticKeyword, this.Alias, this.Name, semicolonToken);
    }
  }

  /// <summary>Member declaration syntax.</summary>
  public abstract partial class MemberDeclarationSyntax : CSharpSyntaxNode
  {
    internal MemberDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  public sealed partial class NamespaceDeclarationSyntax : MemberDeclarationSyntax
  {
    private NameSyntax name;
    private CSharpSyntaxNode externs;
    private CSharpSyntaxNode usings;
    private CSharpSyntaxNode members;

    internal NamespaceDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken NamespaceKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NamespaceDeclarationSyntax)this.Green).namespaceKeyword, this.Position, 0); }
    }

    public NameSyntax Name 
    {
        get
        {
            return this.GetRed(ref this.name, 1);
        }
    }

    public SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NamespaceDeclarationSyntax)this.Green).openBraceToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxList<ExternAliasDirectiveSyntax> Externs 
    {
        get
        {
            return new SyntaxList<ExternAliasDirectiveSyntax>(this.GetRed(ref this.externs, 3));
        }
    }

    public SyntaxList<UsingDirectiveSyntax> Usings 
    {
        get
        {
            return new SyntaxList<UsingDirectiveSyntax>(this.GetRed(ref this.usings, 4));
        }
    }

    public SyntaxList<MemberDeclarationSyntax> Members 
    {
        get
        {
            return new SyntaxList<MemberDeclarationSyntax>(this.GetRed(ref this.members, 5));
        }
    }

    public SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NamespaceDeclarationSyntax)this.Green).closeBraceToken, this.GetChildPosition(6), this.GetChildIndex(6)); }
    }

    /// <summary>Gets the optional semicolon token.</summary>
    public SyntaxToken SemicolonToken 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NamespaceDeclarationSyntax)this.Green).semicolonToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(7), this.GetChildIndex(7));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.name, 1);
            case 3: return this.GetRed(ref this.externs, 3);
            case 4: return this.GetRed(ref this.usings, 4);
            case 5: return this.GetRed(ref this.members, 5);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.name;
            case 3: return this.externs;
            case 4: return this.usings;
            case 5: return this.members;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNamespaceDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitNamespaceDeclaration(this);
    }

    public NamespaceDeclarationSyntax Update(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (namespaceKeyword != this.NamespaceKeyword || name != this.Name || openBraceToken != this.OpenBraceToken || externs != this.Externs || usings != this.Usings || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.NamespaceDeclaration(namespaceKeyword, name, openBraceToken, externs, usings, members, closeBraceToken, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public NamespaceDeclarationSyntax WithNamespaceKeyword(SyntaxToken namespaceKeyword)
    {
        return this.Update(namespaceKeyword, this.Name, this.OpenBraceToken, this.Externs, this.Usings, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public NamespaceDeclarationSyntax WithName(NameSyntax name)
    {
        return this.Update(this.NamespaceKeyword, name, this.OpenBraceToken, this.Externs, this.Usings, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public NamespaceDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(this.NamespaceKeyword, this.Name, openBraceToken, this.Externs, this.Usings, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public NamespaceDeclarationSyntax WithExterns(SyntaxList<ExternAliasDirectiveSyntax> externs)
    {
        return this.Update(this.NamespaceKeyword, this.Name, this.OpenBraceToken, externs, this.Usings, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public NamespaceDeclarationSyntax WithUsings(SyntaxList<UsingDirectiveSyntax> usings)
    {
        return this.Update(this.NamespaceKeyword, this.Name, this.OpenBraceToken, this.Externs, usings, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public NamespaceDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members)
    {
        return this.Update(this.NamespaceKeyword, this.Name, this.OpenBraceToken, this.Externs, this.Usings, members, this.CloseBraceToken, this.SemicolonToken);
    }

    public NamespaceDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.NamespaceKeyword, this.Name, this.OpenBraceToken, this.Externs, this.Usings, this.Members, closeBraceToken, this.SemicolonToken);
    }

    public NamespaceDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.NamespaceKeyword, this.Name, this.OpenBraceToken, this.Externs, this.Usings, this.Members, this.CloseBraceToken, semicolonToken);
    }

    public NamespaceDeclarationSyntax AddExterns(params ExternAliasDirectiveSyntax[] items)
    {
        return this.WithExterns(this.Externs.AddRange(items));
    }

    public NamespaceDeclarationSyntax AddUsings(params UsingDirectiveSyntax[] items)
    {
        return this.WithUsings(this.Usings.AddRange(items));
    }

    public NamespaceDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items)
    {
        return this.WithMembers(this.Members.AddRange(items));
    }
  }

  /// <summary>Class representing one or more attributes applied to a language construct.</summary>
  public sealed partial class AttributeListSyntax : CSharpSyntaxNode
  {
    private AttributeTargetSpecifierSyntax target;
    private SyntaxNode attributes;

    internal AttributeListSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the open bracket token.</summary>
    public SyntaxToken OpenBracketToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax)this.Green).openBracketToken, this.Position, 0); }
    }

    /// <summary>Gets the optional construct targeted by the attribute.</summary>
    public AttributeTargetSpecifierSyntax Target 
    {
        get
        {
            return this.GetRed(ref this.target, 1);
        }
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SeparatedSyntaxList<AttributeSyntax> Attributes 
    {
        get
        {
            var red = this.GetRed(ref this.attributes, 2);
            if (red != null)
                return new SeparatedSyntaxList<AttributeSyntax>(red, this.GetChildIndex(2));

            return default(SeparatedSyntaxList<AttributeSyntax>);
        }
    }

    /// <summary>Gets the close bracket token.</summary>
    public SyntaxToken CloseBracketToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax)this.Green).closeBracketToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.target, 1);
            case 2: return this.GetRed(ref this.attributes, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.target;
            case 2: return this.attributes;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttributeList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAttributeList(this);
    }

    public AttributeListSyntax Update(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || target != this.Target || attributes != this.Attributes || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.AttributeList(openBracketToken, target, attributes, closeBracketToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AttributeListSyntax WithOpenBracketToken(SyntaxToken openBracketToken)
    {
        return this.Update(openBracketToken, this.Target, this.Attributes, this.CloseBracketToken);
    }

    public AttributeListSyntax WithTarget(AttributeTargetSpecifierSyntax target)
    {
        return this.Update(this.OpenBracketToken, target, this.Attributes, this.CloseBracketToken);
    }

    public AttributeListSyntax WithAttributes(SeparatedSyntaxList<AttributeSyntax> attributes)
    {
        return this.Update(this.OpenBracketToken, this.Target, attributes, this.CloseBracketToken);
    }

    public AttributeListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)
    {
        return this.Update(this.OpenBracketToken, this.Target, this.Attributes, closeBracketToken);
    }

    public AttributeListSyntax AddAttributes(params AttributeSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.AddRange(items));
    }
  }

  /// <summary>Class representing what language construct an attribute targets.</summary>
  public sealed partial class AttributeTargetSpecifierSyntax : CSharpSyntaxNode
  {
    internal AttributeTargetSpecifierSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeTargetSpecifierSyntax)this.Green).identifier, this.Position, 0); }
    }

    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeTargetSpecifierSyntax)this.Green).colonToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttributeTargetSpecifier(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAttributeTargetSpecifier(this);
    }

    public AttributeTargetSpecifierSyntax Update(SyntaxToken identifier, SyntaxToken colonToken)
    {
        if (identifier != this.Identifier || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.AttributeTargetSpecifier(identifier, colonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AttributeTargetSpecifierSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(identifier, this.ColonToken);
    }

    public AttributeTargetSpecifierSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.Identifier, colonToken);
    }
  }

  /// <summary>Attribute syntax.</summary>
  public sealed partial class AttributeSyntax : CSharpSyntaxNode
  {
    private NameSyntax name;
    private AttributeArgumentListSyntax argumentList;

    internal AttributeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the name.</summary>
    public NameSyntax Name 
    {
        get
        {
            return this.GetRedAtZero(ref this.name);
        }
    }

    public AttributeArgumentListSyntax ArgumentList 
    {
        get
        {
            return this.GetRed(ref this.argumentList, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.name);
            case 1: return this.GetRed(ref this.argumentList, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.argumentList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttribute(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAttribute(this);
    }

    public AttributeSyntax Update(NameSyntax name, AttributeArgumentListSyntax argumentList)
    {
        if (name != this.Name || argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.Attribute(name, argumentList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AttributeSyntax WithName(NameSyntax name)
    {
        return this.Update(name, this.ArgumentList);
    }

    public AttributeSyntax WithArgumentList(AttributeArgumentListSyntax argumentList)
    {
        return this.Update(this.Name, argumentList);
    }

    public AttributeSyntax AddArgumentListArguments(params AttributeArgumentSyntax[] items)
    {
        var argumentList = this.ArgumentList ?? SyntaxFactory.AttributeArgumentList();
        return this.WithArgumentList(argumentList.WithArguments(argumentList.Arguments.AddRange(items)));
    }
  }

  /// <summary>Attribute argument list syntax.</summary>
  public sealed partial class AttributeArgumentListSyntax : CSharpSyntaxNode
  {
    private SyntaxNode arguments;

    internal AttributeArgumentListSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the open paren token.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeArgumentListSyntax)this.Green).openParenToken, this.Position, 0); }
    }

    /// <summary>Gets the arguments syntax list.</summary>
    public SeparatedSyntaxList<AttributeArgumentSyntax> Arguments 
    {
        get
        {
            var red = this.GetRed(ref this.arguments, 1);
            if (red != null)
                return new SeparatedSyntaxList<AttributeArgumentSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<AttributeArgumentSyntax>);
        }
    }

    /// <summary>Gets the close paren token.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeArgumentListSyntax)this.Green).closeParenToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.arguments, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.arguments;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttributeArgumentList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAttributeArgumentList(this);
    }

    public AttributeArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.AttributeArgumentList(openParenToken, arguments, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AttributeArgumentListSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Arguments, this.CloseParenToken);
    }

    public AttributeArgumentListSyntax WithArguments(SeparatedSyntaxList<AttributeArgumentSyntax> arguments)
    {
        return this.Update(this.OpenParenToken, arguments, this.CloseParenToken);
    }

    public AttributeArgumentListSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Arguments, closeParenToken);
    }

    public AttributeArgumentListSyntax AddArguments(params AttributeArgumentSyntax[] items)
    {
        return this.WithArguments(this.Arguments.AddRange(items));
    }
  }

  /// <summary>Attribute argument syntax.</summary>
  public sealed partial class AttributeArgumentSyntax : CSharpSyntaxNode
  {
    private NameEqualsSyntax nameEquals;
    private NameColonSyntax nameColon;
    private ExpressionSyntax expression;

    internal AttributeArgumentSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public NameEqualsSyntax NameEquals 
    {
        get
        {
            return this.GetRedAtZero(ref this.nameEquals);
        }
    }

    public NameColonSyntax NameColon 
    {
        get
        {
            return this.GetRed(ref this.nameColon, 1);
        }
    }

    /// <summary>Gets the expression.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.nameEquals);
            case 1: return this.GetRed(ref this.nameColon, 1);
            case 2: return this.GetRed(ref this.expression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nameEquals;
            case 1: return this.nameColon;
            case 2: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttributeArgument(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAttributeArgument(this);
    }

    public AttributeArgumentSyntax Update(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
    {
        if (nameEquals != this.NameEquals || nameColon != this.NameColon || expression != this.Expression)
        {
            var newNode = SyntaxFactory.AttributeArgument(nameEquals, nameColon, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AttributeArgumentSyntax WithNameEquals(NameEqualsSyntax nameEquals)
    {
        return this.Update(nameEquals, this.NameColon, this.Expression);
    }

    public AttributeArgumentSyntax WithNameColon(NameColonSyntax nameColon)
    {
        return this.Update(this.NameEquals, nameColon, this.Expression);
    }

    public AttributeArgumentSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.NameEquals, this.NameColon, expression);
    }
  }

  /// <summary>Class representing an identifier name followed by an equals token.</summary>
  public sealed partial class NameEqualsSyntax : CSharpSyntaxNode
  {
    private IdentifierNameSyntax name;

    internal NameEqualsSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the identifier name.</summary>
    public IdentifierNameSyntax Name 
    {
        get
        {
            return this.GetRedAtZero(ref this.name);
        }
    }

    public SyntaxToken EqualsToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameEqualsSyntax)this.Green).equalsToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.name);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNameEquals(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitNameEquals(this);
    }

    public NameEqualsSyntax Update(IdentifierNameSyntax name, SyntaxToken equalsToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken)
        {
            var newNode = SyntaxFactory.NameEquals(name, equalsToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public NameEqualsSyntax WithName(IdentifierNameSyntax name)
    {
        return this.Update(name, this.EqualsToken);
    }

    public NameEqualsSyntax WithEqualsToken(SyntaxToken equalsToken)
    {
        return this.Update(this.Name, equalsToken);
    }
  }

  /// <summary>Type parameter list syntax.</summary>
  public sealed partial class TypeParameterListSyntax : CSharpSyntaxNode
  {
    private SyntaxNode parameters;

    internal TypeParameterListSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the &lt; token.</summary>
    public SyntaxToken LessThanToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax)this.Green).lessThanToken, this.Position, 0); }
    }

    /// <summary>Gets the parameter list.</summary>
    public SeparatedSyntaxList<TypeParameterSyntax> Parameters 
    {
        get
        {
            var red = this.GetRed(ref this.parameters, 1);
            if (red != null)
                return new SeparatedSyntaxList<TypeParameterSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<TypeParameterSyntax>);
        }
    }

    /// <summary>Gets the &gt; token.</summary>
    public SyntaxToken GreaterThanToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax)this.Green).greaterThanToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.parameters, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.parameters;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeParameterList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeParameterList(this);
    }

    public TypeParameterListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || parameters != this.Parameters || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = SyntaxFactory.TypeParameterList(lessThanToken, parameters, greaterThanToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TypeParameterListSyntax WithLessThanToken(SyntaxToken lessThanToken)
    {
        return this.Update(lessThanToken, this.Parameters, this.GreaterThanToken);
    }

    public TypeParameterListSyntax WithParameters(SeparatedSyntaxList<TypeParameterSyntax> parameters)
    {
        return this.Update(this.LessThanToken, parameters, this.GreaterThanToken);
    }

    public TypeParameterListSyntax WithGreaterThanToken(SyntaxToken greaterThanToken)
    {
        return this.Update(this.LessThanToken, this.Parameters, greaterThanToken);
    }

    public TypeParameterListSyntax AddParameters(params TypeParameterSyntax[] items)
    {
        return this.WithParameters(this.Parameters.AddRange(items));
    }
  }

  /// <summary>Type parameter syntax.</summary>
  public sealed partial class TypeParameterSyntax : CSharpSyntaxNode
  {
    private CSharpSyntaxNode attributeLists;

    internal TypeParameterSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeListSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeListSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public SyntaxToken VarianceKeyword 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterSyntax)this.Green).varianceKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxToken);
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterSyntax)this.Green).identifier, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeParameter(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeParameter(this);
    }

    public TypeParameterSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)
    {
        if (attributeLists != this.AttributeLists || varianceKeyword != this.VarianceKeyword || identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.TypeParameter(attributeLists, varianceKeyword, identifier);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TypeParameterSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.VarianceKeyword, this.Identifier);
    }

    public TypeParameterSyntax WithVarianceKeyword(SyntaxToken varianceKeyword)
    {
        return this.Update(this.AttributeLists, varianceKeyword, this.Identifier);
    }

    public TypeParameterSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, this.VarianceKeyword, identifier);
    }

    public TypeParameterSyntax AddAttributeLists(params AttributeListSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }
  }

  /// <summary>Base class for type declaration syntax.</summary>
  public abstract partial class BaseTypeDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BaseTypeDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }

    /// <summary>Gets the modifier list.</summary>
    public abstract SyntaxTokenList Modifiers { get; }

    /// <summary>Gets the identifier.</summary>
    public abstract SyntaxToken Identifier { get; }

    /// <summary>Gets the base type list.</summary>
    public abstract BaseListSyntax BaseList { get; }

    /// <summary>Gets the open brace token.</summary>
    public abstract SyntaxToken OpenBraceToken { get; }

    /// <summary>Gets the close brace token.</summary>
    public abstract SyntaxToken CloseBraceToken { get; }

    /// <summary>Gets the optional semicolon token.</summary>
    public abstract SyntaxToken SemicolonToken { get; }
  }

  /// <summary>Base class for type declaration syntax (class, struct, interface).</summary>
  public abstract partial class TypeDeclarationSyntax : BaseTypeDeclarationSyntax
  {
    internal TypeDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>Gets the type keyword token ("class", "struct", "interface").</summary>
    public abstract SyntaxToken Keyword { get; }

    public abstract TypeParameterListSyntax TypeParameterList { get; }

    /// <summary>Gets the type constraint list.</summary>
    public abstract SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }

    /// <summary>Gets the member declarations.</summary>
    public abstract SyntaxList<MemberDeclarationSyntax> Members { get; }
  }

  /// <summary>Class type declaration syntax.</summary>
  public sealed partial class ClassDeclarationSyntax : TypeDeclarationSyntax
  {
    private CSharpSyntaxNode attributeLists;
    private TypeParameterListSyntax typeParameterList;
    private BaseListSyntax baseList;
    private CSharpSyntaxNode constraintClauses;
    private CSharpSyntaxNode members;

    internal ClassDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeListSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the class keyword token.</summary>
    public override SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ClassDeclarationSyntax)this.Green).keyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ClassDeclarationSyntax)this.Green).identifier, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override TypeParameterListSyntax TypeParameterList 
    {
        get
        {
            return this.GetRed(ref this.typeParameterList, 4);
        }
    }

    public override BaseListSyntax BaseList 
    {
        get
        {
            return this.GetRed(ref this.baseList, 5);
        }
    }

    public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses 
    {
        get
        {
            return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.GetRed(ref this.constraintClauses, 6));
        }
    }

    public override SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ClassDeclarationSyntax)this.Green).openBraceToken, this.GetChildPosition(7), this.GetChildIndex(7)); }
    }

    public override SyntaxList<MemberDeclarationSyntax> Members 
    {
        get
        {
            return new SyntaxList<MemberDeclarationSyntax>(this.GetRed(ref this.members, 8));
        }
    }

    public override SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ClassDeclarationSyntax)this.Green).closeBraceToken, this.GetChildPosition(9), this.GetChildIndex(9)); }
    }

    public override SyntaxToken SemicolonToken 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ClassDeclarationSyntax)this.Green).semicolonToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(10), this.GetChildIndex(10));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 4: return this.GetRed(ref this.typeParameterList, 4);
            case 5: return this.GetRed(ref this.baseList, 5);
            case 6: return this.GetRed(ref this.constraintClauses, 6);
            case 8: return this.GetRed(ref this.members, 8);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 4: return this.typeParameterList;
            case 5: return this.baseList;
            case 6: return this.constraintClauses;
            case 8: return this.members;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitClassDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitClassDeclaration(this);
    }

    public ClassDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ClassDeclaration(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ClassDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public ClassDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public ClassDeclarationSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public ClassDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public ClassDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, typeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public ClassDeclarationSyntax WithBaseList(BaseListSyntax baseList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, baseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public ClassDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, constraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public ClassDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, openBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public ClassDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, members, this.CloseBraceToken, this.SemicolonToken);
    }

    public ClassDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, closeBraceToken, this.SemicolonToken);
    }

    public ClassDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, semicolonToken);
    }

    public ClassDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    public ClassDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }

    public ClassDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)
    {
        var typeParameterList = this.TypeParameterList ?? SyntaxFactory.TypeParameterList();
        return this.WithTypeParameterList(typeParameterList.WithParameters(typeParameterList.Parameters.AddRange(items)));
    }

    public ClassDeclarationSyntax AddBaseListTypes(params BaseTypeSyntax[] items)
    {
        var baseList = this.BaseList ?? SyntaxFactory.BaseList();
        return this.WithBaseList(baseList.WithTypes(baseList.Types.AddRange(items)));
    }

    public ClassDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)
    {
        return this.WithConstraintClauses(this.ConstraintClauses.AddRange(items));
    }

    public ClassDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items)
    {
        return this.WithMembers(this.Members.AddRange(items));
    }
  }

  /// <summary>Struct type declaration syntax.</summary>
  public sealed partial class StructDeclarationSyntax : TypeDeclarationSyntax
  {
    private CSharpSyntaxNode attributeLists;
    private TypeParameterListSyntax typeParameterList;
    private BaseListSyntax baseList;
    private CSharpSyntaxNode constraintClauses;
    private CSharpSyntaxNode members;

    internal StructDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeListSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the struct keyword token.</summary>
    public override SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StructDeclarationSyntax)this.Green).keyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StructDeclarationSyntax)this.Green).identifier, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override TypeParameterListSyntax TypeParameterList 
    {
        get
        {
            return this.GetRed(ref this.typeParameterList, 4);
        }
    }

    public override BaseListSyntax BaseList 
    {
        get
        {
            return this.GetRed(ref this.baseList, 5);
        }
    }

    public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses 
    {
        get
        {
            return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.GetRed(ref this.constraintClauses, 6));
        }
    }

    public override SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StructDeclarationSyntax)this.Green).openBraceToken, this.GetChildPosition(7), this.GetChildIndex(7)); }
    }

    public override SyntaxList<MemberDeclarationSyntax> Members 
    {
        get
        {
            return new SyntaxList<MemberDeclarationSyntax>(this.GetRed(ref this.members, 8));
        }
    }

    public override SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StructDeclarationSyntax)this.Green).closeBraceToken, this.GetChildPosition(9), this.GetChildIndex(9)); }
    }

    public override SyntaxToken SemicolonToken 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StructDeclarationSyntax)this.Green).semicolonToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(10), this.GetChildIndex(10));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 4: return this.GetRed(ref this.typeParameterList, 4);
            case 5: return this.GetRed(ref this.baseList, 5);
            case 6: return this.GetRed(ref this.constraintClauses, 6);
            case 8: return this.GetRed(ref this.members, 8);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 4: return this.typeParameterList;
            case 5: return this.baseList;
            case 6: return this.constraintClauses;
            case 8: return this.members;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitStructDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitStructDeclaration(this);
    }

    public StructDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.StructDeclaration(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public StructDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public StructDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public StructDeclarationSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public StructDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public StructDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, typeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public StructDeclarationSyntax WithBaseList(BaseListSyntax baseList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, baseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public StructDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, constraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public StructDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, openBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public StructDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, members, this.CloseBraceToken, this.SemicolonToken);
    }

    public StructDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, closeBraceToken, this.SemicolonToken);
    }

    public StructDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, semicolonToken);
    }

    public StructDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    public StructDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }

    public StructDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)
    {
        var typeParameterList = this.TypeParameterList ?? SyntaxFactory.TypeParameterList();
        return this.WithTypeParameterList(typeParameterList.WithParameters(typeParameterList.Parameters.AddRange(items)));
    }

    public StructDeclarationSyntax AddBaseListTypes(params BaseTypeSyntax[] items)
    {
        var baseList = this.BaseList ?? SyntaxFactory.BaseList();
        return this.WithBaseList(baseList.WithTypes(baseList.Types.AddRange(items)));
    }

    public StructDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)
    {
        return this.WithConstraintClauses(this.ConstraintClauses.AddRange(items));
    }

    public StructDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items)
    {
        return this.WithMembers(this.Members.AddRange(items));
    }
  }

  /// <summary>Interface type declaration syntax.</summary>
  public sealed partial class InterfaceDeclarationSyntax : TypeDeclarationSyntax
  {
    private CSharpSyntaxNode attributeLists;
    private TypeParameterListSyntax typeParameterList;
    private BaseListSyntax baseList;
    private CSharpSyntaxNode constraintClauses;
    private CSharpSyntaxNode members;

    internal InterfaceDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeListSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the interface keyword token.</summary>
    public override SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterfaceDeclarationSyntax)this.Green).keyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterfaceDeclarationSyntax)this.Green).identifier, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override TypeParameterListSyntax TypeParameterList 
    {
        get
        {
            return this.GetRed(ref this.typeParameterList, 4);
        }
    }

    public override BaseListSyntax BaseList 
    {
        get
        {
            return this.GetRed(ref this.baseList, 5);
        }
    }

    public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses 
    {
        get
        {
            return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.GetRed(ref this.constraintClauses, 6));
        }
    }

    public override SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterfaceDeclarationSyntax)this.Green).openBraceToken, this.GetChildPosition(7), this.GetChildIndex(7)); }
    }

    public override SyntaxList<MemberDeclarationSyntax> Members 
    {
        get
        {
            return new SyntaxList<MemberDeclarationSyntax>(this.GetRed(ref this.members, 8));
        }
    }

    public override SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterfaceDeclarationSyntax)this.Green).closeBraceToken, this.GetChildPosition(9), this.GetChildIndex(9)); }
    }

    public override SyntaxToken SemicolonToken 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterfaceDeclarationSyntax)this.Green).semicolonToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(10), this.GetChildIndex(10));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 4: return this.GetRed(ref this.typeParameterList, 4);
            case 5: return this.GetRed(ref this.baseList, 5);
            case 6: return this.GetRed(ref this.constraintClauses, 6);
            case 8: return this.GetRed(ref this.members, 8);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 4: return this.typeParameterList;
            case 5: return this.baseList;
            case 6: return this.constraintClauses;
            case 8: return this.members;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterfaceDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterfaceDeclaration(this);
    }

    public InterfaceDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.InterfaceDeclaration(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public InterfaceDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public InterfaceDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public InterfaceDeclarationSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public InterfaceDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public InterfaceDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, typeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public InterfaceDeclarationSyntax WithBaseList(BaseListSyntax baseList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, baseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public InterfaceDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, constraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public InterfaceDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, openBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public InterfaceDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, members, this.CloseBraceToken, this.SemicolonToken);
    }

    public InterfaceDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, closeBraceToken, this.SemicolonToken);
    }

    public InterfaceDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.BaseList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, semicolonToken);
    }

    public InterfaceDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    public InterfaceDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }

    public InterfaceDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)
    {
        var typeParameterList = this.TypeParameterList ?? SyntaxFactory.TypeParameterList();
        return this.WithTypeParameterList(typeParameterList.WithParameters(typeParameterList.Parameters.AddRange(items)));
    }

    public InterfaceDeclarationSyntax AddBaseListTypes(params BaseTypeSyntax[] items)
    {
        var baseList = this.BaseList ?? SyntaxFactory.BaseList();
        return this.WithBaseList(baseList.WithTypes(baseList.Types.AddRange(items)));
    }

    public InterfaceDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)
    {
        return this.WithConstraintClauses(this.ConstraintClauses.AddRange(items));
    }

    public InterfaceDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items)
    {
        return this.WithMembers(this.Members.AddRange(items));
    }
  }

  /// <summary>Enum type declaration syntax.</summary>
  public sealed partial class EnumDeclarationSyntax : BaseTypeDeclarationSyntax
  {
    private CSharpSyntaxNode attributeLists;
    private BaseListSyntax baseList;
    private SyntaxNode members;

    internal EnumDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeListSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the enum keyword token.</summary>
    public SyntaxToken EnumKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EnumDeclarationSyntax)this.Green).enumKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EnumDeclarationSyntax)this.Green).identifier, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override BaseListSyntax BaseList 
    {
        get
        {
            return this.GetRed(ref this.baseList, 4);
        }
    }

    public override SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EnumDeclarationSyntax)this.Green).openBraceToken, this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    /// <summary>Gets the members declaration list.</summary>
    public SeparatedSyntaxList<EnumMemberDeclarationSyntax> Members 
    {
        get
        {
            var red = this.GetRed(ref this.members, 6);
            if (red != null)
                return new SeparatedSyntaxList<EnumMemberDeclarationSyntax>(red, this.GetChildIndex(6));

            return default(SeparatedSyntaxList<EnumMemberDeclarationSyntax>);
        }
    }

    public override SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EnumDeclarationSyntax)this.Green).closeBraceToken, this.GetChildPosition(7), this.GetChildIndex(7)); }
    }

    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EnumDeclarationSyntax)this.Green).semicolonToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(8), this.GetChildIndex(8));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 4: return this.GetRed(ref this.baseList, 4);
            case 6: return this.GetRed(ref this.members, 6);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 4: return this.baseList;
            case 6: return this.members;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEnumDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEnumDeclaration(this);
    }

    public EnumDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || enumKeyword != this.EnumKeyword || identifier != this.Identifier || baseList != this.BaseList || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.EnumDeclaration(attributeLists, modifiers, enumKeyword, identifier, baseList, openBraceToken, members, closeBraceToken, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public EnumDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.EnumKeyword, this.Identifier, this.BaseList, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public EnumDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.EnumKeyword, this.Identifier, this.BaseList, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public EnumDeclarationSyntax WithEnumKeyword(SyntaxToken enumKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, enumKeyword, this.Identifier, this.BaseList, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public EnumDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EnumKeyword, identifier, this.BaseList, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public EnumDeclarationSyntax WithBaseList(BaseListSyntax baseList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EnumKeyword, this.Identifier, baseList, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public EnumDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EnumKeyword, this.Identifier, this.BaseList, openBraceToken, this.Members, this.CloseBraceToken, this.SemicolonToken);
    }

    public EnumDeclarationSyntax WithMembers(SeparatedSyntaxList<EnumMemberDeclarationSyntax> members)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EnumKeyword, this.Identifier, this.BaseList, this.OpenBraceToken, members, this.CloseBraceToken, this.SemicolonToken);
    }

    public EnumDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EnumKeyword, this.Identifier, this.BaseList, this.OpenBraceToken, this.Members, closeBraceToken, this.SemicolonToken);
    }

    public EnumDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EnumKeyword, this.Identifier, this.BaseList, this.OpenBraceToken, this.Members, this.CloseBraceToken, semicolonToken);
    }

    public EnumDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    public EnumDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }

    public EnumDeclarationSyntax AddBaseListTypes(params BaseTypeSyntax[] items)
    {
        var baseList = this.BaseList ?? SyntaxFactory.BaseList();
        return this.WithBaseList(baseList.WithTypes(baseList.Types.AddRange(items)));
    }

    public EnumDeclarationSyntax AddMembers(params EnumMemberDeclarationSyntax[] items)
    {
        return this.WithMembers(this.Members.AddRange(items));
    }
  }

  /// <summary>Delegate declaration syntax.</summary>
  public sealed partial class DelegateDeclarationSyntax : MemberDeclarationSyntax
  {
    private CSharpSyntaxNode attributeLists;
    private TypeSyntax returnType;
    private TypeParameterListSyntax typeParameterList;
    private ParameterListSyntax parameterList;
    private CSharpSyntaxNode constraintClauses;

    internal DelegateDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeListSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeListSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    /// <summary>Gets the modifier list.</summary>
    public SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the "delegate" keyword.</summary>
    public SyntaxToken DelegateKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DelegateDeclarationSyntax)this.Green).delegateKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>Gets the "ref" keyword if present.</summary>
    public SyntaxToken RefKeyword 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DelegateDeclarationSyntax)this.Green).refKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(3), this.GetChildIndex(3));

            return default(SyntaxToken);
        }
    }

    /// <summary>Gets the return type.</summary>
    public TypeSyntax ReturnType 
    {
        get
        {
            return this.GetRed(ref this.returnType, 4);
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DelegateDeclarationSyntax)this.Green).identifier, this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    public TypeParameterListSyntax TypeParameterList 
    {
        get
        {
            return this.GetRed(ref this.typeParameterList, 6);
        }
    }

    /// <summary>Gets the parameter list.</summary>
    public ParameterListSyntax ParameterList 
    {
        get
        {
            return this.GetRed(ref this.parameterList, 7);
        }
    }

    /// <summary>Gets the constraint clause list.</summary>
    public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses 
    {
        get
        {
            return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.GetRed(ref this.constraintClauses, 8));
        }
    }

    /// <summary>Gets the semicolon token.</summary>
    public SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DelegateDeclarationSyntax)this.Green).semicolonToken, this.GetChildPosition(9), this.GetChildIndex(9)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 4: return this.GetRed(ref this.returnType, 4);
            case 6: return this.GetRed(ref this.typeParameterList, 6);
            case 7: return this.GetRed(ref this.parameterList, 7);
            case 8: return this.GetRed(ref this.constraintClauses, 8);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 4: return this.returnType;
            case 6: return this.typeParameterList;
            case 7: return this.parameterList;
            case 8: return this.constraintClauses;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDelegateDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDelegateDeclaration(this);
    }

    public DelegateDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, SyntaxToken refKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || delegateKeyword != this.DelegateKeyword || refKeyword != this.RefKeyword || returnType != this.ReturnType || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || constraintClauses != this.ConstraintClauses || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.DelegateDeclaration(attributeLists, modifiers, delegateKeyword, refKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public DelegateDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.DelegateKeyword, this.RefKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.SemicolonToken);
    }

    public DelegateDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.DelegateKeyword, this.RefKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.SemicolonToken);
    }

    public DelegateDeclarationSyntax WithDelegateKeyword(SyntaxToken delegateKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, delegateKeyword, this.RefKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.SemicolonToken);
    }

    public DelegateDeclarationSyntax WithRefKeyword(SyntaxToken refKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.DelegateKeyword, refKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.SemicolonToken);
    }

    public DelegateDeclarationSyntax WithReturnType(TypeSyntax returnType)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.DelegateKeyword, this.RefKeyword, returnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.SemicolonToken);
    }

    public DelegateDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.DelegateKeyword, this.RefKeyword, this.ReturnType, identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.SemicolonToken);
    }

    public DelegateDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.DelegateKeyword, this.RefKeyword, this.ReturnType, this.Identifier, typeParameterList, this.ParameterList, this.ConstraintClauses, this.SemicolonToken);
    }

    public DelegateDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.DelegateKeyword, this.RefKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, parameterList, this.ConstraintClauses, this.SemicolonToken);
    }

    public DelegateDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.DelegateKeyword, this.RefKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, constraintClauses, this.SemicolonToken);
    }

    public DelegateDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.DelegateKeyword, this.RefKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, semicolonToken);
    }

    public DelegateDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    public DelegateDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }

    public DelegateDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)
    {
        var typeParameterList = this.TypeParameterList ?? SyntaxFactory.TypeParameterList();
        return this.WithTypeParameterList(typeParameterList.WithParameters(typeParameterList.Parameters.AddRange(items)));
    }

    public DelegateDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.AddRange(items)));
    }

    public DelegateDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)
    {
        return this.WithConstraintClauses(this.ConstraintClauses.AddRange(items));
    }
  }

  public sealed partial class EnumMemberDeclarationSyntax : MemberDeclarationSyntax
  {
    private CSharpSyntaxNode attributeLists;
    private EqualsValueClauseSyntax equalsValue;

    internal EnumMemberDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeListSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeListSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EnumMemberDeclarationSyntax)this.Green).identifier, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public EqualsValueClauseSyntax EqualsValue 
    {
        get
        {
            return this.GetRed(ref this.equalsValue, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 2: return this.GetRed(ref this.equalsValue, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 2: return this.equalsValue;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEnumMemberDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEnumMemberDeclaration(this);
    }

    public EnumMemberDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
    {
        if (attributeLists != this.AttributeLists || identifier != this.Identifier || equalsValue != this.EqualsValue)
        {
            var newNode = SyntaxFactory.EnumMemberDeclaration(attributeLists, identifier, equalsValue);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public EnumMemberDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Identifier, this.EqualsValue);
    }

    public EnumMemberDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, identifier, this.EqualsValue);
    }

    public EnumMemberDeclarationSyntax WithEqualsValue(EqualsValueClauseSyntax equalsValue)
    {
        return this.Update(this.AttributeLists, this.Identifier, equalsValue);
    }

    public EnumMemberDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }
  }

  /// <summary>Base list syntax.</summary>
  public sealed partial class BaseListSyntax : CSharpSyntaxNode
  {
    private SyntaxNode types;

    internal BaseListSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseListSyntax)this.Green).colonToken, this.Position, 0); }
    }

    /// <summary>Gets the base type references.</summary>
    public SeparatedSyntaxList<BaseTypeSyntax> Types 
    {
        get
        {
            var red = this.GetRed(ref this.types, 1);
            if (red != null)
                return new SeparatedSyntaxList<BaseTypeSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<BaseTypeSyntax>);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.types, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.types;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBaseList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBaseList(this);
    }

    public BaseListSyntax Update(SyntaxToken colonToken, SeparatedSyntaxList<BaseTypeSyntax> types)
    {
        if (colonToken != this.ColonToken || types != this.Types)
        {
            var newNode = SyntaxFactory.BaseList(colonToken, types);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public BaseListSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(colonToken, this.Types);
    }

    public BaseListSyntax WithTypes(SeparatedSyntaxList<BaseTypeSyntax> types)
    {
        return this.Update(this.ColonToken, types);
    }

    public BaseListSyntax AddTypes(params BaseTypeSyntax[] items)
    {
        return this.WithTypes(this.Types.AddRange(items));
    }
  }

  /// <summary>Provides the base class from which the classes that represent base type syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class BaseTypeSyntax : CSharpSyntaxNode
  {
    internal BaseTypeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    public abstract TypeSyntax Type { get; }
  }

  public sealed partial class SimpleBaseTypeSyntax : BaseTypeSyntax
  {
    private TypeSyntax type;

    internal SimpleBaseTypeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override TypeSyntax Type 
    {
        get
        {
            return this.GetRedAtZero(ref this.type);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.type);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSimpleBaseType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSimpleBaseType(this);
    }

    public SimpleBaseTypeSyntax Update(TypeSyntax type)
    {
        if (type != this.Type)
        {
            var newNode = SyntaxFactory.SimpleBaseType(type);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public SimpleBaseTypeSyntax WithType(TypeSyntax type)
    {
        return this.Update(type);
    }
  }

  /// <summary>Type parameter constraint clause.</summary>
  public sealed partial class TypeParameterConstraintClauseSyntax : CSharpSyntaxNode
  {
    private IdentifierNameSyntax name;
    private SyntaxNode constraints;

    internal TypeParameterConstraintClauseSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken WhereKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax)this.Green).whereKeyword, this.Position, 0); }
    }

    /// <summary>Gets the identifier.</summary>
    public IdentifierNameSyntax Name 
    {
        get
        {
            return this.GetRed(ref this.name, 1);
        }
    }

    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax)this.Green).colonToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>Gets the constraints list.</summary>
    public SeparatedSyntaxList<TypeParameterConstraintSyntax> Constraints 
    {
        get
        {
            var red = this.GetRed(ref this.constraints, 3);
            if (red != null)
                return new SeparatedSyntaxList<TypeParameterConstraintSyntax>(red, this.GetChildIndex(3));

            return default(SeparatedSyntaxList<TypeParameterConstraintSyntax>);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.name, 1);
            case 3: return this.GetRed(ref this.constraints, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.name;
            case 3: return this.constraints;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeParameterConstraintClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeParameterConstraintClause(this);
    }

    public TypeParameterConstraintClauseSyntax Update(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
    {
        if (whereKeyword != this.WhereKeyword || name != this.Name || colonToken != this.ColonToken || constraints != this.Constraints)
        {
            var newNode = SyntaxFactory.TypeParameterConstraintClause(whereKeyword, name, colonToken, constraints);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TypeParameterConstraintClauseSyntax WithWhereKeyword(SyntaxToken whereKeyword)
    {
        return this.Update(whereKeyword, this.Name, this.ColonToken, this.Constraints);
    }

    public TypeParameterConstraintClauseSyntax WithName(IdentifierNameSyntax name)
    {
        return this.Update(this.WhereKeyword, name, this.ColonToken, this.Constraints);
    }

    public TypeParameterConstraintClauseSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.WhereKeyword, this.Name, colonToken, this.Constraints);
    }

    public TypeParameterConstraintClauseSyntax WithConstraints(SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
    {
        return this.Update(this.WhereKeyword, this.Name, this.ColonToken, constraints);
    }

    public TypeParameterConstraintClauseSyntax AddConstraints(params TypeParameterConstraintSyntax[] items)
    {
        return this.WithConstraints(this.Constraints.AddRange(items));
    }
  }

  /// <summary>Base type for type parameter constraint syntax.</summary>
  public abstract partial class TypeParameterConstraintSyntax : CSharpSyntaxNode
  {
    internal TypeParameterConstraintSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  /// <summary>Constructor constraint syntax.</summary>
  public sealed partial class ConstructorConstraintSyntax : TypeParameterConstraintSyntax
  {
    internal ConstructorConstraintSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the "new" keyword.</summary>
    public SyntaxToken NewKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorConstraintSyntax)this.Green).newKeyword, this.Position, 0); }
    }

    /// <summary>Gets the open paren keyword.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorConstraintSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the close paren keyword.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorConstraintSyntax)this.Green).closeParenToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstructorConstraint(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConstructorConstraint(this);
    }

    public ConstructorConstraintSyntax Update(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
    {
        if (newKeyword != this.NewKeyword || openParenToken != this.OpenParenToken || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.ConstructorConstraint(newKeyword, openParenToken, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ConstructorConstraintSyntax WithNewKeyword(SyntaxToken newKeyword)
    {
        return this.Update(newKeyword, this.OpenParenToken, this.CloseParenToken);
    }

    public ConstructorConstraintSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.NewKeyword, openParenToken, this.CloseParenToken);
    }

    public ConstructorConstraintSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.NewKeyword, this.OpenParenToken, closeParenToken);
    }
  }

  /// <summary>Base type for class or struct constraint syntax.</summary>
  public sealed partial class ClassOrStructConstraintSyntax : TypeParameterConstraintSyntax
  {
    internal ClassOrStructConstraintSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the constraint keyword ("class" or "struct").</summary>
    public SyntaxToken ClassOrStructKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ClassOrStructConstraintSyntax)this.Green).classOrStructKeyword, this.Position, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitClassOrStructConstraint(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitClassOrStructConstraint(this);
    }

    public ClassOrStructConstraintSyntax Update(SyntaxToken classOrStructKeyword)
    {
        if (classOrStructKeyword != this.ClassOrStructKeyword)
        {
            var newNode = SyntaxFactory.ClassOrStructConstraint(this.Kind(), classOrStructKeyword);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ClassOrStructConstraintSyntax WithClassOrStructKeyword(SyntaxToken classOrStructKeyword)
    {
        return this.Update(classOrStructKeyword);
    }
  }

  /// <summary>Type constraint syntax.</summary>
  public sealed partial class TypeConstraintSyntax : TypeParameterConstraintSyntax
  {
    private TypeSyntax type;

    internal TypeConstraintSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the type syntax.</summary>
    public TypeSyntax Type 
    {
        get
        {
            return this.GetRedAtZero(ref this.type);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.type);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeConstraint(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeConstraint(this);
    }

    public TypeConstraintSyntax Update(TypeSyntax type)
    {
        if (type != this.Type)
        {
            var newNode = SyntaxFactory.TypeConstraint(type);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TypeConstraintSyntax WithType(TypeSyntax type)
    {
        return this.Update(type);
    }
  }

  public abstract partial class BaseFieldDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BaseFieldDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }

    /// <summary>Gets the modifier list.</summary>
    public abstract SyntaxTokenList Modifiers { get; }

    public abstract VariableDeclarationSyntax Declaration { get; }

    public abstract SyntaxToken SemicolonToken { get; }
  }

  public sealed partial class FieldDeclarationSyntax : BaseFieldDeclarationSyntax
  {
    private CSharpSyntaxNode attributeLists;
    private VariableDeclarationSyntax declaration;

    internal FieldDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public override SyntaxList<AttributeListSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeListSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    /// <summary>Gets the modifier list.</summary>
    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    public override VariableDeclarationSyntax Declaration 
    {
        get
        {
            return this.GetRed(ref this.declaration, 2);
        }
    }

    public override SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FieldDeclarationSyntax)this.Green).semicolonToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 2: return this.GetRed(ref this.declaration, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 2: return this.declaration;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFieldDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitFieldDeclaration(this);
    }

    public FieldDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || declaration != this.Declaration || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.FieldDeclaration(attributeLists, modifiers, declaration, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public FieldDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.Declaration, this.SemicolonToken);
    }

    public FieldDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.Declaration, this.SemicolonToken);
    }

    public FieldDeclarationSyntax WithDeclaration(VariableDeclarationSyntax declaration)
    {
        return this.Update(this.AttributeLists, this.Modifiers, declaration, this.SemicolonToken);
    }

    public FieldDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Declaration, semicolonToken);
    }

    public FieldDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    public FieldDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }

    public FieldDeclarationSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items)
    {
        return this.WithDeclaration(this.Declaration.WithVariables(this.Declaration.Variables.AddRange(items)));
    }
  }

  public sealed partial class EventFieldDeclarationSyntax : BaseFieldDeclarationSyntax
  {
    private CSharpSyntaxNode attributeLists;
    private VariableDeclarationSyntax declaration;

    internal EventFieldDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public override SyntaxList<AttributeListSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeListSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    /// <summary>Gets the modifier list.</summary>
    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    public SyntaxToken EventKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EventFieldDeclarationSyntax)this.Green).eventKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override VariableDeclarationSyntax Declaration 
    {
        get
        {
            return this.GetRed(ref this.declaration, 3);
        }
    }

    public override SyntaxToken SemicolonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EventFieldDeclarationSyntax)this.Green).semicolonToken, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 3: return this.GetRed(ref this.declaration, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 3: return this.declaration;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEventFieldDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEventFieldDeclaration(this);
    }

    public EventFieldDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || eventKeyword != this.EventKeyword || declaration != this.Declaration || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.EventFieldDeclaration(attributeLists, modifiers, eventKeyword, declaration, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public EventFieldDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.EventKeyword, this.Declaration, this.SemicolonToken);
    }

    public EventFieldDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.EventKeyword, this.Declaration, this.SemicolonToken);
    }

    public EventFieldDeclarationSyntax WithEventKeyword(SyntaxToken eventKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, eventKeyword, this.Declaration, this.SemicolonToken);
    }

    public EventFieldDeclarationSyntax WithDeclaration(VariableDeclarationSyntax declaration)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EventKeyword, declaration, this.SemicolonToken);
    }

    public EventFieldDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EventKeyword, this.Declaration, semicolonToken);
    }

    public EventFieldDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    public EventFieldDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }

    public EventFieldDeclarationSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items)
    {
        return this.WithDeclaration(this.Declaration.WithVariables(this.Declaration.Variables.AddRange(items)));
    }
  }

  public sealed partial class ExplicitInterfaceSpecifierSyntax : CSharpSyntaxNode
  {
    private NameSyntax name;

    internal ExplicitInterfaceSpecifierSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public NameSyntax Name 
    {
        get
        {
            return this.GetRedAtZero(ref this.name);
        }
    }

    public SyntaxToken DotToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExplicitInterfaceSpecifierSyntax)this.Green).dotToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.name);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitExplicitInterfaceSpecifier(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitExplicitInterfaceSpecifier(this);
    }

    public ExplicitInterfaceSpecifierSyntax Update(NameSyntax name, SyntaxToken dotToken)
    {
        if (name != this.Name || dotToken != this.DotToken)
        {
            var newNode = SyntaxFactory.ExplicitInterfaceSpecifier(name, dotToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ExplicitInterfaceSpecifierSyntax WithName(NameSyntax name)
    {
        return this.Update(name, this.DotToken);
    }

    public ExplicitInterfaceSpecifierSyntax WithDotToken(SyntaxToken dotToken)
    {
        return this.Update(this.Name, dotToken);
    }
  }

  /// <summary>Base type for method declaration syntax.</summary>
  public abstract partial class BaseMethodDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BaseMethodDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }

    /// <summary>Gets the modifier list.</summary>
    public abstract SyntaxTokenList Modifiers { get; }

    /// <summary>Gets the parameter list.</summary>
    public abstract ParameterListSyntax ParameterList { get; }

    public abstract BlockSyntax Body { get; }

    /// <summary>Gets the optional semicolon token.</summary>
    public abstract SyntaxToken SemicolonToken { get; }
  }

  /// <summary>Method declaration syntax.</summary>
  public sealed partial class MethodDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    private CSharpSyntaxNode attributeLists;
    private TypeSyntax returnType;
    private ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    private TypeParameterListSyntax typeParameterList;
    private ParameterListSyntax parameterList;
    private CSharpSyntaxNode constraintClauses;
    private BlockSyntax body;
    private ArrowExpressionClauseSyntax expressionBody;

    internal MethodDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeListSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    public SyntaxToken RefKeyword 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MethodDeclarationSyntax)this.Green).refKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(2), this.GetChildIndex(2));

            return default(SyntaxToken);
        }
    }

    /// <summary>Gets the return type syntax.</summary>
    public TypeSyntax ReturnType 
    {
        get
        {
            return this.GetRed(ref this.returnType, 3);
        }
    }

    public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier 
    {
        get
        {
            return this.GetRed(ref this.explicitInterfaceSpecifier, 4);
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MethodDeclarationSyntax)this.Green).identifier, this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    public TypeParameterListSyntax TypeParameterList 
    {
        get
        {
            return this.GetRed(ref this.typeParameterList, 6);
        }
    }

    public override ParameterListSyntax ParameterList 
    {
        get
        {
            return this.GetRed(ref this.parameterList, 7);
        }
    }

    /// <summary>Gets the constraint clause list.</summary>
    public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses 
    {
        get
        {
            return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.GetRed(ref this.constraintClauses, 8));
        }
    }

    public override BlockSyntax Body 
    {
        get
        {
            return this.GetRed(ref this.body, 9);
        }
    }

    public ArrowExpressionClauseSyntax ExpressionBody 
    {
        get
        {
            return this.GetRed(ref this.expressionBody, 10);
        }
    }

    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MethodDeclarationSyntax)this.Green).semicolonToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(11), this.GetChildIndex(11));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 3: return this.GetRed(ref this.returnType, 3);
            case 4: return this.GetRed(ref this.explicitInterfaceSpecifier, 4);
            case 6: return this.GetRed(ref this.typeParameterList, 6);
            case 7: return this.GetRed(ref this.parameterList, 7);
            case 8: return this.GetRed(ref this.constraintClauses, 8);
            case 9: return this.GetRed(ref this.body, 9);
            case 10: return this.GetRed(ref this.expressionBody, 10);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 3: return this.returnType;
            case 4: return this.explicitInterfaceSpecifier;
            case 6: return this.typeParameterList;
            case 7: return this.parameterList;
            case 8: return this.constraintClauses;
            case 9: return this.body;
            case 10: return this.expressionBody;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitMethodDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitMethodDeclaration(this);
    }

    public MethodDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken refKeyword, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || refKeyword != this.RefKeyword || returnType != this.ReturnType || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || constraintClauses != this.ConstraintClauses || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.MethodDeclaration(attributeLists, modifiers, refKeyword, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public MethodDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.RefKeyword, this.ReturnType, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public MethodDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.RefKeyword, this.ReturnType, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public MethodDeclarationSyntax WithRefKeyword(SyntaxToken refKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, refKeyword, this.ReturnType, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public MethodDeclarationSyntax WithReturnType(TypeSyntax returnType)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, returnType, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public MethodDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, this.ReturnType, explicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public MethodDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, this.ReturnType, this.ExplicitInterfaceSpecifier, identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public MethodDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, this.ReturnType, this.ExplicitInterfaceSpecifier, this.Identifier, typeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public MethodDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, this.ReturnType, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, parameterList, this.ConstraintClauses, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public MethodDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, this.ReturnType, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, constraintClauses, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public MethodDeclarationSyntax WithBody(BlockSyntax body)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, this.ReturnType, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, body, this.ExpressionBody, this.SemicolonToken);
    }

    public MethodDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, this.ReturnType, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, expressionBody, this.SemicolonToken);
    }

    public MethodDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, this.ReturnType, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.ExpressionBody, semicolonToken);
    }

    public MethodDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    public MethodDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }

    public MethodDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)
    {
        var typeParameterList = this.TypeParameterList ?? SyntaxFactory.TypeParameterList();
        return this.WithTypeParameterList(typeParameterList.WithParameters(typeParameterList.Parameters.AddRange(items)));
    }

    public MethodDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.AddRange(items)));
    }

    public MethodDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)
    {
        return this.WithConstraintClauses(this.ConstraintClauses.AddRange(items));
    }

    public MethodDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)
    {
        var body = this.Body ?? SyntaxFactory.Block();
        return this.WithBody(body.WithStatements(body.Statements.AddRange(items)));
    }
  }

  /// <summary>Operator declaration syntax.</summary>
  public sealed partial class OperatorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    private CSharpSyntaxNode attributeLists;
    private TypeSyntax returnType;
    private ParameterListSyntax parameterList;
    private BlockSyntax body;
    private ArrowExpressionClauseSyntax expressionBody;

    internal OperatorDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeListSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the return type.</summary>
    public TypeSyntax ReturnType 
    {
        get
        {
            return this.GetRed(ref this.returnType, 2);
        }
    }

    /// <summary>Gets the "operator" keyword.</summary>
    public SyntaxToken OperatorKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OperatorDeclarationSyntax)this.Green).operatorKeyword, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    /// <summary>Gets the operator token.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OperatorDeclarationSyntax)this.Green).operatorToken, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    public override ParameterListSyntax ParameterList 
    {
        get
        {
            return this.GetRed(ref this.parameterList, 5);
        }
    }

    public override BlockSyntax Body 
    {
        get
        {
            return this.GetRed(ref this.body, 6);
        }
    }

    public ArrowExpressionClauseSyntax ExpressionBody 
    {
        get
        {
            return this.GetRed(ref this.expressionBody, 7);
        }
    }

    public override SyntaxToken SemicolonToken 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OperatorDeclarationSyntax)this.Green).semicolonToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(8), this.GetChildIndex(8));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 2: return this.GetRed(ref this.returnType, 2);
            case 5: return this.GetRed(ref this.parameterList, 5);
            case 6: return this.GetRed(ref this.body, 6);
            case 7: return this.GetRed(ref this.expressionBody, 7);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 2: return this.returnType;
            case 5: return this.parameterList;
            case 6: return this.body;
            case 7: return this.expressionBody;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOperatorDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOperatorDeclaration(this);
    }

    public OperatorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || returnType != this.ReturnType || operatorKeyword != this.OperatorKeyword || operatorToken != this.OperatorToken || parameterList != this.ParameterList || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.OperatorDeclaration(attributeLists, modifiers, returnType, operatorKeyword, operatorToken, parameterList, body, expressionBody, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public OperatorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.ReturnType, this.OperatorKeyword, this.OperatorToken, this.ParameterList, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public OperatorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.ReturnType, this.OperatorKeyword, this.OperatorToken, this.ParameterList, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public OperatorDeclarationSyntax WithReturnType(TypeSyntax returnType)
    {
        return this.Update(this.AttributeLists, this.Modifiers, returnType, this.OperatorKeyword, this.OperatorToken, this.ParameterList, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public OperatorDeclarationSyntax WithOperatorKeyword(SyntaxToken operatorKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ReturnType, operatorKeyword, this.OperatorToken, this.ParameterList, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public OperatorDeclarationSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ReturnType, this.OperatorKeyword, operatorToken, this.ParameterList, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public OperatorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ReturnType, this.OperatorKeyword, this.OperatorToken, parameterList, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public OperatorDeclarationSyntax WithBody(BlockSyntax body)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ReturnType, this.OperatorKeyword, this.OperatorToken, this.ParameterList, body, this.ExpressionBody, this.SemicolonToken);
    }

    public OperatorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ReturnType, this.OperatorKeyword, this.OperatorToken, this.ParameterList, this.Body, expressionBody, this.SemicolonToken);
    }

    public OperatorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ReturnType, this.OperatorKeyword, this.OperatorToken, this.ParameterList, this.Body, this.ExpressionBody, semicolonToken);
    }

    public OperatorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    public OperatorDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }

    public OperatorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.AddRange(items)));
    }

    public OperatorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)
    {
        var body = this.Body ?? SyntaxFactory.Block();
        return this.WithBody(body.WithStatements(body.Statements.AddRange(items)));
    }
  }

  /// <summary>Conversion operator declaration syntax.</summary>
  public sealed partial class ConversionOperatorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    private CSharpSyntaxNode attributeLists;
    private TypeSyntax type;
    private ParameterListSyntax parameterList;
    private BlockSyntax body;
    private ArrowExpressionClauseSyntax expressionBody;

    internal ConversionOperatorDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeListSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the "implicit" or "explicit" token.</summary>
    public SyntaxToken ImplicitOrExplicitKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConversionOperatorDeclarationSyntax)this.Green).implicitOrExplicitKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>Gets the "operator" token.</summary>
    public SyntaxToken OperatorKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConversionOperatorDeclarationSyntax)this.Green).operatorKeyword, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    /// <summary>Gets the type.</summary>
    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 4);
        }
    }

    public override ParameterListSyntax ParameterList 
    {
        get
        {
            return this.GetRed(ref this.parameterList, 5);
        }
    }

    public override BlockSyntax Body 
    {
        get
        {
            return this.GetRed(ref this.body, 6);
        }
    }

    public ArrowExpressionClauseSyntax ExpressionBody 
    {
        get
        {
            return this.GetRed(ref this.expressionBody, 7);
        }
    }

    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConversionOperatorDeclarationSyntax)this.Green).semicolonToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(8), this.GetChildIndex(8));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 4: return this.GetRed(ref this.type, 4);
            case 5: return this.GetRed(ref this.parameterList, 5);
            case 6: return this.GetRed(ref this.body, 6);
            case 7: return this.GetRed(ref this.expressionBody, 7);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 4: return this.type;
            case 5: return this.parameterList;
            case 6: return this.body;
            case 7: return this.expressionBody;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConversionOperatorDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConversionOperatorDeclaration(this);
    }

    public ConversionOperatorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || implicitOrExplicitKeyword != this.ImplicitOrExplicitKeyword || operatorKeyword != this.OperatorKeyword || type != this.Type || parameterList != this.ParameterList || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ConversionOperatorDeclaration(attributeLists, modifiers, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, expressionBody, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ConversionOperatorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.ImplicitOrExplicitKeyword, this.OperatorKeyword, this.Type, this.ParameterList, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public ConversionOperatorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.ImplicitOrExplicitKeyword, this.OperatorKeyword, this.Type, this.ParameterList, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public ConversionOperatorDeclarationSyntax WithImplicitOrExplicitKeyword(SyntaxToken implicitOrExplicitKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, implicitOrExplicitKeyword, this.OperatorKeyword, this.Type, this.ParameterList, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public ConversionOperatorDeclarationSyntax WithOperatorKeyword(SyntaxToken operatorKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ImplicitOrExplicitKeyword, operatorKeyword, this.Type, this.ParameterList, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public ConversionOperatorDeclarationSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ImplicitOrExplicitKeyword, this.OperatorKeyword, type, this.ParameterList, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public ConversionOperatorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ImplicitOrExplicitKeyword, this.OperatorKeyword, this.Type, parameterList, this.Body, this.ExpressionBody, this.SemicolonToken);
    }

    public ConversionOperatorDeclarationSyntax WithBody(BlockSyntax body)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ImplicitOrExplicitKeyword, this.OperatorKeyword, this.Type, this.ParameterList, body, this.ExpressionBody, this.SemicolonToken);
    }

    public ConversionOperatorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ImplicitOrExplicitKeyword, this.OperatorKeyword, this.Type, this.ParameterList, this.Body, expressionBody, this.SemicolonToken);
    }

    public ConversionOperatorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ImplicitOrExplicitKeyword, this.OperatorKeyword, this.Type, this.ParameterList, this.Body, this.ExpressionBody, semicolonToken);
    }

    public ConversionOperatorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    public ConversionOperatorDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }

    public ConversionOperatorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.AddRange(items)));
    }

    public ConversionOperatorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)
    {
        var body = this.Body ?? SyntaxFactory.Block();
        return this.WithBody(body.WithStatements(body.Statements.AddRange(items)));
    }
  }

  /// <summary>Constructor declaration syntax.</summary>
  public sealed partial class ConstructorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    private CSharpSyntaxNode attributeLists;
    private ParameterListSyntax parameterList;
    private ConstructorInitializerSyntax initializer;
    private BlockSyntax body;

    internal ConstructorDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeListSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorDeclarationSyntax)this.Green).identifier, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override ParameterListSyntax ParameterList 
    {
        get
        {
            return this.GetRed(ref this.parameterList, 3);
        }
    }

    public ConstructorInitializerSyntax Initializer 
    {
        get
        {
            return this.GetRed(ref this.initializer, 4);
        }
    }

    public override BlockSyntax Body 
    {
        get
        {
            return this.GetRed(ref this.body, 5);
        }
    }

    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorDeclarationSyntax)this.Green).semicolonToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(6), this.GetChildIndex(6));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 3: return this.GetRed(ref this.parameterList, 3);
            case 4: return this.GetRed(ref this.initializer, 4);
            case 5: return this.GetRed(ref this.body, 5);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 3: return this.parameterList;
            case 4: return this.initializer;
            case 5: return this.body;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstructorDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConstructorDeclaration(this);
    }

    public ConstructorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || identifier != this.Identifier || parameterList != this.ParameterList || initializer != this.Initializer || body != this.Body || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ConstructorDeclaration(attributeLists, modifiers, identifier, parameterList, initializer, body, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ConstructorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.Identifier, this.ParameterList, this.Initializer, this.Body, this.SemicolonToken);
    }

    public ConstructorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.Identifier, this.ParameterList, this.Initializer, this.Body, this.SemicolonToken);
    }

    public ConstructorDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, identifier, this.ParameterList, this.Initializer, this.Body, this.SemicolonToken);
    }

    public ConstructorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Identifier, parameterList, this.Initializer, this.Body, this.SemicolonToken);
    }

    public ConstructorDeclarationSyntax WithInitializer(ConstructorInitializerSyntax initializer)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Identifier, this.ParameterList, initializer, this.Body, this.SemicolonToken);
    }

    public ConstructorDeclarationSyntax WithBody(BlockSyntax body)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Identifier, this.ParameterList, this.Initializer, body, this.SemicolonToken);
    }

    public ConstructorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Identifier, this.ParameterList, this.Initializer, this.Body, semicolonToken);
    }

    public ConstructorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    public ConstructorDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }

    public ConstructorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.AddRange(items)));
    }

    public ConstructorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)
    {
        var body = this.Body ?? SyntaxFactory.Block();
        return this.WithBody(body.WithStatements(body.Statements.AddRange(items)));
    }
  }

  /// <summary>Constructor initializer syntax.</summary>
  public sealed partial class ConstructorInitializerSyntax : CSharpSyntaxNode
  {
    private ArgumentListSyntax argumentList;

    internal ConstructorInitializerSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorInitializerSyntax)this.Green).colonToken, this.Position, 0); }
    }

    /// <summary>Gets the "this" or "base" keyword.</summary>
    public SyntaxToken ThisOrBaseKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorInitializerSyntax)this.Green).thisOrBaseKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public ArgumentListSyntax ArgumentList 
    {
        get
        {
            return this.GetRed(ref this.argumentList, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.argumentList, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.argumentList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstructorInitializer(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConstructorInitializer(this);
    }

    public ConstructorInitializerSyntax Update(SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
    {
        if (colonToken != this.ColonToken || thisOrBaseKeyword != this.ThisOrBaseKeyword || argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.ConstructorInitializer(this.Kind(), colonToken, thisOrBaseKeyword, argumentList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ConstructorInitializerSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(colonToken, this.ThisOrBaseKeyword, this.ArgumentList);
    }

    public ConstructorInitializerSyntax WithThisOrBaseKeyword(SyntaxToken thisOrBaseKeyword)
    {
        return this.Update(this.ColonToken, thisOrBaseKeyword, this.ArgumentList);
    }

    public ConstructorInitializerSyntax WithArgumentList(ArgumentListSyntax argumentList)
    {
        return this.Update(this.ColonToken, this.ThisOrBaseKeyword, argumentList);
    }

    public ConstructorInitializerSyntax AddArgumentListArguments(params ArgumentSyntax[] items)
    {
        return this.WithArgumentList(this.ArgumentList.WithArguments(this.ArgumentList.Arguments.AddRange(items)));
    }
  }

  /// <summary>Destructor declaration syntax.</summary>
  public sealed partial class DestructorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    private CSharpSyntaxNode attributeLists;
    private ParameterListSyntax parameterList;
    private BlockSyntax body;

    internal DestructorDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeListSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the tilde token.</summary>
    public SyntaxToken TildeToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DestructorDeclarationSyntax)this.Green).tildeToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DestructorDeclarationSyntax)this.Green).identifier, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override ParameterListSyntax ParameterList 
    {
        get
        {
            return this.GetRed(ref this.parameterList, 4);
        }
    }

    public override BlockSyntax Body 
    {
        get
        {
            return this.GetRed(ref this.body, 5);
        }
    }

    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DestructorDeclarationSyntax)this.Green).semicolonToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(6), this.GetChildIndex(6));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 4: return this.GetRed(ref this.parameterList, 4);
            case 5: return this.GetRed(ref this.body, 5);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 4: return this.parameterList;
            case 5: return this.body;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDestructorDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDestructorDeclaration(this);
    }

    public DestructorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || tildeToken != this.TildeToken || identifier != this.Identifier || parameterList != this.ParameterList || body != this.Body || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.DestructorDeclaration(attributeLists, modifiers, tildeToken, identifier, parameterList, body, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public DestructorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.TildeToken, this.Identifier, this.ParameterList, this.Body, this.SemicolonToken);
    }

    public DestructorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.TildeToken, this.Identifier, this.ParameterList, this.Body, this.SemicolonToken);
    }

    public DestructorDeclarationSyntax WithTildeToken(SyntaxToken tildeToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, tildeToken, this.Identifier, this.ParameterList, this.Body, this.SemicolonToken);
    }

    public DestructorDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.TildeToken, identifier, this.ParameterList, this.Body, this.SemicolonToken);
    }

    public DestructorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.TildeToken, this.Identifier, parameterList, this.Body, this.SemicolonToken);
    }

    public DestructorDeclarationSyntax WithBody(BlockSyntax body)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.TildeToken, this.Identifier, this.ParameterList, body, this.SemicolonToken);
    }

    public DestructorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.TildeToken, this.Identifier, this.ParameterList, this.Body, semicolonToken);
    }

    public DestructorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    public DestructorDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }

    public DestructorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.AddRange(items)));
    }

    public DestructorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)
    {
        var body = this.Body ?? SyntaxFactory.Block();
        return this.WithBody(body.WithStatements(body.Statements.AddRange(items)));
    }
  }

  /// <summary>Base type for property declaration syntax.</summary>
  public abstract partial class BasePropertyDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BasePropertyDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }

    /// <summary>Gets the modifier list.</summary>
    public abstract SyntaxTokenList Modifiers { get; }

    /// <summary>Gets the type syntax.</summary>
    public abstract TypeSyntax Type { get; }

    /// <summary>Gets the optional explicit interface specifier.</summary>
    public abstract ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }

    public abstract AccessorListSyntax AccessorList { get; }
  }

  public sealed partial class PropertyDeclarationSyntax : BasePropertyDeclarationSyntax
  {
    private CSharpSyntaxNode attributeLists;
    private TypeSyntax type;
    private ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    private AccessorListSyntax accessorList;
    private ArrowExpressionClauseSyntax expressionBody;
    private EqualsValueClauseSyntax initializer;

    internal PropertyDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeListSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    public SyntaxToken RefKeyword 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PropertyDeclarationSyntax)this.Green).refKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(2), this.GetChildIndex(2));

            return default(SyntaxToken);
        }
    }

    public override TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 3);
        }
    }

    public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier 
    {
        get
        {
            return this.GetRed(ref this.explicitInterfaceSpecifier, 4);
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PropertyDeclarationSyntax)this.Green).identifier, this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    public override AccessorListSyntax AccessorList 
    {
        get
        {
            return this.GetRed(ref this.accessorList, 6);
        }
    }

    public ArrowExpressionClauseSyntax ExpressionBody 
    {
        get
        {
            return this.GetRed(ref this.expressionBody, 7);
        }
    }

    public EqualsValueClauseSyntax Initializer 
    {
        get
        {
            return this.GetRed(ref this.initializer, 8);
        }
    }

    public SyntaxToken SemicolonToken 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PropertyDeclarationSyntax)this.Green).semicolonToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(9), this.GetChildIndex(9));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 3: return this.GetRed(ref this.type, 3);
            case 4: return this.GetRed(ref this.explicitInterfaceSpecifier, 4);
            case 6: return this.GetRed(ref this.accessorList, 6);
            case 7: return this.GetRed(ref this.expressionBody, 7);
            case 8: return this.GetRed(ref this.initializer, 8);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 3: return this.type;
            case 4: return this.explicitInterfaceSpecifier;
            case 6: return this.accessorList;
            case 7: return this.expressionBody;
            case 8: return this.initializer;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPropertyDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPropertyDeclaration(this);
    }

    public PropertyDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken refKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || refKeyword != this.RefKeyword || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || accessorList != this.AccessorList || expressionBody != this.ExpressionBody || initializer != this.Initializer || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.PropertyDeclaration(attributeLists, modifiers, refKeyword, type, explicitInterfaceSpecifier, identifier, accessorList, expressionBody, initializer, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public PropertyDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.RefKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.Identifier, this.AccessorList, this.ExpressionBody, this.Initializer, this.SemicolonToken);
    }

    public PropertyDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.RefKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.Identifier, this.AccessorList, this.ExpressionBody, this.Initializer, this.SemicolonToken);
    }

    public PropertyDeclarationSyntax WithRefKeyword(SyntaxToken refKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, refKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.Identifier, this.AccessorList, this.ExpressionBody, this.Initializer, this.SemicolonToken);
    }

    public PropertyDeclarationSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, type, this.ExplicitInterfaceSpecifier, this.Identifier, this.AccessorList, this.ExpressionBody, this.Initializer, this.SemicolonToken);
    }

    public PropertyDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, this.Type, explicitInterfaceSpecifier, this.Identifier, this.AccessorList, this.ExpressionBody, this.Initializer, this.SemicolonToken);
    }

    public PropertyDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, this.Type, this.ExplicitInterfaceSpecifier, identifier, this.AccessorList, this.ExpressionBody, this.Initializer, this.SemicolonToken);
    }

    public PropertyDeclarationSyntax WithAccessorList(AccessorListSyntax accessorList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.Identifier, accessorList, this.ExpressionBody, this.Initializer, this.SemicolonToken);
    }

    public PropertyDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.Identifier, this.AccessorList, expressionBody, this.Initializer, this.SemicolonToken);
    }

    public PropertyDeclarationSyntax WithInitializer(EqualsValueClauseSyntax initializer)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.Identifier, this.AccessorList, this.ExpressionBody, initializer, this.SemicolonToken);
    }

    public PropertyDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.Identifier, this.AccessorList, this.ExpressionBody, this.Initializer, semicolonToken);
    }

    public PropertyDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    public PropertyDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }

    public PropertyDeclarationSyntax AddAccessorListAccessors(params AccessorDeclarationSyntax[] items)
    {
        var accessorList = this.AccessorList ?? SyntaxFactory.AccessorList();
        return this.WithAccessorList(accessorList.WithAccessors(accessorList.Accessors.AddRange(items)));
    }
  }

  /// <summary>The syntax for the expression body of an expression-bodied member.</summary>
  public sealed partial class ArrowExpressionClauseSyntax : CSharpSyntaxNode
  {
    private ExpressionSyntax expression;

    internal ArrowExpressionClauseSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken ArrowToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax)this.Green).arrowToken, this.Position, 0); }
    }

    public SyntaxToken RefKeyword 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax)this.Green).refKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxToken);
        }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArrowExpressionClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArrowExpressionClause(this);
    }

    public ArrowExpressionClauseSyntax Update(SyntaxToken arrowToken, SyntaxToken refKeyword, ExpressionSyntax expression)
    {
        if (arrowToken != this.ArrowToken || refKeyword != this.RefKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.ArrowExpressionClause(arrowToken, refKeyword, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ArrowExpressionClauseSyntax WithArrowToken(SyntaxToken arrowToken)
    {
        return this.Update(arrowToken, this.RefKeyword, this.Expression);
    }

    public ArrowExpressionClauseSyntax WithRefKeyword(SyntaxToken refKeyword)
    {
        return this.Update(this.ArrowToken, refKeyword, this.Expression);
    }

    public ArrowExpressionClauseSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.ArrowToken, this.RefKeyword, expression);
    }
  }

  public sealed partial class EventDeclarationSyntax : BasePropertyDeclarationSyntax
  {
    private CSharpSyntaxNode attributeLists;
    private TypeSyntax type;
    private ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    private AccessorListSyntax accessorList;

    internal EventDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeListSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    public SyntaxToken EventKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EventDeclarationSyntax)this.Green).eventKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 3);
        }
    }

    public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier 
    {
        get
        {
            return this.GetRed(ref this.explicitInterfaceSpecifier, 4);
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EventDeclarationSyntax)this.Green).identifier, this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    public override AccessorListSyntax AccessorList 
    {
        get
        {
            return this.GetRed(ref this.accessorList, 6);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 3: return this.GetRed(ref this.type, 3);
            case 4: return this.GetRed(ref this.explicitInterfaceSpecifier, 4);
            case 6: return this.GetRed(ref this.accessorList, 6);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 3: return this.type;
            case 4: return this.explicitInterfaceSpecifier;
            case 6: return this.accessorList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEventDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEventDeclaration(this);
    }

    public EventDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || eventKeyword != this.EventKeyword || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || accessorList != this.AccessorList)
        {
            var newNode = SyntaxFactory.EventDeclaration(attributeLists, modifiers, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public EventDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.EventKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.Identifier, this.AccessorList);
    }

    public EventDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.EventKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.Identifier, this.AccessorList);
    }

    public EventDeclarationSyntax WithEventKeyword(SyntaxToken eventKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, eventKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.Identifier, this.AccessorList);
    }

    public EventDeclarationSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EventKeyword, type, this.ExplicitInterfaceSpecifier, this.Identifier, this.AccessorList);
    }

    public EventDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EventKeyword, this.Type, explicitInterfaceSpecifier, this.Identifier, this.AccessorList);
    }

    public EventDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EventKeyword, this.Type, this.ExplicitInterfaceSpecifier, identifier, this.AccessorList);
    }

    public EventDeclarationSyntax WithAccessorList(AccessorListSyntax accessorList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EventKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.Identifier, accessorList);
    }

    public EventDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    public EventDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }

    public EventDeclarationSyntax AddAccessorListAccessors(params AccessorDeclarationSyntax[] items)
    {
        return this.WithAccessorList(this.AccessorList.WithAccessors(this.AccessorList.Accessors.AddRange(items)));
    }
  }

  public sealed partial class IndexerDeclarationSyntax : BasePropertyDeclarationSyntax
  {
    private CSharpSyntaxNode attributeLists;
    private TypeSyntax type;
    private ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    private BracketedParameterListSyntax parameterList;
    private AccessorListSyntax accessorList;
    private ArrowExpressionClauseSyntax expressionBody;

    internal IndexerDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeListSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeListSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    public SyntaxToken RefKeyword 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IndexerDeclarationSyntax)this.Green).refKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(2), this.GetChildIndex(2));

            return default(SyntaxToken);
        }
    }

    public override TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 3);
        }
    }

    public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier 
    {
        get
        {
            return this.GetRed(ref this.explicitInterfaceSpecifier, 4);
        }
    }

    public SyntaxToken ThisKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IndexerDeclarationSyntax)this.Green).thisKeyword, this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    /// <summary>Gets the parameter list.</summary>
    public BracketedParameterListSyntax ParameterList 
    {
        get
        {
            return this.GetRed(ref this.parameterList, 6);
        }
    }

    public override AccessorListSyntax AccessorList 
    {
        get
        {
            return this.GetRed(ref this.accessorList, 7);
        }
    }

    public ArrowExpressionClauseSyntax ExpressionBody 
    {
        get
        {
            return this.GetRed(ref this.expressionBody, 8);
        }
    }

    public SyntaxToken SemicolonToken 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IndexerDeclarationSyntax)this.Green).semicolonToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(9), this.GetChildIndex(9));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 3: return this.GetRed(ref this.type, 3);
            case 4: return this.GetRed(ref this.explicitInterfaceSpecifier, 4);
            case 6: return this.GetRed(ref this.parameterList, 6);
            case 7: return this.GetRed(ref this.accessorList, 7);
            case 8: return this.GetRed(ref this.expressionBody, 8);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 3: return this.type;
            case 4: return this.explicitInterfaceSpecifier;
            case 6: return this.parameterList;
            case 7: return this.accessorList;
            case 8: return this.expressionBody;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIndexerDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIndexerDeclaration(this);
    }

    public IndexerDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken refKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || refKeyword != this.RefKeyword || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || thisKeyword != this.ThisKeyword || parameterList != this.ParameterList || accessorList != this.AccessorList || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.IndexerDeclaration(attributeLists, modifiers, refKeyword, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList, expressionBody, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public IndexerDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.RefKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.ThisKeyword, this.ParameterList, this.AccessorList, this.ExpressionBody, this.SemicolonToken);
    }

    public IndexerDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.RefKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.ThisKeyword, this.ParameterList, this.AccessorList, this.ExpressionBody, this.SemicolonToken);
    }

    public IndexerDeclarationSyntax WithRefKeyword(SyntaxToken refKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, refKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.ThisKeyword, this.ParameterList, this.AccessorList, this.ExpressionBody, this.SemicolonToken);
    }

    public IndexerDeclarationSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, type, this.ExplicitInterfaceSpecifier, this.ThisKeyword, this.ParameterList, this.AccessorList, this.ExpressionBody, this.SemicolonToken);
    }

    public IndexerDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, this.Type, explicitInterfaceSpecifier, this.ThisKeyword, this.ParameterList, this.AccessorList, this.ExpressionBody, this.SemicolonToken);
    }

    public IndexerDeclarationSyntax WithThisKeyword(SyntaxToken thisKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, this.Type, this.ExplicitInterfaceSpecifier, thisKeyword, this.ParameterList, this.AccessorList, this.ExpressionBody, this.SemicolonToken);
    }

    public IndexerDeclarationSyntax WithParameterList(BracketedParameterListSyntax parameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.ThisKeyword, parameterList, this.AccessorList, this.ExpressionBody, this.SemicolonToken);
    }

    public IndexerDeclarationSyntax WithAccessorList(AccessorListSyntax accessorList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.ThisKeyword, this.ParameterList, accessorList, this.ExpressionBody, this.SemicolonToken);
    }

    public IndexerDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.ThisKeyword, this.ParameterList, this.AccessorList, expressionBody, this.SemicolonToken);
    }

    public IndexerDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.ThisKeyword, this.ParameterList, this.AccessorList, this.ExpressionBody, semicolonToken);
    }

    public IndexerDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    public IndexerDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }

    public IndexerDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.AddRange(items)));
    }

    public IndexerDeclarationSyntax AddAccessorListAccessors(params AccessorDeclarationSyntax[] items)
    {
        var accessorList = this.AccessorList ?? SyntaxFactory.AccessorList();
        return this.WithAccessorList(accessorList.WithAccessors(accessorList.Accessors.AddRange(items)));
    }
  }

  public sealed partial class AccessorListSyntax : CSharpSyntaxNode
  {
    private CSharpSyntaxNode accessors;

    internal AccessorListSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorListSyntax)this.Green).openBraceToken, this.Position, 0); }
    }

    public SyntaxList<AccessorDeclarationSyntax> Accessors 
    {
        get
        {
            return new SyntaxList<AccessorDeclarationSyntax>(this.GetRed(ref this.accessors, 1));
        }
    }

    public SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorListSyntax)this.Green).closeBraceToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.accessors, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.accessors;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAccessorList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAccessorList(this);
    }

    public AccessorListSyntax Update(SyntaxToken openBraceToken, SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || accessors != this.Accessors || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.AccessorList(openBraceToken, accessors, closeBraceToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AccessorListSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(openBraceToken, this.Accessors, this.CloseBraceToken);
    }

    public AccessorListSyntax WithAccessors(SyntaxList<AccessorDeclarationSyntax> accessors)
    {
        return this.Update(this.OpenBraceToken, accessors, this.CloseBraceToken);
    }

    public AccessorListSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.OpenBraceToken, this.Accessors, closeBraceToken);
    }

    public AccessorListSyntax AddAccessors(params AccessorDeclarationSyntax[] items)
    {
        return this.WithAccessors(this.Accessors.AddRange(items));
    }
  }

  public sealed partial class AccessorDeclarationSyntax : CSharpSyntaxNode
  {
    private CSharpSyntaxNode attributeLists;
    private BlockSyntax body;

    internal AccessorDeclarationSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeListSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeListSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    /// <summary>Gets the modifier list.</summary>
    public SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the keyword token, or identifier if an erroneous accessor declaration.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorDeclarationSyntax)this.Green).keyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>Gets the optional body block which may be empty, but it is null if there are no braces.</summary>
    public BlockSyntax Body 
    {
        get
        {
            return this.GetRed(ref this.body, 3);
        }
    }

    /// <summary>Gets the optional semicolon token.</summary>
    public SyntaxToken SemicolonToken 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorDeclarationSyntax)this.Green).semicolonToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(4), this.GetChildIndex(4));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 3: return this.GetRed(ref this.body, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 3: return this.body;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAccessorDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAccessorDeclaration(this);
    }

    public AccessorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || body != this.Body || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.AccessorDeclaration(this.Kind(), attributeLists, modifiers, keyword, body, semicolonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AccessorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.Keyword, this.Body, this.SemicolonToken);
    }

    public AccessorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.Keyword, this.Body, this.SemicolonToken);
    }

    public AccessorDeclarationSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, keyword, this.Body, this.SemicolonToken);
    }

    public AccessorDeclarationSyntax WithBody(BlockSyntax body)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, body, this.SemicolonToken);
    }

    public AccessorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Body, semicolonToken);
    }

    public AccessorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    public AccessorDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }

    public AccessorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)
    {
        var body = this.Body ?? SyntaxFactory.Block();
        return this.WithBody(body.WithStatements(body.Statements.AddRange(items)));
    }
  }

  /// <summary>Base type for parameter list syntax.</summary>
  public abstract partial class BaseParameterListSyntax : CSharpSyntaxNode
  {
    internal BaseParameterListSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>Gets the parameter list.</summary>
    public abstract SeparatedSyntaxList<ParameterSyntax> Parameters { get; }
  }

  /// <summary>Parameter list syntax.</summary>
  public sealed partial class ParameterListSyntax : BaseParameterListSyntax
  {
    private SyntaxNode parameters;

    internal ParameterListSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the open paren token.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax)this.Green).openParenToken, this.Position, 0); }
    }

    public override SeparatedSyntaxList<ParameterSyntax> Parameters 
    {
        get
        {
            var red = this.GetRed(ref this.parameters, 1);
            if (red != null)
                return new SeparatedSyntaxList<ParameterSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<ParameterSyntax>);
        }
    }

    /// <summary>Gets the close paren token.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax)this.Green).closeParenToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.parameters, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.parameters;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParameterList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitParameterList(this);
    }

    public ParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || parameters != this.Parameters || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.ParameterList(openParenToken, parameters, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ParameterListSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Parameters, this.CloseParenToken);
    }

    public ParameterListSyntax WithParameters(SeparatedSyntaxList<ParameterSyntax> parameters)
    {
        return this.Update(this.OpenParenToken, parameters, this.CloseParenToken);
    }

    public ParameterListSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Parameters, closeParenToken);
    }

    public ParameterListSyntax AddParameters(params ParameterSyntax[] items)
    {
        return this.WithParameters(this.Parameters.AddRange(items));
    }
  }

  /// <summary>Parameter list syntax with surrounding brackets.</summary>
  public sealed partial class BracketedParameterListSyntax : BaseParameterListSyntax
  {
    private SyntaxNode parameters;

    internal BracketedParameterListSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the open bracket token.</summary>
    public SyntaxToken OpenBracketToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedParameterListSyntax)this.Green).openBracketToken, this.Position, 0); }
    }

    public override SeparatedSyntaxList<ParameterSyntax> Parameters 
    {
        get
        {
            var red = this.GetRed(ref this.parameters, 1);
            if (red != null)
                return new SeparatedSyntaxList<ParameterSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<ParameterSyntax>);
        }
    }

    /// <summary>Gets the close bracket token.</summary>
    public SyntaxToken CloseBracketToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedParameterListSyntax)this.Green).closeBracketToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.parameters, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.parameters;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBracketedParameterList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBracketedParameterList(this);
    }

    public BracketedParameterListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || parameters != this.Parameters || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.BracketedParameterList(openBracketToken, parameters, closeBracketToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public BracketedParameterListSyntax WithOpenBracketToken(SyntaxToken openBracketToken)
    {
        return this.Update(openBracketToken, this.Parameters, this.CloseBracketToken);
    }

    public BracketedParameterListSyntax WithParameters(SeparatedSyntaxList<ParameterSyntax> parameters)
    {
        return this.Update(this.OpenBracketToken, parameters, this.CloseBracketToken);
    }

    public BracketedParameterListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)
    {
        return this.Update(this.OpenBracketToken, this.Parameters, closeBracketToken);
    }

    public BracketedParameterListSyntax AddParameters(params ParameterSyntax[] items)
    {
        return this.WithParameters(this.Parameters.AddRange(items));
    }
  }

  /// <summary>Parameter syntax.</summary>
  public sealed partial class ParameterSyntax : CSharpSyntaxNode
  {
    private CSharpSyntaxNode attributeLists;
    private TypeSyntax type;
    private EqualsValueClauseSyntax @default;

    internal ParameterSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeListSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeListSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    /// <summary>Gets the modifier list.</summary>
    public SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 2);
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterSyntax)this.Green).identifier, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public EqualsValueClauseSyntax Default 
    {
        get
        {
            return this.GetRed(ref this.@default, 4);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 2: return this.GetRed(ref this.type, 2);
            case 4: return this.GetRed(ref this.@default, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 2: return this.type;
            case 4: return this.@default;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParameter(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitParameter(this);
    }

    public ParameterSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type || identifier != this.Identifier || @default != this.Default)
        {
            var newNode = SyntaxFactory.Parameter(attributeLists, modifiers, type, identifier, @default);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ParameterSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.Type, this.Identifier, this.Default);
    }

    public ParameterSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.Type, this.Identifier, this.Default);
    }

    public ParameterSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.AttributeLists, this.Modifiers, type, this.Identifier, this.Default);
    }

    public ParameterSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Type, identifier, this.Default);
    }

    public ParameterSyntax WithDefault(EqualsValueClauseSyntax @default)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Type, this.Identifier, @default);
    }

    public ParameterSyntax AddAttributeLists(params AttributeListSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    public ParameterSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }
  }

  public sealed partial class IncompleteMemberSyntax : MemberDeclarationSyntax
  {
    private CSharpSyntaxNode attributeLists;
    private TypeSyntax type;

    internal IncompleteMemberSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeListSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeListSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    /// <summary>Gets the modifier list.</summary>
    public SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    public SyntaxToken RefKeyword 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IncompleteMemberSyntax)this.Green).refKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(2), this.GetChildIndex(2));

            return default(SyntaxToken);
        }
    }

    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 3);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 3: return this.GetRed(ref this.type, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 3: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIncompleteMember(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIncompleteMember(this);
    }

    public IncompleteMemberSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken refKeyword, TypeSyntax type)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || refKeyword != this.RefKeyword || type != this.Type)
        {
            var newNode = SyntaxFactory.IncompleteMember(attributeLists, modifiers, refKeyword, type);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public IncompleteMemberSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.RefKeyword, this.Type);
    }

    public IncompleteMemberSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.RefKeyword, this.Type);
    }

    public IncompleteMemberSyntax WithRefKeyword(SyntaxToken refKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, refKeyword, this.Type);
    }

    public IncompleteMemberSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.RefKeyword, type);
    }

    public IncompleteMemberSyntax AddAttributeLists(params AttributeListSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    public IncompleteMemberSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }
  }

  public sealed partial class SkippedTokensTriviaSyntax : StructuredTriviaSyntax
  {
    internal SkippedTokensTriviaSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxTokenList Tokens 
    {
        get
        {
            var slot = this.Green.GetSlot(0);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.Position, 0);

            return default(SyntaxTokenList);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSkippedTokensTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSkippedTokensTrivia(this);
    }

    public SkippedTokensTriviaSyntax Update(SyntaxTokenList tokens)
    {
        if (tokens != this.Tokens)
        {
            var newNode = SyntaxFactory.SkippedTokensTrivia(tokens);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public SkippedTokensTriviaSyntax WithTokens(SyntaxTokenList tokens)
    {
        return this.Update(tokens);
    }

    public SkippedTokensTriviaSyntax AddTokens(params SyntaxToken[] items)
    {
        return this.WithTokens(this.Tokens.AddRange(items));
    }
  }

  public sealed partial class DocumentationCommentTriviaSyntax : StructuredTriviaSyntax
  {
    private CSharpSyntaxNode content;

    internal DocumentationCommentTriviaSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxList<XmlNodeSyntax> Content 
    {
        get
        {
            return new SyntaxList<XmlNodeSyntax>(this.GetRed(ref this.content, 0));
        }
    }

    public SyntaxToken EndOfComment 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentTriviaSyntax)this.Green).endOfComment, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.content);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.content;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDocumentationCommentTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDocumentationCommentTrivia(this);
    }

    public DocumentationCommentTriviaSyntax Update(SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment)
    {
        if (content != this.Content || endOfComment != this.EndOfComment)
        {
            var newNode = SyntaxFactory.DocumentationCommentTrivia(this.Kind(), content, endOfComment);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public DocumentationCommentTriviaSyntax WithContent(SyntaxList<XmlNodeSyntax> content)
    {
        return this.Update(content, this.EndOfComment);
    }

    public DocumentationCommentTriviaSyntax WithEndOfComment(SyntaxToken endOfComment)
    {
        return this.Update(this.Content, endOfComment);
    }

    public DocumentationCommentTriviaSyntax AddContent(params XmlNodeSyntax[] items)
    {
        return this.WithContent(this.Content.AddRange(items));
    }
  }

  /// <summary>
  /// A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or &lt;seealso&gt; documentation comment tag).
  /// For example, the M in &lt;see cref="M" /&gt;.
  /// </summary>
  public abstract partial class CrefSyntax : CSharpSyntaxNode
  {
    internal CrefSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  /// <summary>
  /// A symbol reference that definitely refers to a type.
  /// For example, "int", "A::B", "A.B", "A&lt;T&gt;", but not "M()" (has parameter list) or "this" (indexer).
  /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
  /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
  /// might be a non-type member.
  /// </summary>
  public sealed partial class TypeCrefSyntax : CrefSyntax
  {
    private TypeSyntax type;

    internal TypeCrefSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public TypeSyntax Type 
    {
        get
        {
            return this.GetRedAtZero(ref this.type);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.type);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeCref(this);
    }

    public TypeCrefSyntax Update(TypeSyntax type)
    {
        if (type != this.Type)
        {
            var newNode = SyntaxFactory.TypeCref(type);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TypeCrefSyntax WithType(TypeSyntax type)
    {
        return this.Update(type);
    }
  }

  /// <summary>
  /// A symbol reference to a type or non-type member that is qualified by an enclosing type or namespace.
  /// For example, cref="System.String.ToString()".
  /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
  /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
  /// might be a non-type member.
  /// </summary>
  public sealed partial class QualifiedCrefSyntax : CrefSyntax
  {
    private TypeSyntax container;
    private MemberCrefSyntax member;

    internal QualifiedCrefSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public TypeSyntax Container 
    {
        get
        {
            return this.GetRedAtZero(ref this.container);
        }
    }

    public SyntaxToken DotToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QualifiedCrefSyntax)this.Green).dotToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public MemberCrefSyntax Member 
    {
        get
        {
            return this.GetRed(ref this.member, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.container);
            case 2: return this.GetRed(ref this.member, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.container;
            case 2: return this.member;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQualifiedCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitQualifiedCref(this);
    }

    public QualifiedCrefSyntax Update(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)
    {
        if (container != this.Container || dotToken != this.DotToken || member != this.Member)
        {
            var newNode = SyntaxFactory.QualifiedCref(container, dotToken, member);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public QualifiedCrefSyntax WithContainer(TypeSyntax container)
    {
        return this.Update(container, this.DotToken, this.Member);
    }

    public QualifiedCrefSyntax WithDotToken(SyntaxToken dotToken)
    {
        return this.Update(this.Container, dotToken, this.Member);
    }

    public QualifiedCrefSyntax WithMember(MemberCrefSyntax member)
    {
        return this.Update(this.Container, this.DotToken, member);
    }
  }

  /// <summary>
  /// The unqualified part of a CrefSyntax.
  /// For example, "ToString()" in "object.ToString()".
  /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
  /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
  /// might be a non-type member.
  /// </summary>
  public abstract partial class MemberCrefSyntax : CrefSyntax
  {
    internal MemberCrefSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  /// <summary>
  /// A MemberCrefSyntax specified by a name (an identifier, predefined type keyword, or an alias-qualified name,
  /// with an optional type parameter list) and an optional parameter list.
  /// For example, "M", "M&lt;T&gt;" or "M(int)".
  /// Also, "A::B()" or "string()".
  /// </summary>
  public sealed partial class NameMemberCrefSyntax : MemberCrefSyntax
  {
    private TypeSyntax name;
    private CrefParameterListSyntax parameters;

    internal NameMemberCrefSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public TypeSyntax Name 
    {
        get
        {
            return this.GetRedAtZero(ref this.name);
        }
    }

    public CrefParameterListSyntax Parameters 
    {
        get
        {
            return this.GetRed(ref this.parameters, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.name);
            case 1: return this.GetRed(ref this.parameters, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.parameters;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNameMemberCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitNameMemberCref(this);
    }

    public NameMemberCrefSyntax Update(TypeSyntax name, CrefParameterListSyntax parameters)
    {
        if (name != this.Name || parameters != this.Parameters)
        {
            var newNode = SyntaxFactory.NameMemberCref(name, parameters);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public NameMemberCrefSyntax WithName(TypeSyntax name)
    {
        return this.Update(name, this.Parameters);
    }

    public NameMemberCrefSyntax WithParameters(CrefParameterListSyntax parameters)
    {
        return this.Update(this.Name, parameters);
    }

    public NameMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items)
    {
        var parameters = this.Parameters ?? SyntaxFactory.CrefParameterList();
        return this.WithParameters(parameters.WithParameters(parameters.Parameters.AddRange(items)));
    }
  }

  /// <summary>
  /// A MemberCrefSyntax specified by a this keyword and an optional parameter list.
  /// For example, "this" or "this[int]".
  /// </summary>
  public sealed partial class IndexerMemberCrefSyntax : MemberCrefSyntax
  {
    private CrefBracketedParameterListSyntax parameters;

    internal IndexerMemberCrefSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken ThisKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IndexerMemberCrefSyntax)this.Green).thisKeyword, this.Position, 0); }
    }

    public CrefBracketedParameterListSyntax Parameters 
    {
        get
        {
            return this.GetRed(ref this.parameters, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.parameters, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.parameters;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIndexerMemberCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIndexerMemberCref(this);
    }

    public IndexerMemberCrefSyntax Update(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)
    {
        if (thisKeyword != this.ThisKeyword || parameters != this.Parameters)
        {
            var newNode = SyntaxFactory.IndexerMemberCref(thisKeyword, parameters);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public IndexerMemberCrefSyntax WithThisKeyword(SyntaxToken thisKeyword)
    {
        return this.Update(thisKeyword, this.Parameters);
    }

    public IndexerMemberCrefSyntax WithParameters(CrefBracketedParameterListSyntax parameters)
    {
        return this.Update(this.ThisKeyword, parameters);
    }

    public IndexerMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items)
    {
        var parameters = this.Parameters ?? SyntaxFactory.CrefBracketedParameterList();
        return this.WithParameters(parameters.WithParameters(parameters.Parameters.AddRange(items)));
    }
  }

  /// <summary>
  /// A MemberCrefSyntax specified by an operator keyword, an operator symbol and an optional parameter list.
  /// For example, "operator +" or "operator -[int]".
  /// NOTE: the operator must be overloadable.
  /// </summary>
  public sealed partial class OperatorMemberCrefSyntax : MemberCrefSyntax
  {
    private CrefParameterListSyntax parameters;

    internal OperatorMemberCrefSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken OperatorKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OperatorMemberCrefSyntax)this.Green).operatorKeyword, this.Position, 0); }
    }

    /// <summary>Gets the operator token.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OperatorMemberCrefSyntax)this.Green).operatorToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public CrefParameterListSyntax Parameters 
    {
        get
        {
            return this.GetRed(ref this.parameters, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.parameters, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.parameters;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOperatorMemberCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOperatorMemberCref(this);
    }

    public OperatorMemberCrefSyntax Update(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)
    {
        if (operatorKeyword != this.OperatorKeyword || operatorToken != this.OperatorToken || parameters != this.Parameters)
        {
            var newNode = SyntaxFactory.OperatorMemberCref(operatorKeyword, operatorToken, parameters);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public OperatorMemberCrefSyntax WithOperatorKeyword(SyntaxToken operatorKeyword)
    {
        return this.Update(operatorKeyword, this.OperatorToken, this.Parameters);
    }

    public OperatorMemberCrefSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(this.OperatorKeyword, operatorToken, this.Parameters);
    }

    public OperatorMemberCrefSyntax WithParameters(CrefParameterListSyntax parameters)
    {
        return this.Update(this.OperatorKeyword, this.OperatorToken, parameters);
    }

    public OperatorMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items)
    {
        var parameters = this.Parameters ?? SyntaxFactory.CrefParameterList();
        return this.WithParameters(parameters.WithParameters(parameters.Parameters.AddRange(items)));
    }
  }

  /// <summary>
  /// A MemberCrefSyntax specified by an implicit or explicit keyword, an operator keyword, a destination type, and an optional parameter list.
  /// For example, "implicit operator int" or "explicit operator MyType(int)".
  /// </summary>
  public sealed partial class ConversionOperatorMemberCrefSyntax : MemberCrefSyntax
  {
    private TypeSyntax type;
    private CrefParameterListSyntax parameters;

    internal ConversionOperatorMemberCrefSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken ImplicitOrExplicitKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConversionOperatorMemberCrefSyntax)this.Green).implicitOrExplicitKeyword, this.Position, 0); }
    }

    public SyntaxToken OperatorKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConversionOperatorMemberCrefSyntax)this.Green).operatorKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 2);
        }
    }

    public CrefParameterListSyntax Parameters 
    {
        get
        {
            return this.GetRed(ref this.parameters, 3);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.type, 2);
            case 3: return this.GetRed(ref this.parameters, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.type;
            case 3: return this.parameters;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConversionOperatorMemberCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConversionOperatorMemberCref(this);
    }

    public ConversionOperatorMemberCrefSyntax Update(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters)
    {
        if (implicitOrExplicitKeyword != this.ImplicitOrExplicitKeyword || operatorKeyword != this.OperatorKeyword || type != this.Type || parameters != this.Parameters)
        {
            var newNode = SyntaxFactory.ConversionOperatorMemberCref(implicitOrExplicitKeyword, operatorKeyword, type, parameters);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ConversionOperatorMemberCrefSyntax WithImplicitOrExplicitKeyword(SyntaxToken implicitOrExplicitKeyword)
    {
        return this.Update(implicitOrExplicitKeyword, this.OperatorKeyword, this.Type, this.Parameters);
    }

    public ConversionOperatorMemberCrefSyntax WithOperatorKeyword(SyntaxToken operatorKeyword)
    {
        return this.Update(this.ImplicitOrExplicitKeyword, operatorKeyword, this.Type, this.Parameters);
    }

    public ConversionOperatorMemberCrefSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.ImplicitOrExplicitKeyword, this.OperatorKeyword, type, this.Parameters);
    }

    public ConversionOperatorMemberCrefSyntax WithParameters(CrefParameterListSyntax parameters)
    {
        return this.Update(this.ImplicitOrExplicitKeyword, this.OperatorKeyword, this.Type, parameters);
    }

    public ConversionOperatorMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items)
    {
        var parameters = this.Parameters ?? SyntaxFactory.CrefParameterList();
        return this.WithParameters(parameters.WithParameters(parameters.Parameters.AddRange(items)));
    }
  }

  /// <summary>
  /// A list of cref parameters with surrounding punctuation.
  /// Unlike regular parameters, cref parameters do not have names.
  /// </summary>
  public abstract partial class BaseCrefParameterListSyntax : CSharpSyntaxNode
  {
    internal BaseCrefParameterListSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>Gets the parameter list.</summary>
    public abstract SeparatedSyntaxList<CrefParameterSyntax> Parameters { get; }
  }

  /// <summary>
  /// A parenthesized list of cref parameters.
  /// </summary>
  public sealed partial class CrefParameterListSyntax : BaseCrefParameterListSyntax
  {
    private SyntaxNode parameters;

    internal CrefParameterListSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the open paren token.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefParameterListSyntax)this.Green).openParenToken, this.Position, 0); }
    }

    public override SeparatedSyntaxList<CrefParameterSyntax> Parameters 
    {
        get
        {
            var red = this.GetRed(ref this.parameters, 1);
            if (red != null)
                return new SeparatedSyntaxList<CrefParameterSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<CrefParameterSyntax>);
        }
    }

    /// <summary>Gets the close paren token.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefParameterListSyntax)this.Green).closeParenToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.parameters, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.parameters;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCrefParameterList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCrefParameterList(this);
    }

    public CrefParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || parameters != this.Parameters || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.CrefParameterList(openParenToken, parameters, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CrefParameterListSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Parameters, this.CloseParenToken);
    }

    public CrefParameterListSyntax WithParameters(SeparatedSyntaxList<CrefParameterSyntax> parameters)
    {
        return this.Update(this.OpenParenToken, parameters, this.CloseParenToken);
    }

    public CrefParameterListSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Parameters, closeParenToken);
    }

    public CrefParameterListSyntax AddParameters(params CrefParameterSyntax[] items)
    {
        return this.WithParameters(this.Parameters.AddRange(items));
    }
  }

  /// <summary>
  /// A bracketed list of cref parameters.
  /// </summary>
  public sealed partial class CrefBracketedParameterListSyntax : BaseCrefParameterListSyntax
  {
    private SyntaxNode parameters;

    internal CrefBracketedParameterListSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the open bracket token.</summary>
    public SyntaxToken OpenBracketToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefBracketedParameterListSyntax)this.Green).openBracketToken, this.Position, 0); }
    }

    public override SeparatedSyntaxList<CrefParameterSyntax> Parameters 
    {
        get
        {
            var red = this.GetRed(ref this.parameters, 1);
            if (red != null)
                return new SeparatedSyntaxList<CrefParameterSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<CrefParameterSyntax>);
        }
    }

    /// <summary>Gets the close bracket token.</summary>
    public SyntaxToken CloseBracketToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefBracketedParameterListSyntax)this.Green).closeBracketToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.parameters, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.parameters;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCrefBracketedParameterList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCrefBracketedParameterList(this);
    }

    public CrefBracketedParameterListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || parameters != this.Parameters || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.CrefBracketedParameterList(openBracketToken, parameters, closeBracketToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CrefBracketedParameterListSyntax WithOpenBracketToken(SyntaxToken openBracketToken)
    {
        return this.Update(openBracketToken, this.Parameters, this.CloseBracketToken);
    }

    public CrefBracketedParameterListSyntax WithParameters(SeparatedSyntaxList<CrefParameterSyntax> parameters)
    {
        return this.Update(this.OpenBracketToken, parameters, this.CloseBracketToken);
    }

    public CrefBracketedParameterListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)
    {
        return this.Update(this.OpenBracketToken, this.Parameters, closeBracketToken);
    }

    public CrefBracketedParameterListSyntax AddParameters(params CrefParameterSyntax[] items)
    {
        return this.WithParameters(this.Parameters.AddRange(items));
    }
  }

  /// <summary>
  /// An element of a BaseCrefParameterListSyntax.
  /// Unlike a regular parameter, a cref parameter has only an optional ref or out keyword and a type -
  /// there is no name and there are no attributes or other modifiers.
  /// </summary>
  public sealed partial class CrefParameterSyntax : CSharpSyntaxNode
  {
    private TypeSyntax type;

    internal CrefParameterSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken RefOrOutKeyword 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefParameterSyntax)this.Green).refOrOutKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.Position, 0);

            return default(SyntaxToken);
        }
    }

    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.type, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCrefParameter(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCrefParameter(this);
    }

    public CrefParameterSyntax Update(SyntaxToken refOrOutKeyword, TypeSyntax type)
    {
        if (refOrOutKeyword != this.RefOrOutKeyword || type != this.Type)
        {
            var newNode = SyntaxFactory.CrefParameter(refOrOutKeyword, type);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CrefParameterSyntax WithRefOrOutKeyword(SyntaxToken refOrOutKeyword)
    {
        return this.Update(refOrOutKeyword, this.Type);
    }

    public CrefParameterSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.RefOrOutKeyword, type);
    }
  }

  public abstract partial class XmlNodeSyntax : CSharpSyntaxNode
  {
    internal XmlNodeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  public sealed partial class XmlElementSyntax : XmlNodeSyntax
  {
    private XmlElementStartTagSyntax startTag;
    private CSharpSyntaxNode content;
    private XmlElementEndTagSyntax endTag;

    internal XmlElementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public XmlElementStartTagSyntax StartTag 
    {
        get
        {
            return this.GetRedAtZero(ref this.startTag);
        }
    }

    public SyntaxList<XmlNodeSyntax> Content 
    {
        get
        {
            return new SyntaxList<XmlNodeSyntax>(this.GetRed(ref this.content, 1));
        }
    }

    public XmlElementEndTagSyntax EndTag 
    {
        get
        {
            return this.GetRed(ref this.endTag, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.startTag);
            case 1: return this.GetRed(ref this.content, 1);
            case 2: return this.GetRed(ref this.endTag, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.startTag;
            case 1: return this.content;
            case 2: return this.endTag;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlElement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlElement(this);
    }

    public XmlElementSyntax Update(XmlElementStartTagSyntax startTag, SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
    {
        if (startTag != this.StartTag || content != this.Content || endTag != this.EndTag)
        {
            var newNode = SyntaxFactory.XmlElement(startTag, content, endTag);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlElementSyntax WithStartTag(XmlElementStartTagSyntax startTag)
    {
        return this.Update(startTag, this.Content, this.EndTag);
    }

    public XmlElementSyntax WithContent(SyntaxList<XmlNodeSyntax> content)
    {
        return this.Update(this.StartTag, content, this.EndTag);
    }

    public XmlElementSyntax WithEndTag(XmlElementEndTagSyntax endTag)
    {
        return this.Update(this.StartTag, this.Content, endTag);
    }

    public XmlElementSyntax AddStartTagAttributes(params XmlAttributeSyntax[] items)
    {
        return this.WithStartTag(this.StartTag.WithAttributes(this.StartTag.Attributes.AddRange(items)));
    }

    public XmlElementSyntax AddContent(params XmlNodeSyntax[] items)
    {
        return this.WithContent(this.Content.AddRange(items));
    }
  }

  public sealed partial class XmlElementStartTagSyntax : CSharpSyntaxNode
  {
    private XmlNameSyntax name;
    private CSharpSyntaxNode attributes;

    internal XmlElementStartTagSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken LessThanToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlElementStartTagSyntax)this.Green).lessThanToken, this.Position, 0); }
    }

    public XmlNameSyntax Name 
    {
        get
        {
            return this.GetRed(ref this.name, 1);
        }
    }

    public SyntaxList<XmlAttributeSyntax> Attributes 
    {
        get
        {
            return new SyntaxList<XmlAttributeSyntax>(this.GetRed(ref this.attributes, 2));
        }
    }

    public SyntaxToken GreaterThanToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlElementStartTagSyntax)this.Green).greaterThanToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.name, 1);
            case 2: return this.GetRed(ref this.attributes, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.name;
            case 2: return this.attributes;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlElementStartTag(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlElementStartTag(this);
    }

    public XmlElementStartTagSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlElementStartTag(lessThanToken, name, attributes, greaterThanToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlElementStartTagSyntax WithLessThanToken(SyntaxToken lessThanToken)
    {
        return this.Update(lessThanToken, this.Name, this.Attributes, this.GreaterThanToken);
    }

    public XmlElementStartTagSyntax WithName(XmlNameSyntax name)
    {
        return this.Update(this.LessThanToken, name, this.Attributes, this.GreaterThanToken);
    }

    public XmlElementStartTagSyntax WithAttributes(SyntaxList<XmlAttributeSyntax> attributes)
    {
        return this.Update(this.LessThanToken, this.Name, attributes, this.GreaterThanToken);
    }

    public XmlElementStartTagSyntax WithGreaterThanToken(SyntaxToken greaterThanToken)
    {
        return this.Update(this.LessThanToken, this.Name, this.Attributes, greaterThanToken);
    }

    public XmlElementStartTagSyntax AddAttributes(params XmlAttributeSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.AddRange(items));
    }
  }

  public sealed partial class XmlElementEndTagSyntax : CSharpSyntaxNode
  {
    private XmlNameSyntax name;

    internal XmlElementEndTagSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken LessThanSlashToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlElementEndTagSyntax)this.Green).lessThanSlashToken, this.Position, 0); }
    }

    public XmlNameSyntax Name 
    {
        get
        {
            return this.GetRed(ref this.name, 1);
        }
    }

    public SyntaxToken GreaterThanToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlElementEndTagSyntax)this.Green).greaterThanToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.name, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlElementEndTag(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlElementEndTag(this);
    }

    public XmlElementEndTagSyntax Update(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
    {
        if (lessThanSlashToken != this.LessThanSlashToken || name != this.Name || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlElementEndTag(lessThanSlashToken, name, greaterThanToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlElementEndTagSyntax WithLessThanSlashToken(SyntaxToken lessThanSlashToken)
    {
        return this.Update(lessThanSlashToken, this.Name, this.GreaterThanToken);
    }

    public XmlElementEndTagSyntax WithName(XmlNameSyntax name)
    {
        return this.Update(this.LessThanSlashToken, name, this.GreaterThanToken);
    }

    public XmlElementEndTagSyntax WithGreaterThanToken(SyntaxToken greaterThanToken)
    {
        return this.Update(this.LessThanSlashToken, this.Name, greaterThanToken);
    }
  }

  public sealed partial class XmlEmptyElementSyntax : XmlNodeSyntax
  {
    private XmlNameSyntax name;
    private CSharpSyntaxNode attributes;

    internal XmlEmptyElementSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken LessThanToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlEmptyElementSyntax)this.Green).lessThanToken, this.Position, 0); }
    }

    public XmlNameSyntax Name 
    {
        get
        {
            return this.GetRed(ref this.name, 1);
        }
    }

    public SyntaxList<XmlAttributeSyntax> Attributes 
    {
        get
        {
            return new SyntaxList<XmlAttributeSyntax>(this.GetRed(ref this.attributes, 2));
        }
    }

    public SyntaxToken SlashGreaterThanToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlEmptyElementSyntax)this.Green).slashGreaterThanToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.name, 1);
            case 2: return this.GetRed(ref this.attributes, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.name;
            case 2: return this.attributes;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlEmptyElement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlEmptyElement(this);
    }

    public XmlEmptyElementSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || slashGreaterThanToken != this.SlashGreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlEmptyElement(lessThanToken, name, attributes, slashGreaterThanToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlEmptyElementSyntax WithLessThanToken(SyntaxToken lessThanToken)
    {
        return this.Update(lessThanToken, this.Name, this.Attributes, this.SlashGreaterThanToken);
    }

    public XmlEmptyElementSyntax WithName(XmlNameSyntax name)
    {
        return this.Update(this.LessThanToken, name, this.Attributes, this.SlashGreaterThanToken);
    }

    public XmlEmptyElementSyntax WithAttributes(SyntaxList<XmlAttributeSyntax> attributes)
    {
        return this.Update(this.LessThanToken, this.Name, attributes, this.SlashGreaterThanToken);
    }

    public XmlEmptyElementSyntax WithSlashGreaterThanToken(SyntaxToken slashGreaterThanToken)
    {
        return this.Update(this.LessThanToken, this.Name, this.Attributes, slashGreaterThanToken);
    }

    public XmlEmptyElementSyntax AddAttributes(params XmlAttributeSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.AddRange(items));
    }
  }

  public sealed partial class XmlNameSyntax : CSharpSyntaxNode
  {
    private XmlPrefixSyntax prefix;

    internal XmlNameSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public XmlPrefixSyntax Prefix 
    {
        get
        {
            return this.GetRedAtZero(ref this.prefix);
        }
    }

    public SyntaxToken LocalName 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNameSyntax)this.Green).localName, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.prefix);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.prefix;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlName(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlName(this);
    }

    public XmlNameSyntax Update(XmlPrefixSyntax prefix, SyntaxToken localName)
    {
        if (prefix != this.Prefix || localName != this.LocalName)
        {
            var newNode = SyntaxFactory.XmlName(prefix, localName);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlNameSyntax WithPrefix(XmlPrefixSyntax prefix)
    {
        return this.Update(prefix, this.LocalName);
    }

    public XmlNameSyntax WithLocalName(SyntaxToken localName)
    {
        return this.Update(this.Prefix, localName);
    }
  }

  public sealed partial class XmlPrefixSyntax : CSharpSyntaxNode
  {
    internal XmlPrefixSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken Prefix 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlPrefixSyntax)this.Green).prefix, this.Position, 0); }
    }

    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlPrefixSyntax)this.Green).colonToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlPrefix(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlPrefix(this);
    }

    public XmlPrefixSyntax Update(SyntaxToken prefix, SyntaxToken colonToken)
    {
        if (prefix != this.Prefix || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.XmlPrefix(prefix, colonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlPrefixSyntax WithPrefix(SyntaxToken prefix)
    {
        return this.Update(prefix, this.ColonToken);
    }

    public XmlPrefixSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.Prefix, colonToken);
    }
  }

  public abstract partial class XmlAttributeSyntax : CSharpSyntaxNode
  {
    internal XmlAttributeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    public abstract XmlNameSyntax Name { get; }

    public abstract SyntaxToken EqualsToken { get; }

    public abstract SyntaxToken StartQuoteToken { get; }

    public abstract SyntaxToken EndQuoteToken { get; }
  }

  public sealed partial class XmlTextAttributeSyntax : XmlAttributeSyntax
  {
    private XmlNameSyntax name;

    internal XmlTextAttributeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override XmlNameSyntax Name 
    {
        get
        {
            return this.GetRedAtZero(ref this.name);
        }
    }

    public override SyntaxToken EqualsToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlTextAttributeSyntax)this.Green).equalsToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken StartQuoteToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlTextAttributeSyntax)this.Green).startQuoteToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxTokenList TextTokens 
    {
        get
        {
            var slot = this.Green.GetSlot(3);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(3), this.GetChildIndex(3));

            return default(SyntaxTokenList);
        }
    }

    public override SyntaxToken EndQuoteToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlTextAttributeSyntax)this.Green).endQuoteToken, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.name);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlTextAttribute(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlTextAttribute(this);
    }

    public XmlTextAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || textTokens != this.TextTokens || endQuoteToken != this.EndQuoteToken)
        {
            var newNode = SyntaxFactory.XmlTextAttribute(name, equalsToken, startQuoteToken, textTokens, endQuoteToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlTextAttributeSyntax WithName(XmlNameSyntax name)
    {
        return this.Update(name, this.EqualsToken, this.StartQuoteToken, this.TextTokens, this.EndQuoteToken);
    }

    public XmlTextAttributeSyntax WithEqualsToken(SyntaxToken equalsToken)
    {
        return this.Update(this.Name, equalsToken, this.StartQuoteToken, this.TextTokens, this.EndQuoteToken);
    }

    public XmlTextAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken)
    {
        return this.Update(this.Name, this.EqualsToken, startQuoteToken, this.TextTokens, this.EndQuoteToken);
    }

    public XmlTextAttributeSyntax WithTextTokens(SyntaxTokenList textTokens)
    {
        return this.Update(this.Name, this.EqualsToken, this.StartQuoteToken, textTokens, this.EndQuoteToken);
    }

    public XmlTextAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken)
    {
        return this.Update(this.Name, this.EqualsToken, this.StartQuoteToken, this.TextTokens, endQuoteToken);
    }

    public XmlTextAttributeSyntax AddTextTokens(params SyntaxToken[] items)
    {
        return this.WithTextTokens(this.TextTokens.AddRange(items));
    }
  }

  public sealed partial class XmlCrefAttributeSyntax : XmlAttributeSyntax
  {
    private XmlNameSyntax name;
    private CrefSyntax cref;

    internal XmlCrefAttributeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override XmlNameSyntax Name 
    {
        get
        {
            return this.GetRedAtZero(ref this.name);
        }
    }

    public override SyntaxToken EqualsToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlCrefAttributeSyntax)this.Green).equalsToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken StartQuoteToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlCrefAttributeSyntax)this.Green).startQuoteToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public CrefSyntax Cref 
    {
        get
        {
            return this.GetRed(ref this.cref, 3);
        }
    }

    public override SyntaxToken EndQuoteToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlCrefAttributeSyntax)this.Green).endQuoteToken, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.name);
            case 3: return this.GetRed(ref this.cref, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 3: return this.cref;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlCrefAttribute(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlCrefAttribute(this);
    }

    public XmlCrefAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || cref != this.Cref || endQuoteToken != this.EndQuoteToken)
        {
            var newNode = SyntaxFactory.XmlCrefAttribute(name, equalsToken, startQuoteToken, cref, endQuoteToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlCrefAttributeSyntax WithName(XmlNameSyntax name)
    {
        return this.Update(name, this.EqualsToken, this.StartQuoteToken, this.Cref, this.EndQuoteToken);
    }

    public XmlCrefAttributeSyntax WithEqualsToken(SyntaxToken equalsToken)
    {
        return this.Update(this.Name, equalsToken, this.StartQuoteToken, this.Cref, this.EndQuoteToken);
    }

    public XmlCrefAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken)
    {
        return this.Update(this.Name, this.EqualsToken, startQuoteToken, this.Cref, this.EndQuoteToken);
    }

    public XmlCrefAttributeSyntax WithCref(CrefSyntax cref)
    {
        return this.Update(this.Name, this.EqualsToken, this.StartQuoteToken, cref, this.EndQuoteToken);
    }

    public XmlCrefAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken)
    {
        return this.Update(this.Name, this.EqualsToken, this.StartQuoteToken, this.Cref, endQuoteToken);
    }
  }

  public sealed partial class XmlNameAttributeSyntax : XmlAttributeSyntax
  {
    private XmlNameSyntax name;
    private IdentifierNameSyntax identifier;

    internal XmlNameAttributeSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override XmlNameSyntax Name 
    {
        get
        {
            return this.GetRedAtZero(ref this.name);
        }
    }

    public override SyntaxToken EqualsToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNameAttributeSyntax)this.Green).equalsToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken StartQuoteToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNameAttributeSyntax)this.Green).startQuoteToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public IdentifierNameSyntax Identifier 
    {
        get
        {
            return this.GetRed(ref this.identifier, 3);
        }
    }

    public override SyntaxToken EndQuoteToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNameAttributeSyntax)this.Green).endQuoteToken, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.name);
            case 3: return this.GetRed(ref this.identifier, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 3: return this.identifier;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlNameAttribute(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlNameAttribute(this);
    }

    public XmlNameAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || identifier != this.Identifier || endQuoteToken != this.EndQuoteToken)
        {
            var newNode = SyntaxFactory.XmlNameAttribute(name, equalsToken, startQuoteToken, identifier, endQuoteToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlNameAttributeSyntax WithName(XmlNameSyntax name)
    {
        return this.Update(name, this.EqualsToken, this.StartQuoteToken, this.Identifier, this.EndQuoteToken);
    }

    public XmlNameAttributeSyntax WithEqualsToken(SyntaxToken equalsToken)
    {
        return this.Update(this.Name, equalsToken, this.StartQuoteToken, this.Identifier, this.EndQuoteToken);
    }

    public XmlNameAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken)
    {
        return this.Update(this.Name, this.EqualsToken, startQuoteToken, this.Identifier, this.EndQuoteToken);
    }

    public XmlNameAttributeSyntax WithIdentifier(IdentifierNameSyntax identifier)
    {
        return this.Update(this.Name, this.EqualsToken, this.StartQuoteToken, identifier, this.EndQuoteToken);
    }

    public XmlNameAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken)
    {
        return this.Update(this.Name, this.EqualsToken, this.StartQuoteToken, this.Identifier, endQuoteToken);
    }
  }

  public sealed partial class XmlTextSyntax : XmlNodeSyntax
  {
    internal XmlTextSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxTokenList TextTokens 
    {
        get
        {
            var slot = this.Green.GetSlot(0);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.Position, 0);

            return default(SyntaxTokenList);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlText(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlText(this);
    }

    public XmlTextSyntax Update(SyntaxTokenList textTokens)
    {
        if (textTokens != this.TextTokens)
        {
            var newNode = SyntaxFactory.XmlText(textTokens);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlTextSyntax WithTextTokens(SyntaxTokenList textTokens)
    {
        return this.Update(textTokens);
    }

    public XmlTextSyntax AddTextTokens(params SyntaxToken[] items)
    {
        return this.WithTextTokens(this.TextTokens.AddRange(items));
    }
  }

  public sealed partial class XmlCDataSectionSyntax : XmlNodeSyntax
  {
    internal XmlCDataSectionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken StartCDataToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlCDataSectionSyntax)this.Green).startCDataToken, this.Position, 0); }
    }

    public SyntaxTokenList TextTokens 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    public SyntaxToken EndCDataToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlCDataSectionSyntax)this.Green).endCDataToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlCDataSection(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlCDataSection(this);
    }

    public XmlCDataSectionSyntax Update(SyntaxToken startCDataToken, SyntaxTokenList textTokens, SyntaxToken endCDataToken)
    {
        if (startCDataToken != this.StartCDataToken || textTokens != this.TextTokens || endCDataToken != this.EndCDataToken)
        {
            var newNode = SyntaxFactory.XmlCDataSection(startCDataToken, textTokens, endCDataToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlCDataSectionSyntax WithStartCDataToken(SyntaxToken startCDataToken)
    {
        return this.Update(startCDataToken, this.TextTokens, this.EndCDataToken);
    }

    public XmlCDataSectionSyntax WithTextTokens(SyntaxTokenList textTokens)
    {
        return this.Update(this.StartCDataToken, textTokens, this.EndCDataToken);
    }

    public XmlCDataSectionSyntax WithEndCDataToken(SyntaxToken endCDataToken)
    {
        return this.Update(this.StartCDataToken, this.TextTokens, endCDataToken);
    }

    public XmlCDataSectionSyntax AddTextTokens(params SyntaxToken[] items)
    {
        return this.WithTextTokens(this.TextTokens.AddRange(items));
    }
  }

  public sealed partial class XmlProcessingInstructionSyntax : XmlNodeSyntax
  {
    private XmlNameSyntax name;

    internal XmlProcessingInstructionSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken StartProcessingInstructionToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlProcessingInstructionSyntax)this.Green).startProcessingInstructionToken, this.Position, 0); }
    }

    public XmlNameSyntax Name 
    {
        get
        {
            return this.GetRed(ref this.name, 1);
        }
    }

    public SyntaxTokenList TextTokens 
    {
        get
        {
            var slot = this.Green.GetSlot(2);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(2), this.GetChildIndex(2));

            return default(SyntaxTokenList);
        }
    }

    public SyntaxToken EndProcessingInstructionToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlProcessingInstructionSyntax)this.Green).endProcessingInstructionToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.name, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlProcessingInstruction(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlProcessingInstruction(this);
    }

    public XmlProcessingInstructionSyntax Update(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxTokenList textTokens, SyntaxToken endProcessingInstructionToken)
    {
        if (startProcessingInstructionToken != this.StartProcessingInstructionToken || name != this.Name || textTokens != this.TextTokens || endProcessingInstructionToken != this.EndProcessingInstructionToken)
        {
            var newNode = SyntaxFactory.XmlProcessingInstruction(startProcessingInstructionToken, name, textTokens, endProcessingInstructionToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlProcessingInstructionSyntax WithStartProcessingInstructionToken(SyntaxToken startProcessingInstructionToken)
    {
        return this.Update(startProcessingInstructionToken, this.Name, this.TextTokens, this.EndProcessingInstructionToken);
    }

    public XmlProcessingInstructionSyntax WithName(XmlNameSyntax name)
    {
        return this.Update(this.StartProcessingInstructionToken, name, this.TextTokens, this.EndProcessingInstructionToken);
    }

    public XmlProcessingInstructionSyntax WithTextTokens(SyntaxTokenList textTokens)
    {
        return this.Update(this.StartProcessingInstructionToken, this.Name, textTokens, this.EndProcessingInstructionToken);
    }

    public XmlProcessingInstructionSyntax WithEndProcessingInstructionToken(SyntaxToken endProcessingInstructionToken)
    {
        return this.Update(this.StartProcessingInstructionToken, this.Name, this.TextTokens, endProcessingInstructionToken);
    }

    public XmlProcessingInstructionSyntax AddTextTokens(params SyntaxToken[] items)
    {
        return this.WithTextTokens(this.TextTokens.AddRange(items));
    }
  }

  public sealed partial class XmlCommentSyntax : XmlNodeSyntax
  {
    internal XmlCommentSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken LessThanExclamationMinusMinusToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlCommentSyntax)this.Green).lessThanExclamationMinusMinusToken, this.Position, 0); }
    }

    public SyntaxTokenList TextTokens 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    public SyntaxToken MinusMinusGreaterThanToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlCommentSyntax)this.Green).minusMinusGreaterThanToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlComment(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlComment(this);
    }

    public XmlCommentSyntax Update(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxTokenList textTokens, SyntaxToken minusMinusGreaterThanToken)
    {
        if (lessThanExclamationMinusMinusToken != this.LessThanExclamationMinusMinusToken || textTokens != this.TextTokens || minusMinusGreaterThanToken != this.MinusMinusGreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlComment(lessThanExclamationMinusMinusToken, textTokens, minusMinusGreaterThanToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlCommentSyntax WithLessThanExclamationMinusMinusToken(SyntaxToken lessThanExclamationMinusMinusToken)
    {
        return this.Update(lessThanExclamationMinusMinusToken, this.TextTokens, this.MinusMinusGreaterThanToken);
    }

    public XmlCommentSyntax WithTextTokens(SyntaxTokenList textTokens)
    {
        return this.Update(this.LessThanExclamationMinusMinusToken, textTokens, this.MinusMinusGreaterThanToken);
    }

    public XmlCommentSyntax WithMinusMinusGreaterThanToken(SyntaxToken minusMinusGreaterThanToken)
    {
        return this.Update(this.LessThanExclamationMinusMinusToken, this.TextTokens, minusMinusGreaterThanToken);
    }

    public XmlCommentSyntax AddTextTokens(params SyntaxToken[] items)
    {
        return this.WithTextTokens(this.TextTokens.AddRange(items));
    }
  }

  public abstract partial class DirectiveTriviaSyntax : StructuredTriviaSyntax
  {
    internal DirectiveTriviaSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    public abstract SyntaxToken HashToken { get; }

    public abstract SyntaxToken EndOfDirectiveToken { get; }

    public abstract bool IsActive { get; }
  }

  public abstract partial class BranchingDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal BranchingDirectiveTriviaSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    public abstract bool BranchTaken { get; }
  }

  public abstract partial class ConditionalDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax
  {
    internal ConditionalDirectiveTriviaSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    public abstract ExpressionSyntax Condition { get; }

    public abstract bool ConditionValue { get; }
  }

  public sealed partial class IfDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax
  {
    private ExpressionSyntax condition;

    internal IfDirectiveTriviaSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken IfKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfDirectiveTriviaSyntax)this.Green).ifKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override ExpressionSyntax Condition 
    {
        get
        {
            return this.GetRed(ref this.condition, 2);
        }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override bool IsActive { get { return ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfDirectiveTriviaSyntax)this.Green).IsActive; } }

    public override bool BranchTaken { get { return ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfDirectiveTriviaSyntax)this.Green).BranchTaken; } }

    public override bool ConditionValue { get { return ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfDirectiveTriviaSyntax)this.Green).ConditionValue; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.condition, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.condition;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIfDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIfDirectiveTrivia(this);
    }

    public IfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
        if (hashToken != this.HashToken || ifKeyword != this.IfKeyword || condition != this.Condition || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.IfDirectiveTrivia(hashToken, ifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public IfDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.IfKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    public IfDirectiveTriviaSyntax WithIfKeyword(SyntaxToken ifKeyword)
    {
        return this.Update(this.HashToken, ifKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    public IfDirectiveTriviaSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.HashToken, this.IfKeyword, condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    public IfDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.IfKeyword, this.Condition, endOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    public IfDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.IfKeyword, this.Condition, this.EndOfDirectiveToken, isActive, this.BranchTaken, this.ConditionValue);
    }

    public IfDirectiveTriviaSyntax WithBranchTaken(bool branchTaken)
    {
        return this.Update(this.HashToken, this.IfKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, branchTaken, this.ConditionValue);
    }

    public IfDirectiveTriviaSyntax WithConditionValue(bool conditionValue)
    {
        return this.Update(this.HashToken, this.IfKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, conditionValue);
    }
  }

  public sealed partial class ElifDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax
  {
    private ExpressionSyntax condition;

    internal ElifDirectiveTriviaSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElifDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken ElifKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElifDirectiveTriviaSyntax)this.Green).elifKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override ExpressionSyntax Condition 
    {
        get
        {
            return this.GetRed(ref this.condition, 2);
        }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElifDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override bool IsActive { get { return ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElifDirectiveTriviaSyntax)this.Green).IsActive; } }

    public override bool BranchTaken { get { return ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElifDirectiveTriviaSyntax)this.Green).BranchTaken; } }

    public override bool ConditionValue { get { return ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElifDirectiveTriviaSyntax)this.Green).ConditionValue; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.condition, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.condition;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElifDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitElifDirectiveTrivia(this);
    }

    public ElifDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
        if (hashToken != this.HashToken || elifKeyword != this.ElifKeyword || condition != this.Condition || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ElifDirectiveTrivia(hashToken, elifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ElifDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.ElifKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    public ElifDirectiveTriviaSyntax WithElifKeyword(SyntaxToken elifKeyword)
    {
        return this.Update(this.HashToken, elifKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    public ElifDirectiveTriviaSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.HashToken, this.ElifKeyword, condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    public ElifDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.ElifKeyword, this.Condition, endOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    public ElifDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.ElifKeyword, this.Condition, this.EndOfDirectiveToken, isActive, this.BranchTaken, this.ConditionValue);
    }

    public ElifDirectiveTriviaSyntax WithBranchTaken(bool branchTaken)
    {
        return this.Update(this.HashToken, this.ElifKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, branchTaken, this.ConditionValue);
    }

    public ElifDirectiveTriviaSyntax WithConditionValue(bool conditionValue)
    {
        return this.Update(this.HashToken, this.ElifKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, conditionValue);
    }
  }

  public sealed partial class ElseDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax
  {
    internal ElseDirectiveTriviaSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElseDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken ElseKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElseDirectiveTriviaSyntax)this.Green).elseKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElseDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override bool IsActive { get { return ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElseDirectiveTriviaSyntax)this.Green).IsActive; } }

    public override bool BranchTaken { get { return ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElseDirectiveTriviaSyntax)this.Green).BranchTaken; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElseDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitElseDirectiveTrivia(this);
    }

    public ElseDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
    {
        if (hashToken != this.HashToken || elseKeyword != this.ElseKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ElseDirectiveTrivia(hashToken, elseKeyword, endOfDirectiveToken, isActive, branchTaken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ElseDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.ElseKeyword, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken);
    }

    public ElseDirectiveTriviaSyntax WithElseKeyword(SyntaxToken elseKeyword)
    {
        return this.Update(this.HashToken, elseKeyword, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken);
    }

    public ElseDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.ElseKeyword, endOfDirectiveToken, this.IsActive, this.BranchTaken);
    }

    public ElseDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.ElseKeyword, this.EndOfDirectiveToken, isActive, this.BranchTaken);
    }

    public ElseDirectiveTriviaSyntax WithBranchTaken(bool branchTaken)
    {
        return this.Update(this.HashToken, this.ElseKeyword, this.EndOfDirectiveToken, this.IsActive, branchTaken);
    }
  }

  public sealed partial class EndIfDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal EndIfDirectiveTriviaSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EndIfDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken EndIfKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EndIfDirectiveTriviaSyntax)this.Green).endIfKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EndIfDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override bool IsActive { get { return ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EndIfDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEndIfDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEndIfDirectiveTrivia(this);
    }

    public EndIfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || endIfKeyword != this.EndIfKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.EndIfDirectiveTrivia(hashToken, endIfKeyword, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public EndIfDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.EndIfKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public EndIfDirectiveTriviaSyntax WithEndIfKeyword(SyntaxToken endIfKeyword)
    {
        return this.Update(this.HashToken, endIfKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public EndIfDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.EndIfKeyword, endOfDirectiveToken, this.IsActive);
    }

    public EndIfDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.EndIfKeyword, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class RegionDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal RegionDirectiveTriviaSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RegionDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken RegionKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RegionDirectiveTriviaSyntax)this.Green).regionKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RegionDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override bool IsActive { get { return ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RegionDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRegionDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitRegionDirectiveTrivia(this);
    }

    public RegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || regionKeyword != this.RegionKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.RegionDirectiveTrivia(hashToken, regionKeyword, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public RegionDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.RegionKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public RegionDirectiveTriviaSyntax WithRegionKeyword(SyntaxToken regionKeyword)
    {
        return this.Update(this.HashToken, regionKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public RegionDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.RegionKeyword, endOfDirectiveToken, this.IsActive);
    }

    public RegionDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.RegionKeyword, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class EndRegionDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal EndRegionDirectiveTriviaSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EndRegionDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken EndRegionKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EndRegionDirectiveTriviaSyntax)this.Green).endRegionKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EndRegionDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override bool IsActive { get { return ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EndRegionDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEndRegionDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEndRegionDirectiveTrivia(this);
    }

    public EndRegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || endRegionKeyword != this.EndRegionKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.EndRegionDirectiveTrivia(hashToken, endRegionKeyword, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public EndRegionDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.EndRegionKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public EndRegionDirectiveTriviaSyntax WithEndRegionKeyword(SyntaxToken endRegionKeyword)
    {
        return this.Update(this.HashToken, endRegionKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public EndRegionDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.EndRegionKeyword, endOfDirectiveToken, this.IsActive);
    }

    public EndRegionDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.EndRegionKeyword, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class ErrorDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal ErrorDirectiveTriviaSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ErrorDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken ErrorKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ErrorDirectiveTriviaSyntax)this.Green).errorKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ErrorDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override bool IsActive { get { return ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ErrorDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitErrorDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitErrorDirectiveTrivia(this);
    }

    public ErrorDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || errorKeyword != this.ErrorKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ErrorDirectiveTrivia(hashToken, errorKeyword, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ErrorDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.ErrorKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public ErrorDirectiveTriviaSyntax WithErrorKeyword(SyntaxToken errorKeyword)
    {
        return this.Update(this.HashToken, errorKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public ErrorDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.ErrorKeyword, endOfDirectiveToken, this.IsActive);
    }

    public ErrorDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.ErrorKeyword, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class WarningDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal WarningDirectiveTriviaSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.WarningDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken WarningKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.WarningDirectiveTriviaSyntax)this.Green).warningKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.WarningDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override bool IsActive { get { return ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.WarningDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitWarningDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitWarningDirectiveTrivia(this);
    }

    public WarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || warningKeyword != this.WarningKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.WarningDirectiveTrivia(hashToken, warningKeyword, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public WarningDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.WarningKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public WarningDirectiveTriviaSyntax WithWarningKeyword(SyntaxToken warningKeyword)
    {
        return this.Update(this.HashToken, warningKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public WarningDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.WarningKeyword, endOfDirectiveToken, this.IsActive);
    }

    public WarningDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.WarningKeyword, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class BadDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal BadDirectiveTriviaSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BadDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BadDirectiveTriviaSyntax)this.Green).identifier, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BadDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override bool IsActive { get { return ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BadDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBadDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBadDirectiveTrivia(this);
    }

    public BadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || identifier != this.Identifier || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.BadDirectiveTrivia(hashToken, identifier, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public BadDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.Identifier, this.EndOfDirectiveToken, this.IsActive);
    }

    public BadDirectiveTriviaSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.HashToken, identifier, this.EndOfDirectiveToken, this.IsActive);
    }

    public BadDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.Identifier, endOfDirectiveToken, this.IsActive);
    }

    public BadDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.Identifier, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class DefineDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal DefineDirectiveTriviaSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefineDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken DefineKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefineDirectiveTriviaSyntax)this.Green).defineKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken Name 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefineDirectiveTriviaSyntax)this.Green).name, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefineDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override bool IsActive { get { return ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefineDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDefineDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDefineDirectiveTrivia(this);
    }

    public DefineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || defineKeyword != this.DefineKeyword || name != this.Name || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.DefineDirectiveTrivia(hashToken, defineKeyword, name, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public DefineDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.DefineKeyword, this.Name, this.EndOfDirectiveToken, this.IsActive);
    }

    public DefineDirectiveTriviaSyntax WithDefineKeyword(SyntaxToken defineKeyword)
    {
        return this.Update(this.HashToken, defineKeyword, this.Name, this.EndOfDirectiveToken, this.IsActive);
    }

    public DefineDirectiveTriviaSyntax WithName(SyntaxToken name)
    {
        return this.Update(this.HashToken, this.DefineKeyword, name, this.EndOfDirectiveToken, this.IsActive);
    }

    public DefineDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.DefineKeyword, this.Name, endOfDirectiveToken, this.IsActive);
    }

    public DefineDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.DefineKeyword, this.Name, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class UndefDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal UndefDirectiveTriviaSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.UndefDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken UndefKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.UndefDirectiveTriviaSyntax)this.Green).undefKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken Name 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.UndefDirectiveTriviaSyntax)this.Green).name, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.UndefDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override bool IsActive { get { return ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.UndefDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitUndefDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitUndefDirectiveTrivia(this);
    }

    public UndefDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || undefKeyword != this.UndefKeyword || name != this.Name || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.UndefDirectiveTrivia(hashToken, undefKeyword, name, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public UndefDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.UndefKeyword, this.Name, this.EndOfDirectiveToken, this.IsActive);
    }

    public UndefDirectiveTriviaSyntax WithUndefKeyword(SyntaxToken undefKeyword)
    {
        return this.Update(this.HashToken, undefKeyword, this.Name, this.EndOfDirectiveToken, this.IsActive);
    }

    public UndefDirectiveTriviaSyntax WithName(SyntaxToken name)
    {
        return this.Update(this.HashToken, this.UndefKeyword, name, this.EndOfDirectiveToken, this.IsActive);
    }

    public UndefDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.UndefKeyword, this.Name, endOfDirectiveToken, this.IsActive);
    }

    public UndefDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.UndefKeyword, this.Name, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class LineDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal LineDirectiveTriviaSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LineDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken LineKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LineDirectiveTriviaSyntax)this.Green).lineKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken Line 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LineDirectiveTriviaSyntax)this.Green).line, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxToken File 
    {
        get
        {
            var slot = ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LineDirectiveTriviaSyntax)this.Green).file;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(3), this.GetChildIndex(3));

            return default(SyntaxToken);
        }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LineDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    public override bool IsActive { get { return ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LineDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLineDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLineDirectiveTrivia(this);
    }

    public LineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || lineKeyword != this.LineKeyword || line != this.Line || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.LineDirectiveTrivia(hashToken, lineKeyword, line, file, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public LineDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.LineKeyword, this.Line, this.File, this.EndOfDirectiveToken, this.IsActive);
    }

    public LineDirectiveTriviaSyntax WithLineKeyword(SyntaxToken lineKeyword)
    {
        return this.Update(this.HashToken, lineKeyword, this.Line, this.File, this.EndOfDirectiveToken, this.IsActive);
    }

    public LineDirectiveTriviaSyntax WithLine(SyntaxToken line)
    {
        return this.Update(this.HashToken, this.LineKeyword, line, this.File, this.EndOfDirectiveToken, this.IsActive);
    }

    public LineDirectiveTriviaSyntax WithFile(SyntaxToken file)
    {
        return this.Update(this.HashToken, this.LineKeyword, this.Line, file, this.EndOfDirectiveToken, this.IsActive);
    }

    public LineDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.LineKeyword, this.Line, this.File, endOfDirectiveToken, this.IsActive);
    }

    public LineDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.LineKeyword, this.Line, this.File, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class PragmaWarningDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    private SyntaxNode errorCodes;

    internal PragmaWarningDirectiveTriviaSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PragmaWarningDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken PragmaKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PragmaWarningDirectiveTriviaSyntax)this.Green).pragmaKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken WarningKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PragmaWarningDirectiveTriviaSyntax)this.Green).warningKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxToken DisableOrRestoreKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PragmaWarningDirectiveTriviaSyntax)this.Green).disableOrRestoreKeyword, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public SeparatedSyntaxList<ExpressionSyntax> ErrorCodes 
    {
        get
        {
            var red = this.GetRed(ref this.errorCodes, 4);
            if (red != null)
                return new SeparatedSyntaxList<ExpressionSyntax>(red, this.GetChildIndex(4));

            return default(SeparatedSyntaxList<ExpressionSyntax>);
        }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PragmaWarningDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    public override bool IsActive { get { return ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PragmaWarningDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 4: return this.GetRed(ref this.errorCodes, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 4: return this.errorCodes;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPragmaWarningDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPragmaWarningDirectiveTrivia(this);
    }

    public PragmaWarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || pragmaKeyword != this.PragmaKeyword || warningKeyword != this.WarningKeyword || disableOrRestoreKeyword != this.DisableOrRestoreKeyword || errorCodes != this.ErrorCodes || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.PragmaWarningDirectiveTrivia(hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public PragmaWarningDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.PragmaKeyword, this.WarningKeyword, this.DisableOrRestoreKeyword, this.ErrorCodes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaWarningDirectiveTriviaSyntax WithPragmaKeyword(SyntaxToken pragmaKeyword)
    {
        return this.Update(this.HashToken, pragmaKeyword, this.WarningKeyword, this.DisableOrRestoreKeyword, this.ErrorCodes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaWarningDirectiveTriviaSyntax WithWarningKeyword(SyntaxToken warningKeyword)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, warningKeyword, this.DisableOrRestoreKeyword, this.ErrorCodes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaWarningDirectiveTriviaSyntax WithDisableOrRestoreKeyword(SyntaxToken disableOrRestoreKeyword)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.WarningKeyword, disableOrRestoreKeyword, this.ErrorCodes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaWarningDirectiveTriviaSyntax WithErrorCodes(SeparatedSyntaxList<ExpressionSyntax> errorCodes)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.WarningKeyword, this.DisableOrRestoreKeyword, errorCodes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaWarningDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.WarningKeyword, this.DisableOrRestoreKeyword, this.ErrorCodes, endOfDirectiveToken, this.IsActive);
    }

    public PragmaWarningDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.WarningKeyword, this.DisableOrRestoreKeyword, this.ErrorCodes, this.EndOfDirectiveToken, isActive);
    }

    public PragmaWarningDirectiveTriviaSyntax AddErrorCodes(params ExpressionSyntax[] items)
    {
        return this.WithErrorCodes(this.ErrorCodes.AddRange(items));
    }
  }

  public sealed partial class PragmaChecksumDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal PragmaChecksumDirectiveTriviaSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PragmaChecksumDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken PragmaKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PragmaChecksumDirectiveTriviaSyntax)this.Green).pragmaKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken ChecksumKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PragmaChecksumDirectiveTriviaSyntax)this.Green).checksumKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxToken File 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PragmaChecksumDirectiveTriviaSyntax)this.Green).file, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public SyntaxToken Guid 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PragmaChecksumDirectiveTriviaSyntax)this.Green).guid, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    public SyntaxToken Bytes 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PragmaChecksumDirectiveTriviaSyntax)this.Green).bytes, this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PragmaChecksumDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(6), this.GetChildIndex(6)); }
    }

    public override bool IsActive { get { return ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PragmaChecksumDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPragmaChecksumDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPragmaChecksumDirectiveTrivia(this);
    }

    public PragmaChecksumDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || pragmaKeyword != this.PragmaKeyword || checksumKeyword != this.ChecksumKeyword || file != this.File || guid != this.Guid || bytes != this.Bytes || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.PragmaChecksumDirectiveTrivia(hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public PragmaChecksumDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.PragmaKeyword, this.ChecksumKeyword, this.File, this.Guid, this.Bytes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaChecksumDirectiveTriviaSyntax WithPragmaKeyword(SyntaxToken pragmaKeyword)
    {
        return this.Update(this.HashToken, pragmaKeyword, this.ChecksumKeyword, this.File, this.Guid, this.Bytes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaChecksumDirectiveTriviaSyntax WithChecksumKeyword(SyntaxToken checksumKeyword)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, checksumKeyword, this.File, this.Guid, this.Bytes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaChecksumDirectiveTriviaSyntax WithFile(SyntaxToken file)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.ChecksumKeyword, file, this.Guid, this.Bytes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaChecksumDirectiveTriviaSyntax WithGuid(SyntaxToken guid)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.ChecksumKeyword, this.File, guid, this.Bytes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaChecksumDirectiveTriviaSyntax WithBytes(SyntaxToken bytes)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.ChecksumKeyword, this.File, this.Guid, bytes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaChecksumDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.ChecksumKeyword, this.File, this.Guid, this.Bytes, endOfDirectiveToken, this.IsActive);
    }

    public PragmaChecksumDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.ChecksumKeyword, this.File, this.Guid, this.Bytes, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class ReferenceDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal ReferenceDirectiveTriviaSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ReferenceDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken ReferenceKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ReferenceDirectiveTriviaSyntax)this.Green).referenceKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken File 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ReferenceDirectiveTriviaSyntax)this.Green).file, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ReferenceDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override bool IsActive { get { return ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ReferenceDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitReferenceDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitReferenceDirectiveTrivia(this);
    }

    public ReferenceDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || referenceKeyword != this.ReferenceKeyword || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ReferenceDirectiveTrivia(hashToken, referenceKeyword, file, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ReferenceDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.ReferenceKeyword, this.File, this.EndOfDirectiveToken, this.IsActive);
    }

    public ReferenceDirectiveTriviaSyntax WithReferenceKeyword(SyntaxToken referenceKeyword)
    {
        return this.Update(this.HashToken, referenceKeyword, this.File, this.EndOfDirectiveToken, this.IsActive);
    }

    public ReferenceDirectiveTriviaSyntax WithFile(SyntaxToken file)
    {
        return this.Update(this.HashToken, this.ReferenceKeyword, file, this.EndOfDirectiveToken, this.IsActive);
    }

    public ReferenceDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.ReferenceKeyword, this.File, endOfDirectiveToken, this.IsActive);
    }

    public ReferenceDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.ReferenceKeyword, this.File, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class LoadDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal LoadDirectiveTriviaSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LoadDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken LoadKeyword 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LoadDirectiveTriviaSyntax)this.Green).loadKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken File 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LoadDirectiveTriviaSyntax)this.Green).file, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LoadDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override bool IsActive { get { return ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LoadDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLoadDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLoadDirectiveTrivia(this);
    }

    public LoadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || loadKeyword != this.LoadKeyword || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.LoadDirectiveTrivia(hashToken, loadKeyword, file, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public LoadDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.LoadKeyword, this.File, this.EndOfDirectiveToken, this.IsActive);
    }

    public LoadDirectiveTriviaSyntax WithLoadKeyword(SyntaxToken loadKeyword)
    {
        return this.Update(this.HashToken, loadKeyword, this.File, this.EndOfDirectiveToken, this.IsActive);
    }

    public LoadDirectiveTriviaSyntax WithFile(SyntaxToken file)
    {
        return this.Update(this.HashToken, this.LoadKeyword, file, this.EndOfDirectiveToken, this.IsActive);
    }

    public LoadDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.LoadKeyword, this.File, endOfDirectiveToken, this.IsActive);
    }

    public LoadDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.LoadKeyword, this.File, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class ShebangDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal ShebangDirectiveTriviaSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ShebangDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken ExclamationToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ShebangDirectiveTriviaSyntax)this.Green).exclamationToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ShebangDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override bool IsActive { get { return ((Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ShebangDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitShebangDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitShebangDirectiveTrivia(this);
    }

    public ShebangDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || exclamationToken != this.ExclamationToken || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ShebangDirectiveTrivia(hashToken, exclamationToken, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ShebangDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.ExclamationToken, this.EndOfDirectiveToken, this.IsActive);
    }

    public ShebangDirectiveTriviaSyntax WithExclamationToken(SyntaxToken exclamationToken)
    {
        return this.Update(this.HashToken, exclamationToken, this.EndOfDirectiveToken, this.IsActive);
    }

    public ShebangDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.ExclamationToken, endOfDirectiveToken, this.IsActive);
    }

    public ShebangDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.ExclamationToken, this.EndOfDirectiveToken, isActive);
    }
  }
}

namespace Microsoft.CodeAnalysis.CSharp
{
    using Microsoft.CodeAnalysis.CSharp.Syntax;


  public partial class CSharpSyntaxVisitor<TResult>
  {
    /// <summary>Called when the visitor visits a IdentifierNameSyntax node.</summary>
    public virtual TResult VisitIdentifierName(IdentifierNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QualifiedNameSyntax node.</summary>
    public virtual TResult VisitQualifiedName(QualifiedNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GenericNameSyntax node.</summary>
    public virtual TResult VisitGenericName(GenericNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeArgumentListSyntax node.</summary>
    public virtual TResult VisitTypeArgumentList(TypeArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AliasQualifiedNameSyntax node.</summary>
    public virtual TResult VisitAliasQualifiedName(AliasQualifiedNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PredefinedTypeSyntax node.</summary>
    public virtual TResult VisitPredefinedType(PredefinedTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArrayTypeSyntax node.</summary>
    public virtual TResult VisitArrayType(ArrayTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArrayRankSpecifierSyntax node.</summary>
    public virtual TResult VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PointerTypeSyntax node.</summary>
    public virtual TResult VisitPointerType(PointerTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NullableTypeSyntax node.</summary>
    public virtual TResult VisitNullableType(NullableTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TupleTypeSyntax node.</summary>
    public virtual TResult VisitTupleType(TupleTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TupleElementSyntax node.</summary>
    public virtual TResult VisitTupleElement(TupleElementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OmittedTypeArgumentSyntax node.</summary>
    public virtual TResult VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParenthesizedExpressionSyntax node.</summary>
    public virtual TResult VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TupleExpressionSyntax node.</summary>
    public virtual TResult VisitTupleExpression(TupleExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PrefixUnaryExpressionSyntax node.</summary>
    public virtual TResult VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AwaitExpressionSyntax node.</summary>
    public virtual TResult VisitAwaitExpression(AwaitExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PostfixUnaryExpressionSyntax node.</summary>
    public virtual TResult VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a MemberAccessExpressionSyntax node.</summary>
    public virtual TResult VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConditionalAccessExpressionSyntax node.</summary>
    public virtual TResult VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a MemberBindingExpressionSyntax node.</summary>
    public virtual TResult VisitMemberBindingExpression(MemberBindingExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElementBindingExpressionSyntax node.</summary>
    public virtual TResult VisitElementBindingExpression(ElementBindingExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ImplicitElementAccessSyntax node.</summary>
    public virtual TResult VisitImplicitElementAccess(ImplicitElementAccessSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BinaryExpressionSyntax node.</summary>
    public virtual TResult VisitBinaryExpression(BinaryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AssignmentExpressionSyntax node.</summary>
    public virtual TResult VisitAssignmentExpression(AssignmentExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConditionalExpressionSyntax node.</summary>
    public virtual TResult VisitConditionalExpression(ConditionalExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ThisExpressionSyntax node.</summary>
    public virtual TResult VisitThisExpression(ThisExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BaseExpressionSyntax node.</summary>
    public virtual TResult VisitBaseExpression(BaseExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OriginalExpressionSyntax node.</summary>
    public virtual TResult VisitOriginalExpression(OriginalExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LiteralExpressionSyntax node.</summary>
    public virtual TResult VisitLiteralExpression(LiteralExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a MakeRefExpressionSyntax node.</summary>
    public virtual TResult VisitMakeRefExpression(MakeRefExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RefTypeExpressionSyntax node.</summary>
    public virtual TResult VisitRefTypeExpression(RefTypeExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RefValueExpressionSyntax node.</summary>
    public virtual TResult VisitRefValueExpression(RefValueExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CheckedExpressionSyntax node.</summary>
    public virtual TResult VisitCheckedExpression(CheckedExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DefaultExpressionSyntax node.</summary>
    public virtual TResult VisitDefaultExpression(DefaultExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeOfExpressionSyntax node.</summary>
    public virtual TResult VisitTypeOfExpression(TypeOfExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SizeOfExpressionSyntax node.</summary>
    public virtual TResult VisitSizeOfExpression(SizeOfExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InvocationExpressionSyntax node.</summary>
    public virtual TResult VisitInvocationExpression(InvocationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElementAccessExpressionSyntax node.</summary>
    public virtual TResult VisitElementAccessExpression(ElementAccessExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArgumentListSyntax node.</summary>
    public virtual TResult VisitArgumentList(ArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BracketedArgumentListSyntax node.</summary>
    public virtual TResult VisitBracketedArgumentList(BracketedArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArgumentSyntax node.</summary>
    public virtual TResult VisitArgument(ArgumentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NameColonSyntax node.</summary>
    public virtual TResult VisitNameColon(NameColonSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CastExpressionSyntax node.</summary>
    public virtual TResult VisitCastExpression(CastExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AnonymousMethodExpressionSyntax node.</summary>
    public virtual TResult VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SimpleLambdaExpressionSyntax node.</summary>
    public virtual TResult VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParenthesizedLambdaExpressionSyntax node.</summary>
    public virtual TResult VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InitializerExpressionSyntax node.</summary>
    public virtual TResult VisitInitializerExpression(InitializerExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ObjectCreationExpressionSyntax node.</summary>
    public virtual TResult VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AnonymousObjectMemberDeclaratorSyntax node.</summary>
    public virtual TResult VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AnonymousObjectCreationExpressionSyntax node.</summary>
    public virtual TResult VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArrayCreationExpressionSyntax node.</summary>
    public virtual TResult VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ImplicitArrayCreationExpressionSyntax node.</summary>
    public virtual TResult VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a StackAllocArrayCreationExpressionSyntax node.</summary>
    public virtual TResult VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QueryExpressionSyntax node.</summary>
    public virtual TResult VisitQueryExpression(QueryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QueryBodySyntax node.</summary>
    public virtual TResult VisitQueryBody(QueryBodySyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FromClauseSyntax node.</summary>
    public virtual TResult VisitFromClause(FromClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LetClauseSyntax node.</summary>
    public virtual TResult VisitLetClause(LetClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a JoinClauseSyntax node.</summary>
    public virtual TResult VisitJoinClause(JoinClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a JoinIntoClauseSyntax node.</summary>
    public virtual TResult VisitJoinIntoClause(JoinIntoClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a WhereClauseSyntax node.</summary>
    public virtual TResult VisitWhereClause(WhereClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OrderByClauseSyntax node.</summary>
    public virtual TResult VisitOrderByClause(OrderByClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OrderingSyntax node.</summary>
    public virtual TResult VisitOrdering(OrderingSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SelectClauseSyntax node.</summary>
    public virtual TResult VisitSelectClause(SelectClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GroupClauseSyntax node.</summary>
    public virtual TResult VisitGroupClause(GroupClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QueryContinuationSyntax node.</summary>
    public virtual TResult VisitQueryContinuation(QueryContinuationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OmittedArraySizeExpressionSyntax node.</summary>
    public virtual TResult VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterpolatedStringExpressionSyntax node.</summary>
    public virtual TResult VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IsPatternExpressionSyntax node.</summary>
    public virtual TResult VisitIsPatternExpression(IsPatternExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a WhenClauseSyntax node.</summary>
    public virtual TResult VisitWhenClause(WhenClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DeclarationPatternSyntax node.</summary>
    public virtual TResult VisitDeclarationPattern(DeclarationPatternSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConstantPatternSyntax node.</summary>
    public virtual TResult VisitConstantPattern(ConstantPatternSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterpolatedStringTextSyntax node.</summary>
    public virtual TResult VisitInterpolatedStringText(InterpolatedStringTextSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterpolationSyntax node.</summary>
    public virtual TResult VisitInterpolation(InterpolationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterpolationAlignmentClauseSyntax node.</summary>
    public virtual TResult VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterpolationFormatClauseSyntax node.</summary>
    public virtual TResult VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GlobalStatementSyntax node.</summary>
    public virtual TResult VisitGlobalStatement(GlobalStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BlockSyntax node.</summary>
    public virtual TResult VisitBlock(BlockSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LocalFunctionStatementSyntax node.</summary>
    public virtual TResult VisitLocalFunctionStatement(LocalFunctionStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LocalDeclarationStatementSyntax node.</summary>
    public virtual TResult VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a VariableDeconstructionDeclaratorSyntax node.</summary>
    public virtual TResult VisitVariableDeconstructionDeclarator(VariableDeconstructionDeclaratorSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a VariableDeclarationSyntax node.</summary>
    public virtual TResult VisitVariableDeclaration(VariableDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a VariableDeclaratorSyntax node.</summary>
    public virtual TResult VisitVariableDeclarator(VariableDeclaratorSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EqualsValueClauseSyntax node.</summary>
    public virtual TResult VisitEqualsValueClause(EqualsValueClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ExpressionStatementSyntax node.</summary>
    public virtual TResult VisitExpressionStatement(ExpressionStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EmptyStatementSyntax node.</summary>
    public virtual TResult VisitEmptyStatement(EmptyStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LabeledStatementSyntax node.</summary>
    public virtual TResult VisitLabeledStatement(LabeledStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GotoStatementSyntax node.</summary>
    public virtual TResult VisitGotoStatement(GotoStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BreakStatementSyntax node.</summary>
    public virtual TResult VisitBreakStatement(BreakStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ContinueStatementSyntax node.</summary>
    public virtual TResult VisitContinueStatement(ContinueStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ReturnStatementSyntax node.</summary>
    public virtual TResult VisitReturnStatement(ReturnStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ThrowStatementSyntax node.</summary>
    public virtual TResult VisitThrowStatement(ThrowStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a YieldStatementSyntax node.</summary>
    public virtual TResult VisitYieldStatement(YieldStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a WhileStatementSyntax node.</summary>
    public virtual TResult VisitWhileStatement(WhileStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DoStatementSyntax node.</summary>
    public virtual TResult VisitDoStatement(DoStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ForStatementSyntax node.</summary>
    public virtual TResult VisitForStatement(ForStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ForEachStatementSyntax node.</summary>
    public virtual TResult VisitForEachStatement(ForEachStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UsingStatementSyntax node.</summary>
    public virtual TResult VisitUsingStatement(UsingStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FixedStatementSyntax node.</summary>
    public virtual TResult VisitFixedStatement(FixedStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CheckedStatementSyntax node.</summary>
    public virtual TResult VisitCheckedStatement(CheckedStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UnsafeStatementSyntax node.</summary>
    public virtual TResult VisitUnsafeStatement(UnsafeStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LockStatementSyntax node.</summary>
    public virtual TResult VisitLockStatement(LockStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IfStatementSyntax node.</summary>
    public virtual TResult VisitIfStatement(IfStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElseClauseSyntax node.</summary>
    public virtual TResult VisitElseClause(ElseClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SwitchStatementSyntax node.</summary>
    public virtual TResult VisitSwitchStatement(SwitchStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SwitchSectionSyntax node.</summary>
    public virtual TResult VisitSwitchSection(SwitchSectionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CasePatternSwitchLabelSyntax node.</summary>
    public virtual TResult VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CaseSwitchLabelSyntax node.</summary>
    public virtual TResult VisitCaseSwitchLabel(CaseSwitchLabelSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DefaultSwitchLabelSyntax node.</summary>
    public virtual TResult VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TryStatementSyntax node.</summary>
    public virtual TResult VisitTryStatement(TryStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CatchClauseSyntax node.</summary>
    public virtual TResult VisitCatchClause(CatchClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CatchDeclarationSyntax node.</summary>
    public virtual TResult VisitCatchDeclaration(CatchDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CatchFilterClauseSyntax node.</summary>
    public virtual TResult VisitCatchFilterClause(CatchFilterClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FinallyClauseSyntax node.</summary>
    public virtual TResult VisitFinallyClause(FinallyClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CompilationUnitSyntax node.</summary>
    public virtual TResult VisitCompilationUnit(CompilationUnitSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ExternAliasDirectiveSyntax node.</summary>
    public virtual TResult VisitExternAliasDirective(ExternAliasDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UsingDirectiveSyntax node.</summary>
    public virtual TResult VisitUsingDirective(UsingDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NamespaceDeclarationSyntax node.</summary>
    public virtual TResult VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeListSyntax node.</summary>
    public virtual TResult VisitAttributeList(AttributeListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeTargetSpecifierSyntax node.</summary>
    public virtual TResult VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeSyntax node.</summary>
    public virtual TResult VisitAttribute(AttributeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeArgumentListSyntax node.</summary>
    public virtual TResult VisitAttributeArgumentList(AttributeArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeArgumentSyntax node.</summary>
    public virtual TResult VisitAttributeArgument(AttributeArgumentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NameEqualsSyntax node.</summary>
    public virtual TResult VisitNameEquals(NameEqualsSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeParameterListSyntax node.</summary>
    public virtual TResult VisitTypeParameterList(TypeParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeParameterSyntax node.</summary>
    public virtual TResult VisitTypeParameter(TypeParameterSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ClassDeclarationSyntax node.</summary>
    public virtual TResult VisitClassDeclaration(ClassDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a StructDeclarationSyntax node.</summary>
    public virtual TResult VisitStructDeclaration(StructDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterfaceDeclarationSyntax node.</summary>
    public virtual TResult VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EnumDeclarationSyntax node.</summary>
    public virtual TResult VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DelegateDeclarationSyntax node.</summary>
    public virtual TResult VisitDelegateDeclaration(DelegateDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EnumMemberDeclarationSyntax node.</summary>
    public virtual TResult VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BaseListSyntax node.</summary>
    public virtual TResult VisitBaseList(BaseListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SimpleBaseTypeSyntax node.</summary>
    public virtual TResult VisitSimpleBaseType(SimpleBaseTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeParameterConstraintClauseSyntax node.</summary>
    public virtual TResult VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConstructorConstraintSyntax node.</summary>
    public virtual TResult VisitConstructorConstraint(ConstructorConstraintSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ClassOrStructConstraintSyntax node.</summary>
    public virtual TResult VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeConstraintSyntax node.</summary>
    public virtual TResult VisitTypeConstraint(TypeConstraintSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FieldDeclarationSyntax node.</summary>
    public virtual TResult VisitFieldDeclaration(FieldDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EventFieldDeclarationSyntax node.</summary>
    public virtual TResult VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ExplicitInterfaceSpecifierSyntax node.</summary>
    public virtual TResult VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a MethodDeclarationSyntax node.</summary>
    public virtual TResult VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OperatorDeclarationSyntax node.</summary>
    public virtual TResult VisitOperatorDeclaration(OperatorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConversionOperatorDeclarationSyntax node.</summary>
    public virtual TResult VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConstructorDeclarationSyntax node.</summary>
    public virtual TResult VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConstructorInitializerSyntax node.</summary>
    public virtual TResult VisitConstructorInitializer(ConstructorInitializerSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DestructorDeclarationSyntax node.</summary>
    public virtual TResult VisitDestructorDeclaration(DestructorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PropertyDeclarationSyntax node.</summary>
    public virtual TResult VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArrowExpressionClauseSyntax node.</summary>
    public virtual TResult VisitArrowExpressionClause(ArrowExpressionClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EventDeclarationSyntax node.</summary>
    public virtual TResult VisitEventDeclaration(EventDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IndexerDeclarationSyntax node.</summary>
    public virtual TResult VisitIndexerDeclaration(IndexerDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AccessorListSyntax node.</summary>
    public virtual TResult VisitAccessorList(AccessorListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AccessorDeclarationSyntax node.</summary>
    public virtual TResult VisitAccessorDeclaration(AccessorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParameterListSyntax node.</summary>
    public virtual TResult VisitParameterList(ParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BracketedParameterListSyntax node.</summary>
    public virtual TResult VisitBracketedParameterList(BracketedParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParameterSyntax node.</summary>
    public virtual TResult VisitParameter(ParameterSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IncompleteMemberSyntax node.</summary>
    public virtual TResult VisitIncompleteMember(IncompleteMemberSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SkippedTokensTriviaSyntax node.</summary>
    public virtual TResult VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DocumentationCommentTriviaSyntax node.</summary>
    public virtual TResult VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeCrefSyntax node.</summary>
    public virtual TResult VisitTypeCref(TypeCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QualifiedCrefSyntax node.</summary>
    public virtual TResult VisitQualifiedCref(QualifiedCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NameMemberCrefSyntax node.</summary>
    public virtual TResult VisitNameMemberCref(NameMemberCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IndexerMemberCrefSyntax node.</summary>
    public virtual TResult VisitIndexerMemberCref(IndexerMemberCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OperatorMemberCrefSyntax node.</summary>
    public virtual TResult VisitOperatorMemberCref(OperatorMemberCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConversionOperatorMemberCrefSyntax node.</summary>
    public virtual TResult VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CrefParameterListSyntax node.</summary>
    public virtual TResult VisitCrefParameterList(CrefParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CrefBracketedParameterListSyntax node.</summary>
    public virtual TResult VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CrefParameterSyntax node.</summary>
    public virtual TResult VisitCrefParameter(CrefParameterSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlElementSyntax node.</summary>
    public virtual TResult VisitXmlElement(XmlElementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlElementStartTagSyntax node.</summary>
    public virtual TResult VisitXmlElementStartTag(XmlElementStartTagSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlElementEndTagSyntax node.</summary>
    public virtual TResult VisitXmlElementEndTag(XmlElementEndTagSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlEmptyElementSyntax node.</summary>
    public virtual TResult VisitXmlEmptyElement(XmlEmptyElementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlNameSyntax node.</summary>
    public virtual TResult VisitXmlName(XmlNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlPrefixSyntax node.</summary>
    public virtual TResult VisitXmlPrefix(XmlPrefixSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlTextAttributeSyntax node.</summary>
    public virtual TResult VisitXmlTextAttribute(XmlTextAttributeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlCrefAttributeSyntax node.</summary>
    public virtual TResult VisitXmlCrefAttribute(XmlCrefAttributeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlNameAttributeSyntax node.</summary>
    public virtual TResult VisitXmlNameAttribute(XmlNameAttributeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlTextSyntax node.</summary>
    public virtual TResult VisitXmlText(XmlTextSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlCDataSectionSyntax node.</summary>
    public virtual TResult VisitXmlCDataSection(XmlCDataSectionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlProcessingInstructionSyntax node.</summary>
    public virtual TResult VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlCommentSyntax node.</summary>
    public virtual TResult VisitXmlComment(XmlCommentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IfDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElifDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElseDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EndIfDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RegionDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EndRegionDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ErrorDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a WarningDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BadDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DefineDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UndefDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LineDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PragmaWarningDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PragmaChecksumDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ReferenceDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LoadDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ShebangDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }
  }

  public partial class CSharpSyntaxVisitor
  {
    /// <summary>Called when the visitor visits a IdentifierNameSyntax node.</summary>
    public virtual void VisitIdentifierName(IdentifierNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QualifiedNameSyntax node.</summary>
    public virtual void VisitQualifiedName(QualifiedNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GenericNameSyntax node.</summary>
    public virtual void VisitGenericName(GenericNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeArgumentListSyntax node.</summary>
    public virtual void VisitTypeArgumentList(TypeArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AliasQualifiedNameSyntax node.</summary>
    public virtual void VisitAliasQualifiedName(AliasQualifiedNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PredefinedTypeSyntax node.</summary>
    public virtual void VisitPredefinedType(PredefinedTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArrayTypeSyntax node.</summary>
    public virtual void VisitArrayType(ArrayTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArrayRankSpecifierSyntax node.</summary>
    public virtual void VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PointerTypeSyntax node.</summary>
    public virtual void VisitPointerType(PointerTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NullableTypeSyntax node.</summary>
    public virtual void VisitNullableType(NullableTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TupleTypeSyntax node.</summary>
    public virtual void VisitTupleType(TupleTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TupleElementSyntax node.</summary>
    public virtual void VisitTupleElement(TupleElementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OmittedTypeArgumentSyntax node.</summary>
    public virtual void VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParenthesizedExpressionSyntax node.</summary>
    public virtual void VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TupleExpressionSyntax node.</summary>
    public virtual void VisitTupleExpression(TupleExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PrefixUnaryExpressionSyntax node.</summary>
    public virtual void VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AwaitExpressionSyntax node.</summary>
    public virtual void VisitAwaitExpression(AwaitExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PostfixUnaryExpressionSyntax node.</summary>
    public virtual void VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a MemberAccessExpressionSyntax node.</summary>
    public virtual void VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConditionalAccessExpressionSyntax node.</summary>
    public virtual void VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a MemberBindingExpressionSyntax node.</summary>
    public virtual void VisitMemberBindingExpression(MemberBindingExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElementBindingExpressionSyntax node.</summary>
    public virtual void VisitElementBindingExpression(ElementBindingExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ImplicitElementAccessSyntax node.</summary>
    public virtual void VisitImplicitElementAccess(ImplicitElementAccessSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BinaryExpressionSyntax node.</summary>
    public virtual void VisitBinaryExpression(BinaryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AssignmentExpressionSyntax node.</summary>
    public virtual void VisitAssignmentExpression(AssignmentExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConditionalExpressionSyntax node.</summary>
    public virtual void VisitConditionalExpression(ConditionalExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ThisExpressionSyntax node.</summary>
    public virtual void VisitThisExpression(ThisExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BaseExpressionSyntax node.</summary>
    public virtual void VisitBaseExpression(BaseExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OriginalExpressionSyntax node.</summary>
    public virtual void VisitOriginalExpression(OriginalExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LiteralExpressionSyntax node.</summary>
    public virtual void VisitLiteralExpression(LiteralExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a MakeRefExpressionSyntax node.</summary>
    public virtual void VisitMakeRefExpression(MakeRefExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RefTypeExpressionSyntax node.</summary>
    public virtual void VisitRefTypeExpression(RefTypeExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RefValueExpressionSyntax node.</summary>
    public virtual void VisitRefValueExpression(RefValueExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CheckedExpressionSyntax node.</summary>
    public virtual void VisitCheckedExpression(CheckedExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DefaultExpressionSyntax node.</summary>
    public virtual void VisitDefaultExpression(DefaultExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeOfExpressionSyntax node.</summary>
    public virtual void VisitTypeOfExpression(TypeOfExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SizeOfExpressionSyntax node.</summary>
    public virtual void VisitSizeOfExpression(SizeOfExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InvocationExpressionSyntax node.</summary>
    public virtual void VisitInvocationExpression(InvocationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElementAccessExpressionSyntax node.</summary>
    public virtual void VisitElementAccessExpression(ElementAccessExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArgumentListSyntax node.</summary>
    public virtual void VisitArgumentList(ArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BracketedArgumentListSyntax node.</summary>
    public virtual void VisitBracketedArgumentList(BracketedArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArgumentSyntax node.</summary>
    public virtual void VisitArgument(ArgumentSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NameColonSyntax node.</summary>
    public virtual void VisitNameColon(NameColonSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CastExpressionSyntax node.</summary>
    public virtual void VisitCastExpression(CastExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AnonymousMethodExpressionSyntax node.</summary>
    public virtual void VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SimpleLambdaExpressionSyntax node.</summary>
    public virtual void VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParenthesizedLambdaExpressionSyntax node.</summary>
    public virtual void VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InitializerExpressionSyntax node.</summary>
    public virtual void VisitInitializerExpression(InitializerExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ObjectCreationExpressionSyntax node.</summary>
    public virtual void VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AnonymousObjectMemberDeclaratorSyntax node.</summary>
    public virtual void VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AnonymousObjectCreationExpressionSyntax node.</summary>
    public virtual void VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArrayCreationExpressionSyntax node.</summary>
    public virtual void VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ImplicitArrayCreationExpressionSyntax node.</summary>
    public virtual void VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a StackAllocArrayCreationExpressionSyntax node.</summary>
    public virtual void VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QueryExpressionSyntax node.</summary>
    public virtual void VisitQueryExpression(QueryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QueryBodySyntax node.</summary>
    public virtual void VisitQueryBody(QueryBodySyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FromClauseSyntax node.</summary>
    public virtual void VisitFromClause(FromClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LetClauseSyntax node.</summary>
    public virtual void VisitLetClause(LetClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a JoinClauseSyntax node.</summary>
    public virtual void VisitJoinClause(JoinClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a JoinIntoClauseSyntax node.</summary>
    public virtual void VisitJoinIntoClause(JoinIntoClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a WhereClauseSyntax node.</summary>
    public virtual void VisitWhereClause(WhereClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OrderByClauseSyntax node.</summary>
    public virtual void VisitOrderByClause(OrderByClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OrderingSyntax node.</summary>
    public virtual void VisitOrdering(OrderingSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SelectClauseSyntax node.</summary>
    public virtual void VisitSelectClause(SelectClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GroupClauseSyntax node.</summary>
    public virtual void VisitGroupClause(GroupClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QueryContinuationSyntax node.</summary>
    public virtual void VisitQueryContinuation(QueryContinuationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OmittedArraySizeExpressionSyntax node.</summary>
    public virtual void VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterpolatedStringExpressionSyntax node.</summary>
    public virtual void VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IsPatternExpressionSyntax node.</summary>
    public virtual void VisitIsPatternExpression(IsPatternExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a WhenClauseSyntax node.</summary>
    public virtual void VisitWhenClause(WhenClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DeclarationPatternSyntax node.</summary>
    public virtual void VisitDeclarationPattern(DeclarationPatternSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConstantPatternSyntax node.</summary>
    public virtual void VisitConstantPattern(ConstantPatternSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterpolatedStringTextSyntax node.</summary>
    public virtual void VisitInterpolatedStringText(InterpolatedStringTextSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterpolationSyntax node.</summary>
    public virtual void VisitInterpolation(InterpolationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterpolationAlignmentClauseSyntax node.</summary>
    public virtual void VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterpolationFormatClauseSyntax node.</summary>
    public virtual void VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GlobalStatementSyntax node.</summary>
    public virtual void VisitGlobalStatement(GlobalStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BlockSyntax node.</summary>
    public virtual void VisitBlock(BlockSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LocalFunctionStatementSyntax node.</summary>
    public virtual void VisitLocalFunctionStatement(LocalFunctionStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LocalDeclarationStatementSyntax node.</summary>
    public virtual void VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a VariableDeconstructionDeclaratorSyntax node.</summary>
    public virtual void VisitVariableDeconstructionDeclarator(VariableDeconstructionDeclaratorSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a VariableDeclarationSyntax node.</summary>
    public virtual void VisitVariableDeclaration(VariableDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a VariableDeclaratorSyntax node.</summary>
    public virtual void VisitVariableDeclarator(VariableDeclaratorSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EqualsValueClauseSyntax node.</summary>
    public virtual void VisitEqualsValueClause(EqualsValueClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ExpressionStatementSyntax node.</summary>
    public virtual void VisitExpressionStatement(ExpressionStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EmptyStatementSyntax node.</summary>
    public virtual void VisitEmptyStatement(EmptyStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LabeledStatementSyntax node.</summary>
    public virtual void VisitLabeledStatement(LabeledStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GotoStatementSyntax node.</summary>
    public virtual void VisitGotoStatement(GotoStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BreakStatementSyntax node.</summary>
    public virtual void VisitBreakStatement(BreakStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ContinueStatementSyntax node.</summary>
    public virtual void VisitContinueStatement(ContinueStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ReturnStatementSyntax node.</summary>
    public virtual void VisitReturnStatement(ReturnStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ThrowStatementSyntax node.</summary>
    public virtual void VisitThrowStatement(ThrowStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a YieldStatementSyntax node.</summary>
    public virtual void VisitYieldStatement(YieldStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a WhileStatementSyntax node.</summary>
    public virtual void VisitWhileStatement(WhileStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DoStatementSyntax node.</summary>
    public virtual void VisitDoStatement(DoStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ForStatementSyntax node.</summary>
    public virtual void VisitForStatement(ForStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ForEachStatementSyntax node.</summary>
    public virtual void VisitForEachStatement(ForEachStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UsingStatementSyntax node.</summary>
    public virtual void VisitUsingStatement(UsingStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FixedStatementSyntax node.</summary>
    public virtual void VisitFixedStatement(FixedStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CheckedStatementSyntax node.</summary>
    public virtual void VisitCheckedStatement(CheckedStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UnsafeStatementSyntax node.</summary>
    public virtual void VisitUnsafeStatement(UnsafeStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LockStatementSyntax node.</summary>
    public virtual void VisitLockStatement(LockStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IfStatementSyntax node.</summary>
    public virtual void VisitIfStatement(IfStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElseClauseSyntax node.</summary>
    public virtual void VisitElseClause(ElseClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SwitchStatementSyntax node.</summary>
    public virtual void VisitSwitchStatement(SwitchStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SwitchSectionSyntax node.</summary>
    public virtual void VisitSwitchSection(SwitchSectionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CasePatternSwitchLabelSyntax node.</summary>
    public virtual void VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CaseSwitchLabelSyntax node.</summary>
    public virtual void VisitCaseSwitchLabel(CaseSwitchLabelSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DefaultSwitchLabelSyntax node.</summary>
    public virtual void VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TryStatementSyntax node.</summary>
    public virtual void VisitTryStatement(TryStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CatchClauseSyntax node.</summary>
    public virtual void VisitCatchClause(CatchClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CatchDeclarationSyntax node.</summary>
    public virtual void VisitCatchDeclaration(CatchDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CatchFilterClauseSyntax node.</summary>
    public virtual void VisitCatchFilterClause(CatchFilterClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FinallyClauseSyntax node.</summary>
    public virtual void VisitFinallyClause(FinallyClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CompilationUnitSyntax node.</summary>
    public virtual void VisitCompilationUnit(CompilationUnitSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ExternAliasDirectiveSyntax node.</summary>
    public virtual void VisitExternAliasDirective(ExternAliasDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UsingDirectiveSyntax node.</summary>
    public virtual void VisitUsingDirective(UsingDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NamespaceDeclarationSyntax node.</summary>
    public virtual void VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeListSyntax node.</summary>
    public virtual void VisitAttributeList(AttributeListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeTargetSpecifierSyntax node.</summary>
    public virtual void VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeSyntax node.</summary>
    public virtual void VisitAttribute(AttributeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeArgumentListSyntax node.</summary>
    public virtual void VisitAttributeArgumentList(AttributeArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeArgumentSyntax node.</summary>
    public virtual void VisitAttributeArgument(AttributeArgumentSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NameEqualsSyntax node.</summary>
    public virtual void VisitNameEquals(NameEqualsSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeParameterListSyntax node.</summary>
    public virtual void VisitTypeParameterList(TypeParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeParameterSyntax node.</summary>
    public virtual void VisitTypeParameter(TypeParameterSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ClassDeclarationSyntax node.</summary>
    public virtual void VisitClassDeclaration(ClassDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a StructDeclarationSyntax node.</summary>
    public virtual void VisitStructDeclaration(StructDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterfaceDeclarationSyntax node.</summary>
    public virtual void VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EnumDeclarationSyntax node.</summary>
    public virtual void VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DelegateDeclarationSyntax node.</summary>
    public virtual void VisitDelegateDeclaration(DelegateDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EnumMemberDeclarationSyntax node.</summary>
    public virtual void VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BaseListSyntax node.</summary>
    public virtual void VisitBaseList(BaseListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SimpleBaseTypeSyntax node.</summary>
    public virtual void VisitSimpleBaseType(SimpleBaseTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeParameterConstraintClauseSyntax node.</summary>
    public virtual void VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConstructorConstraintSyntax node.</summary>
    public virtual void VisitConstructorConstraint(ConstructorConstraintSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ClassOrStructConstraintSyntax node.</summary>
    public virtual void VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeConstraintSyntax node.</summary>
    public virtual void VisitTypeConstraint(TypeConstraintSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FieldDeclarationSyntax node.</summary>
    public virtual void VisitFieldDeclaration(FieldDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EventFieldDeclarationSyntax node.</summary>
    public virtual void VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ExplicitInterfaceSpecifierSyntax node.</summary>
    public virtual void VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a MethodDeclarationSyntax node.</summary>
    public virtual void VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OperatorDeclarationSyntax node.</summary>
    public virtual void VisitOperatorDeclaration(OperatorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConversionOperatorDeclarationSyntax node.</summary>
    public virtual void VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConstructorDeclarationSyntax node.</summary>
    public virtual void VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConstructorInitializerSyntax node.</summary>
    public virtual void VisitConstructorInitializer(ConstructorInitializerSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DestructorDeclarationSyntax node.</summary>
    public virtual void VisitDestructorDeclaration(DestructorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PropertyDeclarationSyntax node.</summary>
    public virtual void VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArrowExpressionClauseSyntax node.</summary>
    public virtual void VisitArrowExpressionClause(ArrowExpressionClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EventDeclarationSyntax node.</summary>
    public virtual void VisitEventDeclaration(EventDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IndexerDeclarationSyntax node.</summary>
    public virtual void VisitIndexerDeclaration(IndexerDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AccessorListSyntax node.</summary>
    public virtual void VisitAccessorList(AccessorListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AccessorDeclarationSyntax node.</summary>
    public virtual void VisitAccessorDeclaration(AccessorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParameterListSyntax node.</summary>
    public virtual void VisitParameterList(ParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BracketedParameterListSyntax node.</summary>
    public virtual void VisitBracketedParameterList(BracketedParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParameterSyntax node.</summary>
    public virtual void VisitParameter(ParameterSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IncompleteMemberSyntax node.</summary>
    public virtual void VisitIncompleteMember(IncompleteMemberSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SkippedTokensTriviaSyntax node.</summary>
    public virtual void VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DocumentationCommentTriviaSyntax node.</summary>
    public virtual void VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeCrefSyntax node.</summary>
    public virtual void VisitTypeCref(TypeCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QualifiedCrefSyntax node.</summary>
    public virtual void VisitQualifiedCref(QualifiedCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NameMemberCrefSyntax node.</summary>
    public virtual void VisitNameMemberCref(NameMemberCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IndexerMemberCrefSyntax node.</summary>
    public virtual void VisitIndexerMemberCref(IndexerMemberCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OperatorMemberCrefSyntax node.</summary>
    public virtual void VisitOperatorMemberCref(OperatorMemberCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConversionOperatorMemberCrefSyntax node.</summary>
    public virtual void VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CrefParameterListSyntax node.</summary>
    public virtual void VisitCrefParameterList(CrefParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CrefBracketedParameterListSyntax node.</summary>
    public virtual void VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CrefParameterSyntax node.</summary>
    public virtual void VisitCrefParameter(CrefParameterSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlElementSyntax node.</summary>
    public virtual void VisitXmlElement(XmlElementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlElementStartTagSyntax node.</summary>
    public virtual void VisitXmlElementStartTag(XmlElementStartTagSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlElementEndTagSyntax node.</summary>
    public virtual void VisitXmlElementEndTag(XmlElementEndTagSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlEmptyElementSyntax node.</summary>
    public virtual void VisitXmlEmptyElement(XmlEmptyElementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlNameSyntax node.</summary>
    public virtual void VisitXmlName(XmlNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlPrefixSyntax node.</summary>
    public virtual void VisitXmlPrefix(XmlPrefixSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlTextAttributeSyntax node.</summary>
    public virtual void VisitXmlTextAttribute(XmlTextAttributeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlCrefAttributeSyntax node.</summary>
    public virtual void VisitXmlCrefAttribute(XmlCrefAttributeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlNameAttributeSyntax node.</summary>
    public virtual void VisitXmlNameAttribute(XmlNameAttributeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlTextSyntax node.</summary>
    public virtual void VisitXmlText(XmlTextSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlCDataSectionSyntax node.</summary>
    public virtual void VisitXmlCDataSection(XmlCDataSectionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlProcessingInstructionSyntax node.</summary>
    public virtual void VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlCommentSyntax node.</summary>
    public virtual void VisitXmlComment(XmlCommentSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IfDirectiveTriviaSyntax node.</summary>
    public virtual void VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElifDirectiveTriviaSyntax node.</summary>
    public virtual void VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElseDirectiveTriviaSyntax node.</summary>
    public virtual void VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EndIfDirectiveTriviaSyntax node.</summary>
    public virtual void VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RegionDirectiveTriviaSyntax node.</summary>
    public virtual void VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EndRegionDirectiveTriviaSyntax node.</summary>
    public virtual void VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ErrorDirectiveTriviaSyntax node.</summary>
    public virtual void VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a WarningDirectiveTriviaSyntax node.</summary>
    public virtual void VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BadDirectiveTriviaSyntax node.</summary>
    public virtual void VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DefineDirectiveTriviaSyntax node.</summary>
    public virtual void VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UndefDirectiveTriviaSyntax node.</summary>
    public virtual void VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LineDirectiveTriviaSyntax node.</summary>
    public virtual void VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PragmaWarningDirectiveTriviaSyntax node.</summary>
    public virtual void VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PragmaChecksumDirectiveTriviaSyntax node.</summary>
    public virtual void VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ReferenceDirectiveTriviaSyntax node.</summary>
    public virtual void VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LoadDirectiveTriviaSyntax node.</summary>
    public virtual void VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ShebangDirectiveTriviaSyntax node.</summary>
    public virtual void VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }
  }

  public partial class CSharpSyntaxRewriter : CSharpSyntaxVisitor<SyntaxNode>
  {
    public override SyntaxNode VisitIdentifierName(IdentifierNameSyntax node)
    {
      var identifier = this.VisitToken(node.Identifier);
      return node.Update(identifier);
    }

    public override SyntaxNode VisitQualifiedName(QualifiedNameSyntax node)
    {
      var left = (NameSyntax)this.Visit(node.Left);
      var dotToken = this.VisitToken(node.DotToken);
      var right = (SimpleNameSyntax)this.Visit(node.Right);
      return node.Update(left, dotToken, right);
    }

    public override SyntaxNode VisitGenericName(GenericNameSyntax node)
    {
      var identifier = this.VisitToken(node.Identifier);
      var typeArgumentList = (TypeArgumentListSyntax)this.Visit(node.TypeArgumentList);
      return node.Update(identifier, typeArgumentList);
    }

    public override SyntaxNode VisitTypeArgumentList(TypeArgumentListSyntax node)
    {
      var lessThanToken = this.VisitToken(node.LessThanToken);
      var arguments = this.VisitList(node.Arguments);
      var greaterThanToken = this.VisitToken(node.GreaterThanToken);
      return node.Update(lessThanToken, arguments, greaterThanToken);
    }

    public override SyntaxNode VisitAliasQualifiedName(AliasQualifiedNameSyntax node)
    {
      var alias = (IdentifierNameSyntax)this.Visit(node.Alias);
      var colonColonToken = this.VisitToken(node.ColonColonToken);
      var name = (SimpleNameSyntax)this.Visit(node.Name);
      return node.Update(alias, colonColonToken, name);
    }

    public override SyntaxNode VisitPredefinedType(PredefinedTypeSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      return node.Update(keyword);
    }

    public override SyntaxNode VisitArrayType(ArrayTypeSyntax node)
    {
      var elementType = (TypeSyntax)this.Visit(node.ElementType);
      var rankSpecifiers = this.VisitList(node.RankSpecifiers);
      return node.Update(elementType, rankSpecifiers);
    }

    public override SyntaxNode VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
    {
      var openBracketToken = this.VisitToken(node.OpenBracketToken);
      var sizes = this.VisitList(node.Sizes);
      var closeBracketToken = this.VisitToken(node.CloseBracketToken);
      return node.Update(openBracketToken, sizes, closeBracketToken);
    }

    public override SyntaxNode VisitPointerType(PointerTypeSyntax node)
    {
      var elementType = (TypeSyntax)this.Visit(node.ElementType);
      var asteriskToken = this.VisitToken(node.AsteriskToken);
      return node.Update(elementType, asteriskToken);
    }

    public override SyntaxNode VisitNullableType(NullableTypeSyntax node)
    {
      var elementType = (TypeSyntax)this.Visit(node.ElementType);
      var questionToken = this.VisitToken(node.QuestionToken);
      return node.Update(elementType, questionToken);
    }

    public override SyntaxNode VisitTupleType(TupleTypeSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var elements = this.VisitList(node.Elements);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(openParenToken, elements, closeParenToken);
    }

    public override SyntaxNode VisitTupleElement(TupleElementSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      var name = (IdentifierNameSyntax)this.Visit(node.Name);
      return node.Update(type, name);
    }

    public override SyntaxNode VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)
    {
      var omittedTypeArgumentToken = this.VisitToken(node.OmittedTypeArgumentToken);
      return node.Update(omittedTypeArgumentToken);
    }

    public override SyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(openParenToken, expression, closeParenToken);
    }

    public override SyntaxNode VisitTupleExpression(TupleExpressionSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var arguments = this.VisitList(node.Arguments);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(openParenToken, arguments, closeParenToken);
    }

    public override SyntaxNode VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
    {
      var operatorToken = this.VisitToken(node.OperatorToken);
      var operand = (ExpressionSyntax)this.Visit(node.Operand);
      return node.Update(operatorToken, operand);
    }

    public override SyntaxNode VisitAwaitExpression(AwaitExpressionSyntax node)
    {
      var awaitKeyword = this.VisitToken(node.AwaitKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(awaitKeyword, expression);
    }

    public override SyntaxNode VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)
    {
      var operand = (ExpressionSyntax)this.Visit(node.Operand);
      var operatorToken = this.VisitToken(node.OperatorToken);
      return node.Update(operand, operatorToken);
    }

    public override SyntaxNode VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var operatorToken = this.VisitToken(node.OperatorToken);
      var name = (SimpleNameSyntax)this.Visit(node.Name);
      return node.Update(expression, operatorToken, name);
    }

    public override SyntaxNode VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var operatorToken = this.VisitToken(node.OperatorToken);
      var whenNotNull = (ExpressionSyntax)this.Visit(node.WhenNotNull);
      return node.Update(expression, operatorToken, whenNotNull);
    }

    public override SyntaxNode VisitMemberBindingExpression(MemberBindingExpressionSyntax node)
    {
      var operatorToken = this.VisitToken(node.OperatorToken);
      var name = (SimpleNameSyntax)this.Visit(node.Name);
      return node.Update(operatorToken, name);
    }

    public override SyntaxNode VisitElementBindingExpression(ElementBindingExpressionSyntax node)
    {
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(argumentList);
    }

    public override SyntaxNode VisitImplicitElementAccess(ImplicitElementAccessSyntax node)
    {
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(argumentList);
    }

    public override SyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node)
    {
      var left = (ExpressionSyntax)this.Visit(node.Left);
      var operatorToken = this.VisitToken(node.OperatorToken);
      var right = (ExpressionSyntax)this.Visit(node.Right);
      return node.Update(left, operatorToken, right);
    }

    public override SyntaxNode VisitAssignmentExpression(AssignmentExpressionSyntax node)
    {
      var left = (ExpressionSyntax)this.Visit(node.Left);
      var operatorToken = this.VisitToken(node.OperatorToken);
      var right = (ExpressionSyntax)this.Visit(node.Right);
      return node.Update(left, operatorToken, right);
    }

    public override SyntaxNode VisitConditionalExpression(ConditionalExpressionSyntax node)
    {
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var questionToken = this.VisitToken(node.QuestionToken);
      var whenTrue = (ExpressionSyntax)this.Visit(node.WhenTrue);
      var colonToken = this.VisitToken(node.ColonToken);
      var whenFalse = (ExpressionSyntax)this.Visit(node.WhenFalse);
      return node.Update(condition, questionToken, whenTrue, colonToken, whenFalse);
    }

    public override SyntaxNode VisitThisExpression(ThisExpressionSyntax node)
    {
      var token = this.VisitToken(node.Token);
      return node.Update(token);
    }

    public override SyntaxNode VisitBaseExpression(BaseExpressionSyntax node)
    {
      var token = this.VisitToken(node.Token);
      return node.Update(token);
    }

    public override SyntaxNode VisitOriginalExpression(OriginalExpressionSyntax node)
    {
      var token = this.VisitToken(node.Token);
      return node.Update(token);
    }

    public override SyntaxNode VisitLiteralExpression(LiteralExpressionSyntax node)
    {
      var token = this.VisitToken(node.Token);
      return node.Update(token);
    }

    public override SyntaxNode VisitMakeRefExpression(MakeRefExpressionSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, closeParenToken);
    }

    public override SyntaxNode VisitRefTypeExpression(RefTypeExpressionSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, closeParenToken);
    }

    public override SyntaxNode VisitRefValueExpression(RefValueExpressionSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var comma = this.VisitToken(node.Comma);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, comma, type, closeParenToken);
    }

    public override SyntaxNode VisitCheckedExpression(CheckedExpressionSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, closeParenToken);
    }

    public override SyntaxNode VisitDefaultExpression(DefaultExpressionSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(keyword, openParenToken, type, closeParenToken);
    }

    public override SyntaxNode VisitTypeOfExpression(TypeOfExpressionSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(keyword, openParenToken, type, closeParenToken);
    }

    public override SyntaxNode VisitSizeOfExpression(SizeOfExpressionSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(keyword, openParenToken, type, closeParenToken);
    }

    public override SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var argumentList = (ArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(expression, argumentList);
    }

    public override SyntaxNode VisitElementAccessExpression(ElementAccessExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(expression, argumentList);
    }

    public override SyntaxNode VisitArgumentList(ArgumentListSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var arguments = this.VisitList(node.Arguments);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(openParenToken, arguments, closeParenToken);
    }

    public override SyntaxNode VisitBracketedArgumentList(BracketedArgumentListSyntax node)
    {
      var openBracketToken = this.VisitToken(node.OpenBracketToken);
      var arguments = this.VisitList(node.Arguments);
      var closeBracketToken = this.VisitToken(node.CloseBracketToken);
      return node.Update(openBracketToken, arguments, closeBracketToken);
    }

    public override SyntaxNode VisitArgument(ArgumentSyntax node)
    {
      var nameColon = (NameColonSyntax)this.Visit(node.NameColon);
      var refOrOutKeyword = this.VisitToken(node.RefOrOutKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(nameColon, refOrOutKeyword, expression);
    }

    public override SyntaxNode VisitNameColon(NameColonSyntax node)
    {
      var name = (IdentifierNameSyntax)this.Visit(node.Name);
      var colonToken = this.VisitToken(node.ColonToken);
      return node.Update(name, colonToken);
    }

    public override SyntaxNode VisitCastExpression(CastExpressionSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(openParenToken, type, closeParenToken, expression);
    }

    public override SyntaxNode VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
    {
      var asyncKeyword = this.VisitToken(node.AsyncKeyword);
      var delegateKeyword = this.VisitToken(node.DelegateKeyword);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (CSharpSyntaxNode)this.Visit(node.Body);
      return node.Update(asyncKeyword, delegateKeyword, parameterList, body);
    }

    public override SyntaxNode VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
    {
      var asyncKeyword = this.VisitToken(node.AsyncKeyword);
      var parameter = (ParameterSyntax)this.Visit(node.Parameter);
      var arrowToken = this.VisitToken(node.ArrowToken);
      var refKeyword = this.VisitToken(node.RefKeyword);
      var body = (CSharpSyntaxNode)this.Visit(node.Body);
      return node.Update(asyncKeyword, parameter, arrowToken, refKeyword, body);
    }

    public override SyntaxNode VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
    {
      var asyncKeyword = this.VisitToken(node.AsyncKeyword);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var arrowToken = this.VisitToken(node.ArrowToken);
      var refKeyword = this.VisitToken(node.RefKeyword);
      var body = (CSharpSyntaxNode)this.Visit(node.Body);
      return node.Update(asyncKeyword, parameterList, arrowToken, refKeyword, body);
    }

    public override SyntaxNode VisitInitializerExpression(InitializerExpressionSyntax node)
    {
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var expressions = this.VisitList(node.Expressions);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      return node.Update(openBraceToken, expressions, closeBraceToken);
    }

    public override SyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
      var newKeyword = this.VisitToken(node.NewKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var argumentList = (ArgumentListSyntax)this.Visit(node.ArgumentList);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(newKeyword, type, argumentList, initializer);
    }

    public override SyntaxNode VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)
    {
      var nameEquals = (NameEqualsSyntax)this.Visit(node.NameEquals);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(nameEquals, expression);
    }

    public override SyntaxNode VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)
    {
      var newKeyword = this.VisitToken(node.NewKeyword);
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var initializers = this.VisitList(node.Initializers);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      return node.Update(newKeyword, openBraceToken, initializers, closeBraceToken);
    }

    public override SyntaxNode VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)
    {
      var newKeyword = this.VisitToken(node.NewKeyword);
      var type = (ArrayTypeSyntax)this.Visit(node.Type);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(newKeyword, type, initializer);
    }

    public override SyntaxNode VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)
    {
      var newKeyword = this.VisitToken(node.NewKeyword);
      var openBracketToken = this.VisitToken(node.OpenBracketToken);
      var commas = this.VisitList(node.Commas);
      var closeBracketToken = this.VisitToken(node.CloseBracketToken);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(newKeyword, openBracketToken, commas, closeBracketToken, initializer);
    }

    public override SyntaxNode VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)
    {
      var stackAllocKeyword = this.VisitToken(node.StackAllocKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(stackAllocKeyword, type);
    }

    public override SyntaxNode VisitQueryExpression(QueryExpressionSyntax node)
    {
      var fromClause = (FromClauseSyntax)this.Visit(node.FromClause);
      var body = (QueryBodySyntax)this.Visit(node.Body);
      return node.Update(fromClause, body);
    }

    public override SyntaxNode VisitQueryBody(QueryBodySyntax node)
    {
      var clauses = this.VisitList(node.Clauses);
      var selectOrGroup = (SelectOrGroupClauseSyntax)this.Visit(node.SelectOrGroup);
      var continuation = (QueryContinuationSyntax)this.Visit(node.Continuation);
      return node.Update(clauses, selectOrGroup, continuation);
    }

    public override SyntaxNode VisitFromClause(FromClauseSyntax node)
    {
      var fromKeyword = this.VisitToken(node.FromKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = this.VisitToken(node.Identifier);
      var inKeyword = this.VisitToken(node.InKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(fromKeyword, type, identifier, inKeyword, expression);
    }

    public override SyntaxNode VisitLetClause(LetClauseSyntax node)
    {
      var letKeyword = this.VisitToken(node.LetKeyword);
      var identifier = this.VisitToken(node.Identifier);
      var equalsToken = this.VisitToken(node.EqualsToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(letKeyword, identifier, equalsToken, expression);
    }

    public override SyntaxNode VisitJoinClause(JoinClauseSyntax node)
    {
      var joinKeyword = this.VisitToken(node.JoinKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = this.VisitToken(node.Identifier);
      var inKeyword = this.VisitToken(node.InKeyword);
      var inExpression = (ExpressionSyntax)this.Visit(node.InExpression);
      var onKeyword = this.VisitToken(node.OnKeyword);
      var leftExpression = (ExpressionSyntax)this.Visit(node.LeftExpression);
      var equalsKeyword = this.VisitToken(node.EqualsKeyword);
      var rightExpression = (ExpressionSyntax)this.Visit(node.RightExpression);
      var into = (JoinIntoClauseSyntax)this.Visit(node.Into);
      return node.Update(joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into);
    }

    public override SyntaxNode VisitJoinIntoClause(JoinIntoClauseSyntax node)
    {
      var intoKeyword = this.VisitToken(node.IntoKeyword);
      var identifier = this.VisitToken(node.Identifier);
      return node.Update(intoKeyword, identifier);
    }

    public override SyntaxNode VisitWhereClause(WhereClauseSyntax node)
    {
      var whereKeyword = this.VisitToken(node.WhereKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      return node.Update(whereKeyword, condition);
    }

    public override SyntaxNode VisitOrderByClause(OrderByClauseSyntax node)
    {
      var orderByKeyword = this.VisitToken(node.OrderByKeyword);
      var orderings = this.VisitList(node.Orderings);
      return node.Update(orderByKeyword, orderings);
    }

    public override SyntaxNode VisitOrdering(OrderingSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var ascendingOrDescendingKeyword = this.VisitToken(node.AscendingOrDescendingKeyword);
      return node.Update(expression, ascendingOrDescendingKeyword);
    }

    public override SyntaxNode VisitSelectClause(SelectClauseSyntax node)
    {
      var selectKeyword = this.VisitToken(node.SelectKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(selectKeyword, expression);
    }

    public override SyntaxNode VisitGroupClause(GroupClauseSyntax node)
    {
      var groupKeyword = this.VisitToken(node.GroupKeyword);
      var groupExpression = (ExpressionSyntax)this.Visit(node.GroupExpression);
      var byKeyword = this.VisitToken(node.ByKeyword);
      var byExpression = (ExpressionSyntax)this.Visit(node.ByExpression);
      return node.Update(groupKeyword, groupExpression, byKeyword, byExpression);
    }

    public override SyntaxNode VisitQueryContinuation(QueryContinuationSyntax node)
    {
      var intoKeyword = this.VisitToken(node.IntoKeyword);
      var identifier = this.VisitToken(node.Identifier);
      var body = (QueryBodySyntax)this.Visit(node.Body);
      return node.Update(intoKeyword, identifier, body);
    }

    public override SyntaxNode VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)
    {
      var omittedArraySizeExpressionToken = this.VisitToken(node.OmittedArraySizeExpressionToken);
      return node.Update(omittedArraySizeExpressionToken);
    }

    public override SyntaxNode VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)
    {
      var stringStartToken = this.VisitToken(node.StringStartToken);
      var contents = this.VisitList(node.Contents);
      var stringEndToken = this.VisitToken(node.StringEndToken);
      return node.Update(stringStartToken, contents, stringEndToken);
    }

    public override SyntaxNode VisitIsPatternExpression(IsPatternExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var isKeyword = this.VisitToken(node.IsKeyword);
      var pattern = (PatternSyntax)this.Visit(node.Pattern);
      return node.Update(expression, isKeyword, pattern);
    }

    public override SyntaxNode VisitWhenClause(WhenClauseSyntax node)
    {
      var whenKeyword = this.VisitToken(node.WhenKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      return node.Update(whenKeyword, condition);
    }

    public override SyntaxNode VisitDeclarationPattern(DeclarationPatternSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = this.VisitToken(node.Identifier);
      return node.Update(type, identifier);
    }

    public override SyntaxNode VisitConstantPattern(ConstantPatternSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(expression);
    }

    public override SyntaxNode VisitInterpolatedStringText(InterpolatedStringTextSyntax node)
    {
      var textToken = this.VisitToken(node.TextToken);
      return node.Update(textToken);
    }

    public override SyntaxNode VisitInterpolation(InterpolationSyntax node)
    {
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var alignmentClause = (InterpolationAlignmentClauseSyntax)this.Visit(node.AlignmentClause);
      var formatClause = (InterpolationFormatClauseSyntax)this.Visit(node.FormatClause);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      return node.Update(openBraceToken, expression, alignmentClause, formatClause, closeBraceToken);
    }

    public override SyntaxNode VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node)
    {
      var commaToken = this.VisitToken(node.CommaToken);
      var value = (ExpressionSyntax)this.Visit(node.Value);
      return node.Update(commaToken, value);
    }

    public override SyntaxNode VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node)
    {
      var colonToken = this.VisitToken(node.ColonToken);
      var formatStringToken = this.VisitToken(node.FormatStringToken);
      return node.Update(colonToken, formatStringToken);
    }

    public override SyntaxNode VisitGlobalStatement(GlobalStatementSyntax node)
    {
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(statement);
    }

    public override SyntaxNode VisitBlock(BlockSyntax node)
    {
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var statements = this.VisitList(node.Statements);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      return node.Update(openBraceToken, statements, closeBraceToken);
    }

    public override SyntaxNode VisitLocalFunctionStatement(LocalFunctionStatementSyntax node)
    {
      var modifiers = this.VisitList(node.Modifiers);
      var refKeyword = this.VisitToken(node.RefKeyword);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var identifier = this.VisitToken(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(modifiers, refKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, semicolonToken);
    }

    public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
    {
      var modifiers = this.VisitList(node.Modifiers);
      var refKeyword = this.VisitToken(node.RefKeyword);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(modifiers, refKeyword, declaration, semicolonToken);
    }

    public override SyntaxNode VisitVariableDeconstructionDeclarator(VariableDeconstructionDeclaratorSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var variables = this.VisitList(node.Variables);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var equalsToken = this.VisitToken(node.EqualsToken);
      var value = (ExpressionSyntax)this.Visit(node.Value);
      return node.Update(openParenToken, variables, closeParenToken, equalsToken, value);
    }

    public override SyntaxNode VisitVariableDeclaration(VariableDeclarationSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      var variables = this.VisitList(node.Variables);
      var deconstruction = (VariableDeconstructionDeclaratorSyntax)this.Visit(node.Deconstruction);
      return node.Update(type, variables, deconstruction);
    }

    public override SyntaxNode VisitVariableDeclarator(VariableDeclaratorSyntax node)
    {
      var identifier = this.VisitToken(node.Identifier);
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      var initializer = (EqualsValueClauseSyntax)this.Visit(node.Initializer);
      return node.Update(identifier, argumentList, initializer);
    }

    public override SyntaxNode VisitEqualsValueClause(EqualsValueClauseSyntax node)
    {
      var equalsToken = this.VisitToken(node.EqualsToken);
      var refKeyword = this.VisitToken(node.RefKeyword);
      var value = (ExpressionSyntax)this.Visit(node.Value);
      return node.Update(equalsToken, refKeyword, value);
    }

    public override SyntaxNode VisitExpressionStatement(ExpressionStatementSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(expression, semicolonToken);
    }

    public override SyntaxNode VisitEmptyStatement(EmptyStatementSyntax node)
    {
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(semicolonToken);
    }

    public override SyntaxNode VisitLabeledStatement(LabeledStatementSyntax node)
    {
      var identifier = this.VisitToken(node.Identifier);
      var colonToken = this.VisitToken(node.ColonToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(identifier, colonToken, statement);
    }

    public override SyntaxNode VisitGotoStatement(GotoStatementSyntax node)
    {
      var gotoKeyword = this.VisitToken(node.GotoKeyword);
      var caseOrDefaultKeyword = this.VisitToken(node.CaseOrDefaultKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
    }

    public override SyntaxNode VisitBreakStatement(BreakStatementSyntax node)
    {
      var breakKeyword = this.VisitToken(node.BreakKeyword);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(breakKeyword, semicolonToken);
    }

    public override SyntaxNode VisitContinueStatement(ContinueStatementSyntax node)
    {
      var continueKeyword = this.VisitToken(node.ContinueKeyword);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(continueKeyword, semicolonToken);
    }

    public override SyntaxNode VisitReturnStatement(ReturnStatementSyntax node)
    {
      var returnKeyword = this.VisitToken(node.ReturnKeyword);
      var refKeyword = this.VisitToken(node.RefKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(returnKeyword, refKeyword, expression, semicolonToken);
    }

    public override SyntaxNode VisitThrowStatement(ThrowStatementSyntax node)
    {
      var throwKeyword = this.VisitToken(node.ThrowKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(throwKeyword, expression, semicolonToken);
    }

    public override SyntaxNode VisitYieldStatement(YieldStatementSyntax node)
    {
      var yieldKeyword = this.VisitToken(node.YieldKeyword);
      var returnOrBreakKeyword = this.VisitToken(node.ReturnOrBreakKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
    }

    public override SyntaxNode VisitWhileStatement(WhileStatementSyntax node)
    {
      var whileKeyword = this.VisitToken(node.WhileKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(whileKeyword, openParenToken, condition, closeParenToken, statement);
    }

    public override SyntaxNode VisitDoStatement(DoStatementSyntax node)
    {
      var doKeyword = this.VisitToken(node.DoKeyword);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      var whileKeyword = this.VisitToken(node.WhileKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
    }

    public override SyntaxNode VisitForStatement(ForStatementSyntax node)
    {
      var forKeyword = this.VisitToken(node.ForKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var refKeyword = this.VisitToken(node.RefKeyword);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var initializers = this.VisitList(node.Initializers);
      var firstSemicolonToken = this.VisitToken(node.FirstSemicolonToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var secondSemicolonToken = this.VisitToken(node.SecondSemicolonToken);
      var incrementors = this.VisitList(node.Incrementors);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(forKeyword, openParenToken, refKeyword, declaration, initializers, firstSemicolonToken, condition, secondSemicolonToken, incrementors, closeParenToken, statement);
    }

    public override SyntaxNode VisitForEachStatement(ForEachStatementSyntax node)
    {
      var forEachKeyword = this.VisitToken(node.ForEachKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = this.VisitToken(node.Identifier);
      var deconstructionVariables = (VariableDeclarationSyntax)this.Visit(node.DeconstructionVariables);
      var inKeyword = this.VisitToken(node.InKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(forEachKeyword, openParenToken, type, identifier, deconstructionVariables, inKeyword, expression, closeParenToken, statement);
    }

    public override SyntaxNode VisitUsingStatement(UsingStatementSyntax node)
    {
      var usingKeyword = this.VisitToken(node.UsingKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(usingKeyword, openParenToken, declaration, expression, closeParenToken, statement);
    }

    public override SyntaxNode VisitFixedStatement(FixedStatementSyntax node)
    {
      var fixedKeyword = this.VisitToken(node.FixedKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(fixedKeyword, openParenToken, declaration, closeParenToken, statement);
    }

    public override SyntaxNode VisitCheckedStatement(CheckedStatementSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(keyword, block);
    }

    public override SyntaxNode VisitUnsafeStatement(UnsafeStatementSyntax node)
    {
      var unsafeKeyword = this.VisitToken(node.UnsafeKeyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(unsafeKeyword, block);
    }

    public override SyntaxNode VisitLockStatement(LockStatementSyntax node)
    {
      var lockKeyword = this.VisitToken(node.LockKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(lockKeyword, openParenToken, expression, closeParenToken, statement);
    }

    public override SyntaxNode VisitIfStatement(IfStatementSyntax node)
    {
      var ifKeyword = this.VisitToken(node.IfKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      var @else = (ElseClauseSyntax)this.Visit(node.Else);
      return node.Update(ifKeyword, openParenToken, condition, closeParenToken, statement, @else);
    }

    public override SyntaxNode VisitElseClause(ElseClauseSyntax node)
    {
      var elseKeyword = this.VisitToken(node.ElseKeyword);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(elseKeyword, statement);
    }

    public override SyntaxNode VisitSwitchStatement(SwitchStatementSyntax node)
    {
      var switchKeyword = this.VisitToken(node.SwitchKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var sections = this.VisitList(node.Sections);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      return node.Update(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections, closeBraceToken);
    }

    public override SyntaxNode VisitSwitchSection(SwitchSectionSyntax node)
    {
      var labels = this.VisitList(node.Labels);
      var statements = this.VisitList(node.Statements);
      return node.Update(labels, statements);
    }

    public override SyntaxNode VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var pattern = (PatternSyntax)this.Visit(node.Pattern);
      var whenClause = (WhenClauseSyntax)this.Visit(node.WhenClause);
      var colonToken = this.VisitToken(node.ColonToken);
      return node.Update(keyword, pattern, whenClause, colonToken);
    }

    public override SyntaxNode VisitCaseSwitchLabel(CaseSwitchLabelSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var value = (ExpressionSyntax)this.Visit(node.Value);
      var colonToken = this.VisitToken(node.ColonToken);
      return node.Update(keyword, value, colonToken);
    }

    public override SyntaxNode VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var colonToken = this.VisitToken(node.ColonToken);
      return node.Update(keyword, colonToken);
    }

    public override SyntaxNode VisitTryStatement(TryStatementSyntax node)
    {
      var tryKeyword = this.VisitToken(node.TryKeyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      var catches = this.VisitList(node.Catches);
      var @finally = (FinallyClauseSyntax)this.Visit(node.Finally);
      return node.Update(tryKeyword, block, catches, @finally);
    }

    public override SyntaxNode VisitCatchClause(CatchClauseSyntax node)
    {
      var catchKeyword = this.VisitToken(node.CatchKeyword);
      var declaration = (CatchDeclarationSyntax)this.Visit(node.Declaration);
      var filter = (CatchFilterClauseSyntax)this.Visit(node.Filter);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(catchKeyword, declaration, filter, block);
    }

    public override SyntaxNode VisitCatchDeclaration(CatchDeclarationSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = this.VisitToken(node.Identifier);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(openParenToken, type, identifier, closeParenToken);
    }

    public override SyntaxNode VisitCatchFilterClause(CatchFilterClauseSyntax node)
    {
      var whenKeyword = this.VisitToken(node.WhenKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var filterExpression = (ExpressionSyntax)this.Visit(node.FilterExpression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(whenKeyword, openParenToken, filterExpression, closeParenToken);
    }

    public override SyntaxNode VisitFinallyClause(FinallyClauseSyntax node)
    {
      var finallyKeyword = this.VisitToken(node.FinallyKeyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(finallyKeyword, block);
    }

    public override SyntaxNode VisitCompilationUnit(CompilationUnitSyntax node)
    {
      var externs = this.VisitList(node.Externs);
      var usings = this.VisitList(node.Usings);
      var attributeLists = this.VisitList(node.AttributeLists);
      var members = this.VisitList(node.Members);
      var endOfFileToken = this.VisitToken(node.EndOfFileToken);
      return node.Update(externs, usings, attributeLists, members, endOfFileToken);
    }

    public override SyntaxNode VisitExternAliasDirective(ExternAliasDirectiveSyntax node)
    {
      var externKeyword = this.VisitToken(node.ExternKeyword);
      var aliasKeyword = this.VisitToken(node.AliasKeyword);
      var identifier = this.VisitToken(node.Identifier);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(externKeyword, aliasKeyword, identifier, semicolonToken);
    }

    public override SyntaxNode VisitUsingDirective(UsingDirectiveSyntax node)
    {
      var usingKeyword = this.VisitToken(node.UsingKeyword);
      var staticKeyword = this.VisitToken(node.StaticKeyword);
      var alias = (NameEqualsSyntax)this.Visit(node.Alias);
      var name = (NameSyntax)this.Visit(node.Name);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(usingKeyword, staticKeyword, alias, name, semicolonToken);
    }

    public override SyntaxNode VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
      var namespaceKeyword = this.VisitToken(node.NamespaceKeyword);
      var name = (NameSyntax)this.Visit(node.Name);
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var externs = this.VisitList(node.Externs);
      var usings = this.VisitList(node.Usings);
      var members = this.VisitList(node.Members);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(namespaceKeyword, name, openBraceToken, externs, usings, members, closeBraceToken, semicolonToken);
    }

    public override SyntaxNode VisitAttributeList(AttributeListSyntax node)
    {
      var openBracketToken = this.VisitToken(node.OpenBracketToken);
      var target = (AttributeTargetSpecifierSyntax)this.Visit(node.Target);
      var attributes = this.VisitList(node.Attributes);
      var closeBracketToken = this.VisitToken(node.CloseBracketToken);
      return node.Update(openBracketToken, target, attributes, closeBracketToken);
    }

    public override SyntaxNode VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)
    {
      var identifier = this.VisitToken(node.Identifier);
      var colonToken = this.VisitToken(node.ColonToken);
      return node.Update(identifier, colonToken);
    }

    public override SyntaxNode VisitAttribute(AttributeSyntax node)
    {
      var name = (NameSyntax)this.Visit(node.Name);
      var argumentList = (AttributeArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(name, argumentList);
    }

    public override SyntaxNode VisitAttributeArgumentList(AttributeArgumentListSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var arguments = this.VisitList(node.Arguments);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(openParenToken, arguments, closeParenToken);
    }

    public override SyntaxNode VisitAttributeArgument(AttributeArgumentSyntax node)
    {
      var nameEquals = (NameEqualsSyntax)this.Visit(node.NameEquals);
      var nameColon = (NameColonSyntax)this.Visit(node.NameColon);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(nameEquals, nameColon, expression);
    }

    public override SyntaxNode VisitNameEquals(NameEqualsSyntax node)
    {
      var name = (IdentifierNameSyntax)this.Visit(node.Name);
      var equalsToken = this.VisitToken(node.EqualsToken);
      return node.Update(name, equalsToken);
    }

    public override SyntaxNode VisitTypeParameterList(TypeParameterListSyntax node)
    {
      var lessThanToken = this.VisitToken(node.LessThanToken);
      var parameters = this.VisitList(node.Parameters);
      var greaterThanToken = this.VisitToken(node.GreaterThanToken);
      return node.Update(lessThanToken, parameters, greaterThanToken);
    }

    public override SyntaxNode VisitTypeParameter(TypeParameterSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var varianceKeyword = this.VisitToken(node.VarianceKeyword);
      var identifier = this.VisitToken(node.Identifier);
      return node.Update(attributeLists, varianceKeyword, identifier);
    }

    public override SyntaxNode VisitClassDeclaration(ClassDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = this.VisitToken(node.Keyword);
      var identifier = this.VisitToken(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override SyntaxNode VisitStructDeclaration(StructDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = this.VisitToken(node.Keyword);
      var identifier = this.VisitToken(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override SyntaxNode VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = this.VisitToken(node.Keyword);
      var identifier = this.VisitToken(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override SyntaxNode VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var enumKeyword = this.VisitToken(node.EnumKeyword);
      var identifier = this.VisitToken(node.Identifier);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, enumKeyword, identifier, baseList, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override SyntaxNode VisitDelegateDeclaration(DelegateDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var delegateKeyword = this.VisitToken(node.DelegateKeyword);
      var refKeyword = this.VisitToken(node.RefKeyword);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var identifier = this.VisitToken(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, delegateKeyword, refKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses, semicolonToken);
    }

    public override SyntaxNode VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var identifier = this.VisitToken(node.Identifier);
      var equalsValue = (EqualsValueClauseSyntax)this.Visit(node.EqualsValue);
      return node.Update(attributeLists, identifier, equalsValue);
    }

    public override SyntaxNode VisitBaseList(BaseListSyntax node)
    {
      var colonToken = this.VisitToken(node.ColonToken);
      var types = this.VisitList(node.Types);
      return node.Update(colonToken, types);
    }

    public override SyntaxNode VisitSimpleBaseType(SimpleBaseTypeSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(type);
    }

    public override SyntaxNode VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)
    {
      var whereKeyword = this.VisitToken(node.WhereKeyword);
      var name = (IdentifierNameSyntax)this.Visit(node.Name);
      var colonToken = this.VisitToken(node.ColonToken);
      var constraints = this.VisitList(node.Constraints);
      return node.Update(whereKeyword, name, colonToken, constraints);
    }

    public override SyntaxNode VisitConstructorConstraint(ConstructorConstraintSyntax node)
    {
      var newKeyword = this.VisitToken(node.NewKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(newKeyword, openParenToken, closeParenToken);
    }

    public override SyntaxNode VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)
    {
      var classOrStructKeyword = this.VisitToken(node.ClassOrStructKeyword);
      return node.Update(classOrStructKeyword);
    }

    public override SyntaxNode VisitTypeConstraint(TypeConstraintSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(type);
    }

    public override SyntaxNode VisitFieldDeclaration(FieldDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, declaration, semicolonToken);
    }

    public override SyntaxNode VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var eventKeyword = this.VisitToken(node.EventKeyword);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, eventKeyword, declaration, semicolonToken);
    }

    public override SyntaxNode VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)
    {
      var name = (NameSyntax)this.Visit(node.Name);
      var dotToken = this.VisitToken(node.DotToken);
      return node.Update(name, dotToken);
    }

    public override SyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var refKeyword = this.VisitToken(node.RefKeyword);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var identifier = this.VisitToken(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, refKeyword, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, semicolonToken);
    }

    public override SyntaxNode VisitOperatorDeclaration(OperatorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var operatorKeyword = this.VisitToken(node.OperatorKeyword);
      var operatorToken = this.VisitToken(node.OperatorToken);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, returnType, operatorKeyword, operatorToken, parameterList, body, expressionBody, semicolonToken);
    }

    public override SyntaxNode VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var implicitOrExplicitKeyword = this.VisitToken(node.ImplicitOrExplicitKeyword);
      var operatorKeyword = this.VisitToken(node.OperatorKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, expressionBody, semicolonToken);
    }

    public override SyntaxNode VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var identifier = this.VisitToken(node.Identifier);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var initializer = (ConstructorInitializerSyntax)this.Visit(node.Initializer);
      var body = (BlockSyntax)this.Visit(node.Body);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, identifier, parameterList, initializer, body, semicolonToken);
    }

    public override SyntaxNode VisitConstructorInitializer(ConstructorInitializerSyntax node)
    {
      var colonToken = this.VisitToken(node.ColonToken);
      var thisOrBaseKeyword = this.VisitToken(node.ThisOrBaseKeyword);
      var argumentList = (ArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(colonToken, thisOrBaseKeyword, argumentList);
    }

    public override SyntaxNode VisitDestructorDeclaration(DestructorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var tildeToken = this.VisitToken(node.TildeToken);
      var identifier = this.VisitToken(node.Identifier);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (BlockSyntax)this.Visit(node.Body);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, tildeToken, identifier, parameterList, body, semicolonToken);
    }

    public override SyntaxNode VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var refKeyword = this.VisitToken(node.RefKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var identifier = this.VisitToken(node.Identifier);
      var accessorList = (AccessorListSyntax)this.Visit(node.AccessorList);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var initializer = (EqualsValueClauseSyntax)this.Visit(node.Initializer);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, refKeyword, type, explicitInterfaceSpecifier, identifier, accessorList, expressionBody, initializer, semicolonToken);
    }

    public override SyntaxNode VisitArrowExpressionClause(ArrowExpressionClauseSyntax node)
    {
      var arrowToken = this.VisitToken(node.ArrowToken);
      var refKeyword = this.VisitToken(node.RefKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(arrowToken, refKeyword, expression);
    }

    public override SyntaxNode VisitEventDeclaration(EventDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var eventKeyword = this.VisitToken(node.EventKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var identifier = this.VisitToken(node.Identifier);
      var accessorList = (AccessorListSyntax)this.Visit(node.AccessorList);
      return node.Update(attributeLists, modifiers, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList);
    }

    public override SyntaxNode VisitIndexerDeclaration(IndexerDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var refKeyword = this.VisitToken(node.RefKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var thisKeyword = this.VisitToken(node.ThisKeyword);
      var parameterList = (BracketedParameterListSyntax)this.Visit(node.ParameterList);
      var accessorList = (AccessorListSyntax)this.Visit(node.AccessorList);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, refKeyword, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList, expressionBody, semicolonToken);
    }

    public override SyntaxNode VisitAccessorList(AccessorListSyntax node)
    {
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var accessors = this.VisitList(node.Accessors);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      return node.Update(openBraceToken, accessors, closeBraceToken);
    }

    public override SyntaxNode VisitAccessorDeclaration(AccessorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = this.VisitToken(node.Keyword);
      var body = (BlockSyntax)this.Visit(node.Body);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, keyword, body, semicolonToken);
    }

    public override SyntaxNode VisitParameterList(ParameterListSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var parameters = this.VisitList(node.Parameters);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(openParenToken, parameters, closeParenToken);
    }

    public override SyntaxNode VisitBracketedParameterList(BracketedParameterListSyntax node)
    {
      var openBracketToken = this.VisitToken(node.OpenBracketToken);
      var parameters = this.VisitList(node.Parameters);
      var closeBracketToken = this.VisitToken(node.CloseBracketToken);
      return node.Update(openBracketToken, parameters, closeBracketToken);
    }

    public override SyntaxNode VisitParameter(ParameterSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = this.VisitToken(node.Identifier);
      var @default = (EqualsValueClauseSyntax)this.Visit(node.Default);
      return node.Update(attributeLists, modifiers, type, identifier, @default);
    }

    public override SyntaxNode VisitIncompleteMember(IncompleteMemberSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var refKeyword = this.VisitToken(node.RefKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(attributeLists, modifiers, refKeyword, type);
    }

    public override SyntaxNode VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
    {
      var tokens = this.VisitList(node.Tokens);
      return node.Update(tokens);
    }

    public override SyntaxNode VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node)
    {
      var content = this.VisitList(node.Content);
      var endOfComment = this.VisitToken(node.EndOfComment);
      return node.Update(content, endOfComment);
    }

    public override SyntaxNode VisitTypeCref(TypeCrefSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(type);
    }

    public override SyntaxNode VisitQualifiedCref(QualifiedCrefSyntax node)
    {
      var container = (TypeSyntax)this.Visit(node.Container);
      var dotToken = this.VisitToken(node.DotToken);
      var member = (MemberCrefSyntax)this.Visit(node.Member);
      return node.Update(container, dotToken, member);
    }

    public override SyntaxNode VisitNameMemberCref(NameMemberCrefSyntax node)
    {
      var name = (TypeSyntax)this.Visit(node.Name);
      var parameters = (CrefParameterListSyntax)this.Visit(node.Parameters);
      return node.Update(name, parameters);
    }

    public override SyntaxNode VisitIndexerMemberCref(IndexerMemberCrefSyntax node)
    {
      var thisKeyword = this.VisitToken(node.ThisKeyword);
      var parameters = (CrefBracketedParameterListSyntax)this.Visit(node.Parameters);
      return node.Update(thisKeyword, parameters);
    }

    public override SyntaxNode VisitOperatorMemberCref(OperatorMemberCrefSyntax node)
    {
      var operatorKeyword = this.VisitToken(node.OperatorKeyword);
      var operatorToken = this.VisitToken(node.OperatorToken);
      var parameters = (CrefParameterListSyntax)this.Visit(node.Parameters);
      return node.Update(operatorKeyword, operatorToken, parameters);
    }

    public override SyntaxNode VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node)
    {
      var implicitOrExplicitKeyword = this.VisitToken(node.ImplicitOrExplicitKeyword);
      var operatorKeyword = this.VisitToken(node.OperatorKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var parameters = (CrefParameterListSyntax)this.Visit(node.Parameters);
      return node.Update(implicitOrExplicitKeyword, operatorKeyword, type, parameters);
    }

    public override SyntaxNode VisitCrefParameterList(CrefParameterListSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var parameters = this.VisitList(node.Parameters);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(openParenToken, parameters, closeParenToken);
    }

    public override SyntaxNode VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node)
    {
      var openBracketToken = this.VisitToken(node.OpenBracketToken);
      var parameters = this.VisitList(node.Parameters);
      var closeBracketToken = this.VisitToken(node.CloseBracketToken);
      return node.Update(openBracketToken, parameters, closeBracketToken);
    }

    public override SyntaxNode VisitCrefParameter(CrefParameterSyntax node)
    {
      var refOrOutKeyword = this.VisitToken(node.RefOrOutKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(refOrOutKeyword, type);
    }

    public override SyntaxNode VisitXmlElement(XmlElementSyntax node)
    {
      var startTag = (XmlElementStartTagSyntax)this.Visit(node.StartTag);
      var content = this.VisitList(node.Content);
      var endTag = (XmlElementEndTagSyntax)this.Visit(node.EndTag);
      return node.Update(startTag, content, endTag);
    }

    public override SyntaxNode VisitXmlElementStartTag(XmlElementStartTagSyntax node)
    {
      var lessThanToken = this.VisitToken(node.LessThanToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var attributes = this.VisitList(node.Attributes);
      var greaterThanToken = this.VisitToken(node.GreaterThanToken);
      return node.Update(lessThanToken, name, attributes, greaterThanToken);
    }

    public override SyntaxNode VisitXmlElementEndTag(XmlElementEndTagSyntax node)
    {
      var lessThanSlashToken = this.VisitToken(node.LessThanSlashToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var greaterThanToken = this.VisitToken(node.GreaterThanToken);
      return node.Update(lessThanSlashToken, name, greaterThanToken);
    }

    public override SyntaxNode VisitXmlEmptyElement(XmlEmptyElementSyntax node)
    {
      var lessThanToken = this.VisitToken(node.LessThanToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var attributes = this.VisitList(node.Attributes);
      var slashGreaterThanToken = this.VisitToken(node.SlashGreaterThanToken);
      return node.Update(lessThanToken, name, attributes, slashGreaterThanToken);
    }

    public override SyntaxNode VisitXmlName(XmlNameSyntax node)
    {
      var prefix = (XmlPrefixSyntax)this.Visit(node.Prefix);
      var localName = this.VisitToken(node.LocalName);
      return node.Update(prefix, localName);
    }

    public override SyntaxNode VisitXmlPrefix(XmlPrefixSyntax node)
    {
      var prefix = this.VisitToken(node.Prefix);
      var colonToken = this.VisitToken(node.ColonToken);
      return node.Update(prefix, colonToken);
    }

    public override SyntaxNode VisitXmlTextAttribute(XmlTextAttributeSyntax node)
    {
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var equalsToken = this.VisitToken(node.EqualsToken);
      var startQuoteToken = this.VisitToken(node.StartQuoteToken);
      var textTokens = this.VisitList(node.TextTokens);
      var endQuoteToken = this.VisitToken(node.EndQuoteToken);
      return node.Update(name, equalsToken, startQuoteToken, textTokens, endQuoteToken);
    }

    public override SyntaxNode VisitXmlCrefAttribute(XmlCrefAttributeSyntax node)
    {
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var equalsToken = this.VisitToken(node.EqualsToken);
      var startQuoteToken = this.VisitToken(node.StartQuoteToken);
      var cref = (CrefSyntax)this.Visit(node.Cref);
      var endQuoteToken = this.VisitToken(node.EndQuoteToken);
      return node.Update(name, equalsToken, startQuoteToken, cref, endQuoteToken);
    }

    public override SyntaxNode VisitXmlNameAttribute(XmlNameAttributeSyntax node)
    {
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var equalsToken = this.VisitToken(node.EqualsToken);
      var startQuoteToken = this.VisitToken(node.StartQuoteToken);
      var identifier = (IdentifierNameSyntax)this.Visit(node.Identifier);
      var endQuoteToken = this.VisitToken(node.EndQuoteToken);
      return node.Update(name, equalsToken, startQuoteToken, identifier, endQuoteToken);
    }

    public override SyntaxNode VisitXmlText(XmlTextSyntax node)
    {
      var textTokens = this.VisitList(node.TextTokens);
      return node.Update(textTokens);
    }

    public override SyntaxNode VisitXmlCDataSection(XmlCDataSectionSyntax node)
    {
      var startCDataToken = this.VisitToken(node.StartCDataToken);
      var textTokens = this.VisitList(node.TextTokens);
      var endCDataToken = this.VisitToken(node.EndCDataToken);
      return node.Update(startCDataToken, textTokens, endCDataToken);
    }

    public override SyntaxNode VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
    {
      var startProcessingInstructionToken = this.VisitToken(node.StartProcessingInstructionToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var textTokens = this.VisitList(node.TextTokens);
      var endProcessingInstructionToken = this.VisitToken(node.EndProcessingInstructionToken);
      return node.Update(startProcessingInstructionToken, name, textTokens, endProcessingInstructionToken);
    }

    public override SyntaxNode VisitXmlComment(XmlCommentSyntax node)
    {
      var lessThanExclamationMinusMinusToken = this.VisitToken(node.LessThanExclamationMinusMinusToken);
      var textTokens = this.VisitList(node.TextTokens);
      var minusMinusGreaterThanToken = this.VisitToken(node.MinusMinusGreaterThanToken);
      return node.Update(lessThanExclamationMinusMinusToken, textTokens, minusMinusGreaterThanToken);
    }

    public override SyntaxNode VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var ifKeyword = this.VisitToken(node.IfKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, ifKeyword, condition, endOfDirectiveToken, node.IsActive, node.BranchTaken, node.ConditionValue);
    }

    public override SyntaxNode VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var elifKeyword = this.VisitToken(node.ElifKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, elifKeyword, condition, endOfDirectiveToken, node.IsActive, node.BranchTaken, node.ConditionValue);
    }

    public override SyntaxNode VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var elseKeyword = this.VisitToken(node.ElseKeyword);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, elseKeyword, endOfDirectiveToken, node.IsActive, node.BranchTaken);
    }

    public override SyntaxNode VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var endIfKeyword = this.VisitToken(node.EndIfKeyword);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, endIfKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var regionKeyword = this.VisitToken(node.RegionKeyword);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, regionKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var endRegionKeyword = this.VisitToken(node.EndRegionKeyword);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, endRegionKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var errorKeyword = this.VisitToken(node.ErrorKeyword);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, errorKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var warningKeyword = this.VisitToken(node.WarningKeyword);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, warningKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var identifier = this.VisitToken(node.Identifier);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, identifier, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var defineKeyword = this.VisitToken(node.DefineKeyword);
      var name = this.VisitToken(node.Name);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, defineKeyword, name, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var undefKeyword = this.VisitToken(node.UndefKeyword);
      var name = this.VisitToken(node.Name);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, undefKeyword, name, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var lineKeyword = this.VisitToken(node.LineKeyword);
      var line = this.VisitToken(node.Line);
      var file = this.VisitToken(node.File);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, lineKeyword, line, file, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var pragmaKeyword = this.VisitToken(node.PragmaKeyword);
      var warningKeyword = this.VisitToken(node.WarningKeyword);
      var disableOrRestoreKeyword = this.VisitToken(node.DisableOrRestoreKeyword);
      var errorCodes = this.VisitList(node.ErrorCodes);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var pragmaKeyword = this.VisitToken(node.PragmaKeyword);
      var checksumKeyword = this.VisitToken(node.ChecksumKeyword);
      var file = this.VisitToken(node.File);
      var guid = this.VisitToken(node.Guid);
      var bytes = this.VisitToken(node.Bytes);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var referenceKeyword = this.VisitToken(node.ReferenceKeyword);
      var file = this.VisitToken(node.File);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, referenceKeyword, file, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var loadKeyword = this.VisitToken(node.LoadKeyword);
      var file = this.VisitToken(node.File);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, loadKeyword, file, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var exclamationToken = this.VisitToken(node.ExclamationToken);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, exclamationToken, endOfDirectiveToken, node.IsActive);
    }
  }

  public static partial class SyntaxFactory
  {
    /// <summary>Creates a new IdentifierNameSyntax instance.</summary>
    public static IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
    {
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.GlobalKeyword:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      return (IdentifierNameSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.IdentifierName((Syntax.InternalSyntax.SyntaxToken)identifier.Node).CreateRed();
    }

    /// <summary>Creates a new QualifiedNameSyntax instance.</summary>
    public static QualifiedNameSyntax QualifiedName(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
    {
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      switch (dotToken.Kind())
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("dotToken");
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
      return (QualifiedNameSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.QualifiedName(left == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameSyntax)left.Green, (Syntax.InternalSyntax.SyntaxToken)dotToken.Node, right == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleNameSyntax)right.Green).CreateRed();
    }

    /// <summary>Creates a new QualifiedNameSyntax instance.</summary>
    public static QualifiedNameSyntax QualifiedName(NameSyntax left, SimpleNameSyntax right)
    {
      return SyntaxFactory.QualifiedName(left, SyntaxFactory.Token(SyntaxKind.DotToken), right);
    }

    /// <summary>Creates a new GenericNameSyntax instance.</summary>
    public static GenericNameSyntax GenericName(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
    {
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (typeArgumentList == null)
        throw new ArgumentNullException(nameof(typeArgumentList));
      return (GenericNameSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.GenericName((Syntax.InternalSyntax.SyntaxToken)identifier.Node, typeArgumentList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeArgumentListSyntax)typeArgumentList.Green).CreateRed();
    }

    /// <summary>Creates a new GenericNameSyntax instance.</summary>
    public static GenericNameSyntax GenericName(SyntaxToken identifier)
    {
      return SyntaxFactory.GenericName(identifier, SyntaxFactory.TypeArgumentList());
    }

    /// <summary>Creates a new GenericNameSyntax instance.</summary>
    public static GenericNameSyntax GenericName(string identifier)
    {
      return SyntaxFactory.GenericName(SyntaxFactory.Identifier(identifier), SyntaxFactory.TypeArgumentList());
    }

    /// <summary>Creates a new TypeArgumentListSyntax instance.</summary>
    public static TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
    {
      switch (lessThanToken.Kind())
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      switch (greaterThanToken.Kind())
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
      return (TypeArgumentListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.TypeArgumentList((Syntax.InternalSyntax.SyntaxToken)lessThanToken.Node, arguments.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax>(), (Syntax.InternalSyntax.SyntaxToken)greaterThanToken.Node).CreateRed();
    }

    /// <summary>Creates a new TypeArgumentListSyntax instance.</summary>
    public static TypeArgumentListSyntax TypeArgumentList(SeparatedSyntaxList<TypeSyntax> arguments = default(SeparatedSyntaxList<TypeSyntax>))
    {
      return SyntaxFactory.TypeArgumentList(SyntaxFactory.Token(SyntaxKind.LessThanToken), arguments, SyntaxFactory.Token(SyntaxKind.GreaterThanToken));
    }

    /// <summary>Creates a new AliasQualifiedNameSyntax instance.</summary>
    public static AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
    {
      if (alias == null)
        throw new ArgumentNullException(nameof(alias));
      switch (colonColonToken.Kind())
      {
        case SyntaxKind.ColonColonToken:
          break;
        default:
          throw new ArgumentException("colonColonToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      return (AliasQualifiedNameSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AliasQualifiedName(alias == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IdentifierNameSyntax)alias.Green, (Syntax.InternalSyntax.SyntaxToken)colonColonToken.Node, name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleNameSyntax)name.Green).CreateRed();
    }

    /// <summary>Creates a new AliasQualifiedNameSyntax instance.</summary>
    public static AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SimpleNameSyntax name)
    {
      return SyntaxFactory.AliasQualifiedName(alias, SyntaxFactory.Token(SyntaxKind.ColonColonToken), name);
    }

    /// <summary>Creates a new AliasQualifiedNameSyntax instance.</summary>
    public static AliasQualifiedNameSyntax AliasQualifiedName(string alias, SimpleNameSyntax name)
    {
      return SyntaxFactory.AliasQualifiedName(SyntaxFactory.IdentifierName(alias), SyntaxFactory.Token(SyntaxKind.ColonColonToken), name);
    }

    /// <summary>Creates a new PredefinedTypeSyntax instance.</summary>
    public static PredefinedTypeSyntax PredefinedType(SyntaxToken keyword)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.BoolKeyword:
        case SyntaxKind.ByteKeyword:
        case SyntaxKind.SByteKeyword:
        case SyntaxKind.IntKeyword:
        case SyntaxKind.UIntKeyword:
        case SyntaxKind.ShortKeyword:
        case SyntaxKind.UShortKeyword:
        case SyntaxKind.LongKeyword:
        case SyntaxKind.ULongKeyword:
        case SyntaxKind.FloatKeyword:
        case SyntaxKind.DoubleKeyword:
        case SyntaxKind.DecimalKeyword:
        case SyntaxKind.StringKeyword:
        case SyntaxKind.CharKeyword:
        case SyntaxKind.ObjectKeyword:
        case SyntaxKind.VoidKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      return (PredefinedTypeSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.PredefinedType((Syntax.InternalSyntax.SyntaxToken)keyword.Node).CreateRed();
    }

    /// <summary>Creates a new ArrayTypeSyntax instance.</summary>
    public static ArrayTypeSyntax ArrayType(TypeSyntax elementType, SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
    {
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
      return (ArrayTypeSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ArrayType(elementType == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)elementType.Green, rankSpecifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayRankSpecifierSyntax>()).CreateRed();
    }

    /// <summary>Creates a new ArrayTypeSyntax instance.</summary>
    public static ArrayTypeSyntax ArrayType(TypeSyntax elementType)
    {
      return SyntaxFactory.ArrayType(elementType, default(SyntaxList<ArrayRankSpecifierSyntax>));
    }

    /// <summary>Creates a new ArrayRankSpecifierSyntax instance.</summary>
    public static ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openBracketToken, SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken)
    {
      switch (openBracketToken.Kind())
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      switch (closeBracketToken.Kind())
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
      return (ArrayRankSpecifierSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ArrayRankSpecifier((Syntax.InternalSyntax.SyntaxToken)openBracketToken.Node, sizes.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBracketToken.Node).CreateRed();
    }

    /// <summary>Creates a new ArrayRankSpecifierSyntax instance.</summary>
    public static ArrayRankSpecifierSyntax ArrayRankSpecifier(SeparatedSyntaxList<ExpressionSyntax> sizes = default(SeparatedSyntaxList<ExpressionSyntax>))
    {
      return SyntaxFactory.ArrayRankSpecifier(SyntaxFactory.Token(SyntaxKind.OpenBracketToken), sizes, SyntaxFactory.Token(SyntaxKind.CloseBracketToken));
    }

    /// <summary>Creates a new PointerTypeSyntax instance.</summary>
    public static PointerTypeSyntax PointerType(TypeSyntax elementType, SyntaxToken asteriskToken)
    {
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
      switch (asteriskToken.Kind())
      {
        case SyntaxKind.AsteriskToken:
          break;
        default:
          throw new ArgumentException("asteriskToken");
      }
      return (PointerTypeSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.PointerType(elementType == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)elementType.Green, (Syntax.InternalSyntax.SyntaxToken)asteriskToken.Node).CreateRed();
    }

    /// <summary>Creates a new PointerTypeSyntax instance.</summary>
    public static PointerTypeSyntax PointerType(TypeSyntax elementType)
    {
      return SyntaxFactory.PointerType(elementType, SyntaxFactory.Token(SyntaxKind.AsteriskToken));
    }

    /// <summary>Creates a new NullableTypeSyntax instance.</summary>
    public static NullableTypeSyntax NullableType(TypeSyntax elementType, SyntaxToken questionToken)
    {
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
      switch (questionToken.Kind())
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException("questionToken");
      }
      return (NullableTypeSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.NullableType(elementType == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)elementType.Green, (Syntax.InternalSyntax.SyntaxToken)questionToken.Node).CreateRed();
    }

    /// <summary>Creates a new NullableTypeSyntax instance.</summary>
    public static NullableTypeSyntax NullableType(TypeSyntax elementType)
    {
      return SyntaxFactory.NullableType(elementType, SyntaxFactory.Token(SyntaxKind.QuestionToken));
    }

    /// <summary>Creates a new TupleTypeSyntax instance.</summary>
    public static TupleTypeSyntax TupleType(SyntaxToken openParenToken, SeparatedSyntaxList<TupleElementSyntax> elements, SyntaxToken closeParenToken)
    {
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (TupleTypeSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.TupleType((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, elements.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TupleElementSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }

    /// <summary>Creates a new TupleTypeSyntax instance.</summary>
    public static TupleTypeSyntax TupleType(SeparatedSyntaxList<TupleElementSyntax> elements = default(SeparatedSyntaxList<TupleElementSyntax>))
    {
      return SyntaxFactory.TupleType(SyntaxFactory.Token(SyntaxKind.OpenParenToken), elements, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new TupleElementSyntax instance.</summary>
    public static TupleElementSyntax TupleElement(TypeSyntax type, IdentifierNameSyntax name)
    {
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      return (TupleElementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.TupleElement(type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IdentifierNameSyntax)name.Green).CreateRed();
    }

    /// <summary>Creates a new TupleElementSyntax instance.</summary>
    public static TupleElementSyntax TupleElement(TypeSyntax type)
    {
      return SyntaxFactory.TupleElement(type, default(IdentifierNameSyntax));
    }

    /// <summary>Creates a new OmittedTypeArgumentSyntax instance.</summary>
    public static OmittedTypeArgumentSyntax OmittedTypeArgument(SyntaxToken omittedTypeArgumentToken)
    {
      switch (omittedTypeArgumentToken.Kind())
      {
        case SyntaxKind.OmittedTypeArgumentToken:
          break;
        default:
          throw new ArgumentException("omittedTypeArgumentToken");
      }
      return (OmittedTypeArgumentSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.OmittedTypeArgument((Syntax.InternalSyntax.SyntaxToken)omittedTypeArgumentToken.Node).CreateRed();
    }

    /// <summary>Creates a new OmittedTypeArgumentSyntax instance.</summary>
    public static OmittedTypeArgumentSyntax OmittedTypeArgument()
    {
      return SyntaxFactory.OmittedTypeArgument(SyntaxFactory.Token(SyntaxKind.OmittedTypeArgumentToken));
    }

    /// <summary>Creates a new ParenthesizedExpressionSyntax instance.</summary>
    public static ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (ParenthesizedExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ParenthesizedExpression((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }

    /// <summary>Creates a new ParenthesizedExpressionSyntax instance.</summary>
    public static ParenthesizedExpressionSyntax ParenthesizedExpression(ExpressionSyntax expression)
    {
      return SyntaxFactory.ParenthesizedExpression(SyntaxFactory.Token(SyntaxKind.OpenParenToken), expression, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new TupleExpressionSyntax instance.</summary>
    public static TupleExpressionSyntax TupleExpression(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (TupleExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.TupleExpression((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, arguments.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }

    /// <summary>Creates a new TupleExpressionSyntax instance.</summary>
    public static TupleExpressionSyntax TupleExpression(SeparatedSyntaxList<ArgumentSyntax> arguments = default(SeparatedSyntaxList<ArgumentSyntax>))
    {
      return SyntaxFactory.TupleExpression(SyntaxFactory.Token(SyntaxKind.OpenParenToken), arguments, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new PrefixUnaryExpressionSyntax instance.</summary>
    public static PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
    {
      switch (kind)
      {
        case SyntaxKind.UnaryPlusExpression:
        case SyntaxKind.UnaryMinusExpression:
        case SyntaxKind.BitwiseNotExpression:
        case SyntaxKind.LogicalNotExpression:
        case SyntaxKind.PreIncrementExpression:
        case SyntaxKind.PreDecrementExpression:
        case SyntaxKind.AddressOfExpression:
        case SyntaxKind.PointerIndirectionExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
      switch (operatorToken.Kind())
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.AsteriskToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (operand == null)
        throw new ArgumentNullException(nameof(operand));
      return (PrefixUnaryExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.PrefixUnaryExpression(kind, (Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, operand == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)operand.Green).CreateRed();
    }

    /// <summary>Creates a new PrefixUnaryExpressionSyntax instance.</summary>
    public static PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand)
    {
      return SyntaxFactory.PrefixUnaryExpression(kind, SyntaxFactory.Token(GetPrefixUnaryExpressionOperatorTokenKind(kind)), operand);
    }

    private static SyntaxKind GetPrefixUnaryExpressionOperatorTokenKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.UnaryPlusExpression:
          return SyntaxKind.PlusToken;
        case SyntaxKind.UnaryMinusExpression:
          return SyntaxKind.MinusToken;
        case SyntaxKind.BitwiseNotExpression:
          return SyntaxKind.TildeToken;
        case SyntaxKind.LogicalNotExpression:
          return SyntaxKind.ExclamationToken;
        case SyntaxKind.PreIncrementExpression:
          return SyntaxKind.PlusPlusToken;
        case SyntaxKind.PreDecrementExpression:
          return SyntaxKind.MinusMinusToken;
        case SyntaxKind.AddressOfExpression:
          return SyntaxKind.AmpersandToken;
        case SyntaxKind.PointerIndirectionExpression:
          return SyntaxKind.AsteriskToken;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new AwaitExpressionSyntax instance.</summary>
    public static AwaitExpressionSyntax AwaitExpression(SyntaxToken awaitKeyword, ExpressionSyntax expression)
    {
      switch (awaitKeyword.Kind())
      {
        case SyntaxKind.AwaitKeyword:
          break;
        default:
          throw new ArgumentException("awaitKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      return (AwaitExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AwaitExpression((Syntax.InternalSyntax.SyntaxToken)awaitKeyword.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
    }

    /// <summary>Creates a new AwaitExpressionSyntax instance.</summary>
    public static AwaitExpressionSyntax AwaitExpression(ExpressionSyntax expression)
    {
      return SyntaxFactory.AwaitExpression(SyntaxFactory.Token(SyntaxKind.AwaitKeyword), expression);
    }

    /// <summary>Creates a new PostfixUnaryExpressionSyntax instance.</summary>
    public static PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken)
    {
      switch (kind)
      {
        case SyntaxKind.PostIncrementExpression:
        case SyntaxKind.PostDecrementExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
      if (operand == null)
        throw new ArgumentNullException(nameof(operand));
      switch (operatorToken.Kind())
      {
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      return (PostfixUnaryExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.PostfixUnaryExpression(kind, operand == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)operand.Green, (Syntax.InternalSyntax.SyntaxToken)operatorToken.Node).CreateRed();
    }

    /// <summary>Creates a new PostfixUnaryExpressionSyntax instance.</summary>
    public static PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand)
    {
      return SyntaxFactory.PostfixUnaryExpression(kind, operand, SyntaxFactory.Token(GetPostfixUnaryExpressionOperatorTokenKind(kind)));
    }

    private static SyntaxKind GetPostfixUnaryExpressionOperatorTokenKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.PostIncrementExpression:
          return SyntaxKind.PlusPlusToken;
        case SyntaxKind.PostDecrementExpression:
          return SyntaxKind.MinusMinusToken;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new MemberAccessExpressionSyntax instance.</summary>
    public static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
    {
      switch (kind)
      {
        case SyntaxKind.SimpleMemberAccessExpression:
        case SyntaxKind.PointerMemberAccessExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (operatorToken.Kind())
      {
        case SyntaxKind.DotToken:
        case SyntaxKind.MinusGreaterThanToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      return (MemberAccessExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.MemberAccessExpression(kind, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleNameSyntax)name.Green).CreateRed();
    }

    /// <summary>Creates a new MemberAccessExpressionSyntax instance.</summary>
    public static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SimpleNameSyntax name)
    {
      return SyntaxFactory.MemberAccessExpression(kind, expression, SyntaxFactory.Token(GetMemberAccessExpressionOperatorTokenKind(kind)), name);
    }

    private static SyntaxKind GetMemberAccessExpressionOperatorTokenKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.SimpleMemberAccessExpression:
          return SyntaxKind.DotToken;
        case SyntaxKind.PointerMemberAccessExpression:
          return SyntaxKind.MinusGreaterThanToken;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new ConditionalAccessExpressionSyntax instance.</summary>
    public static ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)
    {
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (operatorToken.Kind())
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (whenNotNull == null)
        throw new ArgumentNullException(nameof(whenNotNull));
      return (ConditionalAccessExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ConditionalAccessExpression(expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, whenNotNull == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)whenNotNull.Green).CreateRed();
    }

    /// <summary>Creates a new ConditionalAccessExpressionSyntax instance.</summary>
    public static ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, ExpressionSyntax whenNotNull)
    {
      return SyntaxFactory.ConditionalAccessExpression(expression, SyntaxFactory.Token(SyntaxKind.QuestionToken), whenNotNull);
    }

    /// <summary>Creates a new MemberBindingExpressionSyntax instance.</summary>
    public static MemberBindingExpressionSyntax MemberBindingExpression(SyntaxToken operatorToken, SimpleNameSyntax name)
    {
      switch (operatorToken.Kind())
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      return (MemberBindingExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.MemberBindingExpression((Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleNameSyntax)name.Green).CreateRed();
    }

    /// <summary>Creates a new MemberBindingExpressionSyntax instance.</summary>
    public static MemberBindingExpressionSyntax MemberBindingExpression(SimpleNameSyntax name)
    {
      return SyntaxFactory.MemberBindingExpression(SyntaxFactory.Token(SyntaxKind.DotToken), name);
    }

    /// <summary>Creates a new ElementBindingExpressionSyntax instance.</summary>
    public static ElementBindingExpressionSyntax ElementBindingExpression(BracketedArgumentListSyntax argumentList)
    {
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
      return (ElementBindingExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ElementBindingExpression(argumentList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedArgumentListSyntax)argumentList.Green).CreateRed();
    }

    /// <summary>Creates a new ElementBindingExpressionSyntax instance.</summary>
    public static ElementBindingExpressionSyntax ElementBindingExpression()
    {
      return SyntaxFactory.ElementBindingExpression(SyntaxFactory.BracketedArgumentList());
    }

    /// <summary>Creates a new ImplicitElementAccessSyntax instance.</summary>
    public static ImplicitElementAccessSyntax ImplicitElementAccess(BracketedArgumentListSyntax argumentList)
    {
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
      return (ImplicitElementAccessSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ImplicitElementAccess(argumentList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedArgumentListSyntax)argumentList.Green).CreateRed();
    }

    /// <summary>Creates a new ImplicitElementAccessSyntax instance.</summary>
    public static ImplicitElementAccessSyntax ImplicitElementAccess()
    {
      return SyntaxFactory.ImplicitElementAccess(SyntaxFactory.BracketedArgumentList());
    }

    /// <summary>Creates a new BinaryExpressionSyntax instance.</summary>
    public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
      switch (kind)
      {
        case SyntaxKind.AddExpression:
        case SyntaxKind.SubtractExpression:
        case SyntaxKind.MultiplyExpression:
        case SyntaxKind.DivideExpression:
        case SyntaxKind.ModuloExpression:
        case SyntaxKind.LeftShiftExpression:
        case SyntaxKind.RightShiftExpression:
        case SyntaxKind.LogicalOrExpression:
        case SyntaxKind.LogicalAndExpression:
        case SyntaxKind.BitwiseOrExpression:
        case SyntaxKind.BitwiseAndExpression:
        case SyntaxKind.ExclusiveOrExpression:
        case SyntaxKind.EqualsExpression:
        case SyntaxKind.NotEqualsExpression:
        case SyntaxKind.LessThanExpression:
        case SyntaxKind.LessThanOrEqualExpression:
        case SyntaxKind.GreaterThanExpression:
        case SyntaxKind.GreaterThanOrEqualExpression:
        case SyntaxKind.IsExpression:
        case SyntaxKind.AsExpression:
        case SyntaxKind.CoalesceExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      switch (operatorToken.Kind())
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarBarToken:
        case SyntaxKind.AmpersandAmpersandToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.IsKeyword:
        case SyntaxKind.AsKeyword:
        case SyntaxKind.QuestionQuestionToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
      return (BinaryExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.BinaryExpression(kind, left == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)left.Green, (Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)right.Green).CreateRed();
    }

    /// <summary>Creates a new BinaryExpressionSyntax instance.</summary>
    public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, ExpressionSyntax right)
    {
      return SyntaxFactory.BinaryExpression(kind, left, SyntaxFactory.Token(GetBinaryExpressionOperatorTokenKind(kind)), right);
    }

    private static SyntaxKind GetBinaryExpressionOperatorTokenKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.AddExpression:
          return SyntaxKind.PlusToken;
        case SyntaxKind.SubtractExpression:
          return SyntaxKind.MinusToken;
        case SyntaxKind.MultiplyExpression:
          return SyntaxKind.AsteriskToken;
        case SyntaxKind.DivideExpression:
          return SyntaxKind.SlashToken;
        case SyntaxKind.ModuloExpression:
          return SyntaxKind.PercentToken;
        case SyntaxKind.LeftShiftExpression:
          return SyntaxKind.LessThanLessThanToken;
        case SyntaxKind.RightShiftExpression:
          return SyntaxKind.GreaterThanGreaterThanToken;
        case SyntaxKind.LogicalOrExpression:
          return SyntaxKind.BarBarToken;
        case SyntaxKind.LogicalAndExpression:
          return SyntaxKind.AmpersandAmpersandToken;
        case SyntaxKind.BitwiseOrExpression:
          return SyntaxKind.BarToken;
        case SyntaxKind.BitwiseAndExpression:
          return SyntaxKind.AmpersandToken;
        case SyntaxKind.ExclusiveOrExpression:
          return SyntaxKind.CaretToken;
        case SyntaxKind.EqualsExpression:
          return SyntaxKind.EqualsEqualsToken;
        case SyntaxKind.NotEqualsExpression:
          return SyntaxKind.ExclamationEqualsToken;
        case SyntaxKind.LessThanExpression:
          return SyntaxKind.LessThanToken;
        case SyntaxKind.LessThanOrEqualExpression:
          return SyntaxKind.LessThanEqualsToken;
        case SyntaxKind.GreaterThanExpression:
          return SyntaxKind.GreaterThanToken;
        case SyntaxKind.GreaterThanOrEqualExpression:
          return SyntaxKind.GreaterThanEqualsToken;
        case SyntaxKind.IsExpression:
          return SyntaxKind.IsKeyword;
        case SyntaxKind.AsExpression:
          return SyntaxKind.AsKeyword;
        case SyntaxKind.CoalesceExpression:
          return SyntaxKind.QuestionQuestionToken;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new AssignmentExpressionSyntax instance.</summary>
    public static AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
      switch (kind)
      {
        case SyntaxKind.SimpleAssignmentExpression:
        case SyntaxKind.AddAssignmentExpression:
        case SyntaxKind.SubtractAssignmentExpression:
        case SyntaxKind.MultiplyAssignmentExpression:
        case SyntaxKind.DivideAssignmentExpression:
        case SyntaxKind.ModuloAssignmentExpression:
        case SyntaxKind.AndAssignmentExpression:
        case SyntaxKind.ExclusiveOrAssignmentExpression:
        case SyntaxKind.OrAssignmentExpression:
        case SyntaxKind.LeftShiftAssignmentExpression:
        case SyntaxKind.RightShiftAssignmentExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      switch (operatorToken.Kind())
      {
        case SyntaxKind.EqualsToken:
        case SyntaxKind.PlusEqualsToken:
        case SyntaxKind.MinusEqualsToken:
        case SyntaxKind.AsteriskEqualsToken:
        case SyntaxKind.SlashEqualsToken:
        case SyntaxKind.PercentEqualsToken:
        case SyntaxKind.AmpersandEqualsToken:
        case SyntaxKind.CaretEqualsToken:
        case SyntaxKind.BarEqualsToken:
        case SyntaxKind.LessThanLessThanEqualsToken:
        case SyntaxKind.GreaterThanGreaterThanEqualsToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
      return (AssignmentExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AssignmentExpression(kind, left == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)left.Green, (Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)right.Green).CreateRed();
    }

    /// <summary>Creates a new AssignmentExpressionSyntax instance.</summary>
    public static AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, ExpressionSyntax right)
    {
      return SyntaxFactory.AssignmentExpression(kind, left, SyntaxFactory.Token(GetAssignmentExpressionOperatorTokenKind(kind)), right);
    }

    private static SyntaxKind GetAssignmentExpressionOperatorTokenKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.SimpleAssignmentExpression:
          return SyntaxKind.EqualsToken;
        case SyntaxKind.AddAssignmentExpression:
          return SyntaxKind.PlusEqualsToken;
        case SyntaxKind.SubtractAssignmentExpression:
          return SyntaxKind.MinusEqualsToken;
        case SyntaxKind.MultiplyAssignmentExpression:
          return SyntaxKind.AsteriskEqualsToken;
        case SyntaxKind.DivideAssignmentExpression:
          return SyntaxKind.SlashEqualsToken;
        case SyntaxKind.ModuloAssignmentExpression:
          return SyntaxKind.PercentEqualsToken;
        case SyntaxKind.AndAssignmentExpression:
          return SyntaxKind.AmpersandEqualsToken;
        case SyntaxKind.ExclusiveOrAssignmentExpression:
          return SyntaxKind.CaretEqualsToken;
        case SyntaxKind.OrAssignmentExpression:
          return SyntaxKind.BarEqualsToken;
        case SyntaxKind.LeftShiftAssignmentExpression:
          return SyntaxKind.LessThanLessThanEqualsToken;
        case SyntaxKind.RightShiftAssignmentExpression:
          return SyntaxKind.GreaterThanGreaterThanEqualsToken;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new ConditionalExpressionSyntax instance.</summary>
    public static ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
    {
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      switch (questionToken.Kind())
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException("questionToken");
      }
      if (whenTrue == null)
        throw new ArgumentNullException(nameof(whenTrue));
      switch (colonToken.Kind())
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      if (whenFalse == null)
        throw new ArgumentNullException(nameof(whenFalse));
      return (ConditionalExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ConditionalExpression(condition == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken)questionToken.Node, whenTrue == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)whenTrue.Green, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node, whenFalse == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)whenFalse.Green).CreateRed();
    }

    /// <summary>Creates a new ConditionalExpressionSyntax instance.</summary>
    public static ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, ExpressionSyntax whenTrue, ExpressionSyntax whenFalse)
    {
      return SyntaxFactory.ConditionalExpression(condition, SyntaxFactory.Token(SyntaxKind.QuestionToken), whenTrue, SyntaxFactory.Token(SyntaxKind.ColonToken), whenFalse);
    }

    /// <summary>Creates a new ThisExpressionSyntax instance.</summary>
    public static ThisExpressionSyntax ThisExpression(SyntaxToken token)
    {
      switch (token.Kind())
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
      return (ThisExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ThisExpression((Syntax.InternalSyntax.SyntaxToken)token.Node).CreateRed();
    }

    /// <summary>Creates a new ThisExpressionSyntax instance.</summary>
    public static ThisExpressionSyntax ThisExpression()
    {
      return SyntaxFactory.ThisExpression(SyntaxFactory.Token(SyntaxKind.ThisKeyword));
    }

    /// <summary>Creates a new BaseExpressionSyntax instance.</summary>
    public static BaseExpressionSyntax BaseExpression(SyntaxToken token)
    {
      switch (token.Kind())
      {
        case SyntaxKind.BaseKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
      return (BaseExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.BaseExpression((Syntax.InternalSyntax.SyntaxToken)token.Node).CreateRed();
    }

    /// <summary>Creates a new BaseExpressionSyntax instance.</summary>
    public static BaseExpressionSyntax BaseExpression()
    {
      return SyntaxFactory.BaseExpression(SyntaxFactory.Token(SyntaxKind.BaseKeyword));
    }

    /// <summary>Creates a new OriginalExpressionSyntax instance.</summary>
    public static OriginalExpressionSyntax OriginalExpression(SyntaxToken token)
    {
      switch (token.Kind())
      {
        case SyntaxKind.OriginalKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
      return (OriginalExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.OriginalExpression((Syntax.InternalSyntax.SyntaxToken)token.Node).CreateRed();
    }

    /// <summary>Creates a new OriginalExpressionSyntax instance.</summary>
    public static OriginalExpressionSyntax OriginalExpression()
    {
      return SyntaxFactory.OriginalExpression(SyntaxFactory.Token(SyntaxKind.OriginalKeyword));
    }

    /// <summary>Creates a new LiteralExpressionSyntax instance.</summary>
    public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)
    {
      switch (kind)
      {
        case SyntaxKind.ArgListExpression:
        case SyntaxKind.NumericLiteralExpression:
        case SyntaxKind.StringLiteralExpression:
        case SyntaxKind.CharacterLiteralExpression:
        case SyntaxKind.TrueLiteralExpression:
        case SyntaxKind.FalseLiteralExpression:
        case SyntaxKind.NullLiteralExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
      switch (token.Kind())
      {
        case SyntaxKind.ArgListKeyword:
        case SyntaxKind.NumericLiteralToken:
        case SyntaxKind.StringLiteralToken:
        case SyntaxKind.CharacterLiteralToken:
        case SyntaxKind.TrueKeyword:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.NullKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
      return (LiteralExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.LiteralExpression(kind, (Syntax.InternalSyntax.SyntaxToken)token.Node).CreateRed();
    }

    /// <summary>Creates a new LiteralExpressionSyntax instance.</summary>
    public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind)
    {
      return SyntaxFactory.LiteralExpression(kind, SyntaxFactory.Token(GetLiteralExpressionTokenKind(kind)));
    }

    private static SyntaxKind GetLiteralExpressionTokenKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.ArgListExpression:
          return SyntaxKind.ArgListKeyword;
        case SyntaxKind.NumericLiteralExpression:
          return SyntaxKind.NumericLiteralToken;
        case SyntaxKind.StringLiteralExpression:
          return SyntaxKind.StringLiteralToken;
        case SyntaxKind.CharacterLiteralExpression:
          return SyntaxKind.CharacterLiteralToken;
        case SyntaxKind.TrueLiteralExpression:
          return SyntaxKind.TrueKeyword;
        case SyntaxKind.FalseLiteralExpression:
          return SyntaxKind.FalseKeyword;
        case SyntaxKind.NullLiteralExpression:
          return SyntaxKind.NullKeyword;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new MakeRefExpressionSyntax instance.</summary>
    public static MakeRefExpressionSyntax MakeRefExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.MakeRefKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (MakeRefExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.MakeRefExpression((Syntax.InternalSyntax.SyntaxToken)keyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }

    /// <summary>Creates a new MakeRefExpressionSyntax instance.</summary>
    public static MakeRefExpressionSyntax MakeRefExpression(ExpressionSyntax expression)
    {
      return SyntaxFactory.MakeRefExpression(SyntaxFactory.Token(SyntaxKind.MakeRefKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), expression, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new RefTypeExpressionSyntax instance.</summary>
    public static RefTypeExpressionSyntax RefTypeExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.RefTypeKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (RefTypeExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.RefTypeExpression((Syntax.InternalSyntax.SyntaxToken)keyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }

    /// <summary>Creates a new RefTypeExpressionSyntax instance.</summary>
    public static RefTypeExpressionSyntax RefTypeExpression(ExpressionSyntax expression)
    {
      return SyntaxFactory.RefTypeExpression(SyntaxFactory.Token(SyntaxKind.RefTypeKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), expression, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new RefValueExpressionSyntax instance.</summary>
    public static RefValueExpressionSyntax RefValueExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.RefValueKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (comma.Kind())
      {
        case SyntaxKind.CommaToken:
          break;
        default:
          throw new ArgumentException("comma");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (RefValueExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.RefValueExpression((Syntax.InternalSyntax.SyntaxToken)keyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)comma.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }

    /// <summary>Creates a new RefValueExpressionSyntax instance.</summary>
    public static RefValueExpressionSyntax RefValueExpression(ExpressionSyntax expression, TypeSyntax type)
    {
      return SyntaxFactory.RefValueExpression(SyntaxFactory.Token(SyntaxKind.RefValueKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), expression, SyntaxFactory.Token(SyntaxKind.CommaToken), type, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new CheckedExpressionSyntax instance.</summary>
    public static CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedExpression:
        case SyntaxKind.UncheckedExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
      switch (keyword.Kind())
      {
        case SyntaxKind.CheckedKeyword:
        case SyntaxKind.UncheckedKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (CheckedExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CheckedExpression(kind, (Syntax.InternalSyntax.SyntaxToken)keyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }

    /// <summary>Creates a new CheckedExpressionSyntax instance.</summary>
    public static CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, ExpressionSyntax expression)
    {
      return SyntaxFactory.CheckedExpression(kind, SyntaxFactory.Token(GetCheckedExpressionKeywordKind(kind)), SyntaxFactory.Token(SyntaxKind.OpenParenToken), expression, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    private static SyntaxKind GetCheckedExpressionKeywordKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedExpression:
          return SyntaxKind.CheckedKeyword;
        case SyntaxKind.UncheckedExpression:
          return SyntaxKind.UncheckedKeyword;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new DefaultExpressionSyntax instance.</summary>
    public static DefaultExpressionSyntax DefaultExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (DefaultExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.DefaultExpression((Syntax.InternalSyntax.SyntaxToken)keyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }

    /// <summary>Creates a new DefaultExpressionSyntax instance.</summary>
    public static DefaultExpressionSyntax DefaultExpression(TypeSyntax type)
    {
      return SyntaxFactory.DefaultExpression(SyntaxFactory.Token(SyntaxKind.DefaultKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), type, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new TypeOfExpressionSyntax instance.</summary>
    public static TypeOfExpressionSyntax TypeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.TypeOfKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (TypeOfExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.TypeOfExpression((Syntax.InternalSyntax.SyntaxToken)keyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }

    /// <summary>Creates a new TypeOfExpressionSyntax instance.</summary>
    public static TypeOfExpressionSyntax TypeOfExpression(TypeSyntax type)
    {
      return SyntaxFactory.TypeOfExpression(SyntaxFactory.Token(SyntaxKind.TypeOfKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), type, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new SizeOfExpressionSyntax instance.</summary>
    public static SizeOfExpressionSyntax SizeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.SizeOfKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (SizeOfExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.SizeOfExpression((Syntax.InternalSyntax.SyntaxToken)keyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }

    /// <summary>Creates a new SizeOfExpressionSyntax instance.</summary>
    public static SizeOfExpressionSyntax SizeOfExpression(TypeSyntax type)
    {
      return SyntaxFactory.SizeOfExpression(SyntaxFactory.Token(SyntaxKind.SizeOfKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), type, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new InvocationExpressionSyntax instance.</summary>
    public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression, ArgumentListSyntax argumentList)
    {
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
      return (InvocationExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.InvocationExpression(expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, argumentList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentListSyntax)argumentList.Green).CreateRed();
    }

    /// <summary>Creates a new InvocationExpressionSyntax instance.</summary>
    public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression)
    {
      return SyntaxFactory.InvocationExpression(expression, SyntaxFactory.ArgumentList());
    }

    /// <summary>Creates a new ElementAccessExpressionSyntax instance.</summary>
    public static ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
    {
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
      return (ElementAccessExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ElementAccessExpression(expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, argumentList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedArgumentListSyntax)argumentList.Green).CreateRed();
    }

    /// <summary>Creates a new ElementAccessExpressionSyntax instance.</summary>
    public static ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression)
    {
      return SyntaxFactory.ElementAccessExpression(expression, SyntaxFactory.BracketedArgumentList());
    }

    /// <summary>Creates a new ArgumentListSyntax instance.</summary>
    public static ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (ArgumentListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ArgumentList((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, arguments.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }

    /// <summary>Creates a new ArgumentListSyntax instance.</summary>
    public static ArgumentListSyntax ArgumentList(SeparatedSyntaxList<ArgumentSyntax> arguments = default(SeparatedSyntaxList<ArgumentSyntax>))
    {
      return SyntaxFactory.ArgumentList(SyntaxFactory.Token(SyntaxKind.OpenParenToken), arguments, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new BracketedArgumentListSyntax instance.</summary>
    public static BracketedArgumentListSyntax BracketedArgumentList(SyntaxToken openBracketToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
    {
      switch (openBracketToken.Kind())
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      switch (closeBracketToken.Kind())
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
      return (BracketedArgumentListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.BracketedArgumentList((Syntax.InternalSyntax.SyntaxToken)openBracketToken.Node, arguments.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBracketToken.Node).CreateRed();
    }

    /// <summary>Creates a new BracketedArgumentListSyntax instance.</summary>
    public static BracketedArgumentListSyntax BracketedArgumentList(SeparatedSyntaxList<ArgumentSyntax> arguments = default(SeparatedSyntaxList<ArgumentSyntax>))
    {
      return SyntaxFactory.BracketedArgumentList(SyntaxFactory.Token(SyntaxKind.OpenBracketToken), arguments, SyntaxFactory.Token(SyntaxKind.CloseBracketToken));
    }

    /// <summary>Creates a new ArgumentSyntax instance.</summary>
    public static ArgumentSyntax Argument(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression)
    {
      switch (refOrOutKeyword.Kind())
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refOrOutKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      return (ArgumentSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.Argument(nameColon == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameColonSyntax)nameColon.Green, (Syntax.InternalSyntax.SyntaxToken)refOrOutKeyword.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
    }

    /// <summary>Creates a new ArgumentSyntax instance.</summary>
    public static ArgumentSyntax Argument(ExpressionSyntax expression)
    {
      return SyntaxFactory.Argument(default(NameColonSyntax), default(SyntaxToken), expression);
    }

    /// <summary>Creates a new NameColonSyntax instance.</summary>
    public static NameColonSyntax NameColon(IdentifierNameSyntax name, SyntaxToken colonToken)
    {
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (colonToken.Kind())
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      return (NameColonSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.NameColon(name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IdentifierNameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node).CreateRed();
    }

    /// <summary>Creates a new NameColonSyntax instance.</summary>
    public static NameColonSyntax NameColon(IdentifierNameSyntax name)
    {
      return SyntaxFactory.NameColon(name, SyntaxFactory.Token(SyntaxKind.ColonToken));
    }

    /// <summary>Creates a new NameColonSyntax instance.</summary>
    public static NameColonSyntax NameColon(string name)
    {
      return SyntaxFactory.NameColon(SyntaxFactory.IdentifierName(name), SyntaxFactory.Token(SyntaxKind.ColonToken));
    }

    /// <summary>Creates a new CastExpressionSyntax instance.</summary>
    public static CastExpressionSyntax CastExpression(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
    {
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      return (CastExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CastExpression((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
    }

    /// <summary>Creates a new CastExpressionSyntax instance.</summary>
    public static CastExpressionSyntax CastExpression(TypeSyntax type, ExpressionSyntax expression)
    {
      return SyntaxFactory.CastExpression(SyntaxFactory.Token(SyntaxKind.OpenParenToken), type, SyntaxFactory.Token(SyntaxKind.CloseParenToken), expression);
    }

    /// <summary>Creates a new AnonymousMethodExpressionSyntax instance.</summary>
    public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body)
    {
      switch (asyncKeyword.Kind())
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("asyncKeyword");
      }
      switch (delegateKeyword.Kind())
      {
        case SyntaxKind.DelegateKeyword:
          break;
        default:
          throw new ArgumentException("delegateKeyword");
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
      return (AnonymousMethodExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AnonymousMethodExpression((Syntax.InternalSyntax.SyntaxToken)asyncKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)delegateKeyword.Node, parameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax)parameterList.Green, body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode)body.Green).CreateRed();
    }

    /// <summary>Creates a new AnonymousMethodExpressionSyntax instance.</summary>
    public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(ParameterListSyntax parameterList, CSharpSyntaxNode body)
    {
      return SyntaxFactory.AnonymousMethodExpression(default(SyntaxToken), SyntaxFactory.Token(SyntaxKind.DelegateKeyword), parameterList, body);
    }

    /// <summary>Creates a new AnonymousMethodExpressionSyntax instance.</summary>
    public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(CSharpSyntaxNode body)
    {
      return SyntaxFactory.AnonymousMethodExpression(default(SyntaxToken), SyntaxFactory.Token(SyntaxKind.DelegateKeyword), default(ParameterListSyntax), body);
    }

    /// <summary>Creates a new SimpleLambdaExpressionSyntax instance.</summary>
    public static SimpleLambdaExpressionSyntax SimpleLambdaExpression(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, SyntaxToken refKeyword, CSharpSyntaxNode body)
    {
      switch (asyncKeyword.Kind())
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("asyncKeyword");
      }
      if (parameter == null)
        throw new ArgumentNullException(nameof(parameter));
      switch (arrowToken.Kind())
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException("arrowToken");
      }
      switch (refKeyword.Kind())
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
      return (SimpleLambdaExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.SimpleLambdaExpression((Syntax.InternalSyntax.SyntaxToken)asyncKeyword.Node, parameter == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterSyntax)parameter.Green, (Syntax.InternalSyntax.SyntaxToken)arrowToken.Node, (Syntax.InternalSyntax.SyntaxToken)refKeyword.Node, body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode)body.Green).CreateRed();
    }

    /// <summary>Creates a new SimpleLambdaExpressionSyntax instance.</summary>
    public static SimpleLambdaExpressionSyntax SimpleLambdaExpression(ParameterSyntax parameter, CSharpSyntaxNode body)
    {
      return SyntaxFactory.SimpleLambdaExpression(default(SyntaxToken), parameter, SyntaxFactory.Token(SyntaxKind.EqualsGreaterThanToken), default(SyntaxToken), body);
    }

    /// <summary>Creates a new ParenthesizedLambdaExpressionSyntax instance.</summary>
    public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, SyntaxToken refKeyword, CSharpSyntaxNode body)
    {
      switch (asyncKeyword.Kind())
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("asyncKeyword");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      switch (arrowToken.Kind())
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException("arrowToken");
      }
      switch (refKeyword.Kind())
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
      return (ParenthesizedLambdaExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ParenthesizedLambdaExpression((Syntax.InternalSyntax.SyntaxToken)asyncKeyword.Node, parameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax)parameterList.Green, (Syntax.InternalSyntax.SyntaxToken)arrowToken.Node, (Syntax.InternalSyntax.SyntaxToken)refKeyword.Node, body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode)body.Green).CreateRed();
    }

    /// <summary>Creates a new ParenthesizedLambdaExpressionSyntax instance.</summary>
    public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(ParameterListSyntax parameterList, CSharpSyntaxNode body)
    {
      return SyntaxFactory.ParenthesizedLambdaExpression(default(SyntaxToken), parameterList, SyntaxFactory.Token(SyntaxKind.EqualsGreaterThanToken), default(SyntaxToken), body);
    }

    /// <summary>Creates a new ParenthesizedLambdaExpressionSyntax instance.</summary>
    public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(CSharpSyntaxNode body)
    {
      return SyntaxFactory.ParenthesizedLambdaExpression(default(SyntaxToken), SyntaxFactory.ParameterList(), SyntaxFactory.Token(SyntaxKind.EqualsGreaterThanToken), default(SyntaxToken), body);
    }

    /// <summary>Creates a new InitializerExpressionSyntax instance.</summary>
    public static InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)
    {
      switch (kind)
      {
        case SyntaxKind.ObjectInitializerExpression:
        case SyntaxKind.CollectionInitializerExpression:
        case SyntaxKind.ArrayInitializerExpression:
        case SyntaxKind.ComplexElementInitializerExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      return (InitializerExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.InitializerExpression(kind, (Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, expressions.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node).CreateRed();
    }

    /// <summary>Creates a new InitializerExpressionSyntax instance.</summary>
    public static InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SeparatedSyntaxList<ExpressionSyntax> expressions = default(SeparatedSyntaxList<ExpressionSyntax>))
    {
      return SyntaxFactory.InitializerExpression(kind, SyntaxFactory.Token(SyntaxKind.OpenBraceToken), expressions, SyntaxFactory.Token(SyntaxKind.CloseBraceToken));
    }

    /// <summary>Creates a new ObjectCreationExpressionSyntax instance.</summary>
    public static ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
    {
      switch (newKeyword.Kind())
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      return (ObjectCreationExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ObjectCreationExpression((Syntax.InternalSyntax.SyntaxToken)newKeyword.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, argumentList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentListSyntax)argumentList.Green, initializer == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InitializerExpressionSyntax)initializer.Green).CreateRed();
    }

    /// <summary>Creates a new ObjectCreationExpressionSyntax instance.</summary>
    public static ObjectCreationExpressionSyntax ObjectCreationExpression(TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
    {
      return SyntaxFactory.ObjectCreationExpression(SyntaxFactory.Token(SyntaxKind.NewKeyword), type, argumentList, initializer);
    }

    /// <summary>Creates a new ObjectCreationExpressionSyntax instance.</summary>
    public static ObjectCreationExpressionSyntax ObjectCreationExpression(TypeSyntax type)
    {
      return SyntaxFactory.ObjectCreationExpression(SyntaxFactory.Token(SyntaxKind.NewKeyword), type, default(ArgumentListSyntax), default(InitializerExpressionSyntax));
    }

    /// <summary>Creates a new AnonymousObjectMemberDeclaratorSyntax instance.</summary>
    public static AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(NameEqualsSyntax nameEquals, ExpressionSyntax expression)
    {
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      return (AnonymousObjectMemberDeclaratorSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AnonymousObjectMemberDeclarator(nameEquals == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameEqualsSyntax)nameEquals.Green, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
    }

    /// <summary>Creates a new AnonymousObjectMemberDeclaratorSyntax instance.</summary>
    public static AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(ExpressionSyntax expression)
    {
      return SyntaxFactory.AnonymousObjectMemberDeclarator(default(NameEqualsSyntax), expression);
    }

    /// <summary>Creates a new AnonymousObjectCreationExpressionSyntax instance.</summary>
    public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)
    {
      switch (newKeyword.Kind())
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      return (AnonymousObjectCreationExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AnonymousObjectCreationExpression((Syntax.InternalSyntax.SyntaxToken)newKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, initializers.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousObjectMemberDeclaratorSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node).CreateRed();
    }

    /// <summary>Creates a new AnonymousObjectCreationExpressionSyntax instance.</summary>
    public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers = default(SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax>))
    {
      return SyntaxFactory.AnonymousObjectCreationExpression(SyntaxFactory.Token(SyntaxKind.NewKeyword), SyntaxFactory.Token(SyntaxKind.OpenBraceToken), initializers, SyntaxFactory.Token(SyntaxKind.CloseBraceToken));
    }

    /// <summary>Creates a new ArrayCreationExpressionSyntax instance.</summary>
    public static ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
    {
      switch (newKeyword.Kind())
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      return (ArrayCreationExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ArrayCreationExpression((Syntax.InternalSyntax.SyntaxToken)newKeyword.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayTypeSyntax)type.Green, initializer == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InitializerExpressionSyntax)initializer.Green).CreateRed();
    }

    /// <summary>Creates a new ArrayCreationExpressionSyntax instance.</summary>
    public static ArrayCreationExpressionSyntax ArrayCreationExpression(ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
    {
      return SyntaxFactory.ArrayCreationExpression(SyntaxFactory.Token(SyntaxKind.NewKeyword), type, initializer);
    }

    /// <summary>Creates a new ArrayCreationExpressionSyntax instance.</summary>
    public static ArrayCreationExpressionSyntax ArrayCreationExpression(ArrayTypeSyntax type)
    {
      return SyntaxFactory.ArrayCreationExpression(SyntaxFactory.Token(SyntaxKind.NewKeyword), type, default(InitializerExpressionSyntax));
    }

    /// <summary>Creates a new ImplicitArrayCreationExpressionSyntax instance.</summary>
    public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxTokenList commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
    {
      switch (newKeyword.Kind())
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      switch (openBracketToken.Kind())
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      switch (closeBracketToken.Kind())
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
      if (initializer == null)
        throw new ArgumentNullException(nameof(initializer));
      return (ImplicitArrayCreationExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ImplicitArrayCreationExpression((Syntax.InternalSyntax.SyntaxToken)newKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openBracketToken.Node, commas.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), (Syntax.InternalSyntax.SyntaxToken)closeBracketToken.Node, initializer == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InitializerExpressionSyntax)initializer.Green).CreateRed();
    }

    /// <summary>Creates a new ImplicitArrayCreationExpressionSyntax instance.</summary>
    public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxTokenList commas, InitializerExpressionSyntax initializer)
    {
      return SyntaxFactory.ImplicitArrayCreationExpression(SyntaxFactory.Token(SyntaxKind.NewKeyword), SyntaxFactory.Token(SyntaxKind.OpenBracketToken), commas, SyntaxFactory.Token(SyntaxKind.CloseBracketToken), initializer);
    }

    /// <summary>Creates a new ImplicitArrayCreationExpressionSyntax instance.</summary>
    public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(InitializerExpressionSyntax initializer)
    {
      return SyntaxFactory.ImplicitArrayCreationExpression(SyntaxFactory.Token(SyntaxKind.NewKeyword), SyntaxFactory.Token(SyntaxKind.OpenBracketToken), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.CloseBracketToken), initializer);
    }

    /// <summary>Creates a new StackAllocArrayCreationExpressionSyntax instance.</summary>
    public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, TypeSyntax type)
    {
      switch (stackAllocKeyword.Kind())
      {
        case SyntaxKind.StackAllocKeyword:
          break;
        default:
          throw new ArgumentException("stackAllocKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      return (StackAllocArrayCreationExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.StackAllocArrayCreationExpression((Syntax.InternalSyntax.SyntaxToken)stackAllocKeyword.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green).CreateRed();
    }

    /// <summary>Creates a new StackAllocArrayCreationExpressionSyntax instance.</summary>
    public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(TypeSyntax type)
    {
      return SyntaxFactory.StackAllocArrayCreationExpression(SyntaxFactory.Token(SyntaxKind.StackAllocKeyword), type);
    }

    /// <summary>Creates a new QueryExpressionSyntax instance.</summary>
    public static QueryExpressionSyntax QueryExpression(FromClauseSyntax fromClause, QueryBodySyntax body)
    {
      if (fromClause == null)
        throw new ArgumentNullException(nameof(fromClause));
      if (body == null)
        throw new ArgumentNullException(nameof(body));
      return (QueryExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.QueryExpression(fromClause == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FromClauseSyntax)fromClause.Green, body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QueryBodySyntax)body.Green).CreateRed();
    }

    /// <summary>Creates a new QueryBodySyntax instance.</summary>
    public static QueryBodySyntax QueryBody(SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
    {
      if (selectOrGroup == null)
        throw new ArgumentNullException(nameof(selectOrGroup));
      return (QueryBodySyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.QueryBody(clauses.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QueryClauseSyntax>(), selectOrGroup == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SelectOrGroupClauseSyntax)selectOrGroup.Green, continuation == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QueryContinuationSyntax)continuation.Green).CreateRed();
    }

    /// <summary>Creates a new QueryBodySyntax instance.</summary>
    public static QueryBodySyntax QueryBody(SelectOrGroupClauseSyntax selectOrGroup)
    {
      return SyntaxFactory.QueryBody(default(SyntaxList<QueryClauseSyntax>), selectOrGroup, default(QueryContinuationSyntax));
    }

    /// <summary>Creates a new FromClauseSyntax instance.</summary>
    public static FromClauseSyntax FromClause(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
    {
      switch (fromKeyword.Kind())
      {
        case SyntaxKind.FromKeyword:
          break;
        default:
          throw new ArgumentException("fromKeyword");
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      switch (inKeyword.Kind())
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException("inKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      return (FromClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.FromClause((Syntax.InternalSyntax.SyntaxToken)fromKeyword.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, (Syntax.InternalSyntax.SyntaxToken)inKeyword.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
    }

    /// <summary>Creates a new FromClauseSyntax instance.</summary>
    public static FromClauseSyntax FromClause(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax expression)
    {
      return SyntaxFactory.FromClause(SyntaxFactory.Token(SyntaxKind.FromKeyword), type, identifier, SyntaxFactory.Token(SyntaxKind.InKeyword), expression);
    }

    /// <summary>Creates a new FromClauseSyntax instance.</summary>
    public static FromClauseSyntax FromClause(SyntaxToken identifier, ExpressionSyntax expression)
    {
      return SyntaxFactory.FromClause(SyntaxFactory.Token(SyntaxKind.FromKeyword), default(TypeSyntax), identifier, SyntaxFactory.Token(SyntaxKind.InKeyword), expression);
    }

    /// <summary>Creates a new FromClauseSyntax instance.</summary>
    public static FromClauseSyntax FromClause(string identifier, ExpressionSyntax expression)
    {
      return SyntaxFactory.FromClause(SyntaxFactory.Token(SyntaxKind.FromKeyword), default(TypeSyntax), SyntaxFactory.Identifier(identifier), SyntaxFactory.Token(SyntaxKind.InKeyword), expression);
    }

    /// <summary>Creates a new LetClauseSyntax instance.</summary>
    public static LetClauseSyntax LetClause(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
    {
      switch (letKeyword.Kind())
      {
        case SyntaxKind.LetKeyword:
          break;
        default:
          throw new ArgumentException("letKeyword");
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      switch (equalsToken.Kind())
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      return (LetClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.LetClause((Syntax.InternalSyntax.SyntaxToken)letKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, (Syntax.InternalSyntax.SyntaxToken)equalsToken.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
    }

    /// <summary>Creates a new LetClauseSyntax instance.</summary>
    public static LetClauseSyntax LetClause(SyntaxToken identifier, ExpressionSyntax expression)
    {
      return SyntaxFactory.LetClause(SyntaxFactory.Token(SyntaxKind.LetKeyword), identifier, SyntaxFactory.Token(SyntaxKind.EqualsToken), expression);
    }

    /// <summary>Creates a new LetClauseSyntax instance.</summary>
    public static LetClauseSyntax LetClause(string identifier, ExpressionSyntax expression)
    {
      return SyntaxFactory.LetClause(SyntaxFactory.Token(SyntaxKind.LetKeyword), SyntaxFactory.Identifier(identifier), SyntaxFactory.Token(SyntaxKind.EqualsToken), expression);
    }

    /// <summary>Creates a new JoinClauseSyntax instance.</summary>
    public static JoinClauseSyntax JoinClause(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
    {
      switch (joinKeyword.Kind())
      {
        case SyntaxKind.JoinKeyword:
          break;
        default:
          throw new ArgumentException("joinKeyword");
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      switch (inKeyword.Kind())
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException("inKeyword");
      }
      if (inExpression == null)
        throw new ArgumentNullException(nameof(inExpression));
      switch (onKeyword.Kind())
      {
        case SyntaxKind.OnKeyword:
          break;
        default:
          throw new ArgumentException("onKeyword");
      }
      if (leftExpression == null)
        throw new ArgumentNullException(nameof(leftExpression));
      switch (equalsKeyword.Kind())
      {
        case SyntaxKind.EqualsKeyword:
          break;
        default:
          throw new ArgumentException("equalsKeyword");
      }
      if (rightExpression == null)
        throw new ArgumentNullException(nameof(rightExpression));
      return (JoinClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.JoinClause((Syntax.InternalSyntax.SyntaxToken)joinKeyword.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, (Syntax.InternalSyntax.SyntaxToken)inKeyword.Node, inExpression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)inExpression.Green, (Syntax.InternalSyntax.SyntaxToken)onKeyword.Node, leftExpression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)leftExpression.Green, (Syntax.InternalSyntax.SyntaxToken)equalsKeyword.Node, rightExpression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)rightExpression.Green, into == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.JoinIntoClauseSyntax)into.Green).CreateRed();
    }

    /// <summary>Creates a new JoinClauseSyntax instance.</summary>
    public static JoinClauseSyntax JoinClause(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
    {
      return SyntaxFactory.JoinClause(SyntaxFactory.Token(SyntaxKind.JoinKeyword), type, identifier, SyntaxFactory.Token(SyntaxKind.InKeyword), inExpression, SyntaxFactory.Token(SyntaxKind.OnKeyword), leftExpression, SyntaxFactory.Token(SyntaxKind.EqualsKeyword), rightExpression, into);
    }

    /// <summary>Creates a new JoinClauseSyntax instance.</summary>
    public static JoinClauseSyntax JoinClause(SyntaxToken identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression)
    {
      return SyntaxFactory.JoinClause(SyntaxFactory.Token(SyntaxKind.JoinKeyword), default(TypeSyntax), identifier, SyntaxFactory.Token(SyntaxKind.InKeyword), inExpression, SyntaxFactory.Token(SyntaxKind.OnKeyword), leftExpression, SyntaxFactory.Token(SyntaxKind.EqualsKeyword), rightExpression, default(JoinIntoClauseSyntax));
    }

    /// <summary>Creates a new JoinClauseSyntax instance.</summary>
    public static JoinClauseSyntax JoinClause(string identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression)
    {
      return SyntaxFactory.JoinClause(SyntaxFactory.Token(SyntaxKind.JoinKeyword), default(TypeSyntax), SyntaxFactory.Identifier(identifier), SyntaxFactory.Token(SyntaxKind.InKeyword), inExpression, SyntaxFactory.Token(SyntaxKind.OnKeyword), leftExpression, SyntaxFactory.Token(SyntaxKind.EqualsKeyword), rightExpression, default(JoinIntoClauseSyntax));
    }

    /// <summary>Creates a new JoinIntoClauseSyntax instance.</summary>
    public static JoinIntoClauseSyntax JoinIntoClause(SyntaxToken intoKeyword, SyntaxToken identifier)
    {
      switch (intoKeyword.Kind())
      {
        case SyntaxKind.IntoKeyword:
          break;
        default:
          throw new ArgumentException("intoKeyword");
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      return (JoinIntoClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.JoinIntoClause((Syntax.InternalSyntax.SyntaxToken)intoKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)identifier.Node).CreateRed();
    }

    /// <summary>Creates a new JoinIntoClauseSyntax instance.</summary>
    public static JoinIntoClauseSyntax JoinIntoClause(SyntaxToken identifier)
    {
      return SyntaxFactory.JoinIntoClause(SyntaxFactory.Token(SyntaxKind.IntoKeyword), identifier);
    }

    /// <summary>Creates a new JoinIntoClauseSyntax instance.</summary>
    public static JoinIntoClauseSyntax JoinIntoClause(string identifier)
    {
      return SyntaxFactory.JoinIntoClause(SyntaxFactory.Token(SyntaxKind.IntoKeyword), SyntaxFactory.Identifier(identifier));
    }

    /// <summary>Creates a new WhereClauseSyntax instance.</summary>
    public static WhereClauseSyntax WhereClause(SyntaxToken whereKeyword, ExpressionSyntax condition)
    {
      switch (whereKeyword.Kind())
      {
        case SyntaxKind.WhereKeyword:
          break;
        default:
          throw new ArgumentException("whereKeyword");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      return (WhereClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.WhereClause((Syntax.InternalSyntax.SyntaxToken)whereKeyword.Node, condition == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)condition.Green).CreateRed();
    }

    /// <summary>Creates a new WhereClauseSyntax instance.</summary>
    public static WhereClauseSyntax WhereClause(ExpressionSyntax condition)
    {
      return SyntaxFactory.WhereClause(SyntaxFactory.Token(SyntaxKind.WhereKeyword), condition);
    }

    /// <summary>Creates a new OrderByClauseSyntax instance.</summary>
    public static OrderByClauseSyntax OrderByClause(SyntaxToken orderByKeyword, SeparatedSyntaxList<OrderingSyntax> orderings)
    {
      switch (orderByKeyword.Kind())
      {
        case SyntaxKind.OrderByKeyword:
          break;
        default:
          throw new ArgumentException("orderByKeyword");
      }
      return (OrderByClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.OrderByClause((Syntax.InternalSyntax.SyntaxToken)orderByKeyword.Node, orderings.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OrderingSyntax>()).CreateRed();
    }

    /// <summary>Creates a new OrderByClauseSyntax instance.</summary>
    public static OrderByClauseSyntax OrderByClause(SeparatedSyntaxList<OrderingSyntax> orderings = default(SeparatedSyntaxList<OrderingSyntax>))
    {
      return SyntaxFactory.OrderByClause(SyntaxFactory.Token(SyntaxKind.OrderByKeyword), orderings);
    }

    /// <summary>Creates a new OrderingSyntax instance.</summary>
    public static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
    {
      switch (kind)
      {
        case SyntaxKind.AscendingOrdering:
        case SyntaxKind.DescendingOrdering:
          break;
        default:
          throw new ArgumentException("kind");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (ascendingOrDescendingKeyword.Kind())
      {
        case SyntaxKind.AscendingKeyword:
        case SyntaxKind.DescendingKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("ascendingOrDescendingKeyword");
      }
      return (OrderingSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.Ordering(kind, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)ascendingOrDescendingKeyword.Node).CreateRed();
    }

    /// <summary>Creates a new OrderingSyntax instance.</summary>
    public static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression)
    {
      return SyntaxFactory.Ordering(kind, expression, default(SyntaxToken));
    }

    private static SyntaxKind GetOrderingAscendingOrDescendingKeywordKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.AscendingOrdering:
          return SyntaxKind.AscendingKeyword;
        case SyntaxKind.DescendingOrdering:
          return SyntaxKind.DescendingKeyword;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new SelectClauseSyntax instance.</summary>
    public static SelectClauseSyntax SelectClause(SyntaxToken selectKeyword, ExpressionSyntax expression)
    {
      switch (selectKeyword.Kind())
      {
        case SyntaxKind.SelectKeyword:
          break;
        default:
          throw new ArgumentException("selectKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      return (SelectClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.SelectClause((Syntax.InternalSyntax.SyntaxToken)selectKeyword.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
    }

    /// <summary>Creates a new SelectClauseSyntax instance.</summary>
    public static SelectClauseSyntax SelectClause(ExpressionSyntax expression)
    {
      return SyntaxFactory.SelectClause(SyntaxFactory.Token(SyntaxKind.SelectKeyword), expression);
    }

    /// <summary>Creates a new GroupClauseSyntax instance.</summary>
    public static GroupClauseSyntax GroupClause(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
    {
      switch (groupKeyword.Kind())
      {
        case SyntaxKind.GroupKeyword:
          break;
        default:
          throw new ArgumentException("groupKeyword");
      }
      if (groupExpression == null)
        throw new ArgumentNullException(nameof(groupExpression));
      switch (byKeyword.Kind())
      {
        case SyntaxKind.ByKeyword:
          break;
        default:
          throw new ArgumentException("byKeyword");
      }
      if (byExpression == null)
        throw new ArgumentNullException(nameof(byExpression));
      return (GroupClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.GroupClause((Syntax.InternalSyntax.SyntaxToken)groupKeyword.Node, groupExpression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)groupExpression.Green, (Syntax.InternalSyntax.SyntaxToken)byKeyword.Node, byExpression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)byExpression.Green).CreateRed();
    }

    /// <summary>Creates a new GroupClauseSyntax instance.</summary>
    public static GroupClauseSyntax GroupClause(ExpressionSyntax groupExpression, ExpressionSyntax byExpression)
    {
      return SyntaxFactory.GroupClause(SyntaxFactory.Token(SyntaxKind.GroupKeyword), groupExpression, SyntaxFactory.Token(SyntaxKind.ByKeyword), byExpression);
    }

    /// <summary>Creates a new QueryContinuationSyntax instance.</summary>
    public static QueryContinuationSyntax QueryContinuation(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
    {
      switch (intoKeyword.Kind())
      {
        case SyntaxKind.IntoKeyword:
          break;
        default:
          throw new ArgumentException("intoKeyword");
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
      return (QueryContinuationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.QueryContinuation((Syntax.InternalSyntax.SyntaxToken)intoKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QueryBodySyntax)body.Green).CreateRed();
    }

    /// <summary>Creates a new QueryContinuationSyntax instance.</summary>
    public static QueryContinuationSyntax QueryContinuation(SyntaxToken identifier, QueryBodySyntax body)
    {
      return SyntaxFactory.QueryContinuation(SyntaxFactory.Token(SyntaxKind.IntoKeyword), identifier, body);
    }

    /// <summary>Creates a new QueryContinuationSyntax instance.</summary>
    public static QueryContinuationSyntax QueryContinuation(string identifier, QueryBodySyntax body)
    {
      return SyntaxFactory.QueryContinuation(SyntaxFactory.Token(SyntaxKind.IntoKeyword), SyntaxFactory.Identifier(identifier), body);
    }

    /// <summary>Creates a new OmittedArraySizeExpressionSyntax instance.</summary>
    public static OmittedArraySizeExpressionSyntax OmittedArraySizeExpression(SyntaxToken omittedArraySizeExpressionToken)
    {
      switch (omittedArraySizeExpressionToken.Kind())
      {
        case SyntaxKind.OmittedArraySizeExpressionToken:
          break;
        default:
          throw new ArgumentException("omittedArraySizeExpressionToken");
      }
      return (OmittedArraySizeExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.OmittedArraySizeExpression((Syntax.InternalSyntax.SyntaxToken)omittedArraySizeExpressionToken.Node).CreateRed();
    }

    /// <summary>Creates a new OmittedArraySizeExpressionSyntax instance.</summary>
    public static OmittedArraySizeExpressionSyntax OmittedArraySizeExpression()
    {
      return SyntaxFactory.OmittedArraySizeExpression(SyntaxFactory.Token(SyntaxKind.OmittedArraySizeExpressionToken));
    }

    /// <summary>Creates a new InterpolatedStringExpressionSyntax instance.</summary>
    public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
    {
      switch (stringStartToken.Kind())
      {
        case SyntaxKind.InterpolatedStringStartToken:
        case SyntaxKind.InterpolatedVerbatimStringStartToken:
          break;
        default:
          throw new ArgumentException("stringStartToken");
      }
      switch (stringEndToken.Kind())
      {
        case SyntaxKind.InterpolatedStringEndToken:
          break;
        default:
          throw new ArgumentException("stringEndToken");
      }
      return (InterpolatedStringExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.InterpolatedStringExpression((Syntax.InternalSyntax.SyntaxToken)stringStartToken.Node, contents.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolatedStringContentSyntax>(), (Syntax.InternalSyntax.SyntaxToken)stringEndToken.Node).CreateRed();
    }

    /// <summary>Creates a new InterpolatedStringExpressionSyntax instance.</summary>
    public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, SyntaxList<InterpolatedStringContentSyntax> contents)
    {
      return SyntaxFactory.InterpolatedStringExpression(stringStartToken, contents, SyntaxFactory.Token(SyntaxKind.InterpolatedStringEndToken));
    }

    /// <summary>Creates a new InterpolatedStringExpressionSyntax instance.</summary>
    public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken)
    {
      return SyntaxFactory.InterpolatedStringExpression(stringStartToken, default(SyntaxList<InterpolatedStringContentSyntax>), SyntaxFactory.Token(SyntaxKind.InterpolatedStringEndToken));
    }

    /// <summary>Creates a new IsPatternExpressionSyntax instance.</summary>
    public static IsPatternExpressionSyntax IsPatternExpression(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)
    {
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (isKeyword.Kind())
      {
        case SyntaxKind.IsKeyword:
          break;
        default:
          throw new ArgumentException("isKeyword");
      }
      if (pattern == null)
        throw new ArgumentNullException(nameof(pattern));
      return (IsPatternExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.IsPatternExpression(expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)isKeyword.Node, pattern == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PatternSyntax)pattern.Green).CreateRed();
    }

    /// <summary>Creates a new IsPatternExpressionSyntax instance.</summary>
    public static IsPatternExpressionSyntax IsPatternExpression(ExpressionSyntax expression, PatternSyntax pattern)
    {
      return SyntaxFactory.IsPatternExpression(expression, SyntaxFactory.Token(SyntaxKind.IsKeyword), pattern);
    }

    /// <summary>Creates a new WhenClauseSyntax instance.</summary>
    public static WhenClauseSyntax WhenClause(SyntaxToken whenKeyword, ExpressionSyntax condition)
    {
      switch (whenKeyword.Kind())
      {
        case SyntaxKind.WhenKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("whenKeyword");
      }
      return (WhenClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.WhenClause((Syntax.InternalSyntax.SyntaxToken)whenKeyword.Node, condition == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)condition.Green).CreateRed();
    }

    /// <summary>Creates a new WhenClauseSyntax instance.</summary>
    public static WhenClauseSyntax WhenClause(ExpressionSyntax condition = default(ExpressionSyntax))
    {
      return SyntaxFactory.WhenClause(default(SyntaxToken), condition);
    }

    /// <summary>Creates a new DeclarationPatternSyntax instance.</summary>
    public static DeclarationPatternSyntax DeclarationPattern(TypeSyntax type, SyntaxToken identifier)
    {
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      return (DeclarationPatternSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.DeclarationPattern(type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)identifier.Node).CreateRed();
    }

    /// <summary>Creates a new ConstantPatternSyntax instance.</summary>
    public static ConstantPatternSyntax ConstantPattern(ExpressionSyntax expression)
    {
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      return (ConstantPatternSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ConstantPattern(expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
    }

    /// <summary>Creates a new InterpolatedStringTextSyntax instance.</summary>
    public static InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken)
    {
      switch (textToken.Kind())
      {
        case SyntaxKind.InterpolatedStringTextToken:
          break;
        default:
          throw new ArgumentException("textToken");
      }
      return (InterpolatedStringTextSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.InterpolatedStringText((Syntax.InternalSyntax.SyntaxToken)textToken.Node).CreateRed();
    }

    /// <summary>Creates a new InterpolatedStringTextSyntax instance.</summary>
    public static InterpolatedStringTextSyntax InterpolatedStringText()
    {
      return SyntaxFactory.InterpolatedStringText(SyntaxFactory.Token(SyntaxKind.InterpolatedStringTextToken));
    }

    /// <summary>Creates a new InterpolationSyntax instance.</summary>
    public static InterpolationSyntax Interpolation(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)
    {
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      return (InterpolationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.Interpolation((Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, alignmentClause == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolationAlignmentClauseSyntax)alignmentClause.Green, formatClause == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolationFormatClauseSyntax)formatClause.Green, (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node).CreateRed();
    }

    /// <summary>Creates a new InterpolationSyntax instance.</summary>
    public static InterpolationSyntax Interpolation(ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause)
    {
      return SyntaxFactory.Interpolation(SyntaxFactory.Token(SyntaxKind.OpenBraceToken), expression, alignmentClause, formatClause, SyntaxFactory.Token(SyntaxKind.CloseBraceToken));
    }

    /// <summary>Creates a new InterpolationSyntax instance.</summary>
    public static InterpolationSyntax Interpolation(ExpressionSyntax expression)
    {
      return SyntaxFactory.Interpolation(SyntaxFactory.Token(SyntaxKind.OpenBraceToken), expression, default(InterpolationAlignmentClauseSyntax), default(InterpolationFormatClauseSyntax), SyntaxFactory.Token(SyntaxKind.CloseBraceToken));
    }

    /// <summary>Creates a new InterpolationAlignmentClauseSyntax instance.</summary>
    public static InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(SyntaxToken commaToken, ExpressionSyntax value)
    {
      if (value == null)
        throw new ArgumentNullException(nameof(value));
      return (InterpolationAlignmentClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.InterpolationAlignmentClause((Syntax.InternalSyntax.SyntaxToken)commaToken.Node, value == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)value.Green).CreateRed();
    }

    /// <summary>Creates a new InterpolationFormatClauseSyntax instance.</summary>
    public static InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken, SyntaxToken formatStringToken)
    {
      switch (formatStringToken.Kind())
      {
        case SyntaxKind.InterpolatedStringTextToken:
          break;
        default:
          throw new ArgumentException("formatStringToken");
      }
      return (InterpolationFormatClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.InterpolationFormatClause((Syntax.InternalSyntax.SyntaxToken)colonToken.Node, (Syntax.InternalSyntax.SyntaxToken)formatStringToken.Node).CreateRed();
    }

    /// <summary>Creates a new InterpolationFormatClauseSyntax instance.</summary>
    public static InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken)
    {
      return SyntaxFactory.InterpolationFormatClause(colonToken, SyntaxFactory.Token(SyntaxKind.InterpolatedStringTextToken));
    }

    /// <summary>Creates a new GlobalStatementSyntax instance.</summary>
    public static GlobalStatementSyntax GlobalStatement(StatementSyntax statement)
    {
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      return (GlobalStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.GlobalStatement(statement == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax)statement.Green).CreateRed();
    }

    /// <summary>Creates a new BlockSyntax instance.</summary>
    public static BlockSyntax Block(SyntaxToken openBraceToken, SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)
    {
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      return (BlockSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.Block((Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, statements.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node).CreateRed();
    }

    /// <summary>Creates a new BlockSyntax instance.</summary>
    public static BlockSyntax Block(SyntaxList<StatementSyntax> statements = default(SyntaxList<StatementSyntax>))
    {
      return SyntaxFactory.Block(SyntaxFactory.Token(SyntaxKind.OpenBraceToken), statements, SyntaxFactory.Token(SyntaxKind.CloseBraceToken));
    }

    /// <summary>Creates a new LocalFunctionStatementSyntax instance.</summary>
    public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, SyntaxToken refKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
      switch (refKeyword.Kind())
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (LocalFunctionStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.LocalFunctionStatement(modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), (Syntax.InternalSyntax.SyntaxToken)refKeyword.Node, returnType == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)returnType.Green, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, typeParameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax)typeParameterList.Green, parameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax)parameterList.Green, constraintClauses.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax>(), body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)body.Green, expressionBody == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax)expressionBody.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new LocalFunctionStatementSyntax instance.</summary>
    public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)
    {
      return SyntaxFactory.LocalFunctionStatement(modifiers, default(SyntaxToken), returnType, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, default(SyntaxToken));
    }

    /// <summary>Creates a new LocalFunctionStatementSyntax instance.</summary>
    public static LocalFunctionStatementSyntax LocalFunctionStatement(TypeSyntax returnType, SyntaxToken identifier)
    {
      return SyntaxFactory.LocalFunctionStatement(default(SyntaxTokenList), default(SyntaxToken), returnType, identifier, default(TypeParameterListSyntax), SyntaxFactory.ParameterList(), default(SyntaxList<TypeParameterConstraintClauseSyntax>), default(BlockSyntax), default(ArrowExpressionClauseSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new LocalFunctionStatementSyntax instance.</summary>
    public static LocalFunctionStatementSyntax LocalFunctionStatement(TypeSyntax returnType, string identifier)
    {
      return SyntaxFactory.LocalFunctionStatement(default(SyntaxTokenList), default(SyntaxToken), returnType, SyntaxFactory.Identifier(identifier), default(TypeParameterListSyntax), SyntaxFactory.ParameterList(), default(SyntaxList<TypeParameterConstraintClauseSyntax>), default(BlockSyntax), default(ArrowExpressionClauseSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new LocalDeclarationStatementSyntax instance.</summary>
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxTokenList modifiers, SyntaxToken refKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
      switch (refKeyword.Kind())
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (LocalDeclarationStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.LocalDeclarationStatement(modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), (Syntax.InternalSyntax.SyntaxToken)refKeyword.Node, declaration == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeclarationSyntax)declaration.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new LocalDeclarationStatementSyntax instance.</summary>
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxTokenList modifiers, VariableDeclarationSyntax declaration)
    {
      return SyntaxFactory.LocalDeclarationStatement(modifiers, default(SyntaxToken), declaration, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new LocalDeclarationStatementSyntax instance.</summary>
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(VariableDeclarationSyntax declaration)
    {
      return SyntaxFactory.LocalDeclarationStatement(default(SyntaxTokenList), default(SyntaxToken), declaration, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new VariableDeconstructionDeclaratorSyntax instance.</summary>
    public static VariableDeconstructionDeclaratorSyntax VariableDeconstructionDeclarator(SyntaxToken openParenToken, SeparatedSyntaxList<VariableDeclarationSyntax> variables, SyntaxToken closeParenToken, SyntaxToken equalsToken, ExpressionSyntax value)
    {
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      switch (equalsToken.Kind())
      {
        case SyntaxKind.EqualsToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      return (VariableDeconstructionDeclaratorSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.VariableDeconstructionDeclarator((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, variables.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeclarationSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node, (Syntax.InternalSyntax.SyntaxToken)equalsToken.Node, value == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)value.Green).CreateRed();
    }

    /// <summary>Creates a new VariableDeconstructionDeclaratorSyntax instance.</summary>
    public static VariableDeconstructionDeclaratorSyntax VariableDeconstructionDeclarator(SeparatedSyntaxList<VariableDeclarationSyntax> variables, ExpressionSyntax value)
    {
      return SyntaxFactory.VariableDeconstructionDeclarator(SyntaxFactory.Token(SyntaxKind.OpenParenToken), variables, SyntaxFactory.Token(SyntaxKind.CloseParenToken), default(SyntaxToken), value);
    }

    /// <summary>Creates a new VariableDeconstructionDeclaratorSyntax instance.</summary>
    public static VariableDeconstructionDeclaratorSyntax VariableDeconstructionDeclarator(SeparatedSyntaxList<VariableDeclarationSyntax> variables = default(SeparatedSyntaxList<VariableDeclarationSyntax>))
    {
      return SyntaxFactory.VariableDeconstructionDeclarator(SyntaxFactory.Token(SyntaxKind.OpenParenToken), variables, SyntaxFactory.Token(SyntaxKind.CloseParenToken), default(SyntaxToken), default(ExpressionSyntax));
    }

    /// <summary>Creates a new VariableDeclarationSyntax instance.</summary>
    internal static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SeparatedSyntaxList<VariableDeclaratorSyntax> variables, VariableDeconstructionDeclaratorSyntax deconstruction)
    {
      return (VariableDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.VariableDeclaration(type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, variables.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeclaratorSyntax>(), deconstruction == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeconstructionDeclaratorSyntax)deconstruction.Green).CreateRed();
    }

    /// <summary>Creates a new VariableDeclaratorSyntax instance.</summary>
    public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
    {
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      return (VariableDeclaratorSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.VariableDeclarator((Syntax.InternalSyntax.SyntaxToken)identifier.Node, argumentList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedArgumentListSyntax)argumentList.Green, initializer == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EqualsValueClauseSyntax)initializer.Green).CreateRed();
    }

    /// <summary>Creates a new VariableDeclaratorSyntax instance.</summary>
    public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier)
    {
      return SyntaxFactory.VariableDeclarator(identifier, default(BracketedArgumentListSyntax), default(EqualsValueClauseSyntax));
    }

    /// <summary>Creates a new VariableDeclaratorSyntax instance.</summary>
    public static VariableDeclaratorSyntax VariableDeclarator(string identifier)
    {
      return SyntaxFactory.VariableDeclarator(SyntaxFactory.Identifier(identifier), default(BracketedArgumentListSyntax), default(EqualsValueClauseSyntax));
    }

    /// <summary>Creates a new EqualsValueClauseSyntax instance.</summary>
    public static EqualsValueClauseSyntax EqualsValueClause(SyntaxToken equalsToken, SyntaxToken refKeyword, ExpressionSyntax value)
    {
      switch (equalsToken.Kind())
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      switch (refKeyword.Kind())
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      if (value == null)
        throw new ArgumentNullException(nameof(value));
      return (EqualsValueClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.EqualsValueClause((Syntax.InternalSyntax.SyntaxToken)equalsToken.Node, (Syntax.InternalSyntax.SyntaxToken)refKeyword.Node, value == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)value.Green).CreateRed();
    }

    /// <summary>Creates a new EqualsValueClauseSyntax instance.</summary>
    public static EqualsValueClauseSyntax EqualsValueClause(ExpressionSyntax value)
    {
      return SyntaxFactory.EqualsValueClause(SyntaxFactory.Token(SyntaxKind.EqualsToken), default(SyntaxToken), value);
    }

    /// <summary>Creates a new ExpressionStatementSyntax instance.</summary>
    public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (ExpressionStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ExpressionStatement(expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new ExpressionStatementSyntax instance.</summary>
    public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression)
    {
      return SyntaxFactory.ExpressionStatement(expression, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new EmptyStatementSyntax instance.</summary>
    public static EmptyStatementSyntax EmptyStatement(SyntaxToken semicolonToken)
    {
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (EmptyStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.EmptyStatement((Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new EmptyStatementSyntax instance.</summary>
    public static EmptyStatementSyntax EmptyStatement()
    {
      return SyntaxFactory.EmptyStatement(SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new LabeledStatementSyntax instance.</summary>
    public static LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
    {
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      switch (colonToken.Kind())
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      return (LabeledStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.LabeledStatement((Syntax.InternalSyntax.SyntaxToken)identifier.Node, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node, statement == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax)statement.Green).CreateRed();
    }

    /// <summary>Creates a new LabeledStatementSyntax instance.</summary>
    public static LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, StatementSyntax statement)
    {
      return SyntaxFactory.LabeledStatement(identifier, SyntaxFactory.Token(SyntaxKind.ColonToken), statement);
    }

    /// <summary>Creates a new LabeledStatementSyntax instance.</summary>
    public static LabeledStatementSyntax LabeledStatement(string identifier, StatementSyntax statement)
    {
      return SyntaxFactory.LabeledStatement(SyntaxFactory.Identifier(identifier), SyntaxFactory.Token(SyntaxKind.ColonToken), statement);
    }

    /// <summary>Creates a new GotoStatementSyntax instance.</summary>
    public static GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.GotoStatement:
        case SyntaxKind.GotoCaseStatement:
        case SyntaxKind.GotoDefaultStatement:
          break;
        default:
          throw new ArgumentException("kind");
      }
      switch (gotoKeyword.Kind())
      {
        case SyntaxKind.GotoKeyword:
          break;
        default:
          throw new ArgumentException("gotoKeyword");
      }
      switch (caseOrDefaultKeyword.Kind())
      {
        case SyntaxKind.CaseKeyword:
        case SyntaxKind.DefaultKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("caseOrDefaultKeyword");
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (GotoStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.GotoStatement(kind, (Syntax.InternalSyntax.SyntaxToken)gotoKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)caseOrDefaultKeyword.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new GotoStatementSyntax instance.</summary>
    public static GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression)
    {
      return SyntaxFactory.GotoStatement(kind, SyntaxFactory.Token(SyntaxKind.GotoKeyword), caseOrDefaultKeyword, expression, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new GotoStatementSyntax instance.</summary>
    public static GotoStatementSyntax GotoStatement(SyntaxKind kind, ExpressionSyntax expression = default(ExpressionSyntax))
    {
      return SyntaxFactory.GotoStatement(kind, SyntaxFactory.Token(SyntaxKind.GotoKeyword), default(SyntaxToken), expression, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new BreakStatementSyntax instance.</summary>
    public static BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
    {
      switch (breakKeyword.Kind())
      {
        case SyntaxKind.BreakKeyword:
          break;
        default:
          throw new ArgumentException("breakKeyword");
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (BreakStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.BreakStatement((Syntax.InternalSyntax.SyntaxToken)breakKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new BreakStatementSyntax instance.</summary>
    public static BreakStatementSyntax BreakStatement()
    {
      return SyntaxFactory.BreakStatement(SyntaxFactory.Token(SyntaxKind.BreakKeyword), SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new ContinueStatementSyntax instance.</summary>
    public static ContinueStatementSyntax ContinueStatement(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
    {
      switch (continueKeyword.Kind())
      {
        case SyntaxKind.ContinueKeyword:
          break;
        default:
          throw new ArgumentException("continueKeyword");
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (ContinueStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ContinueStatement((Syntax.InternalSyntax.SyntaxToken)continueKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new ContinueStatementSyntax instance.</summary>
    public static ContinueStatementSyntax ContinueStatement()
    {
      return SyntaxFactory.ContinueStatement(SyntaxFactory.Token(SyntaxKind.ContinueKeyword), SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new ReturnStatementSyntax instance.</summary>
    public static ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, SyntaxToken refKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (returnKeyword.Kind())
      {
        case SyntaxKind.ReturnKeyword:
          break;
        default:
          throw new ArgumentException("returnKeyword");
      }
      switch (refKeyword.Kind())
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (ReturnStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ReturnStatement((Syntax.InternalSyntax.SyntaxToken)returnKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)refKeyword.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new ReturnStatementSyntax instance.</summary>
    public static ReturnStatementSyntax ReturnStatement(ExpressionSyntax expression = default(ExpressionSyntax))
    {
      return SyntaxFactory.ReturnStatement(SyntaxFactory.Token(SyntaxKind.ReturnKeyword), default(SyntaxToken), expression, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new ThrowStatementSyntax instance.</summary>
    public static ThrowStatementSyntax ThrowStatement(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (throwKeyword.Kind())
      {
        case SyntaxKind.ThrowKeyword:
          break;
        default:
          throw new ArgumentException("throwKeyword");
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (ThrowStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ThrowStatement((Syntax.InternalSyntax.SyntaxToken)throwKeyword.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new ThrowStatementSyntax instance.</summary>
    public static ThrowStatementSyntax ThrowStatement(ExpressionSyntax expression = default(ExpressionSyntax))
    {
      return SyntaxFactory.ThrowStatement(SyntaxFactory.Token(SyntaxKind.ThrowKeyword), expression, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new YieldStatementSyntax instance.</summary>
    public static YieldStatementSyntax YieldStatement(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.YieldReturnStatement:
        case SyntaxKind.YieldBreakStatement:
          break;
        default:
          throw new ArgumentException("kind");
      }
      switch (yieldKeyword.Kind())
      {
        case SyntaxKind.YieldKeyword:
          break;
        default:
          throw new ArgumentException("yieldKeyword");
      }
      switch (returnOrBreakKeyword.Kind())
      {
        case SyntaxKind.ReturnKeyword:
        case SyntaxKind.BreakKeyword:
          break;
        default:
          throw new ArgumentException("returnOrBreakKeyword");
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (YieldStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.YieldStatement(kind, (Syntax.InternalSyntax.SyntaxToken)yieldKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)returnOrBreakKeyword.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new YieldStatementSyntax instance.</summary>
    public static YieldStatementSyntax YieldStatement(SyntaxKind kind, ExpressionSyntax expression = default(ExpressionSyntax))
    {
      return SyntaxFactory.YieldStatement(kind, SyntaxFactory.Token(SyntaxKind.YieldKeyword), SyntaxFactory.Token(GetYieldStatementReturnOrBreakKeywordKind(kind)), expression, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    private static SyntaxKind GetYieldStatementReturnOrBreakKeywordKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.YieldReturnStatement:
          return SyntaxKind.ReturnKeyword;
        case SyntaxKind.YieldBreakStatement:
          return SyntaxKind.BreakKeyword;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new WhileStatementSyntax instance.</summary>
    public static WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
    {
      switch (whileKeyword.Kind())
      {
        case SyntaxKind.WhileKeyword:
          break;
        default:
          throw new ArgumentException("whileKeyword");
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      return (WhileStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.WhileStatement((Syntax.InternalSyntax.SyntaxToken)whileKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, condition == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node, statement == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax)statement.Green).CreateRed();
    }

    /// <summary>Creates a new WhileStatementSyntax instance.</summary>
    public static WhileStatementSyntax WhileStatement(ExpressionSyntax condition, StatementSyntax statement)
    {
      return SyntaxFactory.WhileStatement(SyntaxFactory.Token(SyntaxKind.WhileKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), condition, SyntaxFactory.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new DoStatementSyntax instance.</summary>
    public static DoStatementSyntax DoStatement(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
    {
      switch (doKeyword.Kind())
      {
        case SyntaxKind.DoKeyword:
          break;
        default:
          throw new ArgumentException("doKeyword");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      switch (whileKeyword.Kind())
      {
        case SyntaxKind.WhileKeyword:
          break;
        default:
          throw new ArgumentException("whileKeyword");
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (DoStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.DoStatement((Syntax.InternalSyntax.SyntaxToken)doKeyword.Node, statement == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax)statement.Green, (Syntax.InternalSyntax.SyntaxToken)whileKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, condition == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new DoStatementSyntax instance.</summary>
    public static DoStatementSyntax DoStatement(StatementSyntax statement, ExpressionSyntax condition)
    {
      return SyntaxFactory.DoStatement(SyntaxFactory.Token(SyntaxKind.DoKeyword), statement, SyntaxFactory.Token(SyntaxKind.WhileKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), condition, SyntaxFactory.Token(SyntaxKind.CloseParenToken), SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new ForStatementSyntax instance.</summary>
    public static ForStatementSyntax ForStatement(SyntaxToken forKeyword, SyntaxToken openParenToken, SyntaxToken refKeyword, VariableDeclarationSyntax declaration, SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
    {
      switch (forKeyword.Kind())
      {
        case SyntaxKind.ForKeyword:
          break;
        default:
          throw new ArgumentException("forKeyword");
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      switch (refKeyword.Kind())
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      switch (firstSemicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("firstSemicolonToken");
      }
      switch (secondSemicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("secondSemicolonToken");
      }
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      return (ForStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ForStatement((Syntax.InternalSyntax.SyntaxToken)forKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, (Syntax.InternalSyntax.SyntaxToken)refKeyword.Node, declaration == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeclarationSyntax)declaration.Green, initializers.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax>(), (Syntax.InternalSyntax.SyntaxToken)firstSemicolonToken.Node, condition == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken)secondSemicolonToken.Node, incrementors.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node, statement == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax)statement.Green).CreateRed();
    }

    /// <summary>Creates a new ForStatementSyntax instance.</summary>
    public static ForStatementSyntax ForStatement(VariableDeclarationSyntax declaration, SeparatedSyntaxList<ExpressionSyntax> initializers, ExpressionSyntax condition, SeparatedSyntaxList<ExpressionSyntax> incrementors, StatementSyntax statement)
    {
      return SyntaxFactory.ForStatement(SyntaxFactory.Token(SyntaxKind.ForKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), default(SyntaxToken), declaration, initializers, SyntaxFactory.Token(SyntaxKind.SemicolonToken), condition, SyntaxFactory.Token(SyntaxKind.SemicolonToken), incrementors, SyntaxFactory.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new ForStatementSyntax instance.</summary>
    public static ForStatementSyntax ForStatement(StatementSyntax statement)
    {
      return SyntaxFactory.ForStatement(SyntaxFactory.Token(SyntaxKind.ForKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), default(SyntaxToken), default(VariableDeclarationSyntax), default(SeparatedSyntaxList<ExpressionSyntax>), SyntaxFactory.Token(SyntaxKind.SemicolonToken), default(ExpressionSyntax), SyntaxFactory.Token(SyntaxKind.SemicolonToken), default(SeparatedSyntaxList<ExpressionSyntax>), SyntaxFactory.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new ForEachStatementSyntax instance.</summary>
    public static ForEachStatementSyntax ForEachStatement(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, VariableDeclarationSyntax deconstructionVariables, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
      switch (forEachKeyword.Kind())
      {
        case SyntaxKind.ForEachKeyword:
          break;
        default:
          throw new ArgumentException("forEachKeyword");
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      switch (inKeyword.Kind())
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException("inKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      return (ForEachStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ForEachStatement((Syntax.InternalSyntax.SyntaxToken)forEachKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, deconstructionVariables == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeclarationSyntax)deconstructionVariables.Green, (Syntax.InternalSyntax.SyntaxToken)inKeyword.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node, statement == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax)statement.Green).CreateRed();
    }

    /// <summary>Creates a new ForEachStatementSyntax instance.</summary>
    public static ForEachStatementSyntax ForEachStatement(TypeSyntax type, SyntaxToken identifier, VariableDeclarationSyntax deconstructionVariables, ExpressionSyntax expression, StatementSyntax statement)
    {
      return SyntaxFactory.ForEachStatement(SyntaxFactory.Token(SyntaxKind.ForEachKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), type, identifier, deconstructionVariables, SyntaxFactory.Token(SyntaxKind.InKeyword), expression, SyntaxFactory.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new ForEachStatementSyntax instance.</summary>
    public static ForEachStatementSyntax ForEachStatement(ExpressionSyntax expression, StatementSyntax statement)
    {
      return SyntaxFactory.ForEachStatement(SyntaxFactory.Token(SyntaxKind.ForEachKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), default(TypeSyntax), default(SyntaxToken), default(VariableDeclarationSyntax), SyntaxFactory.Token(SyntaxKind.InKeyword), expression, SyntaxFactory.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new UsingStatementSyntax instance.</summary>
    public static UsingStatementSyntax UsingStatement(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
      switch (usingKeyword.Kind())
      {
        case SyntaxKind.UsingKeyword:
          break;
        default:
          throw new ArgumentException("usingKeyword");
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      return (UsingStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.UsingStatement((Syntax.InternalSyntax.SyntaxToken)usingKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, declaration == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeclarationSyntax)declaration.Green, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node, statement == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax)statement.Green).CreateRed();
    }

    /// <summary>Creates a new UsingStatementSyntax instance.</summary>
    public static UsingStatementSyntax UsingStatement(VariableDeclarationSyntax declaration, ExpressionSyntax expression, StatementSyntax statement)
    {
      return SyntaxFactory.UsingStatement(SyntaxFactory.Token(SyntaxKind.UsingKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), declaration, expression, SyntaxFactory.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new UsingStatementSyntax instance.</summary>
    public static UsingStatementSyntax UsingStatement(StatementSyntax statement)
    {
      return SyntaxFactory.UsingStatement(SyntaxFactory.Token(SyntaxKind.UsingKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), default(VariableDeclarationSyntax), default(ExpressionSyntax), SyntaxFactory.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new FixedStatementSyntax instance.</summary>
    public static FixedStatementSyntax FixedStatement(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
    {
      switch (fixedKeyword.Kind())
      {
        case SyntaxKind.FixedKeyword:
          break;
        default:
          throw new ArgumentException("fixedKeyword");
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      return (FixedStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.FixedStatement((Syntax.InternalSyntax.SyntaxToken)fixedKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, declaration == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeclarationSyntax)declaration.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node, statement == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax)statement.Green).CreateRed();
    }

    /// <summary>Creates a new FixedStatementSyntax instance.</summary>
    public static FixedStatementSyntax FixedStatement(VariableDeclarationSyntax declaration, StatementSyntax statement)
    {
      return SyntaxFactory.FixedStatement(SyntaxFactory.Token(SyntaxKind.FixedKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), declaration, SyntaxFactory.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new CheckedStatementSyntax instance.</summary>
    public static CheckedStatementSyntax CheckedStatement(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedStatement:
        case SyntaxKind.UncheckedStatement:
          break;
        default:
          throw new ArgumentException("kind");
      }
      switch (keyword.Kind())
      {
        case SyntaxKind.CheckedKeyword:
        case SyntaxKind.UncheckedKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
      return (CheckedStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CheckedStatement(kind, (Syntax.InternalSyntax.SyntaxToken)keyword.Node, block == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)block.Green).CreateRed();
    }

    /// <summary>Creates a new CheckedStatementSyntax instance.</summary>
    public static CheckedStatementSyntax CheckedStatement(SyntaxKind kind, BlockSyntax block = default(BlockSyntax))
    {
      return SyntaxFactory.CheckedStatement(kind, SyntaxFactory.Token(GetCheckedStatementKeywordKind(kind)), block ?? SyntaxFactory.Block());
    }

    private static SyntaxKind GetCheckedStatementKeywordKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedStatement:
          return SyntaxKind.CheckedKeyword;
        case SyntaxKind.UncheckedStatement:
          return SyntaxKind.UncheckedKeyword;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new UnsafeStatementSyntax instance.</summary>
    public static UnsafeStatementSyntax UnsafeStatement(SyntaxToken unsafeKeyword, BlockSyntax block)
    {
      switch (unsafeKeyword.Kind())
      {
        case SyntaxKind.UnsafeKeyword:
          break;
        default:
          throw new ArgumentException("unsafeKeyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
      return (UnsafeStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.UnsafeStatement((Syntax.InternalSyntax.SyntaxToken)unsafeKeyword.Node, block == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)block.Green).CreateRed();
    }

    /// <summary>Creates a new UnsafeStatementSyntax instance.</summary>
    public static UnsafeStatementSyntax UnsafeStatement(BlockSyntax block = default(BlockSyntax))
    {
      return SyntaxFactory.UnsafeStatement(SyntaxFactory.Token(SyntaxKind.UnsafeKeyword), block ?? SyntaxFactory.Block());
    }

    /// <summary>Creates a new LockStatementSyntax instance.</summary>
    public static LockStatementSyntax LockStatement(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
      switch (lockKeyword.Kind())
      {
        case SyntaxKind.LockKeyword:
          break;
        default:
          throw new ArgumentException("lockKeyword");
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      return (LockStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.LockStatement((Syntax.InternalSyntax.SyntaxToken)lockKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node, statement == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax)statement.Green).CreateRed();
    }

    /// <summary>Creates a new LockStatementSyntax instance.</summary>
    public static LockStatementSyntax LockStatement(ExpressionSyntax expression, StatementSyntax statement)
    {
      return SyntaxFactory.LockStatement(SyntaxFactory.Token(SyntaxKind.LockKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), expression, SyntaxFactory.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new IfStatementSyntax instance.</summary>
    public static IfStatementSyntax IfStatement(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)
    {
      switch (ifKeyword.Kind())
      {
        case SyntaxKind.IfKeyword:
          break;
        default:
          throw new ArgumentException("ifKeyword");
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      return (IfStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.IfStatement((Syntax.InternalSyntax.SyntaxToken)ifKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, condition == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node, statement == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax)statement.Green, @else == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElseClauseSyntax)@else.Green).CreateRed();
    }

    /// <summary>Creates a new IfStatementSyntax instance.</summary>
    public static IfStatementSyntax IfStatement(ExpressionSyntax condition, StatementSyntax statement, ElseClauseSyntax @else)
    {
      return SyntaxFactory.IfStatement(SyntaxFactory.Token(SyntaxKind.IfKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), condition, SyntaxFactory.Token(SyntaxKind.CloseParenToken), statement, @else);
    }

    /// <summary>Creates a new IfStatementSyntax instance.</summary>
    public static IfStatementSyntax IfStatement(ExpressionSyntax condition, StatementSyntax statement)
    {
      return SyntaxFactory.IfStatement(SyntaxFactory.Token(SyntaxKind.IfKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), condition, SyntaxFactory.Token(SyntaxKind.CloseParenToken), statement, default(ElseClauseSyntax));
    }

    /// <summary>Creates a new ElseClauseSyntax instance.</summary>
    public static ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StatementSyntax statement)
    {
      switch (elseKeyword.Kind())
      {
        case SyntaxKind.ElseKeyword:
          break;
        default:
          throw new ArgumentException("elseKeyword");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      return (ElseClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ElseClause((Syntax.InternalSyntax.SyntaxToken)elseKeyword.Node, statement == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax)statement.Green).CreateRed();
    }

    /// <summary>Creates a new ElseClauseSyntax instance.</summary>
    public static ElseClauseSyntax ElseClause(StatementSyntax statement)
    {
      return SyntaxFactory.ElseClause(SyntaxFactory.Token(SyntaxKind.ElseKeyword), statement);
    }

    /// <summary>Creates a new SwitchStatementSyntax instance.</summary>
    public static SwitchStatementSyntax SwitchStatement(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)
    {
      switch (switchKeyword.Kind())
      {
        case SyntaxKind.SwitchKeyword:
          break;
        default:
          throw new ArgumentException("switchKeyword");
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      return (SwitchStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.SwitchStatement((Syntax.InternalSyntax.SyntaxToken)switchKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node, (Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, sections.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchSectionSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node).CreateRed();
    }

    /// <summary>Creates a new SwitchStatementSyntax instance.</summary>
    public static SwitchStatementSyntax SwitchStatement(ExpressionSyntax expression, SyntaxList<SwitchSectionSyntax> sections)
    {
      return SyntaxFactory.SwitchStatement(SyntaxFactory.Token(SyntaxKind.SwitchKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), expression, SyntaxFactory.Token(SyntaxKind.CloseParenToken), SyntaxFactory.Token(SyntaxKind.OpenBraceToken), sections, SyntaxFactory.Token(SyntaxKind.CloseBraceToken));
    }

    /// <summary>Creates a new SwitchStatementSyntax instance.</summary>
    public static SwitchStatementSyntax SwitchStatement(ExpressionSyntax expression)
    {
      return SyntaxFactory.SwitchStatement(SyntaxFactory.Token(SyntaxKind.SwitchKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), expression, SyntaxFactory.Token(SyntaxKind.CloseParenToken), SyntaxFactory.Token(SyntaxKind.OpenBraceToken), default(SyntaxList<SwitchSectionSyntax>), SyntaxFactory.Token(SyntaxKind.CloseBraceToken));
    }

    /// <summary>Creates a new SwitchSectionSyntax instance.</summary>
    public static SwitchSectionSyntax SwitchSection(SyntaxList<SwitchLabelSyntax> labels, SyntaxList<StatementSyntax> statements)
    {
      return (SwitchSectionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.SwitchSection(labels.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchLabelSyntax>(), statements.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax>()).CreateRed();
    }

    /// <summary>Creates a new SwitchSectionSyntax instance.</summary>
    public static SwitchSectionSyntax SwitchSection()
    {
      return SyntaxFactory.SwitchSection(default(SyntaxList<SwitchLabelSyntax>), default(SyntaxList<StatementSyntax>));
    }

    /// <summary>Creates a new CasePatternSwitchLabelSyntax instance.</summary>
    public static CasePatternSwitchLabelSyntax CasePatternSwitchLabel(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.CaseKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (pattern == null)
        throw new ArgumentNullException(nameof(pattern));
      return (CasePatternSwitchLabelSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CasePatternSwitchLabel((Syntax.InternalSyntax.SyntaxToken)keyword.Node, pattern == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PatternSyntax)pattern.Green, whenClause == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.WhenClauseSyntax)whenClause.Green, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node).CreateRed();
    }

    /// <summary>Creates a new CasePatternSwitchLabelSyntax instance.</summary>
    public static CasePatternSwitchLabelSyntax CasePatternSwitchLabel(PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)
    {
      return SyntaxFactory.CasePatternSwitchLabel(SyntaxFactory.Token(SyntaxKind.CaseKeyword), pattern, whenClause, colonToken);
    }

    /// <summary>Creates a new CasePatternSwitchLabelSyntax instance.</summary>
    public static CasePatternSwitchLabelSyntax CasePatternSwitchLabel(PatternSyntax pattern, SyntaxToken colonToken)
    {
      return SyntaxFactory.CasePatternSwitchLabel(SyntaxFactory.Token(SyntaxKind.CaseKeyword), pattern, default(WhenClauseSyntax), colonToken);
    }

    /// <summary>Creates a new CaseSwitchLabelSyntax instance.</summary>
    public static CaseSwitchLabelSyntax CaseSwitchLabel(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.CaseKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (value == null)
        throw new ArgumentNullException(nameof(value));
      return (CaseSwitchLabelSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CaseSwitchLabel((Syntax.InternalSyntax.SyntaxToken)keyword.Node, value == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)value.Green, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node).CreateRed();
    }

    /// <summary>Creates a new CaseSwitchLabelSyntax instance.</summary>
    public static CaseSwitchLabelSyntax CaseSwitchLabel(ExpressionSyntax value, SyntaxToken colonToken)
    {
      return SyntaxFactory.CaseSwitchLabel(SyntaxFactory.Token(SyntaxKind.CaseKeyword), value, colonToken);
    }

    /// <summary>Creates a new DefaultSwitchLabelSyntax instance.</summary>
    public static DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken keyword, SyntaxToken colonToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      return (DefaultSwitchLabelSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.DefaultSwitchLabel((Syntax.InternalSyntax.SyntaxToken)keyword.Node, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node).CreateRed();
    }

    /// <summary>Creates a new DefaultSwitchLabelSyntax instance.</summary>
    public static DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken colonToken)
    {
      return SyntaxFactory.DefaultSwitchLabel(SyntaxFactory.Token(SyntaxKind.DefaultKeyword), colonToken);
    }

    /// <summary>Creates a new TryStatementSyntax instance.</summary>
    public static TryStatementSyntax TryStatement(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
    {
      switch (tryKeyword.Kind())
      {
        case SyntaxKind.TryKeyword:
          break;
        default:
          throw new ArgumentException("tryKeyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
      return (TryStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.TryStatement((Syntax.InternalSyntax.SyntaxToken)tryKeyword.Node, block == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)block.Green, catches.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CatchClauseSyntax>(), @finally == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FinallyClauseSyntax)@finally.Green).CreateRed();
    }

    /// <summary>Creates a new TryStatementSyntax instance.</summary>
    public static TryStatementSyntax TryStatement(BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
    {
      return SyntaxFactory.TryStatement(SyntaxFactory.Token(SyntaxKind.TryKeyword), block, catches, @finally);
    }

    /// <summary>Creates a new TryStatementSyntax instance.</summary>
    public static TryStatementSyntax TryStatement(SyntaxList<CatchClauseSyntax> catches = default(SyntaxList<CatchClauseSyntax>))
    {
      return SyntaxFactory.TryStatement(SyntaxFactory.Token(SyntaxKind.TryKeyword), SyntaxFactory.Block(), catches, default(FinallyClauseSyntax));
    }

    /// <summary>Creates a new CatchClauseSyntax instance.</summary>
    public static CatchClauseSyntax CatchClause(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)
    {
      switch (catchKeyword.Kind())
      {
        case SyntaxKind.CatchKeyword:
          break;
        default:
          throw new ArgumentException("catchKeyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
      return (CatchClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CatchClause((Syntax.InternalSyntax.SyntaxToken)catchKeyword.Node, declaration == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CatchDeclarationSyntax)declaration.Green, filter == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CatchFilterClauseSyntax)filter.Green, block == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)block.Green).CreateRed();
    }

    /// <summary>Creates a new CatchClauseSyntax instance.</summary>
    public static CatchClauseSyntax CatchClause(CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)
    {
      return SyntaxFactory.CatchClause(SyntaxFactory.Token(SyntaxKind.CatchKeyword), declaration, filter, block);
    }

    /// <summary>Creates a new CatchClauseSyntax instance.</summary>
    public static CatchClauseSyntax CatchClause()
    {
      return SyntaxFactory.CatchClause(SyntaxFactory.Token(SyntaxKind.CatchKeyword), default(CatchDeclarationSyntax), default(CatchFilterClauseSyntax), SyntaxFactory.Block());
    }

    /// <summary>Creates a new CatchDeclarationSyntax instance.</summary>
    public static CatchDeclarationSyntax CatchDeclaration(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
    {
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (CatchDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CatchDeclaration((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }

    /// <summary>Creates a new CatchDeclarationSyntax instance.</summary>
    public static CatchDeclarationSyntax CatchDeclaration(TypeSyntax type, SyntaxToken identifier)
    {
      return SyntaxFactory.CatchDeclaration(SyntaxFactory.Token(SyntaxKind.OpenParenToken), type, identifier, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new CatchDeclarationSyntax instance.</summary>
    public static CatchDeclarationSyntax CatchDeclaration(TypeSyntax type)
    {
      return SyntaxFactory.CatchDeclaration(SyntaxFactory.Token(SyntaxKind.OpenParenToken), type, default(SyntaxToken), SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new CatchFilterClauseSyntax instance.</summary>
    public static CatchFilterClauseSyntax CatchFilterClause(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)
    {
      switch (whenKeyword.Kind())
      {
        case SyntaxKind.WhenKeyword:
          break;
        default:
          throw new ArgumentException("whenKeyword");
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (filterExpression == null)
        throw new ArgumentNullException(nameof(filterExpression));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (CatchFilterClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CatchFilterClause((Syntax.InternalSyntax.SyntaxToken)whenKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, filterExpression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)filterExpression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }

    /// <summary>Creates a new CatchFilterClauseSyntax instance.</summary>
    public static CatchFilterClauseSyntax CatchFilterClause(ExpressionSyntax filterExpression)
    {
      return SyntaxFactory.CatchFilterClause(SyntaxFactory.Token(SyntaxKind.WhenKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), filterExpression, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new FinallyClauseSyntax instance.</summary>
    public static FinallyClauseSyntax FinallyClause(SyntaxToken finallyKeyword, BlockSyntax block)
    {
      switch (finallyKeyword.Kind())
      {
        case SyntaxKind.FinallyKeyword:
          break;
        default:
          throw new ArgumentException("finallyKeyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
      return (FinallyClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.FinallyClause((Syntax.InternalSyntax.SyntaxToken)finallyKeyword.Node, block == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)block.Green).CreateRed();
    }

    /// <summary>Creates a new FinallyClauseSyntax instance.</summary>
    public static FinallyClauseSyntax FinallyClause(BlockSyntax block = default(BlockSyntax))
    {
      return SyntaxFactory.FinallyClause(SyntaxFactory.Token(SyntaxKind.FinallyKeyword), block ?? SyntaxFactory.Block());
    }

    /// <summary>Creates a new CompilationUnitSyntax instance.</summary>
    public static CompilationUnitSyntax CompilationUnit(SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)
    {
      switch (endOfFileToken.Kind())
      {
        case SyntaxKind.EndOfFileToken:
          break;
        default:
          throw new ArgumentException("endOfFileToken");
      }
      return (CompilationUnitSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CompilationUnit(externs.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExternAliasDirectiveSyntax>(), usings.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.UsingDirectiveSyntax>(), attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), members.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberDeclarationSyntax>(), (Syntax.InternalSyntax.SyntaxToken)endOfFileToken.Node).CreateRed();
    }

    /// <summary>Creates a new CompilationUnitSyntax instance.</summary>
    public static CompilationUnitSyntax CompilationUnit(SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<MemberDeclarationSyntax> members)
    {
      return SyntaxFactory.CompilationUnit(externs, usings, attributeLists, members, SyntaxFactory.Token(SyntaxKind.EndOfFileToken));
    }

    /// <summary>Creates a new CompilationUnitSyntax instance.</summary>
    public static CompilationUnitSyntax CompilationUnit()
    {
      return SyntaxFactory.CompilationUnit(default(SyntaxList<ExternAliasDirectiveSyntax>), default(SyntaxList<UsingDirectiveSyntax>), default(SyntaxList<AttributeListSyntax>), default(SyntaxList<MemberDeclarationSyntax>), SyntaxFactory.Token(SyntaxKind.EndOfFileToken));
    }

    /// <summary>Creates a new ExternAliasDirectiveSyntax instance.</summary>
    public static ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
    {
      switch (externKeyword.Kind())
      {
        case SyntaxKind.ExternKeyword:
          break;
        default:
          throw new ArgumentException("externKeyword");
      }
      switch (aliasKeyword.Kind())
      {
        case SyntaxKind.AliasKeyword:
          break;
        default:
          throw new ArgumentException("aliasKeyword");
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (ExternAliasDirectiveSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ExternAliasDirective((Syntax.InternalSyntax.SyntaxToken)externKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)aliasKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new ExternAliasDirectiveSyntax instance.</summary>
    public static ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken identifier)
    {
      return SyntaxFactory.ExternAliasDirective(SyntaxFactory.Token(SyntaxKind.ExternKeyword), SyntaxFactory.Token(SyntaxKind.AliasKeyword), identifier, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new ExternAliasDirectiveSyntax instance.</summary>
    public static ExternAliasDirectiveSyntax ExternAliasDirective(string identifier)
    {
      return SyntaxFactory.ExternAliasDirective(SyntaxFactory.Token(SyntaxKind.ExternKeyword), SyntaxFactory.Token(SyntaxKind.AliasKeyword), SyntaxFactory.Identifier(identifier), SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new UsingDirectiveSyntax instance.</summary>
    public static UsingDirectiveSyntax UsingDirective(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)
    {
      switch (usingKeyword.Kind())
      {
        case SyntaxKind.UsingKeyword:
          break;
        default:
          throw new ArgumentException("usingKeyword");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (UsingDirectiveSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.UsingDirective((Syntax.InternalSyntax.SyntaxToken)usingKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)staticKeyword.Node, alias == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameEqualsSyntax)alias.Green, name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new UsingDirectiveSyntax instance.</summary>
    public static UsingDirectiveSyntax UsingDirective(SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name)
    {
      return SyntaxFactory.UsingDirective(SyntaxFactory.Token(SyntaxKind.UsingKeyword), staticKeyword, alias, name, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new UsingDirectiveSyntax instance.</summary>
    public static UsingDirectiveSyntax UsingDirective(NameSyntax name)
    {
      return SyntaxFactory.UsingDirective(SyntaxFactory.Token(SyntaxKind.UsingKeyword), default(SyntaxToken), default(NameEqualsSyntax), name, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new NamespaceDeclarationSyntax instance.</summary>
    public static NamespaceDeclarationSyntax NamespaceDeclaration(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
      switch (namespaceKeyword.Kind())
      {
        case SyntaxKind.NamespaceKeyword:
          break;
        default:
          throw new ArgumentException("namespaceKeyword");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (NamespaceDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.NamespaceDeclaration((Syntax.InternalSyntax.SyntaxToken)namespaceKeyword.Node, name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, externs.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExternAliasDirectiveSyntax>(), usings.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.UsingDirectiveSyntax>(), members.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberDeclarationSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new NamespaceDeclarationSyntax instance.</summary>
    public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members)
    {
      return SyntaxFactory.NamespaceDeclaration(SyntaxFactory.Token(SyntaxKind.NamespaceKeyword), name, SyntaxFactory.Token(SyntaxKind.OpenBraceToken), externs, usings, members, SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new NamespaceDeclarationSyntax instance.</summary>
    public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name)
    {
      return SyntaxFactory.NamespaceDeclaration(SyntaxFactory.Token(SyntaxKind.NamespaceKeyword), name, SyntaxFactory.Token(SyntaxKind.OpenBraceToken), default(SyntaxList<ExternAliasDirectiveSyntax>), default(SyntaxList<UsingDirectiveSyntax>), default(SyntaxList<MemberDeclarationSyntax>), SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new AttributeListSyntax instance.</summary>
    public static AttributeListSyntax AttributeList(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
    {
      switch (openBracketToken.Kind())
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      switch (closeBracketToken.Kind())
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
      return (AttributeListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AttributeList((Syntax.InternalSyntax.SyntaxToken)openBracketToken.Node, target == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeTargetSpecifierSyntax)target.Green, attributes.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBracketToken.Node).CreateRed();
    }

    /// <summary>Creates a new AttributeListSyntax instance.</summary>
    public static AttributeListSyntax AttributeList(AttributeTargetSpecifierSyntax target, SeparatedSyntaxList<AttributeSyntax> attributes)
    {
      return SyntaxFactory.AttributeList(SyntaxFactory.Token(SyntaxKind.OpenBracketToken), target, attributes, SyntaxFactory.Token(SyntaxKind.CloseBracketToken));
    }

    /// <summary>Creates a new AttributeListSyntax instance.</summary>
    public static AttributeListSyntax AttributeList(SeparatedSyntaxList<AttributeSyntax> attributes = default(SeparatedSyntaxList<AttributeSyntax>))
    {
      return SyntaxFactory.AttributeList(SyntaxFactory.Token(SyntaxKind.OpenBracketToken), default(AttributeTargetSpecifierSyntax), attributes, SyntaxFactory.Token(SyntaxKind.CloseBracketToken));
    }

    /// <summary>Creates a new AttributeTargetSpecifierSyntax instance.</summary>
    public static AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier, SyntaxToken colonToken)
    {
      switch (colonToken.Kind())
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      return (AttributeTargetSpecifierSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AttributeTargetSpecifier((Syntax.InternalSyntax.SyntaxToken)identifier.Node, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node).CreateRed();
    }

    /// <summary>Creates a new AttributeTargetSpecifierSyntax instance.</summary>
    public static AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier)
    {
      return SyntaxFactory.AttributeTargetSpecifier(identifier, SyntaxFactory.Token(SyntaxKind.ColonToken));
    }

    /// <summary>Creates a new AttributeSyntax instance.</summary>
    public static AttributeSyntax Attribute(NameSyntax name, AttributeArgumentListSyntax argumentList)
    {
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      return (AttributeSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.Attribute(name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameSyntax)name.Green, argumentList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeArgumentListSyntax)argumentList.Green).CreateRed();
    }

    /// <summary>Creates a new AttributeSyntax instance.</summary>
    public static AttributeSyntax Attribute(NameSyntax name)
    {
      return SyntaxFactory.Attribute(name, default(AttributeArgumentListSyntax));
    }

    /// <summary>Creates a new AttributeArgumentListSyntax instance.</summary>
    public static AttributeArgumentListSyntax AttributeArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (AttributeArgumentListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AttributeArgumentList((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, arguments.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeArgumentSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }

    /// <summary>Creates a new AttributeArgumentListSyntax instance.</summary>
    public static AttributeArgumentListSyntax AttributeArgumentList(SeparatedSyntaxList<AttributeArgumentSyntax> arguments = default(SeparatedSyntaxList<AttributeArgumentSyntax>))
    {
      return SyntaxFactory.AttributeArgumentList(SyntaxFactory.Token(SyntaxKind.OpenParenToken), arguments, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new AttributeArgumentSyntax instance.</summary>
    public static AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
    {
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      return (AttributeArgumentSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AttributeArgument(nameEquals == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameEqualsSyntax)nameEquals.Green, nameColon == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameColonSyntax)nameColon.Green, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
    }

    /// <summary>Creates a new AttributeArgumentSyntax instance.</summary>
    public static AttributeArgumentSyntax AttributeArgument(ExpressionSyntax expression)
    {
      return SyntaxFactory.AttributeArgument(default(NameEqualsSyntax), default(NameColonSyntax), expression);
    }

    /// <summary>Creates a new NameEqualsSyntax instance.</summary>
    public static NameEqualsSyntax NameEquals(IdentifierNameSyntax name, SyntaxToken equalsToken)
    {
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (equalsToken.Kind())
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      return (NameEqualsSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.NameEquals(name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IdentifierNameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken)equalsToken.Node).CreateRed();
    }

    /// <summary>Creates a new NameEqualsSyntax instance.</summary>
    public static NameEqualsSyntax NameEquals(IdentifierNameSyntax name)
    {
      return SyntaxFactory.NameEquals(name, SyntaxFactory.Token(SyntaxKind.EqualsToken));
    }

    /// <summary>Creates a new NameEqualsSyntax instance.</summary>
    public static NameEqualsSyntax NameEquals(string name)
    {
      return SyntaxFactory.NameEquals(SyntaxFactory.IdentifierName(name), SyntaxFactory.Token(SyntaxKind.EqualsToken));
    }

    /// <summary>Creates a new TypeParameterListSyntax instance.</summary>
    public static TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
    {
      switch (lessThanToken.Kind())
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      switch (greaterThanToken.Kind())
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
      return (TypeParameterListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.TypeParameterList((Syntax.InternalSyntax.SyntaxToken)lessThanToken.Node, parameters.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterSyntax>(), (Syntax.InternalSyntax.SyntaxToken)greaterThanToken.Node).CreateRed();
    }

    /// <summary>Creates a new TypeParameterListSyntax instance.</summary>
    public static TypeParameterListSyntax TypeParameterList(SeparatedSyntaxList<TypeParameterSyntax> parameters = default(SeparatedSyntaxList<TypeParameterSyntax>))
    {
      return SyntaxFactory.TypeParameterList(SyntaxFactory.Token(SyntaxKind.LessThanToken), parameters, SyntaxFactory.Token(SyntaxKind.GreaterThanToken));
    }

    /// <summary>Creates a new TypeParameterSyntax instance.</summary>
    public static TypeParameterSyntax TypeParameter(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)
    {
      switch (varianceKeyword.Kind())
      {
        case SyntaxKind.InKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("varianceKeyword");
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      return (TypeParameterSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.TypeParameter(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), (Syntax.InternalSyntax.SyntaxToken)varianceKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)identifier.Node).CreateRed();
    }

    /// <summary>Creates a new TypeParameterSyntax instance.</summary>
    public static TypeParameterSyntax TypeParameter(SyntaxToken identifier)
    {
      return SyntaxFactory.TypeParameter(default(SyntaxList<AttributeListSyntax>), default(SyntaxToken), identifier);
    }

    /// <summary>Creates a new TypeParameterSyntax instance.</summary>
    public static TypeParameterSyntax TypeParameter(string identifier)
    {
      return SyntaxFactory.TypeParameter(default(SyntaxList<AttributeListSyntax>), default(SyntaxToken), SyntaxFactory.Identifier(identifier));
    }

    /// <summary>Creates a new ClassDeclarationSyntax instance.</summary>
    public static ClassDeclarationSyntax ClassDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.ClassKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (ClassDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ClassDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), (Syntax.InternalSyntax.SyntaxToken)keyword.Node, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, typeParameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax)typeParameterList.Green, baseList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseListSyntax)baseList.Green, constraintClauses.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax>(), (Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, members.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberDeclarationSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new ClassDeclarationSyntax instance.</summary>
    public static ClassDeclarationSyntax ClassDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList<MemberDeclarationSyntax> members)
    {
      return SyntaxFactory.ClassDeclaration(attributeLists, modifiers, SyntaxFactory.Token(SyntaxKind.ClassKeyword), identifier, typeParameterList, baseList, constraintClauses, SyntaxFactory.Token(SyntaxKind.OpenBraceToken), members, SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new ClassDeclarationSyntax instance.</summary>
    public static ClassDeclarationSyntax ClassDeclaration(SyntaxToken identifier)
    {
      return SyntaxFactory.ClassDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.ClassKeyword), identifier, default(TypeParameterListSyntax), default(BaseListSyntax), default(SyntaxList<TypeParameterConstraintClauseSyntax>), SyntaxFactory.Token(SyntaxKind.OpenBraceToken), default(SyntaxList<MemberDeclarationSyntax>), SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new ClassDeclarationSyntax instance.</summary>
    public static ClassDeclarationSyntax ClassDeclaration(string identifier)
    {
      return SyntaxFactory.ClassDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.ClassKeyword), SyntaxFactory.Identifier(identifier), default(TypeParameterListSyntax), default(BaseListSyntax), default(SyntaxList<TypeParameterConstraintClauseSyntax>), SyntaxFactory.Token(SyntaxKind.OpenBraceToken), default(SyntaxList<MemberDeclarationSyntax>), SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new StructDeclarationSyntax instance.</summary>
    public static StructDeclarationSyntax StructDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.StructKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (StructDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.StructDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), (Syntax.InternalSyntax.SyntaxToken)keyword.Node, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, typeParameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax)typeParameterList.Green, baseList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseListSyntax)baseList.Green, constraintClauses.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax>(), (Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, members.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberDeclarationSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new StructDeclarationSyntax instance.</summary>
    public static StructDeclarationSyntax StructDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList<MemberDeclarationSyntax> members)
    {
      return SyntaxFactory.StructDeclaration(attributeLists, modifiers, SyntaxFactory.Token(SyntaxKind.StructKeyword), identifier, typeParameterList, baseList, constraintClauses, SyntaxFactory.Token(SyntaxKind.OpenBraceToken), members, SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new StructDeclarationSyntax instance.</summary>
    public static StructDeclarationSyntax StructDeclaration(SyntaxToken identifier)
    {
      return SyntaxFactory.StructDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.StructKeyword), identifier, default(TypeParameterListSyntax), default(BaseListSyntax), default(SyntaxList<TypeParameterConstraintClauseSyntax>), SyntaxFactory.Token(SyntaxKind.OpenBraceToken), default(SyntaxList<MemberDeclarationSyntax>), SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new StructDeclarationSyntax instance.</summary>
    public static StructDeclarationSyntax StructDeclaration(string identifier)
    {
      return SyntaxFactory.StructDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.StructKeyword), SyntaxFactory.Identifier(identifier), default(TypeParameterListSyntax), default(BaseListSyntax), default(SyntaxList<TypeParameterConstraintClauseSyntax>), SyntaxFactory.Token(SyntaxKind.OpenBraceToken), default(SyntaxList<MemberDeclarationSyntax>), SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.InterfaceKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (InterfaceDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.InterfaceDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), (Syntax.InternalSyntax.SyntaxToken)keyword.Node, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, typeParameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax)typeParameterList.Green, baseList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseListSyntax)baseList.Green, constraintClauses.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax>(), (Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, members.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberDeclarationSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList<MemberDeclarationSyntax> members)
    {
      return SyntaxFactory.InterfaceDeclaration(attributeLists, modifiers, SyntaxFactory.Token(SyntaxKind.InterfaceKeyword), identifier, typeParameterList, baseList, constraintClauses, SyntaxFactory.Token(SyntaxKind.OpenBraceToken), members, SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxToken identifier)
    {
      return SyntaxFactory.InterfaceDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.InterfaceKeyword), identifier, default(TypeParameterListSyntax), default(BaseListSyntax), default(SyntaxList<TypeParameterConstraintClauseSyntax>), SyntaxFactory.Token(SyntaxKind.OpenBraceToken), default(SyntaxList<MemberDeclarationSyntax>), SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
    public static InterfaceDeclarationSyntax InterfaceDeclaration(string identifier)
    {
      return SyntaxFactory.InterfaceDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.InterfaceKeyword), SyntaxFactory.Identifier(identifier), default(TypeParameterListSyntax), default(BaseListSyntax), default(SyntaxList<TypeParameterConstraintClauseSyntax>), SyntaxFactory.Token(SyntaxKind.OpenBraceToken), default(SyntaxList<MemberDeclarationSyntax>), SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new EnumDeclarationSyntax instance.</summary>
    public static EnumDeclarationSyntax EnumDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
      switch (enumKeyword.Kind())
      {
        case SyntaxKind.EnumKeyword:
          break;
        default:
          throw new ArgumentException("enumKeyword");
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (EnumDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.EnumDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), (Syntax.InternalSyntax.SyntaxToken)enumKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, baseList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseListSyntax)baseList.Green, (Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, members.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EnumMemberDeclarationSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new EnumDeclarationSyntax instance.</summary>
    public static EnumDeclarationSyntax EnumDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, BaseListSyntax baseList, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members)
    {
      return SyntaxFactory.EnumDeclaration(attributeLists, modifiers, SyntaxFactory.Token(SyntaxKind.EnumKeyword), identifier, baseList, SyntaxFactory.Token(SyntaxKind.OpenBraceToken), members, SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new EnumDeclarationSyntax instance.</summary>
    public static EnumDeclarationSyntax EnumDeclaration(SyntaxToken identifier)
    {
      return SyntaxFactory.EnumDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.EnumKeyword), identifier, default(BaseListSyntax), SyntaxFactory.Token(SyntaxKind.OpenBraceToken), default(SeparatedSyntaxList<EnumMemberDeclarationSyntax>), SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new EnumDeclarationSyntax instance.</summary>
    public static EnumDeclarationSyntax EnumDeclaration(string identifier)
    {
      return SyntaxFactory.EnumDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.EnumKeyword), SyntaxFactory.Identifier(identifier), default(BaseListSyntax), SyntaxFactory.Token(SyntaxKind.OpenBraceToken), default(SeparatedSyntaxList<EnumMemberDeclarationSyntax>), SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
    public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, SyntaxToken refKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken)
    {
      switch (delegateKeyword.Kind())
      {
        case SyntaxKind.DelegateKeyword:
          break;
        default:
          throw new ArgumentException("delegateKeyword");
      }
      switch (refKeyword.Kind())
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (DelegateDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.DelegateDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), (Syntax.InternalSyntax.SyntaxToken)delegateKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)refKeyword.Node, returnType == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)returnType.Green, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, typeParameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax)typeParameterList.Green, parameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax)parameterList.Green, constraintClauses.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax>(), (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
    public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)
    {
      return SyntaxFactory.DelegateDeclaration(attributeLists, modifiers, SyntaxFactory.Token(SyntaxKind.DelegateKeyword), default(SyntaxToken), returnType, identifier, typeParameterList, parameterList, constraintClauses, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
    public static DelegateDeclarationSyntax DelegateDeclaration(TypeSyntax returnType, SyntaxToken identifier)
    {
      return SyntaxFactory.DelegateDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.DelegateKeyword), default(SyntaxToken), returnType, identifier, default(TypeParameterListSyntax), SyntaxFactory.ParameterList(), default(SyntaxList<TypeParameterConstraintClauseSyntax>), SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
    public static DelegateDeclarationSyntax DelegateDeclaration(TypeSyntax returnType, string identifier)
    {
      return SyntaxFactory.DelegateDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.DelegateKeyword), default(SyntaxToken), returnType, SyntaxFactory.Identifier(identifier), default(TypeParameterListSyntax), SyntaxFactory.ParameterList(), default(SyntaxList<TypeParameterConstraintClauseSyntax>), SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new EnumMemberDeclarationSyntax instance.</summary>
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
    {
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      return (EnumMemberDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.EnumMemberDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), (Syntax.InternalSyntax.SyntaxToken)identifier.Node, equalsValue == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EqualsValueClauseSyntax)equalsValue.Green).CreateRed();
    }

    /// <summary>Creates a new EnumMemberDeclarationSyntax instance.</summary>
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxToken identifier)
    {
      return SyntaxFactory.EnumMemberDeclaration(default(SyntaxList<AttributeListSyntax>), identifier, default(EqualsValueClauseSyntax));
    }

    /// <summary>Creates a new EnumMemberDeclarationSyntax instance.</summary>
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(string identifier)
    {
      return SyntaxFactory.EnumMemberDeclaration(default(SyntaxList<AttributeListSyntax>), SyntaxFactory.Identifier(identifier), default(EqualsValueClauseSyntax));
    }

    /// <summary>Creates a new BaseListSyntax instance.</summary>
    public static BaseListSyntax BaseList(SyntaxToken colonToken, SeparatedSyntaxList<BaseTypeSyntax> types)
    {
      switch (colonToken.Kind())
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      return (BaseListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.BaseList((Syntax.InternalSyntax.SyntaxToken)colonToken.Node, types.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseTypeSyntax>()).CreateRed();
    }

    /// <summary>Creates a new BaseListSyntax instance.</summary>
    public static BaseListSyntax BaseList(SeparatedSyntaxList<BaseTypeSyntax> types = default(SeparatedSyntaxList<BaseTypeSyntax>))
    {
      return SyntaxFactory.BaseList(SyntaxFactory.Token(SyntaxKind.ColonToken), types);
    }

    /// <summary>Creates a new SimpleBaseTypeSyntax instance.</summary>
    public static SimpleBaseTypeSyntax SimpleBaseType(TypeSyntax type)
    {
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      return (SimpleBaseTypeSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.SimpleBaseType(type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green).CreateRed();
    }

    /// <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
    {
      switch (whereKeyword.Kind())
      {
        case SyntaxKind.WhereKeyword:
          break;
        default:
          throw new ArgumentException("whereKeyword");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (colonToken.Kind())
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      return (TypeParameterConstraintClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.TypeParameterConstraintClause((Syntax.InternalSyntax.SyntaxToken)whereKeyword.Node, name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IdentifierNameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node, constraints.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintSyntax>()).CreateRed();
    }

    /// <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(IdentifierNameSyntax name, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
    {
      return SyntaxFactory.TypeParameterConstraintClause(SyntaxFactory.Token(SyntaxKind.WhereKeyword), name, SyntaxFactory.Token(SyntaxKind.ColonToken), constraints);
    }

    /// <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(IdentifierNameSyntax name)
    {
      return SyntaxFactory.TypeParameterConstraintClause(SyntaxFactory.Token(SyntaxKind.WhereKeyword), name, SyntaxFactory.Token(SyntaxKind.ColonToken), default(SeparatedSyntaxList<TypeParameterConstraintSyntax>));
    }

    /// <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(string name)
    {
      return SyntaxFactory.TypeParameterConstraintClause(SyntaxFactory.Token(SyntaxKind.WhereKeyword), SyntaxFactory.IdentifierName(name), SyntaxFactory.Token(SyntaxKind.ColonToken), default(SeparatedSyntaxList<TypeParameterConstraintSyntax>));
    }

    /// <summary>Creates a new ConstructorConstraintSyntax instance.</summary>
    public static ConstructorConstraintSyntax ConstructorConstraint(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
    {
      switch (newKeyword.Kind())
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (ConstructorConstraintSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ConstructorConstraint((Syntax.InternalSyntax.SyntaxToken)newKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }

    /// <summary>Creates a new ConstructorConstraintSyntax instance.</summary>
    public static ConstructorConstraintSyntax ConstructorConstraint()
    {
      return SyntaxFactory.ConstructorConstraint(SyntaxFactory.Token(SyntaxKind.NewKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new ClassOrStructConstraintSyntax instance.</summary>
    public static ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind, SyntaxToken classOrStructKeyword)
    {
      switch (kind)
      {
        case SyntaxKind.ClassConstraint:
        case SyntaxKind.StructConstraint:
          break;
        default:
          throw new ArgumentException("kind");
      }
      switch (classOrStructKeyword.Kind())
      {
        case SyntaxKind.ClassKeyword:
        case SyntaxKind.StructKeyword:
          break;
        default:
          throw new ArgumentException("classOrStructKeyword");
      }
      return (ClassOrStructConstraintSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ClassOrStructConstraint(kind, (Syntax.InternalSyntax.SyntaxToken)classOrStructKeyword.Node).CreateRed();
    }

    /// <summary>Creates a new ClassOrStructConstraintSyntax instance.</summary>
    public static ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind)
    {
      return SyntaxFactory.ClassOrStructConstraint(kind, SyntaxFactory.Token(GetClassOrStructConstraintClassOrStructKeywordKind(kind)));
    }

    private static SyntaxKind GetClassOrStructConstraintClassOrStructKeywordKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.ClassConstraint:
          return SyntaxKind.ClassKeyword;
        case SyntaxKind.StructConstraint:
          return SyntaxKind.StructKeyword;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new TypeConstraintSyntax instance.</summary>
    public static TypeConstraintSyntax TypeConstraint(TypeSyntax type)
    {
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      return (TypeConstraintSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.TypeConstraint(type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green).CreateRed();
    }

    /// <summary>Creates a new FieldDeclarationSyntax instance.</summary>
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (FieldDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.FieldDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), declaration == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeclarationSyntax)declaration.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new FieldDeclarationSyntax instance.</summary>
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration)
    {
      return SyntaxFactory.FieldDeclaration(attributeLists, modifiers, declaration, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new FieldDeclarationSyntax instance.</summary>
    public static FieldDeclarationSyntax FieldDeclaration(VariableDeclarationSyntax declaration)
    {
      return SyntaxFactory.FieldDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), declaration, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new EventFieldDeclarationSyntax instance.</summary>
    public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
      switch (eventKeyword.Kind())
      {
        case SyntaxKind.EventKeyword:
          break;
        default:
          throw new ArgumentException("eventKeyword");
      }
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (EventFieldDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.EventFieldDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), (Syntax.InternalSyntax.SyntaxToken)eventKeyword.Node, declaration == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeclarationSyntax)declaration.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new EventFieldDeclarationSyntax instance.</summary>
    public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration)
    {
      return SyntaxFactory.EventFieldDeclaration(attributeLists, modifiers, SyntaxFactory.Token(SyntaxKind.EventKeyword), declaration, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new EventFieldDeclarationSyntax instance.</summary>
    public static EventFieldDeclarationSyntax EventFieldDeclaration(VariableDeclarationSyntax declaration)
    {
      return SyntaxFactory.EventFieldDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.EventKeyword), declaration, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new ExplicitInterfaceSpecifierSyntax instance.</summary>
    public static ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name, SyntaxToken dotToken)
    {
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (dotToken.Kind())
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("dotToken");
      }
      return (ExplicitInterfaceSpecifierSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ExplicitInterfaceSpecifier(name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken)dotToken.Node).CreateRed();
    }

    /// <summary>Creates a new ExplicitInterfaceSpecifierSyntax instance.</summary>
    public static ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name)
    {
      return SyntaxFactory.ExplicitInterfaceSpecifier(name, SyntaxFactory.Token(SyntaxKind.DotToken));
    }

    /// <summary>Creates a new MethodDeclarationSyntax instance.</summary>
    public static MethodDeclarationSyntax MethodDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken refKeyword, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
      switch (refKeyword.Kind())
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (MethodDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.MethodDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), (Syntax.InternalSyntax.SyntaxToken)refKeyword.Node, returnType == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)returnType.Green, explicitInterfaceSpecifier == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExplicitInterfaceSpecifierSyntax)explicitInterfaceSpecifier.Green, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, typeParameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax)typeParameterList.Green, parameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax)parameterList.Green, constraintClauses.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax>(), body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)body.Green, expressionBody == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax)expressionBody.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new MethodDeclarationSyntax instance.</summary>
    public static MethodDeclarationSyntax MethodDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)
    {
      return SyntaxFactory.MethodDeclaration(attributeLists, modifiers, default(SyntaxToken), returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, default(SyntaxToken));
    }

    /// <summary>Creates a new MethodDeclarationSyntax instance.</summary>
    public static MethodDeclarationSyntax MethodDeclaration(TypeSyntax returnType, SyntaxToken identifier)
    {
      return SyntaxFactory.MethodDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), default(SyntaxToken), returnType, default(ExplicitInterfaceSpecifierSyntax), identifier, default(TypeParameterListSyntax), SyntaxFactory.ParameterList(), default(SyntaxList<TypeParameterConstraintClauseSyntax>), default(BlockSyntax), default(ArrowExpressionClauseSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new MethodDeclarationSyntax instance.</summary>
    public static MethodDeclarationSyntax MethodDeclaration(TypeSyntax returnType, string identifier)
    {
      return SyntaxFactory.MethodDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), default(SyntaxToken), returnType, default(ExplicitInterfaceSpecifierSyntax), SyntaxFactory.Identifier(identifier), default(TypeParameterListSyntax), SyntaxFactory.ParameterList(), default(SyntaxList<TypeParameterConstraintClauseSyntax>), default(BlockSyntax), default(ArrowExpressionClauseSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new OperatorDeclarationSyntax instance.</summary>
    public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      switch (operatorKeyword.Kind())
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      switch (operatorToken.Kind())
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.TrueKeyword:
        case SyntaxKind.IsKeyword:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (OperatorDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.OperatorDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), returnType == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)returnType.Green, (Syntax.InternalSyntax.SyntaxToken)operatorKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, parameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax)parameterList.Green, body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)body.Green, expressionBody == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax)expressionBody.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new OperatorDeclarationSyntax instance.</summary>
    public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)
    {
      return SyntaxFactory.OperatorDeclaration(attributeLists, modifiers, returnType, SyntaxFactory.Token(SyntaxKind.OperatorKeyword), operatorToken, parameterList, body, expressionBody, default(SyntaxToken));
    }

    /// <summary>Creates a new OperatorDeclarationSyntax instance.</summary>
    public static OperatorDeclarationSyntax OperatorDeclaration(TypeSyntax returnType, SyntaxToken operatorToken)
    {
      return SyntaxFactory.OperatorDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), returnType, SyntaxFactory.Token(SyntaxKind.OperatorKeyword), operatorToken, SyntaxFactory.ParameterList(), default(BlockSyntax), default(ArrowExpressionClauseSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new ConversionOperatorDeclarationSyntax instance.</summary>
    public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
      switch (implicitOrExplicitKeyword.Kind())
      {
        case SyntaxKind.ImplicitKeyword:
        case SyntaxKind.ExplicitKeyword:
          break;
        default:
          throw new ArgumentException("implicitOrExplicitKeyword");
      }
      switch (operatorKeyword.Kind())
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (ConversionOperatorDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ConversionOperatorDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), (Syntax.InternalSyntax.SyntaxToken)implicitOrExplicitKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)operatorKeyword.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, parameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax)parameterList.Green, body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)body.Green, expressionBody == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax)expressionBody.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new ConversionOperatorDeclarationSyntax instance.</summary>
    public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)
    {
      return SyntaxFactory.ConversionOperatorDeclaration(attributeLists, modifiers, implicitOrExplicitKeyword, SyntaxFactory.Token(SyntaxKind.OperatorKeyword), type, parameterList, body, expressionBody, default(SyntaxToken));
    }

    /// <summary>Creates a new ConversionOperatorDeclarationSyntax instance.</summary>
    public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxToken implicitOrExplicitKeyword, TypeSyntax type)
    {
      return SyntaxFactory.ConversionOperatorDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), implicitOrExplicitKeyword, SyntaxFactory.Token(SyntaxKind.OperatorKeyword), type, SyntaxFactory.ParameterList(), default(BlockSyntax), default(ArrowExpressionClauseSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken)
    {
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (ConstructorDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ConstructorDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), (Syntax.InternalSyntax.SyntaxToken)identifier.Node, parameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax)parameterList.Green, initializer == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorInitializerSyntax)initializer.Green, body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)body.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body)
    {
      return SyntaxFactory.ConstructorDeclaration(attributeLists, modifiers, identifier, parameterList, initializer, body, default(SyntaxToken));
    }

    /// <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxToken identifier)
    {
      return SyntaxFactory.ConstructorDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), identifier, SyntaxFactory.ParameterList(), default(ConstructorInitializerSyntax), default(BlockSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
    public static ConstructorDeclarationSyntax ConstructorDeclaration(string identifier)
    {
      return SyntaxFactory.ConstructorDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Identifier(identifier), SyntaxFactory.ParameterList(), default(ConstructorInitializerSyntax), default(BlockSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new ConstructorInitializerSyntax instance.</summary>
    public static ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
    {
      switch (kind)
      {
        case SyntaxKind.BaseConstructorInitializer:
        case SyntaxKind.ThisConstructorInitializer:
          break;
        default:
          throw new ArgumentException("kind");
      }
      switch (colonToken.Kind())
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      switch (thisOrBaseKeyword.Kind())
      {
        case SyntaxKind.BaseKeyword:
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("thisOrBaseKeyword");
      }
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
      return (ConstructorInitializerSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ConstructorInitializer(kind, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node, (Syntax.InternalSyntax.SyntaxToken)thisOrBaseKeyword.Node, argumentList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentListSyntax)argumentList.Green).CreateRed();
    }

    /// <summary>Creates a new ConstructorInitializerSyntax instance.</summary>
    public static ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, ArgumentListSyntax argumentList = default(ArgumentListSyntax))
    {
      return SyntaxFactory.ConstructorInitializer(kind, SyntaxFactory.Token(SyntaxKind.ColonToken), SyntaxFactory.Token(GetConstructorInitializerThisOrBaseKeywordKind(kind)), argumentList ?? SyntaxFactory.ArgumentList());
    }

    private static SyntaxKind GetConstructorInitializerThisOrBaseKeywordKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.BaseConstructorInitializer:
          return SyntaxKind.BaseKeyword;
        case SyntaxKind.ThisConstructorInitializer:
          return SyntaxKind.ThisKeyword;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
    public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken)
    {
      switch (tildeToken.Kind())
      {
        case SyntaxKind.TildeToken:
          break;
        default:
          throw new ArgumentException("tildeToken");
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (DestructorDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.DestructorDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), (Syntax.InternalSyntax.SyntaxToken)tildeToken.Node, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, parameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax)parameterList.Green, body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)body.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
    public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body)
    {
      return SyntaxFactory.DestructorDeclaration(attributeLists, modifiers, SyntaxFactory.Token(SyntaxKind.TildeToken), identifier, parameterList, body, default(SyntaxToken));
    }

    /// <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
    public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxToken identifier)
    {
      return SyntaxFactory.DestructorDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.TildeToken), identifier, SyntaxFactory.ParameterList(), default(BlockSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
    public static DestructorDeclarationSyntax DestructorDeclaration(string identifier)
    {
      return SyntaxFactory.DestructorDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.TildeToken), SyntaxFactory.Identifier(identifier), SyntaxFactory.ParameterList(), default(BlockSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new PropertyDeclarationSyntax instance.</summary>
    public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken refKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken)
    {
      switch (refKeyword.Kind())
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (PropertyDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.PropertyDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), (Syntax.InternalSyntax.SyntaxToken)refKeyword.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, explicitInterfaceSpecifier == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExplicitInterfaceSpecifierSyntax)explicitInterfaceSpecifier.Green, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, accessorList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorListSyntax)accessorList.Green, expressionBody == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax)expressionBody.Green, initializer == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EqualsValueClauseSyntax)initializer.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new PropertyDeclarationSyntax instance.</summary>
    public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer)
    {
      return SyntaxFactory.PropertyDeclaration(attributeLists, modifiers, default(SyntaxToken), type, explicitInterfaceSpecifier, identifier, accessorList, expressionBody, initializer, default(SyntaxToken));
    }

    /// <summary>Creates a new PropertyDeclarationSyntax instance.</summary>
    public static PropertyDeclarationSyntax PropertyDeclaration(TypeSyntax type, SyntaxToken identifier)
    {
      return SyntaxFactory.PropertyDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), default(SyntaxToken), type, default(ExplicitInterfaceSpecifierSyntax), identifier, default(AccessorListSyntax), default(ArrowExpressionClauseSyntax), default(EqualsValueClauseSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new PropertyDeclarationSyntax instance.</summary>
    public static PropertyDeclarationSyntax PropertyDeclaration(TypeSyntax type, string identifier)
    {
      return SyntaxFactory.PropertyDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), default(SyntaxToken), type, default(ExplicitInterfaceSpecifierSyntax), SyntaxFactory.Identifier(identifier), default(AccessorListSyntax), default(ArrowExpressionClauseSyntax), default(EqualsValueClauseSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new ArrowExpressionClauseSyntax instance.</summary>
    public static ArrowExpressionClauseSyntax ArrowExpressionClause(SyntaxToken arrowToken, SyntaxToken refKeyword, ExpressionSyntax expression)
    {
      switch (arrowToken.Kind())
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException("arrowToken");
      }
      switch (refKeyword.Kind())
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      return (ArrowExpressionClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ArrowExpressionClause((Syntax.InternalSyntax.SyntaxToken)arrowToken.Node, (Syntax.InternalSyntax.SyntaxToken)refKeyword.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
    }

    /// <summary>Creates a new ArrowExpressionClauseSyntax instance.</summary>
    public static ArrowExpressionClauseSyntax ArrowExpressionClause(ExpressionSyntax expression)
    {
      return SyntaxFactory.ArrowExpressionClause(SyntaxFactory.Token(SyntaxKind.EqualsGreaterThanToken), default(SyntaxToken), expression);
    }

    /// <summary>Creates a new EventDeclarationSyntax instance.</summary>
    public static EventDeclarationSyntax EventDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
    {
      switch (eventKeyword.Kind())
      {
        case SyntaxKind.EventKeyword:
          break;
        default:
          throw new ArgumentException("eventKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (accessorList == null)
        throw new ArgumentNullException(nameof(accessorList));
      return (EventDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.EventDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), (Syntax.InternalSyntax.SyntaxToken)eventKeyword.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, explicitInterfaceSpecifier == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExplicitInterfaceSpecifierSyntax)explicitInterfaceSpecifier.Green, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, accessorList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorListSyntax)accessorList.Green).CreateRed();
    }

    /// <summary>Creates a new EventDeclarationSyntax instance.</summary>
    public static EventDeclarationSyntax EventDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
    {
      return SyntaxFactory.EventDeclaration(attributeLists, modifiers, SyntaxFactory.Token(SyntaxKind.EventKeyword), type, explicitInterfaceSpecifier, identifier, accessorList);
    }

    /// <summary>Creates a new EventDeclarationSyntax instance.</summary>
    public static EventDeclarationSyntax EventDeclaration(TypeSyntax type, SyntaxToken identifier)
    {
      return SyntaxFactory.EventDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.EventKeyword), type, default(ExplicitInterfaceSpecifierSyntax), identifier, SyntaxFactory.AccessorList());
    }

    /// <summary>Creates a new EventDeclarationSyntax instance.</summary>
    public static EventDeclarationSyntax EventDeclaration(TypeSyntax type, string identifier)
    {
      return SyntaxFactory.EventDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.EventKeyword), type, default(ExplicitInterfaceSpecifierSyntax), SyntaxFactory.Identifier(identifier), SyntaxFactory.AccessorList());
    }

    /// <summary>Creates a new IndexerDeclarationSyntax instance.</summary>
    public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken refKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
      switch (refKeyword.Kind())
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      switch (thisKeyword.Kind())
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("thisKeyword");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (IndexerDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.IndexerDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), (Syntax.InternalSyntax.SyntaxToken)refKeyword.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, explicitInterfaceSpecifier == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExplicitInterfaceSpecifierSyntax)explicitInterfaceSpecifier.Green, (Syntax.InternalSyntax.SyntaxToken)thisKeyword.Node, parameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedParameterListSyntax)parameterList.Green, accessorList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorListSyntax)accessorList.Green, expressionBody == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax)expressionBody.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new IndexerDeclarationSyntax instance.</summary>
    public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody)
    {
      return SyntaxFactory.IndexerDeclaration(attributeLists, modifiers, default(SyntaxToken), type, explicitInterfaceSpecifier, SyntaxFactory.Token(SyntaxKind.ThisKeyword), parameterList, accessorList, expressionBody, default(SyntaxToken));
    }

    /// <summary>Creates a new IndexerDeclarationSyntax instance.</summary>
    public static IndexerDeclarationSyntax IndexerDeclaration(TypeSyntax type)
    {
      return SyntaxFactory.IndexerDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), default(SyntaxToken), type, default(ExplicitInterfaceSpecifierSyntax), SyntaxFactory.Token(SyntaxKind.ThisKeyword), SyntaxFactory.BracketedParameterList(), default(AccessorListSyntax), default(ArrowExpressionClauseSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new AccessorListSyntax instance.</summary>
    public static AccessorListSyntax AccessorList(SyntaxToken openBraceToken, SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)
    {
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      return (AccessorListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AccessorList((Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, accessors.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorDeclarationSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node).CreateRed();
    }

    /// <summary>Creates a new AccessorListSyntax instance.</summary>
    public static AccessorListSyntax AccessorList(SyntaxList<AccessorDeclarationSyntax> accessors = default(SyntaxList<AccessorDeclarationSyntax>))
    {
      return SyntaxFactory.AccessorList(SyntaxFactory.Token(SyntaxKind.OpenBraceToken), accessors, SyntaxFactory.Token(SyntaxKind.CloseBraceToken));
    }

    /// <summary>Creates a new AccessorDeclarationSyntax instance.</summary>
    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.GetAccessorDeclaration:
        case SyntaxKind.SetAccessorDeclaration:
        case SyntaxKind.AddAccessorDeclaration:
        case SyntaxKind.RemoveAccessorDeclaration:
        case SyntaxKind.UnknownAccessorDeclaration:
          break;
        default:
          throw new ArgumentException("kind");
      }
      switch (keyword.Kind())
      {
        case SyntaxKind.GetKeyword:
        case SyntaxKind.SetKeyword:
        case SyntaxKind.AddKeyword:
        case SyntaxKind.RemoveKeyword:
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      return (AccessorDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AccessorDeclaration(kind, attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), (Syntax.InternalSyntax.SyntaxToken)keyword.Node, body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)body.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }

    /// <summary>Creates a new AccessorDeclarationSyntax instance.</summary>
    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, BlockSyntax body)
    {
      return SyntaxFactory.AccessorDeclaration(kind, attributeLists, modifiers, SyntaxFactory.Token(GetAccessorDeclarationKeywordKind(kind)), body, default(SyntaxToken));
    }

    /// <summary>Creates a new AccessorDeclarationSyntax instance.</summary>
    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, BlockSyntax body = default(BlockSyntax))
    {
      return SyntaxFactory.AccessorDeclaration(kind, default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(GetAccessorDeclarationKeywordKind(kind)), body, default(SyntaxToken));
    }

    private static SyntaxKind GetAccessorDeclarationKeywordKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.GetAccessorDeclaration:
          return SyntaxKind.GetKeyword;
        case SyntaxKind.SetAccessorDeclaration:
          return SyntaxKind.SetKeyword;
        case SyntaxKind.AddAccessorDeclaration:
          return SyntaxKind.AddKeyword;
        case SyntaxKind.RemoveAccessorDeclaration:
          return SyntaxKind.RemoveKeyword;
        case SyntaxKind.UnknownAccessorDeclaration:
          return SyntaxKind.IdentifierToken;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new ParameterListSyntax instance.</summary>
    public static ParameterListSyntax ParameterList(SyntaxToken openParenToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (ParameterListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ParameterList((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, parameters.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }

    /// <summary>Creates a new ParameterListSyntax instance.</summary>
    public static ParameterListSyntax ParameterList(SeparatedSyntaxList<ParameterSyntax> parameters = default(SeparatedSyntaxList<ParameterSyntax>))
    {
      return SyntaxFactory.ParameterList(SyntaxFactory.Token(SyntaxKind.OpenParenToken), parameters, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new BracketedParameterListSyntax instance.</summary>
    public static BracketedParameterListSyntax BracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
      switch (openBracketToken.Kind())
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      switch (closeBracketToken.Kind())
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
      return (BracketedParameterListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.BracketedParameterList((Syntax.InternalSyntax.SyntaxToken)openBracketToken.Node, parameters.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBracketToken.Node).CreateRed();
    }

    /// <summary>Creates a new BracketedParameterListSyntax instance.</summary>
    public static BracketedParameterListSyntax BracketedParameterList(SeparatedSyntaxList<ParameterSyntax> parameters = default(SeparatedSyntaxList<ParameterSyntax>))
    {
      return SyntaxFactory.BracketedParameterList(SyntaxFactory.Token(SyntaxKind.OpenBracketToken), parameters, SyntaxFactory.Token(SyntaxKind.CloseBracketToken));
    }

    /// <summary>Creates a new ParameterSyntax instance.</summary>
    public static ParameterSyntax Parameter(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)
    {
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.ArgListKeyword:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      return (ParameterSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.Parameter(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, @default == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EqualsValueClauseSyntax)@default.Green).CreateRed();
    }

    /// <summary>Creates a new ParameterSyntax instance.</summary>
    public static ParameterSyntax Parameter(SyntaxToken identifier)
    {
      return SyntaxFactory.Parameter(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), default(TypeSyntax), identifier, default(EqualsValueClauseSyntax));
    }

    /// <summary>Creates a new IncompleteMemberSyntax instance.</summary>
    public static IncompleteMemberSyntax IncompleteMember(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken refKeyword, TypeSyntax type)
    {
      switch (refKeyword.Kind())
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      return (IncompleteMemberSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.IncompleteMember(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), (Syntax.InternalSyntax.SyntaxToken)refKeyword.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green).CreateRed();
    }

    /// <summary>Creates a new IncompleteMemberSyntax instance.</summary>
    public static IncompleteMemberSyntax IncompleteMember(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type)
    {
      return SyntaxFactory.IncompleteMember(attributeLists, modifiers, default(SyntaxToken), type);
    }

    /// <summary>Creates a new IncompleteMemberSyntax instance.</summary>
    public static IncompleteMemberSyntax IncompleteMember(TypeSyntax type = default(TypeSyntax))
    {
      return SyntaxFactory.IncompleteMember(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), default(SyntaxToken), type);
    }

    /// <summary>Creates a new SkippedTokensTriviaSyntax instance.</summary>
    public static SkippedTokensTriviaSyntax SkippedTokensTrivia(SyntaxTokenList tokens)
    {
      return (SkippedTokensTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.SkippedTokensTrivia(tokens.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>()).CreateRed();
    }

    /// <summary>Creates a new SkippedTokensTriviaSyntax instance.</summary>
    public static SkippedTokensTriviaSyntax SkippedTokensTrivia()
    {
      return SyntaxFactory.SkippedTokensTrivia(default(SyntaxTokenList));
    }

    /// <summary>Creates a new DocumentationCommentTriviaSyntax instance.</summary>
    public static DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment)
    {
      switch (kind)
      {
        case SyntaxKind.SingleLineDocumentationCommentTrivia:
        case SyntaxKind.MultiLineDocumentationCommentTrivia:
          break;
        default:
          throw new ArgumentException("kind");
      }
      switch (endOfComment.Kind())
      {
        case SyntaxKind.EndOfDocumentationCommentToken:
          break;
        default:
          throw new ArgumentException("endOfComment");
      }
      return (DocumentationCommentTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.DocumentationCommentTrivia(kind, content.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNodeSyntax>(), (Syntax.InternalSyntax.SyntaxToken)endOfComment.Node).CreateRed();
    }

    /// <summary>Creates a new DocumentationCommentTriviaSyntax instance.</summary>
    public static DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, SyntaxList<XmlNodeSyntax> content = default(SyntaxList<XmlNodeSyntax>))
    {
      return SyntaxFactory.DocumentationCommentTrivia(kind, content, SyntaxFactory.Token(SyntaxKind.EndOfDocumentationCommentToken));
    }

    /// <summary>Creates a new TypeCrefSyntax instance.</summary>
    public static TypeCrefSyntax TypeCref(TypeSyntax type)
    {
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      return (TypeCrefSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.TypeCref(type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green).CreateRed();
    }

    /// <summary>Creates a new QualifiedCrefSyntax instance.</summary>
    public static QualifiedCrefSyntax QualifiedCref(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)
    {
      if (container == null)
        throw new ArgumentNullException(nameof(container));
      switch (dotToken.Kind())
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("dotToken");
      }
      if (member == null)
        throw new ArgumentNullException(nameof(member));
      return (QualifiedCrefSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.QualifiedCref(container == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)container.Green, (Syntax.InternalSyntax.SyntaxToken)dotToken.Node, member == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberCrefSyntax)member.Green).CreateRed();
    }

    /// <summary>Creates a new QualifiedCrefSyntax instance.</summary>
    public static QualifiedCrefSyntax QualifiedCref(TypeSyntax container, MemberCrefSyntax member)
    {
      return SyntaxFactory.QualifiedCref(container, SyntaxFactory.Token(SyntaxKind.DotToken), member);
    }

    /// <summary>Creates a new NameMemberCrefSyntax instance.</summary>
    public static NameMemberCrefSyntax NameMemberCref(TypeSyntax name, CrefParameterListSyntax parameters)
    {
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      return (NameMemberCrefSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.NameMemberCref(name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)name.Green, parameters == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefParameterListSyntax)parameters.Green).CreateRed();
    }

    /// <summary>Creates a new NameMemberCrefSyntax instance.</summary>
    public static NameMemberCrefSyntax NameMemberCref(TypeSyntax name)
    {
      return SyntaxFactory.NameMemberCref(name, default(CrefParameterListSyntax));
    }

    /// <summary>Creates a new IndexerMemberCrefSyntax instance.</summary>
    public static IndexerMemberCrefSyntax IndexerMemberCref(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)
    {
      switch (thisKeyword.Kind())
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("thisKeyword");
      }
      return (IndexerMemberCrefSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.IndexerMemberCref((Syntax.InternalSyntax.SyntaxToken)thisKeyword.Node, parameters == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefBracketedParameterListSyntax)parameters.Green).CreateRed();
    }

    /// <summary>Creates a new IndexerMemberCrefSyntax instance.</summary>
    public static IndexerMemberCrefSyntax IndexerMemberCref(CrefBracketedParameterListSyntax parameters = default(CrefBracketedParameterListSyntax))
    {
      return SyntaxFactory.IndexerMemberCref(SyntaxFactory.Token(SyntaxKind.ThisKeyword), parameters);
    }

    /// <summary>Creates a new OperatorMemberCrefSyntax instance.</summary>
    public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)
    {
      switch (operatorKeyword.Kind())
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      switch (operatorToken.Kind())
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.TrueKeyword:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      return (OperatorMemberCrefSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.OperatorMemberCref((Syntax.InternalSyntax.SyntaxToken)operatorKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, parameters == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefParameterListSyntax)parameters.Green).CreateRed();
    }

    /// <summary>Creates a new OperatorMemberCrefSyntax instance.</summary>
    public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorToken, CrefParameterListSyntax parameters)
    {
      return SyntaxFactory.OperatorMemberCref(SyntaxFactory.Token(SyntaxKind.OperatorKeyword), operatorToken, parameters);
    }

    /// <summary>Creates a new OperatorMemberCrefSyntax instance.</summary>
    public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorToken)
    {
      return SyntaxFactory.OperatorMemberCref(SyntaxFactory.Token(SyntaxKind.OperatorKeyword), operatorToken, default(CrefParameterListSyntax));
    }

    /// <summary>Creates a new ConversionOperatorMemberCrefSyntax instance.</summary>
    public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters)
    {
      switch (implicitOrExplicitKeyword.Kind())
      {
        case SyntaxKind.ImplicitKeyword:
        case SyntaxKind.ExplicitKeyword:
          break;
        default:
          throw new ArgumentException("implicitOrExplicitKeyword");
      }
      switch (operatorKeyword.Kind())
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      return (ConversionOperatorMemberCrefSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ConversionOperatorMemberCref((Syntax.InternalSyntax.SyntaxToken)implicitOrExplicitKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)operatorKeyword.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, parameters == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefParameterListSyntax)parameters.Green).CreateRed();
    }

    /// <summary>Creates a new ConversionOperatorMemberCrefSyntax instance.</summary>
    public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, TypeSyntax type, CrefParameterListSyntax parameters)
    {
      return SyntaxFactory.ConversionOperatorMemberCref(implicitOrExplicitKeyword, SyntaxFactory.Token(SyntaxKind.OperatorKeyword), type, parameters);
    }

    /// <summary>Creates a new ConversionOperatorMemberCrefSyntax instance.</summary>
    public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, TypeSyntax type)
    {
      return SyntaxFactory.ConversionOperatorMemberCref(implicitOrExplicitKeyword, SyntaxFactory.Token(SyntaxKind.OperatorKeyword), type, default(CrefParameterListSyntax));
    }

    /// <summary>Creates a new CrefParameterListSyntax instance.</summary>
    public static CrefParameterListSyntax CrefParameterList(SyntaxToken openParenToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      return (CrefParameterListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CrefParameterList((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, parameters.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefParameterSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }

    /// <summary>Creates a new CrefParameterListSyntax instance.</summary>
    public static CrefParameterListSyntax CrefParameterList(SeparatedSyntaxList<CrefParameterSyntax> parameters = default(SeparatedSyntaxList<CrefParameterSyntax>))
    {
      return SyntaxFactory.CrefParameterList(SyntaxFactory.Token(SyntaxKind.OpenParenToken), parameters, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new CrefBracketedParameterListSyntax instance.</summary>
    public static CrefBracketedParameterListSyntax CrefBracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
      switch (openBracketToken.Kind())
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      switch (closeBracketToken.Kind())
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
      return (CrefBracketedParameterListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CrefBracketedParameterList((Syntax.InternalSyntax.SyntaxToken)openBracketToken.Node, parameters.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefParameterSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBracketToken.Node).CreateRed();
    }

    /// <summary>Creates a new CrefBracketedParameterListSyntax instance.</summary>
    public static CrefBracketedParameterListSyntax CrefBracketedParameterList(SeparatedSyntaxList<CrefParameterSyntax> parameters = default(SeparatedSyntaxList<CrefParameterSyntax>))
    {
      return SyntaxFactory.CrefBracketedParameterList(SyntaxFactory.Token(SyntaxKind.OpenBracketToken), parameters, SyntaxFactory.Token(SyntaxKind.CloseBracketToken));
    }

    /// <summary>Creates a new CrefParameterSyntax instance.</summary>
    public static CrefParameterSyntax CrefParameter(SyntaxToken refOrOutKeyword, TypeSyntax type)
    {
      switch (refOrOutKeyword.Kind())
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refOrOutKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      return (CrefParameterSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CrefParameter((Syntax.InternalSyntax.SyntaxToken)refOrOutKeyword.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green).CreateRed();
    }

    /// <summary>Creates a new CrefParameterSyntax instance.</summary>
    public static CrefParameterSyntax CrefParameter(TypeSyntax type)
    {
      return SyntaxFactory.CrefParameter(default(SyntaxToken), type);
    }

    /// <summary>Creates a new XmlElementSyntax instance.</summary>
    public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
    {
      if (startTag == null)
        throw new ArgumentNullException(nameof(startTag));
      if (endTag == null)
        throw new ArgumentNullException(nameof(endTag));
      return (XmlElementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlElement(startTag == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlElementStartTagSyntax)startTag.Green, content.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNodeSyntax>(), endTag == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlElementEndTagSyntax)endTag.Green).CreateRed();
    }

    /// <summary>Creates a new XmlElementSyntax instance.</summary>
    public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, XmlElementEndTagSyntax endTag)
    {
      return SyntaxFactory.XmlElement(startTag, default(SyntaxList<XmlNodeSyntax>), endTag);
    }

    /// <summary>Creates a new XmlElementStartTagSyntax instance.</summary>
    public static XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
    {
      switch (lessThanToken.Kind())
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (greaterThanToken.Kind())
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
      return (XmlElementStartTagSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlElementStartTag((Syntax.InternalSyntax.SyntaxToken)lessThanToken.Node, name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNameSyntax)name.Green, attributes.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlAttributeSyntax>(), (Syntax.InternalSyntax.SyntaxToken)greaterThanToken.Node).CreateRed();
    }

    /// <summary>Creates a new XmlElementStartTagSyntax instance.</summary>
    public static XmlElementStartTagSyntax XmlElementStartTag(XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes)
    {
      return SyntaxFactory.XmlElementStartTag(SyntaxFactory.Token(SyntaxKind.LessThanToken), name, attributes, SyntaxFactory.Token(SyntaxKind.GreaterThanToken));
    }

    /// <summary>Creates a new XmlElementStartTagSyntax instance.</summary>
    public static XmlElementStartTagSyntax XmlElementStartTag(XmlNameSyntax name)
    {
      return SyntaxFactory.XmlElementStartTag(SyntaxFactory.Token(SyntaxKind.LessThanToken), name, default(SyntaxList<XmlAttributeSyntax>), SyntaxFactory.Token(SyntaxKind.GreaterThanToken));
    }

    /// <summary>Creates a new XmlElementEndTagSyntax instance.</summary>
    public static XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
    {
      switch (lessThanSlashToken.Kind())
      {
        case SyntaxKind.LessThanSlashToken:
          break;
        default:
          throw new ArgumentException("lessThanSlashToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (greaterThanToken.Kind())
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
      return (XmlElementEndTagSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlElementEndTag((Syntax.InternalSyntax.SyntaxToken)lessThanSlashToken.Node, name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken)greaterThanToken.Node).CreateRed();
    }

    /// <summary>Creates a new XmlElementEndTagSyntax instance.</summary>
    public static XmlElementEndTagSyntax XmlElementEndTag(XmlNameSyntax name)
    {
      return SyntaxFactory.XmlElementEndTag(SyntaxFactory.Token(SyntaxKind.LessThanSlashToken), name, SyntaxFactory.Token(SyntaxKind.GreaterThanToken));
    }

    /// <summary>Creates a new XmlEmptyElementSyntax instance.</summary>
    public static XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
    {
      switch (lessThanToken.Kind())
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (slashGreaterThanToken.Kind())
      {
        case SyntaxKind.SlashGreaterThanToken:
          break;
        default:
          throw new ArgumentException("slashGreaterThanToken");
      }
      return (XmlEmptyElementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlEmptyElement((Syntax.InternalSyntax.SyntaxToken)lessThanToken.Node, name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNameSyntax)name.Green, attributes.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlAttributeSyntax>(), (Syntax.InternalSyntax.SyntaxToken)slashGreaterThanToken.Node).CreateRed();
    }

    /// <summary>Creates a new XmlEmptyElementSyntax instance.</summary>
    public static XmlEmptyElementSyntax XmlEmptyElement(XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes)
    {
      return SyntaxFactory.XmlEmptyElement(SyntaxFactory.Token(SyntaxKind.LessThanToken), name, attributes, SyntaxFactory.Token(SyntaxKind.SlashGreaterThanToken));
    }

    /// <summary>Creates a new XmlEmptyElementSyntax instance.</summary>
    public static XmlEmptyElementSyntax XmlEmptyElement(XmlNameSyntax name)
    {
      return SyntaxFactory.XmlEmptyElement(SyntaxFactory.Token(SyntaxKind.LessThanToken), name, default(SyntaxList<XmlAttributeSyntax>), SyntaxFactory.Token(SyntaxKind.SlashGreaterThanToken));
    }

    /// <summary>Creates a new XmlNameSyntax instance.</summary>
    public static XmlNameSyntax XmlName(XmlPrefixSyntax prefix, SyntaxToken localName)
    {
      switch (localName.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("localName");
      }
      return (XmlNameSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlName(prefix == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlPrefixSyntax)prefix.Green, (Syntax.InternalSyntax.SyntaxToken)localName.Node).CreateRed();
    }

    /// <summary>Creates a new XmlNameSyntax instance.</summary>
    public static XmlNameSyntax XmlName(SyntaxToken localName)
    {
      return SyntaxFactory.XmlName(default(XmlPrefixSyntax), localName);
    }

    /// <summary>Creates a new XmlNameSyntax instance.</summary>
    public static XmlNameSyntax XmlName(string localName)
    {
      return SyntaxFactory.XmlName(default(XmlPrefixSyntax), SyntaxFactory.Identifier(localName));
    }

    /// <summary>Creates a new XmlPrefixSyntax instance.</summary>
    public static XmlPrefixSyntax XmlPrefix(SyntaxToken prefix, SyntaxToken colonToken)
    {
      switch (prefix.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("prefix");
      }
      switch (colonToken.Kind())
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      return (XmlPrefixSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlPrefix((Syntax.InternalSyntax.SyntaxToken)prefix.Node, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node).CreateRed();
    }

    /// <summary>Creates a new XmlPrefixSyntax instance.</summary>
    public static XmlPrefixSyntax XmlPrefix(SyntaxToken prefix)
    {
      return SyntaxFactory.XmlPrefix(prefix, SyntaxFactory.Token(SyntaxKind.ColonToken));
    }

    /// <summary>Creates a new XmlPrefixSyntax instance.</summary>
    public static XmlPrefixSyntax XmlPrefix(string prefix)
    {
      return SyntaxFactory.XmlPrefix(SyntaxFactory.Identifier(prefix), SyntaxFactory.Token(SyntaxKind.ColonToken));
    }

    /// <summary>Creates a new XmlTextAttributeSyntax instance.</summary>
    public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken)
    {
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (equalsToken.Kind())
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      switch (startQuoteToken.Kind())
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("startQuoteToken");
      }
      switch (endQuoteToken.Kind())
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("endQuoteToken");
      }
      return (XmlTextAttributeSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlTextAttribute(name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken)equalsToken.Node, (Syntax.InternalSyntax.SyntaxToken)startQuoteToken.Node, textTokens.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), (Syntax.InternalSyntax.SyntaxToken)endQuoteToken.Node).CreateRed();
    }

    /// <summary>Creates a new XmlTextAttributeSyntax instance.</summary>
    public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken)
    {
      return SyntaxFactory.XmlTextAttribute(name, SyntaxFactory.Token(SyntaxKind.EqualsToken), startQuoteToken, textTokens, endQuoteToken);
    }

    /// <summary>Creates a new XmlTextAttributeSyntax instance.</summary>
    public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, SyntaxToken endQuoteToken)
    {
      return SyntaxFactory.XmlTextAttribute(name, SyntaxFactory.Token(SyntaxKind.EqualsToken), startQuoteToken, default(SyntaxTokenList), endQuoteToken);
    }

    /// <summary>Creates a new XmlCrefAttributeSyntax instance.</summary>
    public static XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
    {
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (equalsToken.Kind())
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      switch (startQuoteToken.Kind())
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("startQuoteToken");
      }
      if (cref == null)
        throw new ArgumentNullException(nameof(cref));
      switch (endQuoteToken.Kind())
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("endQuoteToken");
      }
      return (XmlCrefAttributeSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlCrefAttribute(name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken)equalsToken.Node, (Syntax.InternalSyntax.SyntaxToken)startQuoteToken.Node, cref == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefSyntax)cref.Green, (Syntax.InternalSyntax.SyntaxToken)endQuoteToken.Node).CreateRed();
    }

    /// <summary>Creates a new XmlCrefAttributeSyntax instance.</summary>
    public static XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
    {
      return SyntaxFactory.XmlCrefAttribute(name, SyntaxFactory.Token(SyntaxKind.EqualsToken), startQuoteToken, cref, endQuoteToken);
    }

    /// <summary>Creates a new XmlNameAttributeSyntax instance.</summary>
    public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
    {
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (equalsToken.Kind())
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      switch (startQuoteToken.Kind())
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("startQuoteToken");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (endQuoteToken.Kind())
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("endQuoteToken");
      }
      return (XmlNameAttributeSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlNameAttribute(name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken)equalsToken.Node, (Syntax.InternalSyntax.SyntaxToken)startQuoteToken.Node, identifier == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IdentifierNameSyntax)identifier.Green, (Syntax.InternalSyntax.SyntaxToken)endQuoteToken.Node).CreateRed();
    }

    /// <summary>Creates a new XmlNameAttributeSyntax instance.</summary>
    public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
    {
      return SyntaxFactory.XmlNameAttribute(name, SyntaxFactory.Token(SyntaxKind.EqualsToken), startQuoteToken, identifier, endQuoteToken);
    }

    /// <summary>Creates a new XmlNameAttributeSyntax instance.</summary>
    public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, string identifier, SyntaxToken endQuoteToken)
    {
      return SyntaxFactory.XmlNameAttribute(name, SyntaxFactory.Token(SyntaxKind.EqualsToken), startQuoteToken, SyntaxFactory.IdentifierName(identifier), endQuoteToken);
    }

    /// <summary>Creates a new XmlTextSyntax instance.</summary>
    public static XmlTextSyntax XmlText(SyntaxTokenList textTokens)
    {
      return (XmlTextSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlText(textTokens.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>()).CreateRed();
    }

    /// <summary>Creates a new XmlTextSyntax instance.</summary>
    public static XmlTextSyntax XmlText()
    {
      return SyntaxFactory.XmlText(default(SyntaxTokenList));
    }

    /// <summary>Creates a new XmlCDataSectionSyntax instance.</summary>
    public static XmlCDataSectionSyntax XmlCDataSection(SyntaxToken startCDataToken, SyntaxTokenList textTokens, SyntaxToken endCDataToken)
    {
      switch (startCDataToken.Kind())
      {
        case SyntaxKind.XmlCDataStartToken:
          break;
        default:
          throw new ArgumentException("startCDataToken");
      }
      switch (endCDataToken.Kind())
      {
        case SyntaxKind.XmlCDataEndToken:
          break;
        default:
          throw new ArgumentException("endCDataToken");
      }
      return (XmlCDataSectionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlCDataSection((Syntax.InternalSyntax.SyntaxToken)startCDataToken.Node, textTokens.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), (Syntax.InternalSyntax.SyntaxToken)endCDataToken.Node).CreateRed();
    }

    /// <summary>Creates a new XmlCDataSectionSyntax instance.</summary>
    public static XmlCDataSectionSyntax XmlCDataSection(SyntaxTokenList textTokens = default(SyntaxTokenList))
    {
      return SyntaxFactory.XmlCDataSection(SyntaxFactory.Token(SyntaxKind.XmlCDataStartToken), textTokens, SyntaxFactory.Token(SyntaxKind.XmlCDataEndToken));
    }

    /// <summary>Creates a new XmlProcessingInstructionSyntax instance.</summary>
    public static XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxTokenList textTokens, SyntaxToken endProcessingInstructionToken)
    {
      switch (startProcessingInstructionToken.Kind())
      {
        case SyntaxKind.XmlProcessingInstructionStartToken:
          break;
        default:
          throw new ArgumentException("startProcessingInstructionToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (endProcessingInstructionToken.Kind())
      {
        case SyntaxKind.XmlProcessingInstructionEndToken:
          break;
        default:
          throw new ArgumentException("endProcessingInstructionToken");
      }
      return (XmlProcessingInstructionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlProcessingInstruction((Syntax.InternalSyntax.SyntaxToken)startProcessingInstructionToken.Node, name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNameSyntax)name.Green, textTokens.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), (Syntax.InternalSyntax.SyntaxToken)endProcessingInstructionToken.Node).CreateRed();
    }

    /// <summary>Creates a new XmlProcessingInstructionSyntax instance.</summary>
    public static XmlProcessingInstructionSyntax XmlProcessingInstruction(XmlNameSyntax name, SyntaxTokenList textTokens)
    {
      return SyntaxFactory.XmlProcessingInstruction(SyntaxFactory.Token(SyntaxKind.XmlProcessingInstructionStartToken), name, textTokens, SyntaxFactory.Token(SyntaxKind.XmlProcessingInstructionEndToken));
    }

    /// <summary>Creates a new XmlProcessingInstructionSyntax instance.</summary>
    public static XmlProcessingInstructionSyntax XmlProcessingInstruction(XmlNameSyntax name)
    {
      return SyntaxFactory.XmlProcessingInstruction(SyntaxFactory.Token(SyntaxKind.XmlProcessingInstructionStartToken), name, default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.XmlProcessingInstructionEndToken));
    }

    /// <summary>Creates a new XmlCommentSyntax instance.</summary>
    public static XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxTokenList textTokens, SyntaxToken minusMinusGreaterThanToken)
    {
      switch (lessThanExclamationMinusMinusToken.Kind())
      {
        case SyntaxKind.XmlCommentStartToken:
          break;
        default:
          throw new ArgumentException("lessThanExclamationMinusMinusToken");
      }
      switch (minusMinusGreaterThanToken.Kind())
      {
        case SyntaxKind.XmlCommentEndToken:
          break;
        default:
          throw new ArgumentException("minusMinusGreaterThanToken");
      }
      return (XmlCommentSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlComment((Syntax.InternalSyntax.SyntaxToken)lessThanExclamationMinusMinusToken.Node, textTokens.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode>(), (Syntax.InternalSyntax.SyntaxToken)minusMinusGreaterThanToken.Node).CreateRed();
    }

    /// <summary>Creates a new XmlCommentSyntax instance.</summary>
    public static XmlCommentSyntax XmlComment(SyntaxTokenList textTokens = default(SyntaxTokenList))
    {
      return SyntaxFactory.XmlComment(SyntaxFactory.Token(SyntaxKind.XmlCommentStartToken), textTokens, SyntaxFactory.Token(SyntaxKind.XmlCommentEndToken));
    }

    /// <summary>Creates a new IfDirectiveTriviaSyntax instance.</summary>
    public static IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (ifKeyword.Kind())
      {
        case SyntaxKind.IfKeyword:
          break;
        default:
          throw new ArgumentException("ifKeyword");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (IfDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.IfDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)ifKeyword.Node, condition == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive, branchTaken, conditionValue).CreateRed();
    }

    /// <summary>Creates a new IfDirectiveTriviaSyntax instance.</summary>
    public static IfDirectiveTriviaSyntax IfDirectiveTrivia(ExpressionSyntax condition, bool isActive, bool branchTaken, bool conditionValue)
    {
      return SyntaxFactory.IfDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.IfKeyword), condition, SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive, branchTaken, conditionValue);
    }

    /// <summary>Creates a new ElifDirectiveTriviaSyntax instance.</summary>
    public static ElifDirectiveTriviaSyntax ElifDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (elifKeyword.Kind())
      {
        case SyntaxKind.ElifKeyword:
          break;
        default:
          throw new ArgumentException("elifKeyword");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (ElifDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ElifDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)elifKeyword.Node, condition == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive, branchTaken, conditionValue).CreateRed();
    }

    /// <summary>Creates a new ElifDirectiveTriviaSyntax instance.</summary>
    public static ElifDirectiveTriviaSyntax ElifDirectiveTrivia(ExpressionSyntax condition, bool isActive, bool branchTaken, bool conditionValue)
    {
      return SyntaxFactory.ElifDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.ElifKeyword), condition, SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive, branchTaken, conditionValue);
    }

    /// <summary>Creates a new ElseDirectiveTriviaSyntax instance.</summary>
    public static ElseDirectiveTriviaSyntax ElseDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (elseKeyword.Kind())
      {
        case SyntaxKind.ElseKeyword:
          break;
        default:
          throw new ArgumentException("elseKeyword");
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (ElseDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ElseDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)elseKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive, branchTaken).CreateRed();
    }

    /// <summary>Creates a new ElseDirectiveTriviaSyntax instance.</summary>
    public static ElseDirectiveTriviaSyntax ElseDirectiveTrivia(bool isActive, bool branchTaken)
    {
      return SyntaxFactory.ElseDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.ElseKeyword), SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive, branchTaken);
    }

    /// <summary>Creates a new EndIfDirectiveTriviaSyntax instance.</summary>
    public static EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (endIfKeyword.Kind())
      {
        case SyntaxKind.EndIfKeyword:
          break;
        default:
          throw new ArgumentException("endIfKeyword");
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (EndIfDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.EndIfDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)endIfKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }

    /// <summary>Creates a new EndIfDirectiveTriviaSyntax instance.</summary>
    public static EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(bool isActive)
    {
      return SyntaxFactory.EndIfDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.EndIfKeyword), SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new RegionDirectiveTriviaSyntax instance.</summary>
    public static RegionDirectiveTriviaSyntax RegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (regionKeyword.Kind())
      {
        case SyntaxKind.RegionKeyword:
          break;
        default:
          throw new ArgumentException("regionKeyword");
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (RegionDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.RegionDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)regionKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }

    /// <summary>Creates a new RegionDirectiveTriviaSyntax instance.</summary>
    public static RegionDirectiveTriviaSyntax RegionDirectiveTrivia(bool isActive)
    {
      return SyntaxFactory.RegionDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.RegionKeyword), SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new EndRegionDirectiveTriviaSyntax instance.</summary>
    public static EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (endRegionKeyword.Kind())
      {
        case SyntaxKind.EndRegionKeyword:
          break;
        default:
          throw new ArgumentException("endRegionKeyword");
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (EndRegionDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.EndRegionDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)endRegionKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }

    /// <summary>Creates a new EndRegionDirectiveTriviaSyntax instance.</summary>
    public static EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(bool isActive)
    {
      return SyntaxFactory.EndRegionDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.EndRegionKeyword), SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new ErrorDirectiveTriviaSyntax instance.</summary>
    public static ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (errorKeyword.Kind())
      {
        case SyntaxKind.ErrorKeyword:
          break;
        default:
          throw new ArgumentException("errorKeyword");
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (ErrorDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ErrorDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)errorKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }

    /// <summary>Creates a new ErrorDirectiveTriviaSyntax instance.</summary>
    public static ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(bool isActive)
    {
      return SyntaxFactory.ErrorDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.ErrorKeyword), SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new WarningDirectiveTriviaSyntax instance.</summary>
    public static WarningDirectiveTriviaSyntax WarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (warningKeyword.Kind())
      {
        case SyntaxKind.WarningKeyword:
          break;
        default:
          throw new ArgumentException("warningKeyword");
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (WarningDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.WarningDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)warningKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }

    /// <summary>Creates a new WarningDirectiveTriviaSyntax instance.</summary>
    public static WarningDirectiveTriviaSyntax WarningDirectiveTrivia(bool isActive)
    {
      return SyntaxFactory.WarningDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.WarningKeyword), SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new BadDirectiveTriviaSyntax instance.</summary>
    public static BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (BadDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.BadDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }

    /// <summary>Creates a new BadDirectiveTriviaSyntax instance.</summary>
    public static BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken identifier, bool isActive)
    {
      return SyntaxFactory.BadDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), identifier, SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new DefineDirectiveTriviaSyntax instance.</summary>
    public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (defineKeyword.Kind())
      {
        case SyntaxKind.DefineKeyword:
          break;
        default:
          throw new ArgumentException("defineKeyword");
      }
      switch (name.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("name");
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (DefineDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.DefineDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)defineKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)name.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }

    /// <summary>Creates a new DefineDirectiveTriviaSyntax instance.</summary>
    public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken name, bool isActive)
    {
      return SyntaxFactory.DefineDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.DefineKeyword), name, SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new DefineDirectiveTriviaSyntax instance.</summary>
    public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(string name, bool isActive)
    {
      return SyntaxFactory.DefineDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.DefineKeyword), SyntaxFactory.Identifier(name), SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new UndefDirectiveTriviaSyntax instance.</summary>
    public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (undefKeyword.Kind())
      {
        case SyntaxKind.UndefKeyword:
          break;
        default:
          throw new ArgumentException("undefKeyword");
      }
      switch (name.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("name");
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (UndefDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.UndefDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)undefKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)name.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }

    /// <summary>Creates a new UndefDirectiveTriviaSyntax instance.</summary>
    public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken name, bool isActive)
    {
      return SyntaxFactory.UndefDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.UndefKeyword), name, SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new UndefDirectiveTriviaSyntax instance.</summary>
    public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(string name, bool isActive)
    {
      return SyntaxFactory.UndefDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.UndefKeyword), SyntaxFactory.Identifier(name), SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new LineDirectiveTriviaSyntax instance.</summary>
    public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (lineKeyword.Kind())
      {
        case SyntaxKind.LineKeyword:
          break;
        default:
          throw new ArgumentException("lineKeyword");
      }
      switch (line.Kind())
      {
        case SyntaxKind.NumericLiteralToken:
        case SyntaxKind.DefaultKeyword:
        case SyntaxKind.HiddenKeyword:
          break;
        default:
          throw new ArgumentException("line");
      }
      switch (file.Kind())
      {
        case SyntaxKind.StringLiteralToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("file");
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (LineDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.LineDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)lineKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)line.Node, (Syntax.InternalSyntax.SyntaxToken)file.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }

    /// <summary>Creates a new LineDirectiveTriviaSyntax instance.</summary>
    public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken line, SyntaxToken file, bool isActive)
    {
      return SyntaxFactory.LineDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.LineKeyword), line, file, SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new LineDirectiveTriviaSyntax instance.</summary>
    public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken line, bool isActive)
    {
      return SyntaxFactory.LineDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.LineKeyword), line, default(SyntaxToken), SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new PragmaWarningDirectiveTriviaSyntax instance.</summary>
    public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (pragmaKeyword.Kind())
      {
        case SyntaxKind.PragmaKeyword:
          break;
        default:
          throw new ArgumentException("pragmaKeyword");
      }
      switch (warningKeyword.Kind())
      {
        case SyntaxKind.WarningKeyword:
          break;
        default:
          throw new ArgumentException("warningKeyword");
      }
      switch (disableOrRestoreKeyword.Kind())
      {
        case SyntaxKind.DisableKeyword:
        case SyntaxKind.RestoreKeyword:
          break;
        default:
          throw new ArgumentException("disableOrRestoreKeyword");
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (PragmaWarningDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.PragmaWarningDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)pragmaKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)warningKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)disableOrRestoreKeyword.Node, errorCodes.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax>(), (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }

    /// <summary>Creates a new PragmaWarningDirectiveTriviaSyntax instance.</summary>
    public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList<ExpressionSyntax> errorCodes, bool isActive)
    {
      return SyntaxFactory.PragmaWarningDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.PragmaKeyword), SyntaxFactory.Token(SyntaxKind.WarningKeyword), disableOrRestoreKeyword, errorCodes, SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new PragmaWarningDirectiveTriviaSyntax instance.</summary>
    public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken disableOrRestoreKeyword, bool isActive)
    {
      return SyntaxFactory.PragmaWarningDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.PragmaKeyword), SyntaxFactory.Token(SyntaxKind.WarningKeyword), disableOrRestoreKeyword, default(SeparatedSyntaxList<ExpressionSyntax>), SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new PragmaChecksumDirectiveTriviaSyntax instance.</summary>
    public static PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (pragmaKeyword.Kind())
      {
        case SyntaxKind.PragmaKeyword:
          break;
        default:
          throw new ArgumentException("pragmaKeyword");
      }
      switch (checksumKeyword.Kind())
      {
        case SyntaxKind.ChecksumKeyword:
          break;
        default:
          throw new ArgumentException("checksumKeyword");
      }
      switch (file.Kind())
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("file");
      }
      switch (guid.Kind())
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("guid");
      }
      switch (bytes.Kind())
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("bytes");
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (PragmaChecksumDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.PragmaChecksumDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)pragmaKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)checksumKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)file.Node, (Syntax.InternalSyntax.SyntaxToken)guid.Node, (Syntax.InternalSyntax.SyntaxToken)bytes.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }

    /// <summary>Creates a new PragmaChecksumDirectiveTriviaSyntax instance.</summary>
    public static PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, bool isActive)
    {
      return SyntaxFactory.PragmaChecksumDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.PragmaKeyword), SyntaxFactory.Token(SyntaxKind.ChecksumKeyword), file, guid, bytes, SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new ReferenceDirectiveTriviaSyntax instance.</summary>
    public static ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (referenceKeyword.Kind())
      {
        case SyntaxKind.ReferenceKeyword:
          break;
        default:
          throw new ArgumentException("referenceKeyword");
      }
      switch (file.Kind())
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("file");
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (ReferenceDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ReferenceDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)referenceKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)file.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }

    /// <summary>Creates a new ReferenceDirectiveTriviaSyntax instance.</summary>
    public static ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken file, bool isActive)
    {
      return SyntaxFactory.ReferenceDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.ReferenceKeyword), file, SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new LoadDirectiveTriviaSyntax instance.</summary>
    public static LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (loadKeyword.Kind())
      {
        case SyntaxKind.LoadKeyword:
          break;
        default:
          throw new ArgumentException("loadKeyword");
      }
      switch (file.Kind())
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("file");
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (LoadDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.LoadDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)loadKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)file.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }

    /// <summary>Creates a new LoadDirectiveTriviaSyntax instance.</summary>
    public static LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken file, bool isActive)
    {
      return SyntaxFactory.LoadDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.LoadKeyword), file, SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new ShebangDirectiveTriviaSyntax instance.</summary>
    public static ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      switch (exclamationToken.Kind())
      {
        case SyntaxKind.ExclamationToken:
          break;
        default:
          throw new ArgumentException("exclamationToken");
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
      return (ShebangDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ShebangDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)exclamationToken.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }

    /// <summary>Creates a new ShebangDirectiveTriviaSyntax instance.</summary>
    public static ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(bool isActive)
    {
      return SyntaxFactory.ShebangDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.ExclamationToken), SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }
  }
}
