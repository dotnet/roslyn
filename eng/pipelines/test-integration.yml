parameters:
  - name: poolName
    type: string
  - name: queueName
    type: string
  - name: configuration
    type: string
    default: 'Debug'
    values: [ 'Debug', 'Release' ] 
  - name: timeout
    type: number
  - name: useHelix
    type: boolean
    default: true
  - name: testRuns
    type: object
    default:
      - oop64bit: true
        oopCoreClr: false
        lspEditor: false
        runName: 64
  

stages:
- stage: Windows_${{ parameters.configuration }}_Build
  dependsOn: []
  jobs:
  - template: build-windows-job.yml
    parameters:
      jobName: Build_Windows_${{ parameters.configuration }}
      testArtifactName: Transport_Artifacts_Windows_${{ parameters.configuration }}
      configuration: ${{ parameters.configuration }}
      poolName: ${{ parameters.poolName }}
      queueName: ${{ parameters.queueName }}
      restoreArguments: -msbuildEngine vs
      buildArguments: -msbuildEngine vs /p:Projects='"$(Build.Repository.LocalPath)\src\VisualStudio\IntegrationTest\IntegrationTestBuildProject.csproj"'

- stage: ${{ parameters.configuration }}_Integration
  dependsOn: Windows_${{ parameters.configuration }}_Build
  variables:
  - name: XUNIT_LOGS
    value: $(Build.SourcesDirectory)\artifacts\log\${{ parameters.configuration }}
  jobs:
  - ${{ each testParameters in parameters.testRuns }}:
    - job: ${{ testParameters.runName }}
      variables:
        - name: helixFlag
          ${{ if parameters.useHelix }}:
            value: '-helix'
          ${{ else }}:
            value: ''
      timeoutInMinutes: ${{ parameters.timeout }}
      pool:
        ${{ if not(parameters.useHelix) }}:
          name: ${{ parameters.poolName }}
          demands: ImageOverride -equals ${{ parameters.queueName }}
        ${{ else }}:
          name: ${{ parameters.poolName }}
          # Note that when helix is enabled, the agent running this job is essentially
          # a thin client that kicks off a helix job and waits for it to complete.
          # Thus we don't use a helix queue to run the job here, and instead use the plentiful AzDO vmImages.
          demands: ImageOverride -equals 1es-windows-2022-open
        
      steps:
      - checkout: none
      - task: DownloadPipelineArtifact@2
        displayName: Download Test Payload
        inputs:
          artifact: Transport_Artifacts_Windows_${{ parameters.configuration }}
          path: '$(Build.SourcesDirectory)'

      - task: BatchScript@1
        displayName: Rehydrate RunTests
        inputs:
          filename: ./artifacts/bin/RunTests/${{ parameters.configuration }}/net7.0/rehydrate.cmd
        env:
          HELIX_CORRELATION_PAYLOAD: '$(Build.SourcesDirectory)\.duplicate'

      # If the tests are running on a single machine (for example the scouting queue), also restore the test assets.
      - ${{ if not(parameters.useHelix) }}:
        - task: CmdLine@2
          displayName: Rehydrate Integration Test Assets
          inputs:
            script: |
              call $(Build.SourcesDirectory)/artifacts/bin/Microsoft.VisualStudio.LanguageServices.New.IntegrationTests/${{ parameters.configuration }}/net472/rehydrate.cmd && ^
              call $(Build.SourcesDirectory)/artifacts\bin\Microsoft.CodeAnalysis.Workspaces.MSBuild.UnitTests/${{ parameters.configuration }}/net6.0-windows/rehydrate.cmd && ^
              call $(Build.SourcesDirectory)/artifacts\bin\Microsoft.CodeAnalysis.Workspaces.MSBuild.UnitTests/${{ parameters.configuration }}/net472/rehydrate.cmd
          env:
            HELIX_CORRELATION_PAYLOAD: '$(Build.SourcesDirectory)\.duplicate'

      - task: PowerShell@2
        displayName: Run Integration Tests
        inputs:
          filePath: eng/build.ps1
          arguments: -ci $(helixFlag) -prepareMachine -testVsi -helixQueueName windows.amd64.vs2022.pre.open -configuration ${{ parameters.configuration }} -oop64bit:$${{ testParameters.oop64bit }} -oopCoreClr:$${{ testParameters.oopCoreClr }} -collectDumps -lspEditor:$${{ testParameters.lspEditor }}
        env:
          SYSTEM_ACCESSTOKEN: $(System.AccessToken)

      - task: PublishBuildArtifacts@1
        displayName: Publish Logs
        inputs:
          PathtoPublish: '$(Build.SourcesDirectory)\artifacts\log\${{ parameters.configuration }}'
          ArtifactName: '$(System.JobAttempt)-Logs ${{ parameters.configuration }} OOP64_${{ testParameters.oop64bit }} OOPCoreClr_${{ testParameters.oopCoreClr }} LspEditor_${{ testParameters.lspEditor }} $(Build.BuildNumber)'
          publishLocation: Container
        continueOnError: true
        condition: not(succeeded())

      # Publish xunit results when we're not using helix.
      - ${{ if not(parameters.useHelix) }}:
        - task: PublishTestResults@2
          displayName: Publish xUnit Test Results
          inputs:
            testRunner: XUnit
            testResultsFiles: $(Build.SourcesDirectory)\artifacts\TestResults\${{ parameters.configuration }}\*.xml
            mergeTestResults: true
            testRunTitle: '$(System.JobAttempt)-Integration ${{ parameters.configuration }} OOP64_${{ testParameters.oop64bit }} OOPCoreClr_${{ testParameters.oopCoreClr }}'
          condition: always()

      # Publish integration test results when we're not using helix.
      - ${{ if not(parameters.useHelix) }}:
        - task: PublishBuildArtifacts@1
          displayName: Publish Test Results Directory
          inputs:
            PathtoPublish: '$(Build.SourcesDirectory)\artifacts\TestResults\${{ parameters.configuration }}'
            ArtifactName: '$(System.JobAttempt)-Logs ${{ parameters.configuration }} OOP64_${{ testParameters.oop64bit }} OOPCoreClr_${{ testParameters.oopCoreClr }} LspEditor_${{ testParameters.lspEditor }} $(Build.BuildNumber)'
            publishLocation: Container
          continueOnError: true
          condition: not(succeeded())
